(self.webpackChunkizam_layout_2022 = self.webpackChunkizam_layout_2022 || []).push([
    [29], {
        88785: function() {
            tinymce.IconManager.add("default", {
                icons: {
                    "accessibility-check": '<svg width="24" height="24"><path d="M12 2a2 2 0 0 1 2 2 2 2 0 0 1-2 2 2 2 0 0 1-2-2c0-1.1.9-2 2-2Zm8 7h-5v12c0 .6-.4 1-1 1a1 1 0 0 1-1-1v-5c0-.6-.4-1-1-1a1 1 0 0 0-1 1v5c0 .6-.4 1-1 1a1 1 0 0 1-1-1V9H4a1 1 0 1 1 0-2h16c.6 0 1 .4 1 1s-.4 1-1 1Z" fill-rule="nonzero"/></svg>',
                    "action-next": '<svg width="24" height="24"><path fill-rule="nonzero" d="M5.7 7.3a1 1 0 0 0-1.4 1.4l7.7 7.7 7.7-7.7a1 1 0 1 0-1.4-1.4L12 13.6 5.7 7.3Z"/></svg>',
                    "action-prev": '<svg width="24" height="24"><path fill-rule="nonzero" d="M18.3 15.7a1 1 0 0 0 1.4-1.4L12 6.6l-7.7 7.7a1 1 0 0 0 1.4 1.4L12 9.4l6.3 6.3Z"/></svg>',
                    addtag: '<svg width="24" height="24"><path fill-rule="evenodd" clip-rule="evenodd" d="M15 5a2 2 0 0 1 1.6.8L21 12l-4.4 6.2a2 2 0 0 1-1.6.8h-3v-2h3l3.5-5L15 7H5v3H3V7c0-1.1.9-2 2-2h10Z"/><path fill-rule="evenodd" clip-rule="evenodd" d="M6 12a1 1 0 0 0-1 1v2H3a1 1 0 1 0 0 2h2v2a1 1 0 1 0 2 0v-2h2a1 1 0 1 0 0-2H7v-2c0-.6-.4-1-1-1Z"/></svg>',
                    "align-center": '<svg width="24" height="24"><path d="M5 5h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2Zm3 4h8c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 1 1 0-2Zm0 8h8c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 0 1 0-2Zm-3-4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2Z" fill-rule="evenodd"/></svg>',
                    "align-justify": '<svg width="24" height="24"><path d="M5 5h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2Zm0 4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2Zm0 4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2Zm0 4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2Z" fill-rule="evenodd"/></svg>',
                    "align-left": '<svg width="24" height="24"><path d="M5 5h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2Zm0 4h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2Zm0 8h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2Zm0-4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2Z" fill-rule="evenodd"/></svg>',
                    "align-none": '<svg width="24" height="24"><path d="M14.2 5 13 7H5a1 1 0 1 1 0-2h9.2Zm4 0h.8a1 1 0 0 1 0 2h-2l1.2-2Zm-6.4 4-1.2 2H5a1 1 0 0 1 0-2h6.8Zm4 0H19a1 1 0 0 1 0 2h-4.4l1.2-2Zm-6.4 4-1.2 2H5a1 1 0 0 1 0-2h4.4Zm4 0H19a1 1 0 0 1 0 2h-6.8l1.2-2ZM7 17l-1.2 2H5a1 1 0 0 1 0-2h2Zm4 0h8a1 1 0 0 1 0 2H9.8l1.2-2Zm5.2-13.5 1.3.7-9.7 16.3-1.3-.7 9.7-16.3Z" fill-rule="evenodd"/></svg>',
                    "align-right": '<svg width="24" height="24"><path d="M5 5h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2Zm6 4h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0 8h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm-6-4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2Z" fill-rule="evenodd"/></svg>',
                    "arrow-left": '<svg width="24" height="24"><path d="m5.6 13 12 6a1 1 0 0 0 1.4-1V6a1 1 0 0 0-1.4-.9l-12 6a1 1 0 0 0 0 1.8Z" fill-rule="evenodd"/></svg>',
                    "arrow-right": '<svg width="24" height="24"><path d="m18.5 13-12 6A1 1 0 0 1 5 18V6a1 1 0 0 1 1.4-.9l12 6a1 1 0 0 1 0 1.8Z" fill-rule="evenodd"/></svg>',
                    bold: '<svg width="24" height="24"><path d="M7.8 19c-.3 0-.5 0-.6-.2l-.2-.5V5.7c0-.2 0-.4.2-.5l.6-.2h5c1.5 0 2.7.3 3.5 1 .7.6 1.1 1.4 1.1 2.5a3 3 0 0 1-.6 1.9c-.4.6-1 1-1.6 1.2.4.1.9.3 1.3.6s.8.7 1 1.2c.4.4.5 1 .5 1.6 0 1.3-.4 2.3-1.3 3-.8.7-2.1 1-3.8 1H7.8Zm5-8.3c.6 0 1.2-.1 1.6-.5.4-.3.6-.7.6-1.3 0-1.1-.8-1.7-2.3-1.7H9.3v3.5h3.4Zm.5 6c.7 0 1.3-.1 1.7-.4.4-.4.6-.9.6-1.5s-.2-1-.7-1.4c-.4-.3-1-.4-2-.4H9.4v3.8h4Z" fill-rule="evenodd"/></svg>',
                    bookmark: '<svg width="24" height="24"><path d="M6 4v17l6-4 6 4V4c0-.6-.4-1-1-1H7a1 1 0 0 0-1 1Z" fill-rule="nonzero"/></svg>',
                    "border-style": '<svg width="24" height="24"><g fill-rule="evenodd"><rect width="18" height="2" x="3" y="6" rx="1"/><rect width="2.8" height="2" x="3" y="16" rx="1"/><rect width="2.8" height="2" x="6.8" y="16" rx="1"/><rect width="2.8" height="2" x="10.6" y="16" rx="1"/><rect width="2.8" height="2" x="14.4" y="16" rx="1"/><rect width="2.8" height="2" x="18.2" y="16" rx="1"/><rect width="8" height="2" x="3" y="11" rx="1"/><rect width="8" height="2" x="13" y="11" rx="1"/></g></svg>',
                    "border-width": '<svg width="24" height="24"><g fill-rule="evenodd"><rect width="18" height="5" x="3" y="5" rx="1"/><rect width="18" height="3.5" x="3" y="11.5" rx="1"/><rect width="18" height="2" x="3" y="17" rx="1"/></g></svg>',
                    brightness: '<svg width="24" height="24"><path d="M12 17c.3 0 .5.1.7.3.2.2.3.4.3.7v1c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3 1 1 0 0 1-.7-.3 1 1 0 0 1-.3-.7v-1c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3Zm0-10a1 1 0 0 1-.7-.3A1 1 0 0 1 11 6V5c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3.3 0 .5.1.7.3.2.2.3.4.3.7v1c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3Zm7 4c.3 0 .5.1.7.3.2.2.3.4.3.7 0 .3-.1.5-.3.7a1 1 0 0 1-.7.3h-1a1 1 0 0 1-.7-.3 1 1 0 0 1-.3-.7c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h1ZM7 12c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3H5a1 1 0 0 1-.7-.3A1 1 0 0 1 4 12c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h1c.3 0 .5.1.7.3.2.2.3.4.3.7Zm10 3.5.7.8c.2.1.3.4.3.6 0 .3-.1.6-.3.8a1 1 0 0 1-.8.3 1 1 0 0 1-.6-.3l-.8-.7a1 1 0 0 1-.3-.8c0-.2.1-.5.3-.7a1 1 0 0 1 1.4 0Zm-10-7-.7-.8a1 1 0 0 1-.3-.6c0-.3.1-.6.3-.8.2-.2.5-.3.8-.3.2 0 .5.1.7.3l.7.7c.2.2.3.5.3.8 0 .2-.1.5-.3.7a1 1 0 0 1-.7.3 1 1 0 0 1-.8-.3Zm10 0a1 1 0 0 1-.8.3 1 1 0 0 1-.7-.3 1 1 0 0 1-.3-.7c0-.3.1-.6.3-.8l.8-.7c.1-.2.4-.3.6-.3.3 0 .6.1.8.3.2.2.3.5.3.8 0 .2-.1.5-.3.7l-.7.7Zm-10 7c.2-.2.5-.3.8-.3.2 0 .5.1.7.3a1 1 0 0 1 0 1.4l-.8.8a1 1 0 0 1-.6.3 1 1 0 0 1-.8-.3 1 1 0 0 1-.3-.8c0-.2.1-.5.3-.6l.7-.8ZM12 8a4 4 0 0 1 3.7 2.4 4 4 0 0 1 0 3.2A4 4 0 0 1 12 16a4 4 0 0 1-3.7-2.4 4 4 0 0 1 0-3.2A4 4 0 0 1 12 8Zm0 6.5c.7 0 1.3-.2 1.8-.7.5-.5.7-1.1.7-1.8s-.2-1.3-.7-1.8c-.5-.5-1.1-.7-1.8-.7s-1.3.2-1.8.7c-.5.5-.7 1.1-.7 1.8s.2 1.3.7 1.8c.5.5 1.1.7 1.8.7Z" fill-rule="evenodd"/></svg>',
                    browse: '<svg width="24" height="24"><path d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2h-4v-2h4V8H5v10h4v2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm-8 9.4-2.3 2.3a1 1 0 1 1-1.4-1.4l4-4a1 1 0 0 1 1.4 0l4 4a1 1 0 0 1-1.4 1.4L13 13.4V20a1 1 0 0 1-2 0v-6.6Z" fill-rule="nonzero"/></svg>',
                    cancel: '<svg width="24" height="24"><path d="M12 4.6a7.4 7.4 0 1 1 0 14.8 7.4 7.4 0 0 1 0-14.8ZM12 3a9 9 0 1 0 0 18 9 9 0 0 0 0-18Zm0 8L14.8 8l1 1.1-2.7 2.8 2.7 2.7-1.1 1.1-2.7-2.7-2.7 2.7-1-1.1 2.6-2.7-2.7-2.7 1-1.1 2.8 2.7Z" fill-rule="nonzero"/></svg>',
                    "cell-background-color": '<svg width="24" height="24"><path d="m15.7 2 1.6 1.6-2.7 2.6 5.9 5.8c.7.7.7 1.7 0 2.4l-6.3 6.1a1.7 1.7 0 0 1-2.4 0l-6.3-6.1c-.7-.7-.7-1.7 0-2.4L15.7 2ZM18 12l-4.5-4L9 12h9ZM4 16s2 2.4 2 3.8C6 21 5.1 22 4 22s-2-1-2-2.2C2 18.4 4 16 4 16Z"/></svg>',
                    "cell-border-color": '<svg width="24" height="24"><g fill-rule="evenodd"><path fill-rule="nonzero" d="M5 13v5h2v2H5a2 2 0 0 1-2-2v-5h2zm8-7V4h6a2 2 0 0 1 2 2h-8z" opacity=".2"/><path fill-rule="nonzero" d="M13 4v2H5v7H3V6c0-1.1.9-2 2-2h8zm-2.6 14.1.1-.1.1.1.2.3.2.2.2.2c.4.6.8 1.2.8 1.7 0 .8-.7 1.5-1.5 1.5S9 21.3 9 20.5c0-.5.4-1.1.8-1.7l.2-.2.2-.2.2-.3z"/><path d="m13 11-2 2H5v-2h6V6h2z"/><path fill-rule="nonzero" d="m18.4 8 1 1-1.8 1.9 4 4c.5.4.5 1.1 0 1.6l-4.3 4.2a1.2 1.2 0 0 1-1.6 0l-4.4-4.2c-.4-.5-.4-1.2 0-1.7l7-6.8Zm1.6 7-3-3-3 3h6Z"/></g></svg>',
                    "change-case": '<svg width="24" height="24"><path d="M18.4 18.2v-.6c-.5.8-1.3 1.2-2.4 1.2-2.2 0-3.3-1.6-3.3-4.8 0-3.1 1-4.7 3.3-4.7 1.1 0 1.8.3 2.4 1.1v-.6c0-.5.4-.8.8-.8s.8.3.8.8v8.4c0 .5-.4.8-.8.8a.8.8 0 0 1-.8-.8zm-2-7.4c-1.3 0-1.8.9-1.8 3.2 0 2.4.5 3.3 1.7 3.3 1.3 0 1.8-.9 1.8-3.2 0-2.4-.5-3.3-1.7-3.3zM10 15.7H5.5l-.8 2.6a1 1 0 0 1-1 .7h-.2a.7.7 0 0 1-.7-1l4-12a1 1 0 0 1 2 0l4 12a.7.7 0 0 1-.8 1h-.2a1 1 0 0 1-1-.7l-.8-2.6zm-.3-1.5-2-6.5-1.9 6.5h3.9z" fill-rule="evenodd"/></svg>',
                    "character-count": '<svg width="24" height="24"><path d="M4 11.5h16v1H4v-1Zm4.8-6.8V10H7.7V5.8h-1v-1h2ZM11 8.3V9h2v1h-3V7.7l2-1v-.9h-2v-1h3v2.4l-2 1Zm6.3-3.4V10h-3.1V9h2.1V8h-2.1V6.8h2.1v-1h-2.1v-1h3.1ZM5.8 16.4c0-.5.2-.8.5-1 .2-.2.6-.3 1.2-.3l.8.1c.2 0 .4.2.5.3l.4.4v2.8l.2.3H8.2V18.7l-.6.3H7c-.4 0-.7 0-1-.2a1 1 0 0 1-.3-.9c0-.3 0-.6.3-.8.3-.2.7-.4 1.2-.4l.6-.2h.3v-.2l-.1-.2a.8.8 0 0 0-.5-.1 1 1 0 0 0-.4 0l-.3.4h-1Zm2.3.8h-.2l-.2.1-.4.1a1 1 0 0 0-.4.2l-.2.2.1.3.5.1h.4l.4-.4v-.6Zm2-3.4h1.2v1.7l.5-.3h.5c.5 0 .9.1 1.2.5.3.4.5.8.5 1.4 0 .6-.2 1.1-.5 1.5-.3.4-.7.6-1.3.6l-.6-.1-.4-.4v.4h-1.1v-5.4Zm1.1 3.3c0 .3 0 .6.2.8a.7.7 0 0 0 1.2 0l.2-.8c0-.4 0-.6-.2-.8a.7.7 0 0 0-.6-.3l-.6.3-.2.8Zm6.1-.5c0-.2 0-.3-.2-.4a.8.8 0 0 0-.5-.2c-.3 0-.5.1-.6.3l-.2.9c0 .3 0 .6.2.8.1.2.3.3.6.3.2 0 .4 0 .5-.2l.2-.4h1.1c0 .5-.3.8-.6 1.1a2 2 0 0 1-1.3.4c-.5 0-1-.2-1.3-.6a2 2 0 0 1-.5-1.4c0-.6.1-1.1.5-1.5.3-.4.8-.5 1.4-.5.5 0 1 0 1.2.3.4.3.5.7.5 1.2h-1v-.1Z" fill-rule="evenodd"/></svg>',
                    "checklist-rtl": '<svg width="24" height="24"><path d="M5 17h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2zm14.2 11c.2-.4.6-.5.9-.3.3.2.4.6.2 1L18 20c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8zm0-6c.2-.4.6-.5.9-.3.3.2.4.6.2 1L18 14c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8zm0-6c.2-.4.6-.5.9-.3.3.2.4.6.2 1L18 8c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8z" fill-rule="evenodd"/></svg>',
                    checklist: '<svg width="24" height="24"><path d="M11 17h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0-6h8a1 1 0 0 1 0 2h-8a1 1 0 0 1 0-2ZM7.2 16c.2-.4.6-.5.9-.3.3.2.4.6.2 1L6 20c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8Zm0-6c.2-.4.6-.5.9-.3.3.2.4.6.2 1L6 14c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8Zm0-6c.2-.4.6-.5.9-.3.3.2.4.6.2 1L6 8c-.2.3-.7.4-1 0L3.8 6.9a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8Z" fill-rule="evenodd"/></svg>',
                    checkmark: '<svg width="24" height="24"><path d="M18.2 5.4a1 1 0 0 1 1.6 1.2l-8 12a1 1 0 0 1-1.5.1l-5-5a1 1 0 1 1 1.4-1.4l4.1 4.1 7.4-11Z" fill-rule="nonzero"/></svg>',
                    "chevron-down": '<svg width="10" height="10"><path d="M8.7 2.2c.3-.3.8-.3 1 0 .4.4.4.9 0 1.2L5.7 7.8c-.3.3-.9.3-1.2 0L.2 3.4a.8.8 0 0 1 0-1.2c.3-.3.8-.3 1.1 0L5 6l3.7-3.8Z" fill-rule="nonzero"/></svg>',
                    "chevron-left": '<svg width="10" height="10"><path d="M7.8 1.3 4 5l3.8 3.7c.3.3.3.8 0 1-.4.4-.9.4-1.2 0L2.2 5.7a.8.8 0 0 1 0-1.2L6.6.2C7 0 7.4 0 7.8.2c.3.3.3.8 0 1.1Z" fill-rule="nonzero"/></svg>',
                    "chevron-right": '<svg width="10" height="10"><path d="M2.2 1.3a.8.8 0 0 1 0-1c.4-.4.9-.4 1.2 0l4.4 4.1c.3.4.3.9 0 1.2L3.4 9.8c-.3.3-.8.3-1.2 0a.8.8 0 0 1 0-1.1L6 5 2.2 1.3Z" fill-rule="nonzero"/></svg>',
                    "chevron-up": '<svg width="10" height="10"><path d="M8.7 7.8 5 4 1.3 7.8c-.3.3-.8.3-1 0a.8.8 0 0 1 0-1.2l4.1-4.4c.3-.3.9-.3 1.2 0l4.2 4.4c.3.3.3.9 0 1.2-.3.3-.8.3-1.1 0Z" fill-rule="nonzero"/></svg>',
                    close: '<svg width="24" height="24"><path d="M17.3 8.2 13.4 12l3.9 3.8a1 1 0 0 1-1.5 1.5L12 13.4l-3.8 3.9a1 1 0 0 1-1.5-1.5l3.9-3.8-3.9-3.8a1 1 0 0 1 1.5-1.5l3.8 3.9 3.8-3.9a1 1 0 0 1 1.5 1.5Z" fill-rule="evenodd"/></svg>',
                    "code-sample": '<svg width="24" height="26"><path d="M7.1 11a2.8 2.8 0 0 1-.8 2 2.8 2.8 0 0 1 .8 2v1.7c0 .3.1.6.4.8.2.3.5.4.8.4.3 0 .4.2.4.4v.8c0 .2-.1.4-.4.4-.7 0-1.4-.3-2-.8-.5-.6-.8-1.3-.8-2V15c0-.3-.1-.6-.4-.8-.2-.3-.5-.4-.8-.4a.4.4 0 0 1-.4-.4v-.8c0-.2.2-.4.4-.4.3 0 .6-.1.8-.4.3-.2.4-.5.4-.8V9.3c0-.7.3-1.4.8-2 .6-.5 1.3-.8 2-.8.3 0 .4.2.4.4v.8c0 .2-.1.4-.4.4-.3 0-.6.1-.8.4-.3.2-.4.5-.4.8V11Zm9.8 0V9.3c0-.3-.1-.6-.4-.8-.2-.3-.5-.4-.8-.4a.4.4 0 0 1-.4-.4V7c0-.2.1-.4.4-.4.7 0 1.4.3 2 .8.5.6.8 1.3.8 2V11c0 .3.1.6.4.8.2.3.5.4.8.4.2 0 .4.2.4.4v.8c0 .2-.2.4-.4.4-.3 0-.6.1-.8.4-.3.2-.4.5-.4.8v1.7c0 .7-.3 1.4-.8 2-.6.5-1.3.8-2 .8a.4.4 0 0 1-.4-.4v-.8c0-.2.1-.4.4-.4.3 0 .6-.1.8-.4.3-.2.4-.5.4-.8V15a2.8 2.8 0 0 1 .8-2 2.8 2.8 0 0 1-.8-2Zm-3.3-.4c0 .4-.1.8-.5 1.1-.3.3-.7.5-1.1.5-.4 0-.8-.2-1.1-.5-.4-.3-.5-.7-.5-1.1 0-.5.1-.9.5-1.2.3-.3.7-.4 1.1-.4.4 0 .8.1 1.1.4.4.3.5.7.5 1.2ZM12 13c.4 0 .8.1 1.1.5.4.3.5.7.5 1.1 0 1-.1 1.6-.5 2a3 3 0 0 1-1.1 1c-.4.3-.8.4-1.1.4a.5.5 0 0 1-.5-.5V17a3 3 0 0 0 1-.2l.6-.6c-.6 0-1-.2-1.3-.5-.2-.3-.3-.7-.3-1 0-.5.1-1 .5-1.2.3-.4.7-.5 1.1-.5Z" fill-rule="evenodd"/></svg>',
                    "color-levels": '<svg width="24" height="24"><path d="M17.5 11.4A9 9 0 0 1 18 14c0 .5 0 1-.2 1.4 0 .4-.3.9-.5 1.3a6.2 6.2 0 0 1-3.7 3 5.7 5.7 0 0 1-3.2 0A5.9 5.9 0 0 1 7.6 18a6.2 6.2 0 0 1-1.4-2.6 6.7 6.7 0 0 1 0-2.8c0-.4.1-.9.3-1.3a13.6 13.6 0 0 1 2.3-4A20 20 0 0 1 12 4a26.4 26.4 0 0 1 3.2 3.4 18.2 18.2 0 0 1 2.3 4Zm-2 4.5c.4-.7.5-1.4.5-2a7.3 7.3 0 0 0-1-3.2c.2.6.2 1.2.2 1.9a4.5 4.5 0 0 1-1.3 3 5.3 5.3 0 0 1-2.3 1.5 4.9 4.9 0 0 1-2 .1 4.3 4.3 0 0 0 2.4.8 4 4 0 0 0 2-.6 4 4 0 0 0 1.5-1.5Z" fill-rule="evenodd"/></svg>',
                    "color-picker": '<svg width="24" height="24"><path d="M12 3a9 9 0 0 0 0 18 1.5 1.5 0 0 0 1.1-2.5c-.2-.3-.4-.6-.4-1 0-.8.7-1.5 1.5-1.5H16a5 5 0 0 0 5-5c0-4.4-4-8-9-8Zm-5.5 9a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3Zm3-4a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3Zm5 0a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3Zm3 4a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3Z" fill-rule="nonzero"/></svg>',
                    "color-swatch-remove-color": '<svg width="24" height="24"><path stroke="#000" stroke-width="2" d="M21 3 3 21" fill-rule="evenodd"/></svg>',
                    "color-swatch": '<svg width="24" height="24"><rect x="3" y="3" width="18" height="18" rx="1" fill-rule="evenodd"/></svg>',
                    "comment-add": '<svg width="24" height="24"><g fill-rule="nonzero"><path d="m9 19 3-2h7c.6 0 1-.4 1-1V6c0-.6-.4-1-1-1H5a1 1 0 0 0-1 1v10c0 .6.4 1 1 1h4v2Zm-2 4v-4H5a3 3 0 0 1-3-3V6a3 3 0 0 1 3-3h14a3 3 0 0 1 3 3v10a3 3 0 0 1-3 3h-6.4L7 23Z"/><path d="M13 10h2a1 1 0 0 1 0 2h-2v2a1 1 0 0 1-2 0v-2H9a1 1 0 0 1 0-2h2V8a1 1 0 0 1 2 0v2Z"/></g></svg>',
                    comment: '<svg width="24" height="24"><path fill-rule="nonzero" d="m9 19 3-2h7c.6 0 1-.4 1-1V6c0-.6-.4-1-1-1H5a1 1 0 0 0-1 1v10c0 .6.4 1 1 1h4v2Zm-2 4v-4H5a3 3 0 0 1-3-3V6a3 3 0 0 1 3-3h14a3 3 0 0 1 3 3v10a3 3 0 0 1-3 3h-6.4L7 23Z"/></svg>',
                    contrast: '<svg width="24" height="24"><path d="M12 4a7.8 7.8 0 0 1 5.7 2.3A8 8 0 1 1 12 4Zm-6 8a6 6 0 0 0 6 6V6a6 6 0 0 0-6 6Z" fill-rule="evenodd"/></svg>',
                    copy: '<svg width="24" height="24"><path d="M16 3H6a2 2 0 0 0-2 2v11h2V5h10V3Zm1 4a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-7a2 2 0 0 1-2-2V9c0-1.2.9-2 2-2h7Zm0 12V9h-7v10h7Z" fill-rule="nonzero"/></svg>',
                    crop: '<svg width="24" height="24"><path d="M17 8v7h2c.6 0 1 .4 1 1s-.4 1-1 1h-2v2c0 .6-.4 1-1 1a1 1 0 0 1-1-1v-2H7V9H5a1 1 0 1 1 0-2h2V5c0-.6.4-1 1-1s1 .4 1 1v2h7l3-3 1 1-3 3ZM9 9v5l5-5H9Zm1 6h5v-5l-5 5Z" fill-rule="evenodd"/></svg>',
                    "cut-column": '<svg width="24" height="24"><path fill-rule="evenodd" d="M7.2 4.5c.9 0 1.6.4 2.2 1A3.7 3.7 0 0 1 10.5 8v.5l1 1 4-4 1-.5a3.3 3.3 0 0 1 2 0c.4 0 .7.3 1 .5L17 8h4v13h-6V10l-1.5 1.5.5.5v4l-2.5-2.5-1 1v.5c0 .4 0 .8-.3 1.2-.2.5-.4.9-.8 1.2-.6.7-1.3 1-2.2 1-.8.2-1.5 0-2-.6l-.5-.8-.2-1c0-.4 0-.8.3-1.2A3.9 3.9 0 0 1 7 12.7c.5-.2 1-.3 1.5-.2l1-1-1-1c-.5 0-1 0-1.5-.2-.5-.1-1-.4-1.4-.9-.4-.3-.6-.7-.8-1.2L4.5 7c0-.4 0-.7.2-1 0-.3.3-.6.5-.8.5-.5 1.2-.8 2-.7Zm12.3 5h-3v10h3v-10ZM8 13.8h-.3l-.4.2a2.8 2.8 0 0 0-.7.4v.1a2.8 2.8 0 0 0-.6.8l-.1.4v.7l.2.5.5.2h.7a2.6 2.6 0 0 0 .8-.3 2.4 2.4 0 0 0 .7-.7 2.5 2.5 0 0 0 .3-.8 1.5 1.5 0 0 0 0-.8 1 1 0 0 0-.2-.4 1 1 0 0 0-.5-.2H8Zm3.5-3.7c-.4 0-.7.1-1 .4-.3.3-.4.6-.4 1s.1.7.4 1c.3.3.6.4 1 .4s.7-.1 1-.4c.3-.3.4-.6.4-1s-.1-.7-.4-1c-.3-.3-.6-.4-1-.4ZM7 5.8h-.4a1 1 0 0 0-.5.3 1 1 0 0 0-.2.5v.7a2.5 2.5 0 0 0 .3.8l.2.3h.1l.4.4.4.2.4.1h.7L9 9l.2-.4a1.6 1.6 0 0 0 0-.8 2.6 2.6 0 0 0-.3-.8A2.5 2.5 0 0 0 7.7 6l-.4-.1H7Z"/></svg>',
                    "cut-row": '<svg width="24" height="24"><path fill-rule="evenodd" d="M22 3v5H9l3 3 2-2h4l-4 4 1 1h.5c.4 0 .8 0 1.2.3.5.2.9.4 1.2.8.7.6 1 1.3 1 2.2.2.8 0 1.5-.6 2l-.8.5-1 .2c-.4 0-.8 0-1.2-.3a3.9 3.9 0 0 1-2.1-2.2c-.2-.5-.3-1-.2-1.5l-1-1-1 1c0 .5 0 1-.2 1.5-.1.5-.4 1-.9 1.4-.3.4-.7.6-1.2.8l-1.2.3c-.4 0-.7 0-1-.2-.3 0-.6-.3-.8-.5-.5-.5-.8-1.2-.7-2 0-.9.4-1.6 1-2.2A3.7 3.7 0 0 1 8.6 14H9l1-1-4-4-.5-1a3.3 3.3 0 0 1 0-2c0-.4.3-.7.5-1l2 2V3h14ZM8.5 15.3h-.3a2.6 2.6 0 0 0-.8.4 2.5 2.5 0 0 0-.9 1.1l-.1.4v.7l.2.5.5.2h.7a2.5 2.5 0 0 0 .8-.3L9 18V18l.4-.4.2-.4.1-.4v-.7a1 1 0 0 0-.2-.5 1 1 0 0 0-.4-.2h-.5Zm7 0H15a1 1 0 0 0-.4.3 1 1 0 0 0-.2.5 1.5 1.5 0 0 0 0 .7v.4a2.8 2.8 0 0 0 .5.7h.1a2.8 2.8 0 0 0 .8.6l.4.1h.7l.5-.2.2-.5v-.7a2.6 2.6 0 0 0-.3-.8 2.4 2.4 0 0 0-.7-.7 2.5 2.5 0 0 0-.8-.3h-.3ZM12 11.6c-.4 0-.7.1-1 .4-.3.3-.4.6-.4 1s.1.7.4 1c.3.3.6.4 1 .4s.7-.1 1-.4c.3-.3.4-.6.4-1s-.1-.7-.4-1c-.3-.3-.6-.4-1-.4Zm8.5-7.1h-11v2h11v-2Z"/></svg>',
                    cut: '<svg width="24" height="24"><path d="M18 15c.6.7 1 1.4 1 2.3 0 .8-.2 1.5-.7 2l-.8.5-1 .2c-.4 0-.8 0-1.2-.3a3.9 3.9 0 0 1-2.1-2.2c-.2-.5-.3-1-.2-1.5l-1-1-1 1c0 .5 0 1-.2 1.5-.1.5-.4 1-.9 1.4-.3.4-.7.6-1.2.8l-1.2.3c-.4 0-.7 0-1-.2-.3 0-.6-.3-.8-.5-.5-.5-.8-1.2-.7-2 0-.9.4-1.6 1-2.2A3.7 3.7 0 0 1 8.6 14H9l1-1-4-4-.5-1a3.3 3.3 0 0 1 0-2c0-.4.3-.7.5-1l6 6 6-6 .5 1a3.3 3.3 0 0 1 0 2c0 .4-.3.7-.5 1l-4 4 1 1h.5c.4 0 .8 0 1.2.3.5.2.9.4 1.2.8Zm-8.5 2.2.1-.4v-.7a1 1 0 0 0-.2-.5 1 1 0 0 0-.4-.2 1.6 1.6 0 0 0-.8 0 2.6 2.6 0 0 0-.8.3 2.5 2.5 0 0 0-.9 1.1l-.1.4v.7l.2.5.5.2h.7a2.5 2.5 0 0 0 .8-.3 2.8 2.8 0 0 0 1-1Zm2.5-2.8c.4 0 .7-.1 1-.4.3-.3.4-.6.4-1s-.1-.7-.4-1c-.3-.3-.6-.4-1-.4s-.7.1-1 .4c-.3.3-.4.6-.4 1s.1.7.4 1c.3.3.6.4 1 .4Zm5.4 4 .2-.5v-.7a2.6 2.6 0 0 0-.3-.8 2.4 2.4 0 0 0-.7-.7 2.5 2.5 0 0 0-.8-.3 1.5 1.5 0 0 0-.8 0 1 1 0 0 0-.4.2 1 1 0 0 0-.2.5 1.5 1.5 0 0 0 0 .7v.4l.3.4.3.4a2.8 2.8 0 0 0 .8.5l.4.1h.7l.5-.2Z" fill-rule="evenodd"/></svg>',
                    "document-properties": '<svg width="24" height="24"><path d="M14.4 3H7a2 2 0 0 0-2 2v14c0 1.1.9 2 2 2h10a2 2 0 0 0 2-2V7.6L14.4 3ZM17 19H7V5h6v4h4v10Z" fill-rule="nonzero"/></svg>',
                    drag: '<svg width="24" height="24"><path d="M13 5h2v2h-2V5Zm0 4h2v2h-2V9ZM9 9h2v2H9V9Zm4 4h2v2h-2v-2Zm-4 0h2v2H9v-2Zm0 4h2v2H9v-2Zm4 0h2v2h-2v-2ZM9 5h2v2H9V5Z" fill-rule="evenodd"/></svg>',
                    "duplicate-column": '<svg width="24" height="24"><path d="M17 6v16h-7V6h7Zm-2 2h-3v12h3V8Zm-2-6v2H8v15H6V2h7Z"/></svg>',
                    "duplicate-row": '<svg width="24" height="24"><path d="M22 11v7H6v-7h16Zm-2 2H8v3h12v-3Zm-1-6v2H4v5H2V7h17Z"/></svg>',
                    duplicate: '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M16 3v2H6v11H4V5c0-1.1.9-2 2-2h10Zm3 8h-2V9h-7v10h9a2 2 0 0 1-2 2h-7a2 2 0 0 1-2-2V9c0-1.2.9-2 2-2h7a2 2 0 0 1 2 2v2Z"/><path d="M17 14h1a1 1 0 0 1 0 2h-1v1a1 1 0 0 1-2 0v-1h-1a1 1 0 0 1 0-2h1v-1a1 1 0 0 1 2 0v1Z"/></g></svg>',
                    "edit-block": '<svg width="24" height="24"><path fill-rule="nonzero" d="m19.8 8.8-9.4 9.4c-.2.2-.5.4-.9.4l-5.4 1.2 1.2-5.4.5-.8 9.4-9.4c.7-.7 1.8-.7 2.5 0l2.1 2.1c.7.7.7 1.8 0 2.5Zm-2-.2 1-.9v-.3l-2.2-2.2a.3.3 0 0 0-.3 0l-1 1L18 8.5Zm-1 1-2.5-2.4-6 6 2.5 2.5 6-6Zm-7 7.1-2.6-2.4-.3.3-.1.2-.7 3 3.1-.6h.1l.4-.5Z"/></svg>',
                    "edit-image": '<svg width="24" height="24"><path d="M18 16h2V7a2 2 0 0 0-2-2H7v2h11v9ZM6 17h15a1 1 0 0 1 0 2h-1v1a1 1 0 0 1-2 0v-1H6a2 2 0 0 1-2-2V7H3a1 1 0 1 1 0-2h1V4a1 1 0 1 1 2 0v13Zm3-5.3 1.3 2 3-4.7 3.7 6H7l2-3.3Z" fill-rule="nonzero"/></svg>',
                    "embed-page": '<svg width="24" height="24"><path d="M19 6V5H5v14h2A13 13 0 0 1 19 6Zm0 1.4c-.8.8-1.6 2.4-2.2 4.6H19V7.4Zm0 5.6h-2.4c-.4 1.8-.6 3.8-.6 6h3v-6Zm-4 6c0-2.2.2-4.2.6-6H13c-.7 1.8-1.1 3.8-1.1 6h3Zm-4 0c0-2.2.4-4.2 1-6H9.6A12 12 0 0 0 8 19h3ZM4 3h16c.6 0 1 .4 1 1v16c0 .6-.4 1-1 1H4a1 1 0 0 1-1-1V4c0-.6.4-1 1-1Zm11.8 9c.4-1.9 1-3.4 1.8-4.5a9.2 9.2 0 0 0-4 4.5h2.2Zm-3.4 0a12 12 0 0 1 2.8-4 12 12 0 0 0-5 4h2.2Z" fill-rule="nonzero"/></svg>',
                    embed: '<svg width="24" height="24"><path d="M4 3h16c.6 0 1 .4 1 1v16c0 .6-.4 1-1 1H4a1 1 0 0 1-1-1V4c0-.6.4-1 1-1Zm1 2v14h14V5H5Zm4.8 2.6 5.6 4a.5.5 0 0 1 0 .8l-5.6 4A.5.5 0 0 1 9 16V8a.5.5 0 0 1 .8-.4Z" fill-rule="nonzero"/></svg>',
                    emoji: '<svg width="24" height="24"><path d="M9 11c.6 0 1-.4 1-1s-.4-1-1-1a1 1 0 0 0-1 1c0 .6.4 1 1 1Zm6 0c.6 0 1-.4 1-1s-.4-1-1-1a1 1 0 0 0-1 1c0 .6.4 1 1 1Zm-3 5.5c2.1 0 4-1.5 4.4-3.5H7.6c.5 2 2.3 3.5 4.4 3.5ZM12 4a8 8 0 1 0 0 16 8 8 0 0 0 0-16Zm0 14.5a6.5 6.5 0 1 1 0-13 6.5 6.5 0 0 1 0 13Z" fill-rule="nonzero"/></svg>',
                    export: '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M14.4 3 18 7v1h-5V5H7v14h9a1 1 0 0 1 2 0c0 1-.8 2-1.9 2H7c-1 0-2-.8-2-1.9V5c0-1 .8-2 1.9-2h7.5Z"/><path d="M18.1 12c.5 0 .9.4.9 1 0 .5-.3 1-.8 1h-7.3c-.5 0-.9-.4-.9-1 0-.5.3-1 .8-1h7.3Z"/><path d="M16.4 9.2a1 1 0 0 1 1.4.2l2.4 3.6-2.4 3.6a1 1 0 0 1-1.7-1v-.2l1.7-2.4-1.6-2.4a1 1 0 0 1 .2-1.4Z"/></g></svg>',
                    fill: '<svg width="24" height="26"><path d="m16.6 12-9-9-1.4 1.4 2.4 2.4-5.2 5.1c-.5.6-.5 1.6 0 2.2L9 19.6a1.5 1.5 0 0 0 2.2 0l5.5-5.5c.5-.6.5-1.6 0-2.2ZM5.2 13 10 8.2l4.8 4.8H5.2ZM19 14.5s-2 2.2-2 3.5c0 1.1.9 2 2 2a2 2 0 0 0 2-2c0-1.3-2-3.5-2-3.5Z" fill-rule="nonzero"/></svg>',
                    "flip-horizontally": '<svg width="24" height="24"><path d="M14 19h2v-2h-2v2Zm4-8h2V9h-2v2ZM4 7v10c0 1.1.9 2 2 2h3v-2H6V7h3V5H6a2 2 0 0 0-2 2Zm14-2v2h2a2 2 0 0 0-2-2Zm-7 16h2V3h-2v18Zm7-6h2v-2h-2v2Zm-4-8h2V5h-2v2Zm4 12a2 2 0 0 0 2-2h-2v2Z" fill-rule="nonzero"/></svg>',
                    "flip-vertically": '<svg width="24" height="24"><path d="M5 14v2h2v-2H5Zm8 4v2h2v-2h-2Zm4-14H7a2 2 0 0 0-2 2v3h2V6h10v3h2V6a2 2 0 0 0-2-2Zm2 14h-2v2a2 2 0 0 0 2-2ZM3 11v2h18v-2H3Zm6 7v2h2v-2H9Zm8-4v2h2v-2h-2ZM5 18c0 1.1.9 2 2 2v-2H5Z" fill-rule="nonzero"/></svg>',
                    footnote: '<svg width="24" height="24"><path d="M19 13c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2h14Z"/><path fill-rule="evenodd" clip-rule="evenodd" d="M19 4v6h-1V5h-1.5V4h2.6Z"/><path d="M12 18c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2h7ZM14 8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2h9Z"/></svg>',
                    "format-painter": '<svg width="24" height="24"><path d="M18 5V4c0-.5-.4-1-1-1H5a1 1 0 0 0-1 1v4c0 .6.5 1 1 1h12c.6 0 1-.4 1-1V7h1v4H9v9c0 .6.4 1 1 1h2c.6 0 1-.4 1-1v-7h8V5h-3Z" fill-rule="nonzero"/></svg>',
                    format: '<svg width="24" height="24"><path fill-rule="evenodd" d="M17 5a1 1 0 0 1 0 2h-4v11a1 1 0 0 1-2 0V7H7a1 1 0 1 1 0-2h10Z"/></svg>',
                    fullscreen: '<svg width="24" height="24"><path d="m15.3 10-1.2-1.3 2.9-3h-2.3a.9.9 0 1 1 0-1.7H19c.5 0 .9.4.9.9v4.4a.9.9 0 1 1-1.8 0V7l-2.9 3Zm0 4 3 3v-2.3a.9.9 0 1 1 1.7 0V19c0 .5-.4.9-.9.9h-4.4a.9.9 0 1 1 0-1.8H17l-3-2.9 1.3-1.2ZM10 15.4l-2.9 3h2.3a.9.9 0 1 1 0 1.7H5a.9.9 0 0 1-.9-.9v-4.4a.9.9 0 1 1 1.8 0V17l2.9-3 1.2 1.3ZM8.7 10 5.7 7v2.3a.9.9 0 0 1-1.7 0V5c0-.5.4-.9.9-.9h4.4a.9.9 0 0 1 0 1.8H7l3 2.9-1.3 1.2Z" fill-rule="nonzero"/></svg>',
                    gallery: '<svg width="24" height="24"><path fill-rule="nonzero" d="m5 15.7 2.3-2.2c.3-.3.7-.3 1 0L11 16l5.1-5c.3-.4.8-.4 1 0l2 1.9V8H5v7.7ZM5 18V19h3l1.8-1.9-2-2L5 17.9Zm14-3-2.5-2.4-6.4 6.5H19v-4ZM4 6h16c.6 0 1 .4 1 1v13c0 .6-.4 1-1 1H4a1 1 0 0 1-1-1V7c0-.6.4-1 1-1Zm6 7a2 2 0 1 1 0-4 2 2 0 0 1 0 4ZM4.5 4h15a.5.5 0 1 1 0 1h-15a.5.5 0 0 1 0-1Zm2-2h11a.5.5 0 1 1 0 1h-11a.5.5 0 0 1 0-1Z"/></svg>',
                    gamma: '<svg width="24" height="24"><path d="M4 3h16c.6 0 1 .4 1 1v16c0 .6-.4 1-1 1H4a1 1 0 0 1-1-1V4c0-.6.4-1 1-1Zm1 2v14h14V5H5Zm6.5 11.8V14L9.2 8.7a5.1 5.1 0 0 0-.4-.8l-.1-.2H8v-1l.3-.1.3-.1h.7a1 1 0 0 1 .6.5l.1.3a8.5 8.5 0 0 1 .3.6l1.9 4.6 2-5.2a1 1 0 0 1 1-.6.5.5 0 0 1 .5.6L13 14v2.8a.7.7 0 0 1-1.4 0Z" fill-rule="nonzero"/></svg>',
                    help: '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M12 5.5a6.5 6.5 0 0 0-6 9 6.3 6.3 0 0 0 1.4 2l1 1a6.3 6.3 0 0 0 3.6 1 6.5 6.5 0 0 0 6-9 6.3 6.3 0 0 0-1.4-2l-1-1a6.3 6.3 0 0 0-3.6-1ZM12 4a7.8 7.8 0 0 1 5.7 2.3A8 8 0 1 1 12 4Z"/><path d="M9.6 9.7a.7.7 0 0 1-.7-.8c0-1.1 1.5-1.8 3.2-1.8 1.8 0 3.2.8 3.2 2.4 0 1.4-.4 2.1-1.5 2.8-.2 0-.3.1-.3.2a2 2 0 0 0-.8.8.8.8 0 0 1-1.4-.6c.3-.7.8-1 1.3-1.5l.4-.2c.7-.4.8-.6.8-1.5 0-.5-.6-.9-1.7-.9-.5 0-1 .1-1.4.3-.2 0-.3.1-.3.2v-.2c0 .4-.4.8-.8.8Z" fill-rule="nonzero"/><circle cx="12" cy="16" r="1"/></g></svg>',
                    "highlight-bg-color": '<svg width="24" height="24"><g fill-rule="evenodd"><path id="tox-icon-highlight-bg-color__color" d="M3 18h18v3H3z"/><path fill-rule="nonzero" d="M7.7 16.7H3l3.3-3.3-.7-.8L10.2 8l4 4.1-4 4.2c-.2.2-.6.2-.8 0l-.6-.7-1.1 1.1zm5-7.5L11 7.4l3-2.9a2 2 0 0 1 2.6 0L18 6c.7.7.7 2 0 2.7l-2.9 2.9-1.8-1.8-.5-.6"/></g></svg>',
                    home: '<svg width="24" height="24"><path fill-rule="nonzero" d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/></svg>',
                    "horizontal-rule": '<svg width="24" height="24"><path d="M4 11h16v2H4z" fill-rule="evenodd"/></svg>',
                    "image-options": '<svg width="24" height="24"><path d="M6 10a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2Zm12 0a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2Zm-6 0a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2Z" fill-rule="nonzero"/></svg>',
                    image: '<svg width="24" height="24"><path d="m5 15.7 3.3-3.2c.3-.3.7-.3 1 0L12 15l4.1-4c.3-.4.8-.4 1 0l2 1.9V5H5v10.7ZM5 18V19h3l2.8-2.9-2-2L5 17.9Zm14-3-2.5-2.4-6.4 6.5H19v-4ZM4 3h16c.6 0 1 .4 1 1v16c0 .6-.4 1-1 1H4a1 1 0 0 1-1-1V4c0-.6.4-1 1-1Zm6 8a2 2 0 1 0 0-4 2 2 0 0 0 0 4Z" fill-rule="nonzero"/></svg>',
                    indent: '<svg width="24" height="24"><path d="M7 5h12c.6 0 1 .4 1 1s-.4 1-1 1H7a1 1 0 1 1 0-2Zm5 4h7c.6 0 1 .4 1 1s-.4 1-1 1h-7a1 1 0 0 1 0-2Zm0 4h7c.6 0 1 .4 1 1s-.4 1-1 1h-7a1 1 0 0 1 0-2Zm-5 4h12a1 1 0 0 1 0 2H7a1 1 0 0 1 0-2Zm-2.6-3.8L6.2 12l-1.8-1.2a1 1 0 0 1 1.2-1.6l3 2a1 1 0 0 1 0 1.6l-3 2a1 1 0 1 1-1.2-1.6Z" fill-rule="evenodd"/></svg>',
                    info: '<svg width="24" height="24"><path d="M12 4a7.8 7.8 0 0 1 5.7 2.3A8 8 0 1 1 12 4Zm-1 3v2h2V7h-2Zm3 10v-1h-1v-5h-3v1h1v4h-1v1h4Z" fill-rule="evenodd"/></svg>',
                    "insert-character": '<svg width="24" height="24"><path d="M15 18h4l1-2v4h-6v-3.3l1.4-1a6 6 0 0 0 1.8-2.9 6.3 6.3 0 0 0-.1-4.1 5.8 5.8 0 0 0-3-3.2c-.6-.3-1.3-.5-2.1-.5a5.1 5.1 0 0 0-3.9 1.8 6.3 6.3 0 0 0-1.3 6 6.2 6.2 0 0 0 1.8 3l1.4.9V20H4v-4l1 2h4v-.5l-2-1L5.4 15A6.5 6.5 0 0 1 4 11c0-1 .2-1.9.6-2.7A7 7 0 0 1 6.3 6C7.1 5.4 8 5 9 4.5c1-.3 2-.5 3.1-.5a8.8 8.8 0 0 1 5.7 2 7 7 0 0 1 1.7 2.3 6 6 0 0 1 .2 4.8c-.2.7-.6 1.3-1 1.9a7.6 7.6 0 0 1-3.6 2.5v.5Z" fill-rule="evenodd"/></svg>',
                    "insert-time": '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M12 19a7 7 0 1 0 0-14 7 7 0 0 0 0 14Zm0 2a9 9 0 1 1 0-18 9 9 0 0 1 0 18Z"/><path d="M16 12h-3V7c0-.6-.4-1-1-1a1 1 0 0 0-1 1v7h5c.6 0 1-.4 1-1s-.4-1-1-1Z"/></g></svg>',
                    invert: '<svg width="24" height="24"><path d="M18 19.3 16.5 18a5.8 5.8 0 0 1-3.1 1.9 6.1 6.1 0 0 1-5.5-1.6A5.8 5.8 0 0 1 6 14v-.3l.1-1.2A13.9 13.9 0 0 1 7.7 9l-3-3 .7-.8 2.8 2.9 9 8.9 1.5 1.6-.7.6Zm0-5.5v.3l-.1 1.1-.4 1-1.2-1.2a4.3 4.3 0 0 0 .2-1v-.2c0-.4 0-.8-.2-1.3l-.5-1.4a14.8 14.8 0 0 0-3-4.2L12 6a26.1 26.1 0 0 0-2.2 2.5l-1-1a20.9 20.9 0 0 1 2.9-3.3L12 4l1 .8a22.2 22.2 0 0 1 4 5.4c.6 1.2 1 2.4 1 3.6Z" fill-rule="evenodd"/></svg>',
                    italic: '<svg width="24" height="24"><path d="m16.7 4.7-.1.9h-.3c-.6 0-1 0-1.4.3-.3.3-.4.6-.5 1.1l-2.1 9.8v.6c0 .5.4.8 1.4.8h.2l-.2.8H8l.2-.8h.2c1.1 0 1.8-.5 2-1.5l2-9.8.1-.5c0-.6-.4-.8-1.4-.8h-.3l.2-.9h5.8Z" fill-rule="evenodd"/></svg>',
                    language: '<svg width="24" height="24"><path d="M12 3a9 9 0 1 1 0 18 9 9 0 0 1 0-18Zm4.3 13.3c-.5 1-1.2 2-2 2.9a7.5 7.5 0 0 0 3.2-2.1l-.2-.2a6 6 0 0 0-1-.6Zm-8.6 0c-.5.2-.9.5-1.2.8.9 1 2 1.7 3.2 2a10 10 0 0 1-2-2.8Zm3.6-.8c-.8 0-1.6.1-2.2.3.5 1 1.2 1.9 2.1 2.7Zm1.5 0v3c.9-.8 1.6-1.7 2.1-2.7-.6-.2-1.4-.3-2.1-.3Zm-6-2.7H4.5c.2 1 .5 2.1 1 3h.3l1.3-1a10 10 0 0 1-.3-2Zm12.7 0h-2.3c0 .7-.1 1.4-.3 2l1.6 1.1c.5-1 .9-2 1-3.1Zm-3.8 0h-3V14c1 0 2 .1 2.7.4.2-.5.3-1 .3-1.6Zm-4.4 0h-3l.3 1.6c.8-.3 1.7-.4 2.7-.4v-1.3Zm-5.5-5c-.7 1-1.1 2.2-1.3 3.5h2.3c0-1 .2-1.8.5-2.6l-1.5-1Zm2.9 1.4v.1c-.2.6-.4 1.3-.4 2h3V9.4c-1 0-1.8-.1-2.6-.3Zm6.6 0h-.1l-2.4.3v1.8h3l-.5-2.1Zm3-1.4-.3.1-1.3.8c.3.8.5 1.6.5 2.6h2.3a7.5 7.5 0 0 0-1.3-3.5Zm-9 0 2 .2V5.5a9 9 0 0 0-2 2.2Zm3.5-2.3V8c.6 0 1.3 0 1.9-.2a9 9 0 0 0-2-2.3Zm-3-.7h-.1c-1.1.4-2.1 1-3 1.8l1.2.7a10 10 0 0 1 1.9-2.5Zm4.4 0 .1.1a10 10 0 0 1 1.8 2.4l1.1-.7a7.5 7.5 0 0 0-3-1.8Z"/></svg>',
                    "line-height": '<svg width="24" height="24"><path d="M21 5a1 1 0 0 1 .1 2H13a1 1 0 0 1-.1-2H21zm0 4a1 1 0 0 1 .1 2H13a1 1 0 0 1-.1-2H21zm0 4a1 1 0 0 1 .1 2H13a1 1 0 0 1-.1-2H21zm0 4a1 1 0 0 1 .1 2H13a1 1 0 0 1-.1-2H21zM7 3.6l3.7 3.7a1 1 0 0 1-1.3 1.5h-.1L8 7.3v9.2l1.3-1.3a1 1 0 0 1 1.3 0h.1c.4.4.4 1 0 1.3v.1L7 20.4l-3.7-3.7a1 1 0 0 1 1.3-1.5h.1L6 16.7V7.4L4.7 8.7a1 1 0 0 1-1.3 0h-.1a1 1 0 0 1 0-1.3v-.1L7 3.6z"/></svg>',
                    line: '<svg width="24" height="24"><path d="m15 9-8 8H4v-3l8-8 3 3Zm1-1-3-3 1-1h1c-.2 0 0 0 0 0l2 2s0 .2 0 0v1l-1 1ZM4 18h16v2H4v-2Z" fill-rule="evenodd"/></svg>',
                    link: '<svg width="24" height="24"><path d="M6.2 12.3a1 1 0 0 1 1.4 1.4l-2 2a2 2 0 1 0 2.6 2.8l4.8-4.8a1 1 0 0 0 0-1.4 1 1 0 1 1 1.4-1.3 2.9 2.9 0 0 1 0 4L9.6 20a3.9 3.9 0 0 1-5.5-5.5l2-2Zm11.6-.6a1 1 0 0 1-1.4-1.4l2-2a2 2 0 1 0-2.6-2.8L11 10.3a1 1 0 0 0 0 1.4A1 1 0 1 1 9.6 13a2.9 2.9 0 0 1 0-4L14.4 4a3.9 3.9 0 0 1 5.5 5.5l-2 2Z" fill-rule="nonzero"/></svg>',
                    "list-bull-circle": '<svg width="48" height="48"><g fill-rule="evenodd"><path d="M11 16a2 2 0 1 0 0-4 2 2 0 0 0 0 4Zm0 1a3 3 0 1 1 0-6 3 3 0 0 1 0 6ZM11 26a2 2 0 1 0 0-4 2 2 0 0 0 0 4Zm0 1a3 3 0 1 1 0-6 3 3 0 0 1 0 6ZM11 36a2 2 0 1 0 0-4 2 2 0 0 0 0 4Zm0 1a3 3 0 1 1 0-6 3 3 0 0 1 0 6Z" fill-rule="nonzero"/><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/></g></svg>',
                    "list-bull-default": '<svg width="48" height="48"><g fill-rule="evenodd"><circle cx="11" cy="14" r="3"/><circle cx="11" cy="24" r="3"/><circle cx="11" cy="34" r="3"/><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/></g></svg>',
                    "list-bull-square": '<svg width="48" height="48"><g fill-rule="evenodd"><path d="M8 11h6v6H8zM8 21h6v6H8zM8 31h6v6H8z"/><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/></g></svg>',
                    "list-num-default-rtl": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="M37.4 17v-4.8h-.1l-1.5 1v-1.1l1.6-1.1h1.2v6zM33.3 17.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7zm1.7 5.7c0-1.2 1-2 2.2-2 1.3 0 2.1.8 2.1 1.8 0 .7-.3 1.2-1.3 2.2l-1.2 1v.2h2.6v1h-4.3v-.9l2-1.9c.8-.8 1-1.1 1-1.5 0-.5-.4-.8-1-.8-.5 0-.9.3-.9.9H35zm-1.7 4.3c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7zm3.2 7.3v-1h.7c.6 0 1-.3 1-.8 0-.4-.4-.7-1-.7s-1 .3-1 .8H35c0-1.1 1-1.8 2.2-1.8 1.2 0 2.1.6 2.1 1.6 0 .7-.4 1.2-1 1.3v.1c.7.1 1.3.7 1.3 1.4 0 1-1 1.9-2.4 1.9-1.3 0-2.2-.8-2.3-2h1.2c0 .6.5 1 1.1 1 .6 0 1-.4 1-1 0-.5-.3-.8-1-.8h-.7zm-3.3 2.7c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7z"/></g></svg>',
                    "list-num-default": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M10 17v-4.8l-1.5 1v-1.1l1.6-1h1.2V17h-1.2Zm3.6.1c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .7.3.7.7 0 .4-.2.7-.7.7Zm-5 5.7c0-1.2.8-2 2.1-2s2.1.8 2.1 1.8c0 .7-.3 1.2-1.4 2.2l-1.1 1v.2h2.6v1H8.6v-.9l2-1.9c.8-.8 1-1.1 1-1.5 0-.5-.4-.8-1-.8-.5 0-.9.3-.9.9H8.5Zm6.3 4.3c-.5 0-.7-.3-.7-.7 0-.4.2-.7.7-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7ZM10 34.4v-1h.7c.6 0 1-.3 1-.8 0-.4-.4-.7-1-.7s-1 .3-1 .8H8.6c0-1.1 1-1.8 2.2-1.8 1.3 0 2.1.6 2.1 1.6 0 .7-.4 1.2-1 1.3v.1c.8.1 1.3.7 1.3 1.4 0 1-1 1.9-2.4 1.9-1.3 0-2.2-.8-2.3-2h1.2c0 .6.5 1 1.1 1 .7 0 1-.4 1-1 0-.5-.3-.8-1-.8h-.7Zm4.7 2.7c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7Z"/></g></svg>',
                    "list-num-lower-alpha-rtl": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="M36.5 16c-.9 0-1.5-.5-1.5-1.3s.6-1.3 1.8-1.4h1v-.4c0-.4-.2-.6-.7-.6-.4 0-.7.1-.8.4h-1.1c0-.8.8-1.4 2-1.4S39 12 39 13V16h-1.2v-.6c-.3.4-.8.7-1.4.7Zm.4-.8c.6 0 1-.4 1-.9V14h-1c-.5.1-.7.3-.7.6 0 .4.3.6.7.6ZM33.1 16.1c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7ZM37.7 26c-.7 0-1.2-.2-1.5-.7v.7H35v-6.3h1.2v2.5c.3-.5.8-.9 1.5-.9 1.1 0 1.8 1 1.8 2.4 0 1.5-.7 2.4-1.8 2.4Zm-.5-3.6c-.6 0-1 .5-1 1.3s.4 1.4 1 1.4c.7 0 1-.6 1-1.4 0-.8-.3-1.3-1-1.3ZM33.2 26.1c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7zm6 7h-1c-.1-.5-.4-.8-1-.8s-1 .5-1 1.4c0 1 .4 1.4 1 1.4.5 0 .9-.2 1-.7h1c0 1-.8 1.7-2 1.7-1.4 0-2.2-.9-2.2-2.4s.8-2.4 2.2-2.4c1.2 0 2 .7 2 1.7zm-6.1 3c-.5 0-.7-.3-.7-.7 0-.4.2-.7.7-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7z"/></g></svg>',
                    "list-num-lower-alpha": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M10.3 15.2c.5 0 1-.4 1-.9V14h-1c-.5.1-.8.3-.8.6 0 .4.3.6.8.6Zm-.4.9c-1 0-1.5-.6-1.5-1.4 0-.8.6-1.3 1.7-1.4h1.1v-.4c0-.4-.2-.6-.7-.6-.5 0-.8.1-.9.4h-1c0-.8.8-1.4 2-1.4 1.1 0 1.8.6 1.8 1.6V16h-1.1v-.6h-.1c-.2.4-.7.7-1.3.7Zm4.6 0c-.5 0-.7-.3-.7-.7 0-.4.2-.7.7-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Zm-3.2 10c-.6 0-1.2-.3-1.4-.8v.7H8.5v-6.3H10v2.5c.3-.5.8-.9 1.4-.9 1.2 0 1.9 1 1.9 2.4 0 1.5-.7 2.4-1.9 2.4Zm-.4-3.7c-.7 0-1 .5-1 1.3s.3 1.4 1 1.4c.6 0 1-.6 1-1.4 0-.8-.4-1.3-1-1.3Zm4 3.7c-.5 0-.7-.3-.7-.7 0-.4.2-.7.7-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Zm-2.2 7h-1.2c0-.5-.4-.8-.9-.8-.6 0-1 .5-1 1.4 0 1 .4 1.4 1 1.4.5 0 .8-.2 1-.7h1c0 1-.8 1.7-2 1.7-1.4 0-2.2-.9-2.2-2.4s.8-2.4 2.2-2.4c1.2 0 2 .7 2 1.7Zm1.8 3c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Z"/></g></svg>',
                    "list-num-lower-greek-rtl": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="M37.4 16c-1.2 0-2-.8-2-2.3 0-1.5.8-2.4 2-2.4.6 0 1 .4 1.3 1v-.9H40v3.2c0 .4.1.5.4.5h.2v.9h-.6c-.6 0-1-.2-1-.7h-.2c-.2.4-.7.8-1.3.8Zm.3-1c.6 0 1-.5 1-1.3s-.4-1.3-1-1.3-1 .5-1 1.3.4 1.4 1 1.4ZM33.3 16.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7ZM36 21.9c0-1.5.8-2.3 2.1-2.3 1.2 0 2 .6 2 1.6 0 .6-.3 1-.9 1.3.9.3 1.3.8 1.3 1.7 0 1.2-.7 1.9-1.8 1.9-.6 0-1.1-.3-1.4-.8v2.2H36V22Zm1.8 1.2v-1h.3c.5 0 .9-.2.9-.7 0-.5-.3-.8-.9-.8-.5 0-.8.3-.8 1v2.2c0 .8.4 1.3 1 1.3s1-.4 1-1-.4-1-1.2-1h-.3ZM33.3 26.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7ZM37.1 34.6 34.8 30h1.4l1.7 3.5 1.7-3.5h1.1l-2.2 4.6v.1c.5.8.7 1.4.7 1.8 0 .4-.2.8-.4 1-.2.2-.6.3-1 .3-.9 0-1.3-.4-1.3-1.2 0-.5.2-1 .5-1.7l.1-.2Zm.7 1a2 2 0 0 0-.4.9c0 .3.1.4.4.4.3 0 .4-.1.4-.4 0-.2-.1-.6-.4-1ZM33.3 36.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Z"/></g></svg>',
                    "list-num-lower-greek": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M10.5 15c.7 0 1-.5 1-1.3s-.3-1.3-1-1.3c-.5 0-.9.5-.9 1.3s.4 1.4 1 1.4Zm-.3 1c-1.1 0-1.8-.8-1.8-2.3 0-1.5.7-2.4 1.8-2.4.7 0 1.1.4 1.3 1h.1v-.9h1.2v3.2c0 .4.1.5.4.5h.2v.9h-.6c-.6 0-1-.2-1.1-.7h-.1c-.2.4-.7.8-1.4.8Zm5 .1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7Zm-4.9 7v-1h.3c.6 0 1-.2 1-.7 0-.5-.4-.8-1-.8-.5 0-.8.3-.8 1v2.2c0 .8.4 1.3 1.1 1.3.6 0 1-.4 1-1s-.5-1-1.3-1h-.3ZM8.6 22c0-1.5.7-2.3 2-2.3 1.2 0 2 .6 2 1.6 0 .6-.3 1-.8 1.3.8.3 1.3.8 1.3 1.7 0 1.2-.8 1.9-1.9 1.9-.6 0-1.1-.3-1.3-.8v2.2H8.5V22Zm6.2 4.2c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .7.3.7.7 0 .4-.2.7-.7.7Zm-4.5 8.5L8 30h1.4l1.7 3.5 1.7-3.5h1.1l-2.2 4.6v.1c.5.8.7 1.4.7 1.8 0 .4-.1.8-.4 1-.2.2-.6.3-1 .3-.9 0-1.3-.4-1.3-1.2 0-.5.2-1 .5-1.7l.1-.2Zm.7 1a2 2 0 0 0-.4.9c0 .3.1.4.4.4.3 0 .4-.1.4-.4 0-.2-.1-.6-.4-1Zm4.5.5c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Z"/></g></svg>',
                    "list-num-lower-roman-rtl": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="M32.9 16v-1.2h-1.3V16H33Zm0 10v-1.2h-1.3V26H33Zm0 10v-1.2h-1.3V36H33Z"/><path fill-rule="nonzero" d="M36 21h-1.5v5H36zM36 31h-1.5v5H36zM39 21h-1.5v5H39zM39 31h-1.5v5H39zM42 31h-1.5v5H42zM36 11h-1.5v5H36zM36 19h-1.5v1H36zM36 29h-1.5v1H36zM39 19h-1.5v1H39zM39 29h-1.5v1H39zM42 29h-1.5v1H42zM36 9h-1.5v1H36z"/></g></svg>',
                    "list-num-lower-roman": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M15.1 16v-1.2h1.3V16H15Zm0 10v-1.2h1.3V26H15Zm0 10v-1.2h1.3V36H15Z"/><path fill-rule="nonzero" d="M12 21h1.5v5H12zM12 31h1.5v5H12zM9 21h1.5v5H9zM9 31h1.5v5H9zM6 31h1.5v5H6zM12 11h1.5v5H12zM12 19h1.5v1H12zM12 29h1.5v1H12zM9 19h1.5v1H9zM9 29h1.5v1H9zM6 29h1.5v1H6zM12 9h1.5v1H12z"/></g></svg>',
                    "list-num-upper-alpha-rtl": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="m39.3 17-.5-1.4h-2l-.5 1.4H35l2-6h1.6l2 6h-1.3Zm-1.6-4.7-.7 2.3h1.6l-.8-2.3ZM33.4 17c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .7.3.7.7 0 .4-.2.7-.7.7Zm4.7 9.9h-2.7v-6H38c1.2 0 1.9.6 1.9 1.5 0 .6-.5 1.2-1 1.3.7.1 1.3.7 1.3 1.5 0 1-.8 1.7-2 1.7Zm-1.4-5v1.5h1c.6 0 1-.3 1-.8 0-.4-.4-.7-1-.7h-1Zm0 4h1.1c.7 0 1.1-.3 1.1-.8 0-.6-.4-.9-1.1-.9h-1.1V26ZM33 27.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Zm4.9 10c-1.8 0-2.8-1.1-2.8-3.1s1-3.1 2.8-3.1c1.4 0 2.5.9 2.6 2.2h-1.3c0-.7-.6-1.1-1.3-1.1-1 0-1.6.7-1.6 2s.6 2 1.6 2c.7 0 1.2-.4 1.4-1h1.2c-.1 1.3-1.2 2.2-2.6 2.2Zm-4.5 0c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Z"/></g></svg>',
                    "list-num-upper-alpha": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="m12.6 17-.5-1.4h-2L9.5 17H8.3l2-6H12l2 6h-1.3ZM11 12.3l-.7 2.3h1.6l-.8-2.3Zm4.7 4.8c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .7.3.7.7 0 .4-.2.7-.7.7ZM11.4 27H8.7v-6h2.6c1.2 0 1.9.6 1.9 1.5 0 .6-.5 1.2-1 1.3.7.1 1.3.7 1.3 1.5 0 1-.8 1.7-2 1.7ZM10 22v1.5h1c.6 0 1-.3 1-.8 0-.4-.4-.7-1-.7h-1Zm0 4H11c.7 0 1.1-.3 1.1-.8 0-.6-.4-.9-1.1-.9H10V26Zm5.4 1.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Zm-4.1 10c-1.8 0-2.8-1.1-2.8-3.1s1-3.1 2.8-3.1c1.4 0 2.5.9 2.6 2.2h-1.3c0-.7-.6-1.1-1.3-1.1-1 0-1.6.7-1.6 2s.6 2 1.6 2c.7 0 1.2-.4 1.4-1h1.2c-.1 1.3-1.2 2.2-2.6 2.2Zm4.5 0c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Z"/></g></svg>',
                    "list-num-upper-roman-rtl": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="M31.6 17v-1.2H33V17h-1.3Zm0 10v-1.2H33V27h-1.3Zm0 10v-1.2H33V37h-1.3Z"/><path fill-rule="nonzero" d="M34.5 20H36v7h-1.5zM34.5 30H36v7h-1.5zM37.5 20H39v7h-1.5zM37.5 30H39v7h-1.5zM40.5 30H42v7h-1.5zM34.5 10H36v7h-1.5z"/></g></svg>',
                    "list-num-upper-roman": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M15.1 17v-1.2h1.3V17H15Zm0 10v-1.2h1.3V27H15Zm0 10v-1.2h1.3V37H15Z"/><path fill-rule="nonzero" d="M12 20h1.5v7H12zM12 30h1.5v7H12zM9 20h1.5v7H9zM9 30h1.5v7H9zM6 30h1.5v7H6zM12 10h1.5v7H12z"/></g></svg>',
                    lock: '<svg width="24" height="24"><path d="M16.3 11c.2 0 .3 0 .5.2l.2.6v7.4c0 .3 0 .4-.2.6l-.6.2H7.8c-.3 0-.4 0-.6-.2a.7.7 0 0 1-.2-.6v-7.4c0-.3 0-.4.2-.6l.5-.2H8V8c0-.8.3-1.5.9-2.1.6-.6 1.3-.9 2.1-.9h2c.8 0 1.5.3 2.1.9.6.6.9 1.3.9 2.1v3h.3ZM10 8v3h4V8a1 1 0 0 0-.3-.7A1 1 0 0 0 13 7h-2a1 1 0 0 0-.7.3 1 1 0 0 0-.3.7Z" fill-rule="evenodd"/></svg>',
                    ltr: '<svg width="24" height="24"><path d="M11 5h7a1 1 0 0 1 0 2h-1v11a1 1 0 0 1-2 0V7h-2v11a1 1 0 0 1-2 0v-6c-.5 0-1 0-1.4-.3A3.4 3.4 0 0 1 7.8 10a3.3 3.3 0 0 1 0-2.8 3.4 3.4 0 0 1 1.8-1.8L11 5ZM4.4 16.2 6.2 15l-1.8-1.2a1 1 0 0 1 1.2-1.6l3 2a1 1 0 0 1 0 1.6l-3 2a1 1 0 1 1-1.2-1.6Z" fill-rule="evenodd"/></svg>',
                    "more-drawer": '<svg width="24" height="24"><path d="M6 10a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2Zm12 0a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2Zm-6 0a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2Z" fill-rule="nonzero"/></svg>',
                    "new-document": '<svg width="24" height="24"><path d="M14.4 3H7a2 2 0 0 0-2 2v14c0 1.1.9 2 2 2h10a2 2 0 0 0 2-2V7.6L14.4 3ZM17 19H7V5h6v4h4v10Z" fill-rule="nonzero"/></svg>',
                    "new-tab": '<svg width="24" height="24"><path d="m15 13 2-2v8H5V7h8l-2 2H7v8h8v-4Zm4-8v5.5l-2-2-5.6 5.5H10v-1.4L15.5 7l-2-2H19Z" fill-rule="evenodd"/></svg>',
                    "non-breaking": '<svg width="24" height="24"><path d="M11 11H8a1 1 0 1 1 0-2h3V6c0-.6.4-1 1-1s1 .4 1 1v3h3c.6 0 1 .4 1 1s-.4 1-1 1h-3v3c0 .6-.4 1-1 1a1 1 0 0 1-1-1v-3Zm10 4v5H3v-5c0-.6.4-1 1-1s1 .4 1 1v3h14v-3c0-.6.4-1 1-1s1 .4 1 1Z" fill-rule="evenodd"/></svg>',
                    notice: '<svg width="24" height="24"><path d="M15.5 4 20 8.5v7L15.5 20h-7L4 15.5v-7L8.5 4h7ZM13 17v-2h-2v2h2Zm0-4V7h-2v6h2Z" fill-rule="evenodd" clip-rule="evenodd"/></svg>',
                    "ordered-list-rtl": '<svg width="24" height="24"><path d="M6 17h8a1 1 0 0 1 0 2H6a1 1 0 0 1 0-2Zm0-6h8a1 1 0 0 1 0 2H6a1 1 0 0 1 0-2Zm0-6h8a1 1 0 0 1 0 2H6a1 1 0 1 1 0-2Zm13-1v3.5a.5.5 0 1 1-1 0V5h-.5a.5.5 0 1 1 0-1H19Zm-1 8.8.2.2h1.3a.5.5 0 1 1 0 1h-1.6a1 1 0 0 1-.9-1V13c0-.4.3-.8.6-1l1.2-.4.2-.3a.2.2 0 0 0-.2-.2h-1.3a.5.5 0 0 1-.5-.5c0-.3.2-.5.5-.5h1.6c.5 0 .9.4.9 1v.1c0 .4-.3.8-.6 1l-1.2.4-.2.3Zm2 4.2v2c0 .6-.4 1-1 1h-1.5a.5.5 0 0 1 0-1h1.2a.3.3 0 1 0 0-.6h-1.3a.4.4 0 1 1 0-.8h1.3a.3.3 0 0 0 0-.6h-1.2a.5.5 0 1 1 0-1H19c.6 0 1 .4 1 1Z" fill-rule="evenodd"/></svg>',
                    "ordered-list": '<svg width="24" height="24"><path d="M10 17h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 1 1 0-2ZM6 4v3.5c0 .3-.2.5-.5.5a.5.5 0 0 1-.5-.5V5h-.5a.5.5 0 0 1 0-1H6Zm-1 8.8.2.2h1.3c.3 0 .5.2.5.5s-.2.5-.5.5H4.9a1 1 0 0 1-.9-1V13c0-.4.3-.8.6-1l1.2-.4.2-.3a.2.2 0 0 0-.2-.2H4.5a.5.5 0 0 1-.5-.5c0-.3.2-.5.5-.5h1.6c.5 0 .9.4.9 1v.1c0 .4-.3.8-.6 1l-1.2.4-.2.3ZM7 17v2c0 .6-.4 1-1 1H4.5a.5.5 0 0 1 0-1h1.2c.2 0 .3-.1.3-.3 0-.2-.1-.3-.3-.3H4.4a.4.4 0 1 1 0-.8h1.3c.2 0 .3-.1.3-.3 0-.2-.1-.3-.3-.3H4.5a.5.5 0 1 1 0-1H6c.6 0 1 .4 1 1Z" fill-rule="evenodd"/></svg>',
                    orientation: '<svg width="24" height="24"><path d="M7.3 6.4 1 13l6.4 6.5 6.5-6.5-6.5-6.5ZM3.7 13l3.6-3.7L11 13l-3.7 3.7-3.6-3.7ZM12 6l2.8 2.7c.3.3.3.8 0 1-.3.4-.9.4-1.2 0L9.2 5.7a.8.8 0 0 1 0-1.2L13.6.2c.3-.3.9-.3 1.2 0 .3.3.3.8 0 1.1L12 4h1a9 9 0 1 1-4.3 16.9l1.5-1.5A7 7 0 1 0 13 6h-1Z" fill-rule="nonzero"/></svg>',
                    outdent: '<svg width="24" height="24"><path d="M7 5h12c.6 0 1 .4 1 1s-.4 1-1 1H7a1 1 0 1 1 0-2Zm5 4h7c.6 0 1 .4 1 1s-.4 1-1 1h-7a1 1 0 0 1 0-2Zm0 4h7c.6 0 1 .4 1 1s-.4 1-1 1h-7a1 1 0 0 1 0-2Zm-5 4h12a1 1 0 0 1 0 2H7a1 1 0 0 1 0-2Zm1.6-3.8a1 1 0 0 1-1.2 1.6l-3-2a1 1 0 0 1 0-1.6l3-2a1 1 0 0 1 1.2 1.6L6.8 12l1.8 1.2Z" fill-rule="evenodd"/></svg>',
                    "page-break": '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M5 11c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 0 1 0-2Zm3 0h1c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 0 1 0-2Zm4 0c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 0 1 0-2Zm3 0h1c.6 0 1 .4 1 1s-.4 1-1 1h-1a1 1 0 0 1 0-2Zm4 0c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 0 1 0-2ZM7 3v5h10V3c0-.6.4-1 1-1s1 .4 1 1v7H5V3c0-.6.4-1 1-1s1 .4 1 1ZM6 22a1 1 0 0 1-1-1v-7h14v7c0 .6-.4 1-1 1a1 1 0 0 1-1-1v-5H7v5c0 .6-.4 1-1 1Z"/></g></svg>',
                    paragraph: '<svg width="24" height="24"><path fill-rule="evenodd" d="M10 5h7a1 1 0 0 1 0 2h-1v11a1 1 0 0 1-2 0V7h-2v11a1 1 0 0 1-2 0v-6c-.5 0-1 0-1.4-.3A3.4 3.4 0 0 1 6.8 10a3.3 3.3 0 0 1 0-2.8 3.4 3.4 0 0 1 1.8-1.8L10 5Z"/></svg>',
                    "paste-column-after": '<svg width="24" height="24"><path fill-rule="evenodd" d="M12 1a3 3 0 0 1 2.8 2H18c1 0 2 .8 2 1.9V7h-2V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 0 1-1-1V5H6v13h7v2H6c-1 0-2-.8-2-1.9V5c0-1 .8-2 1.9-2H9.2A3 3 0 0 1 12 1Zm8 7v12h-6V8h6Zm-1.5 1.5h-3v9h3v-9ZM12 3a1 1 0 1 0 0 2 1 1 0 0 0 0-2Z"/></svg>',
                    "paste-column-before": '<svg width="24" height="24"><path fill-rule="evenodd" d="M12 1a3 3 0 0 1 2.8 2H18c1 0 2 .8 2 1.9V18c0 1-.8 2-1.9 2H11v-2h7V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 0 1-1-1V5H6v2H4V5c0-1 .8-2 1.9-2H9.2A3 3 0 0 1 12 1Zm-2 7v12H4V8h6ZM8.5 9.5h-3v9h3v-9ZM12 3a1 1 0 1 0 0 2 1 1 0 0 0 0-2Z"/></svg>',
                    "paste-row-after": '<svg width="24" height="24"><path fill-rule="evenodd" d="M12 1a3 3 0 0 1 2.8 2H18c1 0 2 .8 2 1.9V11h-2V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 0 1-1-1V5H6v13h14c0 1-.8 2-1.9 2H6c-1 0-2-.8-2-1.9V5c0-1 .8-2 1.9-2H9.2A3 3 0 0 1 12 1Zm10 11v5H8v-5h14Zm-1.5 1.5h-11v2h11v-2ZM12 3a1 1 0 1 0 0 2 1 1 0 0 0 0-2Z"/></svg>',
                    "paste-row-before": '<svg width="24" height="24"><path fill-rule="evenodd" d="M12 1a3 3 0 0 1 2.8 2H18c1 0 2 .8 2 1.9V7h-2V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 0 1-1-1V5H6v13h12v-4h2v4c0 1-.8 2-1.9 2H6c-1 0-2-.8-2-1.9V5c0-1 .8-2 1.9-2H9.2A3 3 0 0 1 12 1Zm10 7v5H8V8h14Zm-1.5 1.5h-11v2h11v-2ZM12 3a1 1 0 1 0 0 2 1 1 0 0 0 0-2Z"/></svg>',
                    "paste-text": '<svg width="24" height="24"><path d="M18 9V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 0 1-1-1V5H6v13h3V9h9ZM9 20H6a2 2 0 0 1-2-2V5c0-1.1.9-2 2-2h3.2A3 3 0 0 1 12 1a3 3 0 0 1 2.8 2H18a2 2 0 0 1 2 2v4h1v12H9v-1Zm1.5-9.5v9h9v-9h-9ZM12 3a1 1 0 0 0-1 1c0 .5.4 1 1 1s1-.5 1-1-.4-1-1-1Zm0 9h6v2h-.5l-.5-1h-1v4h.8v1h-3.6v-1h.8v-4h-1l-.5 1H12v-2Z" fill-rule="nonzero"/></svg>',
                    paste: '<svg width="24" height="24"><path d="M18 9V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 0 1-1-1V5H6v13h3V9h9ZM9 20H6a2 2 0 0 1-2-2V5c0-1.1.9-2 2-2h3.2A3 3 0 0 1 12 1a3 3 0 0 1 2.8 2H18a2 2 0 0 1 2 2v4h1v12H9v-1Zm1.5-9.5v9h9v-9h-9ZM12 3a1 1 0 0 0-1 1c0 .5.4 1 1 1s1-.5 1-1-.4-1-1-1Z" fill-rule="nonzero"/></svg>',
                    "permanent-pen": '<svg width="24" height="24"><path d="M10.5 17.5 8 20H3v-3l3.5-3.5a2 2 0 0 1 0-3L14 3l1 1-7.3 7.3a1 1 0 0 0 0 1.4l3.6 3.6c.4.4 1 .4 1.4 0L20 9l1 1-7.6 7.6a2 2 0 0 1-2.8 0l-.1-.1Z" fill-rule="nonzero"/></svg>',
                    plus: '<svg width="24" height="24"><path d="M12 4c.5 0 1 .4 1 .9V11h6a1 1 0 0 1 .1 2H13v6a1 1 0 0 1-2 .1V13H5a1 1 0 0 1-.1-2H11V5c0-.6.4-1 1-1Z"/></svg>',
                    preferences: '<svg width="24" height="24"><path d="m20.1 13.5-1.9.2a5.8 5.8 0 0 1-.6 1.5l1.2 1.5c.4.4.3 1 0 1.4l-.7.7a1 1 0 0 1-1.4 0l-1.5-1.2a6.2 6.2 0 0 1-1.5.6l-.2 1.9c0 .5-.5.9-1 .9h-1a1 1 0 0 1-1-.9l-.2-1.9a5.8 5.8 0 0 1-1.5-.6l-1.5 1.2a1 1 0 0 1-1.4 0l-.7-.7a1 1 0 0 1 0-1.4l1.2-1.5a6.2 6.2 0 0 1-.6-1.5l-1.9-.2a1 1 0 0 1-.9-1v-1c0-.5.4-1 .9-1l1.9-.2a5.8 5.8 0 0 1 .6-1.5L5.2 7.3a1 1 0 0 1 0-1.4l.7-.7a1 1 0 0 1 1.4 0l1.5 1.2a6.2 6.2 0 0 1 1.5-.6l.2-1.9c0-.5.5-.9 1-.9h1c.5 0 1 .4 1 .9l.2 1.9a5.8 5.8 0 0 1 1.5.6l1.5-1.2a1 1 0 0 1 1.4 0l.7.7c.3.4.4 1 0 1.4l-1.2 1.5a6.2 6.2 0 0 1 .6 1.5l1.9.2c.5 0 .9.5.9 1v1c0 .5-.4 1-.9 1ZM12 15a3 3 0 1 0 0-6 3 3 0 0 0 0 6Z" fill-rule="evenodd"/></svg>',
                    preview: '<svg width="24" height="24"><path d="M3.5 12.5c.5.8 1.1 1.6 1.8 2.3 2 2 4.2 3.2 6.7 3.2s4.7-1.2 6.7-3.2a16.2 16.2 0 0 0 2.1-2.8 15.7 15.7 0 0 0-2.1-2.8c-2-2-4.2-3.2-6.7-3.2a9.3 9.3 0 0 0-6.7 3.2A16.2 16.2 0 0 0 3.2 12c0 .2.2.3.3.5Zm-2.4-1 .7-1.2L4 7.8C6.2 5.4 8.9 4 12 4c3 0 5.8 1.4 8.1 3.8a18.2 18.2 0 0 1 2.8 3.7v1l-.7 1.2-2.1 2.5c-2.3 2.4-5 3.8-8.1 3.8-3 0-5.8-1.4-8.1-3.8a18.2 18.2 0 0 1-2.8-3.7 1 1 0 0 1 0-1Zm12-3.3a2 2 0 1 0 2.7 2.6 4 4 0 1 1-2.6-2.6Z" fill-rule="nonzero"/></svg>',
                    print: '<svg width="24" height="24"><path d="M18 8H6a3 3 0 0 0-3 3v6h2v3h14v-3h2v-6a3 3 0 0 0-3-3Zm-1 10H7v-4h10v4Zm.5-5c-.8 0-1.5-.7-1.5-1.5s.7-1.5 1.5-1.5 1.5.7 1.5 1.5-.7 1.5-1.5 1.5Zm.5-8H6v2h12V5Z" fill-rule="nonzero"/></svg>',
                    quote: '<svg width="24" height="24"><path d="M7.5 17h.9c.4 0 .7-.2.9-.6L11 13V8c0-.6-.4-1-1-1H6a1 1 0 0 0-1 1v4c0 .6.4 1 1 1h2l-1.3 2.7a1 1 0 0 0 .8 1.3Zm8 0h.9c.4 0 .7-.2.9-.6L19 13V8c0-.6-.4-1-1-1h-4a1 1 0 0 0-1 1v4c0 .6.4 1 1 1h2l-1.3 2.7a1 1 0 0 0 .8 1.3Z" fill-rule="nonzero"/></svg>',
                    redo: '<svg width="24" height="24"><path d="M17.6 10H12c-2.8 0-4.4 1.4-4.9 3.5-.4 2 .3 4 1.4 4.6a1 1 0 1 1-1 1.8c-2-1.2-2.9-4.1-2.3-6.8.6-3 3-5.1 6.8-5.1h5.6l-3.3-3.3a1 1 0 1 1 1.4-1.4l5 5a1 1 0 0 1 0 1.4l-5 5a1 1 0 0 1-1.4-1.4l3.3-3.3Z" fill-rule="nonzero"/></svg>',
                    reload: '<svg width="24" height="24"><g fill-rule="nonzero"><path d="m5 22.1-1.2-4.7v-.2a1 1 0 0 1 1-1l5 .4a1 1 0 1 1-.2 2l-2.2-.2a7.8 7.8 0 0 0 8.4.2 7.5 7.5 0 0 0 3.5-6.4 1 1 0 1 1 2 0 9.5 9.5 0 0 1-4.5 8 9.9 9.9 0 0 1-10.2 0l.4 1.4a1 1 0 1 1-2 .5ZM13.6 7.4c0-.5.5-1 1-.9l2.8.2a8 8 0 0 0-9.5-1 7.5 7.5 0 0 0-3.6 7 1 1 0 0 1-2 0 9.5 9.5 0 0 1 4.5-8.6 10 10 0 0 1 10.9.3l-.3-1a1 1 0 0 1 2-.5l1.1 4.8a1 1 0 0 1-1 1.2l-5-.4a1 1 0 0 1-.9-1Z"/></g></svg>',
                    "remove-formatting": '<svg width="24" height="24"><path d="M13.2 6a1 1 0 0 1 0 .2l-2.6 10a1 1 0 0 1-1 .8h-.2a.8.8 0 0 1-.8-1l2.6-10H8a1 1 0 1 1 0-2h9a1 1 0 0 1 0 2h-3.8ZM5 18h7a1 1 0 0 1 0 2H5a1 1 0 0 1 0-2Zm13 1.5L16.5 18 15 19.5a.7.7 0 0 1-1-1l1.5-1.5-1.5-1.5a.7.7 0 0 1 1-1l1.5 1.5 1.5-1.5a.7.7 0 0 1 1 1L17.5 17l1.5 1.5a.7.7 0 0 1-1 1Z" fill-rule="evenodd"/></svg>',
                    remove: '<svg width="24" height="24"><path d="M16 7h3a1 1 0 0 1 0 2h-1v9a3 3 0 0 1-3 3H9a3 3 0 0 1-3-3V9H5a1 1 0 1 1 0-2h3V6a3 3 0 0 1 3-3h2a3 3 0 0 1 3 3v1Zm-2 0V6c0-.6-.4-1-1-1h-2a1 1 0 0 0-1 1v1h4Zm2 2H8v9c0 .6.4 1 1 1h6c.6 0 1-.4 1-1V9Zm-7 3a1 1 0 0 1 2 0v4a1 1 0 0 1-2 0v-4Zm4 0a1 1 0 0 1 2 0v4a1 1 0 0 1-2 0v-4Z" fill-rule="nonzero"/></svg>',
                    "resize-handle": '<svg width="10" height="10"><g fill-rule="nonzero"><path d="M8.1 1.1A.5.5 0 1 1 9 2l-7 7A.5.5 0 1 1 1 8l7-7ZM8.1 5.1A.5.5 0 1 1 9 6l-3 3A.5.5 0 1 1 5 8l3-3Z"/></g></svg>',
                    resize: '<svg width="24" height="24"><path d="M4 5c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h6c.3 0 .5.1.7.3.2.2.3.4.3.7 0 .3-.1.5-.3.7a1 1 0 0 1-.7.3H7.4L18 16.6V13c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3.3 0 .5.1.7.3.2.2.3.4.3.7v6c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3h-6a1 1 0 0 1-.7-.3 1 1 0 0 1-.3-.7c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h3.6L6 7.4V11c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3 1 1 0 0 1-.7-.3A1 1 0 0 1 4 11V5Z" fill-rule="evenodd"/></svg>',
                    "restore-draft": '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M17 13c0 .6-.4 1-1 1h-4V8c0-.6.4-1 1-1s1 .4 1 1v4h2c.6 0 1 .4 1 1Z"/><path d="M4.7 10H9a1 1 0 0 1 0 2H3a1 1 0 0 1-1-1V5a1 1 0 1 1 2 0v3l2.5-2.4a9.2 9.2 0 0 1 10.8-1.5A9 9 0 0 1 13.4 21c-2.4.1-4.7-.7-6.5-2.2a1 1 0 1 1 1.3-1.5 7.2 7.2 0 0 0 11.6-3.7 7 7 0 0 0-3.5-7.7A7.2 7.2 0 0 0 8 7L4.7 10Z" fill-rule="nonzero"/></g></svg>',
                    "rotate-left": '<svg width="24" height="24"><path d="M4.7 10H9a1 1 0 0 1 0 2H3a1 1 0 0 1-1-1V5a1 1 0 1 1 2 0v3l2.5-2.4a9.2 9.2 0 0 1 10.8-1.5A9 9 0 0 1 13.4 21c-2.4.1-4.7-.7-6.5-2.2a1 1 0 1 1 1.3-1.5 7.2 7.2 0 0 0 11.6-3.7 7 7 0 0 0-3.5-7.7A7.2 7.2 0 0 0 8 7L4.7 10Z" fill-rule="nonzero"/></svg>',
                    "rotate-right": '<svg width="24" height="24"><path d="M20 8V5a1 1 0 0 1 2 0v6c0 .6-.4 1-1 1h-6a1 1 0 0 1 0-2h4.3L16 7A7.2 7.2 0 0 0 7.7 6a7 7 0 0 0 3 13.1c1.9.1 3.7-.5 5-1.7a1 1 0 0 1 1.4 1.5A9.2 9.2 0 0 1 2.2 14c-.9-3.9 1-8 4.5-9.9 3.5-1.9 8-1.3 10.8 1.5L20 8Z" fill-rule="nonzero"/></svg>',
                    rtl: '<svg width="24" height="24"><path d="M8 5h8v2h-2v12h-2V7h-2v12H8v-7c-.5 0-1 0-1.4-.3A3.4 3.4 0 0 1 4.8 10a3.3 3.3 0 0 1 0-2.8 3.4 3.4 0 0 1 1.8-1.8L8 5Zm12 11.2a1 1 0 1 1-1 1.6l-3-2a1 1 0 0 1 0-1.6l3-2a1 1 0 1 1 1 1.6L18.4 15l1.8 1.2Z" fill-rule="evenodd"/></svg>',
                    save: '<svg width="24" height="24"><path d="M5 16h14a2 2 0 0 1 2 2v2a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-2c0-1.1.9-2 2-2Zm0 2v2h14v-2H5Zm10 0h2v2h-2v-2Zm-4-6.4L8.7 9.3a1 1 0 1 0-1.4 1.4l4 4c.4.4 1 .4 1.4 0l4-4a1 1 0 1 0-1.4-1.4L13 11.6V4a1 1 0 0 0-2 0v7.6Z" fill-rule="nonzero"/></svg>',
                    search: '<svg width="24" height="24"><path d="M16 17.3a8 8 0 1 1 1.4-1.4l4.3 4.4a1 1 0 0 1-1.4 1.4l-4.4-4.3Zm-5-.3a6 6 0 1 0 0-12 6 6 0 0 0 0 12Z" fill-rule="nonzero"/></svg>',
                    "select-all": '<svg width="24" height="24"><path d="M3 5h2V3a2 2 0 0 0-2 2Zm0 8h2v-2H3v2Zm4 8h2v-2H7v2ZM3 9h2V7H3v2Zm10-6h-2v2h2V3Zm6 0v2h2a2 2 0 0 0-2-2ZM5 21v-2H3c0 1.1.9 2 2 2Zm-2-4h2v-2H3v2ZM9 3H7v2h2V3Zm2 18h2v-2h-2v2Zm8-8h2v-2h-2v2Zm0 8a2 2 0 0 0 2-2h-2v2Zm0-12h2V7h-2v2Zm0 8h2v-2h-2v2Zm-4 4h2v-2h-2v2Zm0-16h2V3h-2v2ZM7 17h10V7H7v10Zm2-8h6v6H9V9Z" fill-rule="nonzero"/></svg>',
                    selected: '<svg width="24" height="24"><path fill-rule="nonzero" d="M6 4h12a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2Zm3.6 10.9L7 12.3a.7.7 0 0 0-1 1L9.6 17 18 8.6a.7.7 0 0 0 0-1 .7.7 0 0 0-1 0l-7.4 7.3Z"/></svg>',
                    settings: '<svg width="24" height="24"><path d="M11 6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8v.3c0 .2 0 .3-.2.5l-.6.2H7.8c-.3 0-.4 0-.6-.2a.7.7 0 0 1-.2-.6V8H5a1 1 0 1 1 0-2h2v-.3c0-.2 0-.3.2-.5l.5-.2h2.5c.3 0 .4 0 .6.2l.2.5V6ZM8 8h2V6H8v2Zm9 2.8v.2h2c.6 0 1 .4 1 1s-.4 1-1 1h-2v.3c0 .2 0 .3-.2.5l-.6.2h-2.4c-.3 0-.4 0-.6-.2a.7.7 0 0 1-.2-.6V13H5a1 1 0 0 1 0-2h8v-.3c0-.2 0-.3.2-.5l.6-.2h2.4c.3 0 .4 0 .6.2l.2.6ZM14 13h2v-2h-2v2Zm-3 2.8v.2h8c.6 0 1 .4 1 1s-.4 1-1 1h-8v.3c0 .2 0 .3-.2.5l-.6.2H7.8c-.3 0-.4 0-.6-.2a.7.7 0 0 1-.2-.6V18H5a1 1 0 0 1 0-2h2v-.3c0-.2 0-.3.2-.5l.5-.2h2.5c.3 0 .4 0 .6.2l.2.6ZM8 18h2v-2H8v2Z" fill-rule="evenodd"/></svg>',
                    sharpen: '<svg width="24" height="24"><path d="m16 6 4 4-8 9-8-9 4-4h8Zm-4 10.2 5.5-6.2-.1-.1H12v-.3h5.1l-.2-.2H12V9h4.6l-.2-.2H12v-.3h4.1l-.2-.2H12V8h3.6l-.2-.2H8.7L6.5 10l.1.1H12v.3H6.9l.2.2H12v.3H7.3l.2.2H12v.3H7.7l.3.2h4v.3H8.2l.2.2H12v.3H8.6l.3.2H12v.3H9l.3.2H12v.3H9.5l.2.2H12v.3h-2l.2.2H12v.3h-1.6l.2.2H12v.3h-1.1l.2.2h.9v.3h-.7l.2.2h.5v.3h-.3l.3.2Z" fill-rule="evenodd"/></svg>',
                    sourcecode: '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M9.8 15.7c.3.3.3.8 0 1-.3.4-.9.4-1.2 0l-4.4-4.1a.8.8 0 0 1 0-1.2l4.4-4.2c.3-.3.9-.3 1.2 0 .3.3.3.8 0 1.1L6 12l3.8 3.7ZM14.2 15.7c-.3.3-.3.8 0 1 .4.4.9.4 1.2 0l4.4-4.1c.3-.3.3-.9 0-1.2l-4.4-4.2a.8.8 0 0 0-1.2 0c-.3.3-.3.8 0 1.1L18 12l-3.8 3.7Z"/></g></svg>',
                    "spell-check": '<svg width="24" height="24"><path d="M6 8v3H5V5c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h2c.3 0 .5.1.7.3.2.2.3.4.3.7v6H8V8H6Zm0-3v2h2V5H6Zm13 0h-3v5h3v1h-3a1 1 0 0 1-.7-.3 1 1 0 0 1-.3-.7V5c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h3v1Zm-5 1.5-.1.7c-.1.2-.3.3-.6.3.3 0 .5.1.6.3l.1.7V10c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3h-3V4h3c.3 0 .5.1.7.3.2.2.3.4.3.7v1.5ZM13 10V8h-2v2h2Zm0-3V5h-2v2h2Zm3 5 1 1-6.5 7L7 15.5l1.3-1 2.2 2.2L16 12Z" fill-rule="evenodd"/></svg>',
                    "strike-through": '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M15.6 8.5c-.5-.7-1-1.1-1.3-1.3-.6-.4-1.3-.6-2-.6-2.7 0-2.8 1.7-2.8 2.1 0 1.6 1.8 2 3.2 2.3 4.4.9 4.6 2.8 4.6 3.9 0 1.4-.7 4.1-5 4.1A6.2 6.2 0 0 1 7 16.4l1.5-1.1c.4.6 1.6 2 3.7 2 1.6 0 2.5-.4 3-1.2.4-.8.3-2-.8-2.6-.7-.4-1.6-.7-2.9-1-1-.2-3.9-.8-3.9-3.6C7.6 6 10.3 5 12.4 5c2.9 0 4.2 1.6 4.7 2.4l-1.5 1.1Z"/><path d="M5 11h14a1 1 0 0 1 0 2H5a1 1 0 0 1 0-2Z" fill-rule="nonzero"/></g></svg>',
                    subscript: '<svg width="24" height="24"><path d="m10.4 10 4.6 4.6-1.4 1.4L9 11.4 4.4 16 3 14.6 7.6 10 3 5.4 4.4 4 9 8.6 13.6 4 15 5.4 10.4 10ZM21 19h-5v-1l1-.8 1.7-1.6c.3-.4.5-.8.5-1.2 0-.3 0-.6-.2-.7-.2-.2-.5-.3-.9-.3a2 2 0 0 0-.8.2l-.7.3-.4-1.1 1-.6 1.2-.2c.8 0 1.4.3 1.8.7.4.4.6.9.6 1.5s-.2 1.1-.5 1.6a8 8 0 0 1-1.3 1.3l-.6.6h2.6V19Z" fill-rule="nonzero"/></svg>',
                    superscript: '<svg width="24" height="24"><path d="M15 9.4 10.4 14l4.6 4.6-1.4 1.4L9 15.4 4.4 20 3 18.6 7.6 14 3 9.4 4.4 8 9 12.6 13.6 8 15 9.4Zm5.9 1.6h-5v-1l1-.8 1.7-1.6c.3-.5.5-.9.5-1.3 0-.3 0-.5-.2-.7-.2-.2-.5-.3-.9-.3l-.8.2-.7.4-.4-1.2c.2-.2.5-.4 1-.5.3-.2.8-.2 1.2-.2.8 0 1.4.2 1.8.6.4.4.6 1 .6 1.6 0 .5-.2 1-.5 1.5l-1.3 1.4-.6.5h2.6V11Z" fill-rule="nonzero"/></svg>',
                    "table-caption": '<svg width="24" height="24"><g fill-rule="nonzero"><rect width="12" height="2" x="3" y="4" rx="1"/><path d="M19 8a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-8c0-1.1.9-2 2-2h14ZM5 15v3h6v-3H5Zm14 0h-6v3h6v-3Zm0-5h-6v3h6v-3ZM5 13h6v-3H5v3Z"/></g></svg>',
                    "table-cell-classes": '<svg width="24" height="24"><g fill-rule="evenodd"><path fill-rule="nonzero" d="M13 4v9H3V6c0-1.1.9-2 2-2h8Zm-2 2H5v5h6V6Z"/><path fill-rule="nonzero" d="M13 4h6a2 2 0 0 1 2 2v7h-8v-2h6V6h-6V4Z" opacity=".2"/><path d="m18 20-2.6 1.6.7-3-2.4-2 3.1-.2 1.2-2.9 1.2 2.9 3.1.2-2.4 2 .7 3z"/><path fill-rule="nonzero" d="M3 13v5c0 1.1.9 2 2 2h8v-7h-2v5H5v-5H3Z" opacity=".2"/></g></svg>',
                    "table-cell-properties": '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm-8 9H5v5h6v-5Zm8 0h-6v5h6v-5Zm-8-7H5v5h6V6Z"/></svg>',
                    "table-cell-select-all": '<svg width="24" height="24"><g fill-rule="evenodd"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm0 2H5v12h14V6Z"/><path d="M13 6v5h6v2h-6v5h-2v-5H5v-2h6V6h2Z" opacity=".2"/></g></svg>',
                    "table-cell-select-inner": '<svg width="24" height="24"><g fill-rule="evenodd"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm0 2H5v12h14V6Z" opacity=".2"/><path d="M13 6v5h6v2h-6v5h-2v-5H5v-2h6V6h2Z"/></g></svg>',
                    "table-classes": '<svg width="24" height="24"><g fill-rule="evenodd"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v7h-8v7H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm-8 9H5v5h6v-5Zm8-7h-6v5h6V6Zm-8 0H5v5h6V6Z"/><path d="m18 20-2.6 1.6.7-3-2.4-2 3.1-.2 1.2-2.9 1.2 2.9 3.1.2-2.4 2 .7 3z"/></g></svg>',
                    "table-delete-column": '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm-4 4h-2V6h-2v2H9V6H5v12h4v-2h2v2h2v-2h2v2h4V6h-4v2Zm.3.5 1 1.2-3 2.3 3 2.3-1 1.2L12 13l-3.3 2.6-1-1.2 3-2.3-3-2.3 1-1.2L12 11l3.3-2.5Z"/></svg>',
                    "table-delete-row": '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm0 2H5v3h2.5v2H5v2h2.5v2H5v3h14v-3h-2.5v-2H19v-2h-2.5V9H19V6Zm-4.7 1.8 1.2 1L13 12l2.6 3.3-1.2 1-2.3-3-2.3 3-1.2-1L11 12 8.5 8.7l1.2-1 2.3 3 2.3-3Z"/></svg>',
                    "table-delete-table": '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14ZM5 6v12h14V6H5Z"/><path d="m14.4 8.6 1.1 1-2.4 2.4 2.4 2.4-1.1 1.1-2.4-2.4-2.4 2.4-1-1.1 2.3-2.4-2.3-2.4 1-1 2.4 2.3z"/></g></svg>',
                    "table-insert-column-after": '<svg width="24" height="24"><path fill-rule="nonzero" d="M20 4c.6 0 1 .4 1 1v2a1 1 0 0 1-2 0V6h-8v12h8v-1a1 1 0 0 1 2 0v2c0 .5-.4 1-.9 1H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h15ZM9 13H5v5h4v-5Zm7-5c.5 0 1 .4 1 .9V11h2a1 1 0 0 1 .1 2H17v2a1 1 0 0 1-2 .1V13h-2a1 1 0 0 1-.1-2H15V9c0-.6.4-1 1-1ZM9 6H5v5h4V6Z"/></svg>',
                    "table-insert-column-before": '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H4a1 1 0 0 1-1-1v-2a1 1 0 0 1 2 0v1h8V6H5v1a1 1 0 1 1-2 0V5c0-.6.4-1 1-1h15Zm0 9h-4v5h4v-5ZM8 8c.5 0 1 .4 1 .9V11h2a1 1 0 0 1 .1 2H9v2a1 1 0 0 1-2 .1V13H5a1 1 0 0 1-.1-2H7V9c0-.6.4-1 1-1Zm11-2h-4v5h4V6Z"/></svg>',
                    "table-insert-row-above": '<svg width="24" height="24"><path fill-rule="nonzero" d="M6 4a1 1 0 1 1 0 2H5v6h14V6h-1a1 1 0 0 1 0-2h2c.6 0 1 .4 1 1v13a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5c0-.6.4-1 1-1h2Zm5 10H5v4h6v-4Zm8 0h-6v4h6v-4ZM12 3c.5 0 1 .4 1 .9V6h2a1 1 0 0 1 0 2h-2v2a1 1 0 0 1-2 .1V8H9a1 1 0 0 1 0-2h2V4c0-.6.4-1 1-1Z"/></svg>',
                    "table-insert-row-after": '<svg width="24" height="24"><path fill-rule="nonzero" d="M12 13c.5 0 1 .4 1 .9V16h2a1 1 0 0 1 .1 2H13v2a1 1 0 0 1-2 .1V18H9a1 1 0 0 1-.1-2H11v-2c0-.6.4-1 1-1Zm6 7a1 1 0 0 1 0-2h1v-6H5v6h1a1 1 0 0 1 0 2H4a1 1 0 0 1-1-1V6c0-1.1.9-2 2-2h14a2 2 0 0 1 2 2v13c0 .5-.4 1-.9 1H18ZM11 6H5v4h6V6Zm8 0h-6v4h6V6Z"/></svg>',
                    "table-left-header": '<svg width="24" height="24"><path d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm0 9h-4v5h4v-5Zm-6 0H9v5h4v-5Zm0-7H9v5h4V6Zm6 0h-4v5h4V6Z"/></svg>',
                    "table-merge-cells": '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14ZM5 15.5V18h3v-2.5H5Zm14-5h-9V18h9v-7.5ZM19 6h-4v2.5h4V6ZM8 6H5v2.5h3V6Zm5 0h-3v2.5h3V6Zm-8 7.5h3v-3H5v3Z"/></svg>',
                    "table-row-numbering-rtl": '<svg width="24" height="24"><path d="M6 4a2 2 0 0 0-2 2v13c0 1.1.9 2 2 2h12a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2H6Zm0 12h8v3H6v-3Zm11 0c.6 0 1 .4 1 1v1a1 1 0 0 1-2 0v-1c0-.6.4-1 1-1ZM6 11h8v3H6v-3Zm11 0c.6 0 1 .4 1 1v1a1 1 0 0 1-2 0v-1c0-.6.4-1 1-1ZM6 6h8v3H6V6Zm11 0c.6 0 1 .4 1 1v1a1 1 0 1 1-2 0V7c0-.6.4-1 1-1Z"/></svg>',
                    "table-row-numbering": '<svg width="24" height="24"><path d="M18 4a2 2 0 0 1 2 2v13a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h12Zm0 12h-8v3h8v-3ZM7 16a1 1 0 0 0-1 1v1a1 1 0 0 0 2 0v-1c0-.6-.4-1-1-1Zm11-5h-8v3h8v-3ZM7 11a1 1 0 0 0-1 1v1a1 1 0 0 0 2 0v-1c0-.6-.4-1-1-1Zm11-5h-8v3h8V6ZM7 6a1 1 0 0 0-1 1v1a1 1 0 1 0 2 0V7c0-.6-.4-1-1-1Z"/></svg>',
                    "table-row-properties": '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14ZM5 15v3h6v-3H5Zm14 0h-6v3h6v-3Zm0-9h-6v3h6V6ZM5 9h6V6H5v3Z"/></svg>',
                    "table-split-cells": '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14ZM8 15.5H5V18h3v-2.5Zm11-5h-9V18h9v-7.5Zm-2.5 1 1 1-2 2 2 2-1 1-2-2-2 2-1-1 2-2-2-2 1-1 2 2 2-2Zm-8.5-1H5v3h3v-3ZM19 6h-4v2.5h4V6ZM8 6H5v2.5h3V6Zm5 0h-3v2.5h3V6Z"/></svg>',
                    "table-top-header": '<svg width="24" height="24"><path d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm-8 11H5v3h6v-3Zm8 0h-6v3h6v-3Zm0-5h-6v3h6v-3ZM5 13h6v-3H5v3Z"/></svg>',
                    table: '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14ZM5 14v4h6v-4H5Zm14 0h-6v4h6v-4Zm0-6h-6v4h6V8ZM5 12h6V8H5v4Z"/></svg>',
                    template: '<svg width="24" height="24"><path d="M19 19v-1H5v1h14ZM9 16v-4a5 5 0 1 1 6 0v4h4a2 2 0 0 1 2 2v3H3v-3c0-1.1.9-2 2-2h4Zm4 0v-5l.8-.6a3 3 0 1 0-3.6 0l.8.6v5h2Z" fill-rule="nonzero"/></svg>',
                    "temporary-placeholder": '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M9 7.6V6h2.5V4.5a.5.5 0 1 1 1 0V6H15v1.6a8 8 0 1 1-6 0Zm-2.6 5.3a.5.5 0 0 0 .3.6c.3 0 .6 0 .6-.3l.1-.2a5 5 0 0 1 3.3-2.8c.3-.1.4-.4.4-.6-.1-.3-.4-.5-.6-.4a6 6 0 0 0-4.1 3.7Z"/><circle cx="14" cy="4" r="1"/><circle cx="12" cy="2" r="1"/><circle cx="10" cy="4" r="1"/></g></svg>',
                    "text-color": '<svg width="24" height="24"><g fill-rule="evenodd"><path id="tox-icon-text-color__color" d="M3 18h18v3H3z"/><path d="M8.7 16h-.8a.5.5 0 0 1-.5-.6l2.7-9c.1-.3.3-.4.5-.4h2.8c.2 0 .4.1.5.4l2.7 9a.5.5 0 0 1-.5.6h-.8a.5.5 0 0 1-.4-.4l-.7-2.2c0-.3-.3-.4-.5-.4h-3.4c-.2 0-.4.1-.5.4l-.7 2.2c0 .3-.2.4-.4.4Zm2.6-7.6-.6 2a.5.5 0 0 0 .5.6h1.6a.5.5 0 0 0 .5-.6l-.6-2c0-.3-.3-.4-.5-.4h-.4c-.2 0-.4.1-.5.4Z"/></g></svg>',
                    toc: '<svg width="24" height="24"><path d="M5 5c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 1 1 0-2Zm3 0h11c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 1 1 0-2Zm-3 8c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 0 1 0-2Zm3 0h11c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 0 1 0-2Zm0-4c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 1 1 0-2Zm3 0h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm-3 8c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 0 1 0-2Zm3 0h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Z" fill-rule="evenodd"/></svg>',
                    translate: '<svg width="24" height="24"><path d="m12.7 14.3-.3.7-.4.7-2.2-2.2-3.1 3c-.3.4-.8.4-1 0a.7.7 0 0 1 0-1l3.1-3A12.4 12.4 0 0 1 6.7 9H8a10.1 10.1 0 0 0 1.7 2.4c.5-.5 1-1.1 1.4-1.8l.9-2H4.7a.7.7 0 1 1 0-1.5h4.4v-.7c0-.4.3-.8.7-.8.4 0 .7.4.7.8v.7H15c.4 0 .8.3.8.7 0 .4-.4.8-.8.8h-1.4a12.3 12.3 0 0 1-1 2.4 13.5 13.5 0 0 1-1.7 2.3l1.9 1.8Zm4.3-3 2.7 7.3a.5.5 0 0 1-.4.7 1 1 0 0 1-1-.7l-.6-1.5h-3.4l-.6 1.5a1 1 0 0 1-1 .7.5.5 0 0 1-.4-.7l2.7-7.4a1 1 0 0 1 2 0Zm-2.2 4.4h2.4L16 12.5l-1.2 3.2Z" fill-rule="evenodd"/></svg>',
                    typography: '<svg width="24" height="24"><path fill-rule="evenodd" clip-rule="evenodd" d="M17 5a1 1 0 1 1 0 2h-4v11a1 1 0 1 1-2 0V7H7a1 1 0 0 1 0-2h10Z"/><path d="m17.5 14 .8-1.7 1.7-.8-1.7-.8-.8-1.7-.8 1.7-1.7.8 1.7.8.8 1.7ZM7 14l1 2 2 1-2 1-1 2-1-2-2-1 2-1 1-2Z"/></svg>',
                    underline: '<svg width="24" height="24"><path d="M16 5c.6 0 1 .4 1 1v5.5a4 4 0 0 1-.4 1.8l-1 1.4a5.3 5.3 0 0 1-5.5 1 5 5 0 0 1-1.6-1c-.5-.4-.8-.9-1.1-1.4a4 4 0 0 1-.4-1.8V6c0-.6.4-1 1-1s1 .4 1 1v5.5c0 .3 0 .6.2 1l.6.7a3.3 3.3 0 0 0 2.2.8 3.4 3.4 0 0 0 2.2-.8c.3-.2.4-.5.6-.8l.2-.9V6c0-.6.4-1 1-1ZM8 17h8c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 0 1 0-2Z" fill-rule="evenodd"/></svg>',
                    undo: '<svg width="24" height="24"><path d="M6.4 8H12c3.7 0 6.2 2 6.8 5.1.6 2.7-.4 5.6-2.3 6.8a1 1 0 0 1-1-1.8c1.1-.6 1.8-2.7 1.4-4.6-.5-2.1-2.1-3.5-4.9-3.5H6.4l3.3 3.3a1 1 0 1 1-1.4 1.4l-5-5a1 1 0 0 1 0-1.4l5-5a1 1 0 0 1 1.4 1.4L6.4 8Z" fill-rule="nonzero"/></svg>',
                    unlink: '<svg width="24" height="24"><path d="M6.2 12.3a1 1 0 0 1 1.4 1.4l-2 2a2 2 0 1 0 2.6 2.8l4.8-4.8a1 1 0 0 0 0-1.4 1 1 0 1 1 1.4-1.3 2.9 2.9 0 0 1 0 4L9.6 20a3.9 3.9 0 0 1-5.5-5.5l2-2Zm11.6-.6a1 1 0 0 1-1.4-1.4l2.1-2a2 2 0 1 0-2.7-2.8L11 10.3a1 1 0 0 0 0 1.4A1 1 0 1 1 9.6 13a2.9 2.9 0 0 1 0-4L14.4 4a3.9 3.9 0 0 1 5.5 5.5l-2 2ZM7.6 6.3a.8.8 0 0 1-1 1.1L3.3 4.2a.7.7 0 1 1 1-1l3.2 3.1ZM5.1 8.6a.8.8 0 0 1 0 1.5H3a.8.8 0 0 1 0-1.5H5Zm5-3.5a.8.8 0 0 1-1.5 0V3a.8.8 0 0 1 1.5 0V5Zm6 11.8a.8.8 0 0 1 1-1l3.2 3.2a.8.8 0 0 1-1 1L16 17Zm-2.2 2a.8.8 0 0 1 1.5 0V21a.8.8 0 0 1-1.5 0V19Zm5-3.5a.7.7 0 1 1 0-1.5H21a.8.8 0 0 1 0 1.5H19Z" fill-rule="nonzero"/></svg>',
                    unlock: '<svg width="24" height="24"><path d="M16 5c.8 0 1.5.3 2.1.9.6.6.9 1.3.9 2.1v3h-2V8a1 1 0 0 0-.3-.7A1 1 0 0 0 16 7h-2a1 1 0 0 0-.7.3 1 1 0 0 0-.3.7v3h.3c.2 0 .3 0 .5.2l.2.6v7.4c0 .3 0 .4-.2.6l-.6.2H4.8c-.3 0-.4 0-.6-.2a.7.7 0 0 1-.2-.6v-7.4c0-.3 0-.4.2-.6l.5-.2H11V8c0-.8.3-1.5.9-2.1.6-.6 1.3-.9 2.1-.9h2Z" fill-rule="evenodd"/></svg>',
                    "unordered-list": '<svg width="24" height="24"><path d="M11 5h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0 6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0 6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2ZM4.5 6c0-.4.1-.8.4-1 .3-.4.7-.5 1.1-.5.4 0 .8.1 1 .4.4.3.5.7.5 1.1 0 .4-.1.8-.4 1-.3.4-.7.5-1.1.5-.4 0-.8-.1-1-.4-.4-.3-.5-.7-.5-1.1Zm0 6c0-.4.1-.8.4-1 .3-.4.7-.5 1.1-.5.4 0 .8.1 1 .4.4.3.5.7.5 1.1 0 .4-.1.8-.4 1-.3.4-.7.5-1.1.5-.4 0-.8-.1-1-.4-.4-.3-.5-.7-.5-1.1Zm0 6c0-.4.1-.8.4-1 .3-.4.7-.5 1.1-.5.4 0 .8.1 1 .4.4.3.5.7.5 1.1 0 .4-.1.8-.4 1-.3.4-.7.5-1.1.5-.4 0-.8-.1-1-.4-.4-.3-.5-.7-.5-1.1Z" fill-rule="evenodd"/></svg>',
                    unselected: '<svg width="24" height="24"><path fill-rule="nonzero" d="M6 4h12a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2Zm0 1a1 1 0 0 0-1 1v12c0 .6.4 1 1 1h12c.6 0 1-.4 1-1V6c0-.6-.4-1-1-1H6Z"/></svg>',
                    upload: '<svg width="24" height="24"><path d="M18 19v-2a1 1 0 0 1 2 0v3c0 .6-.4 1-1 1H5a1 1 0 0 1-1-1v-3a1 1 0 0 1 2 0v2h12ZM11 6.4 8.7 8.7a1 1 0 0 1-1.4-1.4l4-4a1 1 0 0 1 1.4 0l4 4a1 1 0 1 1-1.4 1.4L13 6.4V16a1 1 0 0 1-2 0V6.4Z" fill-rule="nonzero"/></svg>',
                    user: '<svg width="24" height="24"><path d="M12 24a12 12 0 1 1 0-24 12 12 0 0 1 0 24Zm-8.7-5.3a11 11 0 0 0 17.4 0C19.4 16.3 14.6 15 12 15c-2.6 0-7.4 1.3-8.7 3.7ZM12 13c2.2 0 4-2 4-4.5S14.2 4 12 4 8 6 8 8.5 9.8 13 12 13Z" fill-rule="nonzero"/></svg>',
                    "vertical-align": '<svg width="24" height="24"><g fill-rule="nonzero"><rect width="18" height="2" x="3" y="11" rx="1"/><path d="M12 2c.6 0 1 .4 1 1v4l2-1.3a1 1 0 0 1 1.2 1.5l-.1.1-4.1 3-4-3a1 1 0 0 1 1-1.7l2 1.5V3c0-.6.4-1 1-1zm0 11.8 4 2.9a1 1 0 0 1-1 1.7l-2-1.5V21c0 .5-.4 1-.9 1H12a1 1 0 0 1-1-1v-4l-2 1.3a1 1 0 0 1-1.2-.1l-.1-.1a1 1 0 0 1 .1-1.3l.1-.1 4.1-3z"/></g></svg>',
                    visualblocks: '<svg width="24" height="24"><path d="M9 19v2H7v-2h2Zm-4 0v2a2 2 0 0 1-2-2h2Zm8 0v2h-2v-2h2Zm8 0a2 2 0 0 1-2 2v-2h2Zm-4 0v2h-2v-2h2ZM15 7a1 1 0 0 1 0 2v7a1 1 0 0 1-2 0V9h-1v7a1 1 0 0 1-2 0v-4a2.5 2.5 0 0 1-.2-5H15ZM5 15v2H3v-2h2Zm16 0v2h-2v-2h2ZM5 11v2H3v-2h2Zm16 0v2h-2v-2h2ZM5 7v2H3V7h2Zm16 0v2h-2V7h2ZM5 3v2H3c0-1.1.9-2 2-2Zm8 0v2h-2V3h2Zm6 0a2 2 0 0 1 2 2h-2V3ZM9 3v2H7V3h2Zm8 0v2h-2V3h2Z" fill-rule="evenodd"/></svg>',
                    visualchars: '<svg width="24" height="24"><path d="M10 5h7a1 1 0 0 1 0 2h-1v11a1 1 0 0 1-2 0V7h-2v11a1 1 0 0 1-2 0v-6c-.5 0-1 0-1.4-.3A3.4 3.4 0 0 1 6.8 10a3.3 3.3 0 0 1 0-2.8 3.4 3.4 0 0 1 1.8-1.8L10 5Z" fill-rule="evenodd"/></svg>',
                    warning: '<svg width="24" height="24"><path d="M19.8 18.3c.2.5.3.9 0 1.2-.1.3-.5.5-1 .5H5.2c-.5 0-.9-.2-1-.5-.3-.3-.2-.7 0-1.2L11 4.7l.5-.5.5-.2c.2 0 .3 0 .5.2.2 0 .3.3.5.5l6.8 13.6ZM12 18c.3 0 .5-.1.7-.3.2-.2.3-.4.3-.7a1 1 0 0 0-.3-.7 1 1 0 0 0-.7-.3 1 1 0 0 0-.7.3 1 1 0 0 0-.3.7c0 .3.1.5.3.7.2.2.4.3.7.3Zm.7-3 .3-4a1 1 0 0 0-.3-.7 1 1 0 0 0-.7-.3 1 1 0 0 0-.7.3 1 1 0 0 0-.3.7l.3 4h1.4Z" fill-rule="evenodd"/></svg>',
                    "zoom-in": '<svg width="24" height="24"><path d="M16 17.3a8 8 0 1 1 1.4-1.4l4.3 4.4a1 1 0 0 1-1.4 1.4l-4.4-4.3Zm-5-.3a6 6 0 1 0 0-12 6 6 0 0 0 0 12Zm-1-9a1 1 0 0 1 2 0v6a1 1 0 0 1-2 0V8Zm-2 4a1 1 0 0 1 0-2h6a1 1 0 0 1 0 2H8Z" fill-rule="nonzero"/></svg>',
                    "zoom-out": '<svg width="24" height="24"><path d="M16 17.3a8 8 0 1 1 1.4-1.4l4.3 4.4a1 1 0 0 1-1.4 1.4l-4.4-4.3Zm-5-.3a6 6 0 1 0 0-12 6 6 0 0 0 0 12Zm-3-5a1 1 0 0 1 0-2h6a1 1 0 0 1 0 2H8Z" fill-rule="nonzero"/></svg>'
                }
            })
        },
        6890: function(e, t, o) {
            o(88785)
        },
        7490: function(e, t, o) {
            o(63557)
        },
        63557: function() {
            ! function() {
                "use strict";
                var e = tinymce.util.Tools.resolve("tinymce.ModelManager");
                const t = e => t => (e => {
                        const t = typeof e;
                        return null === e ? "null" : "object" === t && Array.isArray(e) ? "array" : "object" === t && (o = n = e, (r = String).prototype.isPrototypeOf(o) || (null === (s = n.constructor) || void 0 === s ? void 0 : s.name) === r.name) ? "string" : t;
                        var o, n, r, s
                    })(t) === e,
                    o = e => t => typeof t === e,
                    n = e => t => e === t,
                    r = t("string"),
                    s = t("object"),
                    a = t("array"),
                    i = n(null),
                    l = o("boolean"),
                    c = n(void 0),
                    d = e => !(e => null == e)(e),
                    u = o("function"),
                    m = o("number"),
                    g = () => {},
                    h = e => () => e,
                    p = e => e,
                    f = (e, t) => e === t;

                function v(e, ...t) {
                    return (...o) => {
                        const n = t.concat(o);
                        return e.apply(null, n)
                    }
                }
                const b = e => t => !e(t),
                    y = e => e(),
                    w = h(!1),
                    x = h(!0);
                class C {
                    constructor(e, t) {
                        this.tag = e, this.value = t
                    }
                    static some(e) {
                        return new C(!0, e)
                    }
                    static none() {
                        return C.singletonNone
                    }
                    fold(e, t) {
                        return this.tag ? t(this.value) : e()
                    }
                    isSome() {
                        return this.tag
                    }
                    isNone() {
                        return !this.tag
                    }
                    map(e) {
                        return this.tag ? C.some(e(this.value)) : C.none()
                    }
                    bind(e) {
                        return this.tag ? e(this.value) : C.none()
                    }
                    exists(e) {
                        return this.tag && e(this.value)
                    }
                    forall(e) {
                        return !this.tag || e(this.value)
                    }
                    filter(e) {
                        return !this.tag || e(this.value) ? this : C.none()
                    }
                    getOr(e) {
                        return this.tag ? this.value : e
                    }
                    or(e) {
                        return this.tag ? this : e
                    }
                    getOrThunk(e) {
                        return this.tag ? this.value : e()
                    }
                    orThunk(e) {
                        return this.tag ? this : e()
                    }
                    getOrDie(e) {
                        if (this.tag) return this.value;
                        throw new Error(null != e ? e : "Called getOrDie on None")
                    }
                    static from(e) {
                        return d(e) ? C.some(e) : C.none()
                    }
                    getOrNull() {
                        return this.tag ? this.value : null
                    }
                    getOrUndefined() {
                        return this.value
                    }
                    each(e) {
                        this.tag && e(this.value)
                    }
                    toArray() {
                        return this.tag ? [this.value] : []
                    }
                    toString() {
                        return this.tag ? `some(${this.value})` : "none()"
                    }
                }
                C.singletonNone = new C(!1);
                const S = Array.prototype.slice,
                    k = Array.prototype.indexOf,
                    _ = Array.prototype.push,
                    O = (e, t) => {
                        return o = e, n = t, k.call(o, n) > -1;
                        var o, n
                    },
                    T = (e, t) => {
                        for (let o = 0, n = e.length; o < n; o++)
                            if (t(e[o], o)) return !0;
                        return !1
                    },
                    E = (e, t) => {
                        const o = [];
                        for (let n = 0; n < e; n++) o.push(t(n));
                        return o
                    },
                    A = (e, t) => {
                        const o = e.length,
                            n = new Array(o);
                        for (let r = 0; r < o; r++) {
                            const o = e[r];
                            n[r] = t(o, r)
                        }
                        return n
                    },
                    M = (e, t) => {
                        for (let o = 0, n = e.length; o < n; o++) t(e[o], o)
                    },
                    N = (e, t) => {
                        const o = [],
                            n = [];
                        for (let r = 0, s = e.length; r < s; r++) {
                            const s = e[r];
                            (t(s, r) ? o : n).push(s)
                        }
                        return {
                            pass: o,
                            fail: n
                        }
                    },
                    R = (e, t) => {
                        const o = [];
                        for (let n = 0, r = e.length; n < r; n++) {
                            const r = e[n];
                            t(r, n) && o.push(r)
                        }
                        return o
                    },
                    D = (e, t, o) => (((e, t) => {
                        for (let o = e.length - 1; o >= 0; o--) t(e[o], o)
                    })(e, ((e, n) => {
                        o = t(o, e, n)
                    })), o),
                    B = (e, t, o) => (M(e, ((e, n) => {
                        o = t(o, e, n)
                    })), o),
                    L = (e, t) => ((e, t, o) => {
                        for (let n = 0, r = e.length; n < r; n++) {
                            const r = e[n];
                            if (t(r, n)) return C.some(r);
                            if (o(r, n)) break
                        }
                        return C.none()
                    })(e, t, w),
                    H = (e, t) => {
                        for (let o = 0, n = e.length; o < n; o++)
                            if (t(e[o], o)) return C.some(o);
                        return C.none()
                    },
                    I = e => {
                        const t = [];
                        for (let o = 0, n = e.length; o < n; ++o) {
                            if (!a(e[o])) throw new Error("Arr.flatten item " + o + " was not an array, input: " + e);
                            _.apply(t, e[o])
                        }
                        return t
                    },
                    P = (e, t) => I(A(e, t)),
                    z = (e, t) => {
                        for (let o = 0, n = e.length; o < n; ++o)
                            if (!0 !== t(e[o], o)) return !1;
                        return !0
                    },
                    F = (e, t) => {
                        const o = {};
                        for (let n = 0, r = e.length; n < r; n++) {
                            const r = e[n];
                            o[String(r)] = t(r, n)
                        }
                        return o
                    },
                    V = (e, t) => t >= 0 && t < e.length ? C.some(e[t]) : C.none(),
                    Z = e => V(e, 0),
                    U = e => V(e, e.length - 1),
                    j = (e, t) => {
                        for (let o = 0; o < e.length; o++) {
                            const n = t(e[o], o);
                            if (n.isSome()) return n
                        }
                        return C.none()
                    },
                    W = Object.keys,
                    $ = Object.hasOwnProperty,
                    q = (e, t) => {
                        const o = W(e);
                        for (let n = 0, r = o.length; n < r; n++) {
                            const r = o[n];
                            t(e[r], r)
                        }
                    },
                    G = (e, t) => K(e, ((e, o) => ({
                        k: o,
                        v: t(e, o)
                    }))),
                    K = (e, t) => {
                        const o = {};
                        return q(e, ((e, n) => {
                            const r = t(e, n);
                            o[r.k] = r.v
                        })), o
                    },
                    Y = (e, t) => {
                        const o = [];
                        return q(e, ((e, n) => {
                            o.push(t(e, n))
                        })), o
                    },
                    X = e => Y(e, p),
                    J = (e, t) => $.call(e, t);
                "undefined" != typeof window ? window : Function("return this;")();
                const Q = e => e.dom.nodeName.toLowerCase(),
                    ee = e => e.dom.nodeType,
                    te = e => t => ee(t) === e,
                    oe = e => 8 === ee(e) || "#comment" === Q(e),
                    ne = te(1),
                    re = te(3),
                    se = te(9),
                    ae = te(11),
                    ie = e => t => ne(t) && Q(t) === e,
                    le = (e, t, o) => {
                        if (!(r(o) || l(o) || m(o))) throw console.error("Invalid call to Attribute.set. Key ", t, ":: Value ", o, ":: Element ", e), new Error("Attribute value was not simple");
                        e.setAttribute(t, o + "")
                    },
                    ce = (e, t, o) => {
                        le(e.dom, t, o)
                    },
                    de = (e, t) => {
                        const o = e.dom;
                        q(t, ((e, t) => {
                            le(o, t, e)
                        }))
                    },
                    ue = (e, t) => {
                        const o = e.dom.getAttribute(t);
                        return null === o ? void 0 : o
                    },
                    me = (e, t) => C.from(ue(e, t)),
                    ge = (e, t) => {
                        e.dom.removeAttribute(t)
                    },
                    he = e => B(e.dom.attributes, ((e, t) => (e[t.name] = t.value, e)), {}),
                    pe = e => {
                        if (null == e) throw new Error("Node cannot be null or undefined");
                        return {
                            dom: e
                        }
                    },
                    fe = {
                        fromHtml: (e, t) => {
                            const o = (t || document).createElement("div");
                            if (o.innerHTML = e, !o.hasChildNodes() || o.childNodes.length > 1) {
                                const t = "HTML does not have a single root node";
                                throw console.error(t, e), new Error(t)
                            }
                            return pe(o.childNodes[0])
                        },
                        fromTag: (e, t) => {
                            const o = (t || document).createElement(e);
                            return pe(o)
                        },
                        fromText: (e, t) => {
                            const o = (t || document).createTextNode(e);
                            return pe(o)
                        },
                        fromDom: pe,
                        fromPoint: (e, t, o) => C.from(e.dom.elementFromPoint(t, o)).map(pe)
                    },
                    ve = (e, t) => {
                        const o = e.dom;
                        if (1 !== o.nodeType) return !1; {
                            const e = o;
                            if (void 0 !== e.matches) return e.matches(t);
                            if (void 0 !== e.msMatchesSelector) return e.msMatchesSelector(t);
                            if (void 0 !== e.webkitMatchesSelector) return e.webkitMatchesSelector(t);
                            if (void 0 !== e.mozMatchesSelector) return e.mozMatchesSelector(t);
                            throw new Error("Browser lacks native selectors")
                        }
                    },
                    be = e => 1 !== e.nodeType && 9 !== e.nodeType && 11 !== e.nodeType || 0 === e.childElementCount,
                    ye = (e, t) => {
                        const o = void 0 === t ? document : t.dom;
                        return be(o) ? C.none() : C.from(o.querySelector(e)).map(fe.fromDom)
                    },
                    we = (e, t) => e.dom === t.dom,
                    xe = (e, t) => {
                        const o = e.dom,
                            n = t.dom;
                        return o !== n && o.contains(n)
                    },
                    Ce = ve,
                    Se = e => fe.fromDom(e.dom.ownerDocument),
                    ke = e => se(e) ? e : Se(e),
                    _e = e => C.from(e.dom.parentNode).map(fe.fromDom),
                    Oe = (e, t) => {
                        const o = u(t) ? t : w;
                        let n = e.dom;
                        const r = [];
                        for (; null !== n.parentNode && void 0 !== n.parentNode;) {
                            const e = n.parentNode,
                                t = fe.fromDom(e);
                            if (r.push(t), !0 === o(t)) break;
                            n = e
                        }
                        return r
                    },
                    Te = e => C.from(e.dom.previousSibling).map(fe.fromDom),
                    Ee = e => C.from(e.dom.nextSibling).map(fe.fromDom),
                    Ae = e => A(e.dom.childNodes, fe.fromDom),
                    Me = (e, t) => {
                        const o = e.dom.childNodes;
                        return C.from(o[t]).map(fe.fromDom)
                    },
                    Ne = (e, t) => {
                        _e(e).each((o => {
                            o.dom.insertBefore(t.dom, e.dom)
                        }))
                    },
                    Re = (e, t) => {
                        Ee(e).fold((() => {
                            _e(e).each((e => {
                                Be(e, t)
                            }))
                        }), (e => {
                            Ne(e, t)
                        }))
                    },
                    De = (e, t) => {
                        const o = (e => Me(e, 0))(e);
                        o.fold((() => {
                            Be(e, t)
                        }), (o => {
                            e.dom.insertBefore(t.dom, o.dom)
                        }))
                    },
                    Be = (e, t) => {
                        e.dom.appendChild(t.dom)
                    },
                    Le = (e, t) => {
                        Ne(e, t), Be(t, e)
                    },
                    He = (e, t) => {
                        M(t, ((o, n) => {
                            const r = 0 === n ? e : t[n - 1];
                            Re(r, o)
                        }))
                    },
                    Ie = (e, t) => {
                        M(t, (t => {
                            Be(e, t)
                        }))
                    },
                    Pe = e => {
                        e.dom.textContent = "", M(Ae(e), (e => {
                            ze(e)
                        }))
                    },
                    ze = e => {
                        const t = e.dom;
                        null !== t.parentNode && t.parentNode.removeChild(t)
                    },
                    Fe = e => {
                        const t = Ae(e);
                        t.length > 0 && He(e, t), ze(e)
                    },
                    Ve = (e, t) => fe.fromDom(e.dom.cloneNode(t)),
                    Ze = e => Ve(e, !1),
                    Ue = e => Ve(e, !0),
                    je = (e, t) => {
                        const o = fe.fromTag(t),
                            n = he(e);
                        return de(o, n), o
                    },
                    We = ["tfoot", "thead", "tbody", "colgroup"],
                    $e = (e, t, o) => ({
                        element: e,
                        rowspan: t,
                        colspan: o
                    }),
                    qe = (e, t, o) => ({
                        element: e,
                        cells: t,
                        section: o
                    }),
                    Ge = (e, t, o) => ({
                        element: e,
                        isNew: t,
                        isLocked: o
                    }),
                    Ke = (e, t, o, n) => ({
                        element: e,
                        cells: t,
                        section: o,
                        isNew: n
                    }),
                    Ye = u(Element.prototype.attachShadow) && u(Node.prototype.getRootNode),
                    Xe = h(Ye),
                    Je = Ye ? e => fe.fromDom(e.dom.getRootNode()) : ke,
                    Qe = e => fe.fromDom(e.dom.host),
                    et = e => {
                        const t = re(e) ? e.dom.parentNode : e.dom;
                        if (null == t || null === t.ownerDocument) return !1;
                        const o = t.ownerDocument;
                        return (e => {
                            const t = Je(e);
                            return ae(o = t) && d(o.dom.host) ? C.some(t) : C.none();
                            var o
                        })(fe.fromDom(t)).fold((() => o.body.contains(t)), (n = et, r = Qe, e => n(r(e))));
                        var n, r
                    },
                    tt = e => {
                        const t = e.dom.body;
                        if (null == t) throw new Error("Body is not available yet");
                        return fe.fromDom(t)
                    },
                    ot = (e, t) => {
                        let o = [];
                        return M(Ae(e), (e => {
                            t(e) && (o = o.concat([e])), o = o.concat(ot(e, t))
                        })), o
                    },
                    nt = (e, t, o) => ((e, o, n) => R(Oe(e, n), (e => ve(e, t))))(e, 0, o),
                    rt = (e, t) => ((e, o) => R(Ae(e), (e => ve(e, t))))(e),
                    st = (e, t) => ((e, t) => {
                        const o = void 0 === t ? document : t.dom;
                        return be(o) ? [] : A(o.querySelectorAll(e), fe.fromDom)
                    })(t, e);
                var at = (e, t, o, n, r) => e(o, n) ? C.some(o) : u(r) && r(o) ? C.none() : t(o, n, r);
                const it = (e, t, o) => {
                        let n = e.dom;
                        const r = u(o) ? o : w;
                        for (; n.parentNode;) {
                            n = n.parentNode;
                            const e = fe.fromDom(n);
                            if (t(e)) return C.some(e);
                            if (r(e)) break
                        }
                        return C.none()
                    },
                    lt = (e, t, o) => it(e, (e => ve(e, t)), o),
                    ct = (e, t) => ((e, o) => L(e.dom.childNodes, (e => {
                        return o = fe.fromDom(e), ve(o, t);
                        var o
                    })).map(fe.fromDom))(e),
                    dt = (e, t) => ye(t, e),
                    ut = (e, t, o) => at(((e, t) => ve(e, t)), lt, e, t, o),
                    mt = (e, t, o = f) => e.exists((e => o(e, t))),
                    gt = e => {
                        const t = [],
                            o = e => {
                                t.push(e)
                            };
                        for (let t = 0; t < e.length; t++) e[t].each(o);
                        return t
                    },
                    ht = (e, t) => e ? C.some(t) : C.none(),
                    pt = (e, t, o) => "" === t || e.length >= t.length && e.substr(o, o + t.length) === t,
                    ft = (e, t, o = 0, n) => {
                        const r = e.indexOf(t, o);
                        return -1 !== r && (!!c(n) || r + t.length <= n)
                    },
                    vt = (e, t) => pt(e, t, 0),
                    bt = (e, t) => pt(e, t, e.length - t.length),
                    yt = (e => t => t.replace(e, ""))(/^\s+|\s+$/g),
                    wt = e => e.length > 0,
                    xt = e => void 0 !== e.style && u(e.style.getPropertyValue),
                    Ct = (e, t, o) => {
                        if (!r(o)) throw console.error("Invalid call to CSS.set. Property ", t, ":: Value ", o, ":: Element ", e), new Error("CSS value must be a string: " + o);
                        xt(e) && e.style.setProperty(t, o)
                    },
                    St = (e, t, o) => {
                        const n = e.dom;
                        Ct(n, t, o)
                    },
                    kt = (e, t) => {
                        const o = e.dom;
                        q(t, ((e, t) => {
                            Ct(o, t, e)
                        }))
                    },
                    _t = (e, t) => {
                        const o = e.dom,
                            n = window.getComputedStyle(o).getPropertyValue(t);
                        return "" !== n || et(e) ? n : Ot(o, t)
                    },
                    Ot = (e, t) => xt(e) ? e.style.getPropertyValue(t) : "",
                    Tt = (e, t) => {
                        const o = e.dom,
                            n = Ot(o, t);
                        return C.from(n).filter((e => e.length > 0))
                    },
                    Et = (e, t) => {
                        ((e, t) => {
                            xt(e) && e.style.removeProperty(t)
                        })(e.dom, t), mt(me(e, "style").map(yt), "") && ge(e, "style")
                    },
                    At = (e, t, o = 0) => me(e, t).map((e => parseInt(e, 10))).getOr(o),
                    Mt = (e, t) => At(e, t, 1),
                    Nt = e => ie("col")(e) ? At(e, "span", 1) > 1 : Mt(e, "colspan") > 1,
                    Rt = e => Mt(e, "rowspan") > 1,
                    Dt = (e, t) => parseInt(_t(e, t), 10),
                    Bt = h(10),
                    Lt = h(10),
                    Ht = (e, t) => It(e, t, x),
                    It = (e, t, o) => P(Ae(e), (e => ve(e, t) ? o(e) ? [e] : [] : It(e, t, o))),
                    Pt = (e, t) => ((e, t, o = w) => o(t) ? C.none() : O(e, Q(t)) ? C.some(t) : lt(t, e.join(","), (e => ve(e, "table") || o(e))))(["td", "th"], e, t),
                    zt = e => Ht(e, "th,td"),
                    Ft = e => ve(e, "colgroup") ? rt(e, "col") : P(Ut(e), (e => rt(e, "col"))),
                    Vt = (e, t) => ut(e, "table", t),
                    Zt = e => Ht(e, "tr"),
                    Ut = e => Vt(e).fold(h([]), (e => rt(e, "colgroup"))),
                    jt = (e, t) => A(e, (e => {
                        if ("colgroup" === Q(e)) {
                            const t = A(Ft(e), (e => {
                                const t = At(e, "span", 1);
                                return $e(e, 1, t)
                            }));
                            return qe(e, t, "colgroup")
                        } {
                            const o = A(zt(e), (e => {
                                const t = At(e, "rowspan", 1),
                                    o = At(e, "colspan", 1);
                                return $e(e, t, o)
                            }));
                            return qe(e, o, t(e))
                        }
                    })),
                    Wt = e => _e(e).map((e => {
                        const t = Q(e);
                        return (e => O(We, e))(t) ? t : "tbody"
                    })).getOr("tbody"),
                    $t = e => {
                        const t = Zt(e),
                            o = [...Ut(e), ...t];
                        return jt(o, Wt)
                    },
                    qt = e => {
                        let t, o = !1;
                        return (...n) => (o || (o = !0, t = e.apply(null, n)), t)
                    },
                    Gt = () => Kt(0, 0),
                    Kt = (e, t) => ({
                        major: e,
                        minor: t
                    }),
                    Yt = {
                        nu: Kt,
                        detect: (e, t) => {
                            const o = String(t).toLowerCase();
                            return 0 === e.length ? Gt() : ((e, t) => {
                                const o = ((e, t) => {
                                    for (let o = 0; o < e.length; o++) {
                                        const n = e[o];
                                        if (n.test(t)) return n
                                    }
                                })(e, t);
                                if (!o) return {
                                    major: 0,
                                    minor: 0
                                };
                                const n = e => Number(t.replace(o, "$" + e));
                                return Kt(n(1), n(2))
                            })(e, o)
                        },
                        unknown: Gt
                    },
                    Xt = (e, t) => {
                        const o = String(t).toLowerCase();
                        return L(e, (e => e.search(o)))
                    },
                    Jt = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/,
                    Qt = e => t => ft(t, e),
                    eo = [{
                        name: "Edge",
                        versionRegexes: [/.*?edge\/ ?([0-9]+)\.([0-9]+)$/],
                        search: e => ft(e, "edge/") && ft(e, "chrome") && ft(e, "safari") && ft(e, "applewebkit")
                    }, {
                        name: "Chromium",
                        brand: "Chromium",
                        versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/, Jt],
                        search: e => ft(e, "chrome") && !ft(e, "chromeframe")
                    }, {
                        name: "IE",
                        versionRegexes: [/.*?msie\ ?([0-9]+)\.([0-9]+).*/, /.*?rv:([0-9]+)\.([0-9]+).*/],
                        search: e => ft(e, "msie") || ft(e, "trident")
                    }, {
                        name: "Opera",
                        versionRegexes: [Jt, /.*?opera\/([0-9]+)\.([0-9]+).*/],
                        search: Qt("opera")
                    }, {
                        name: "Firefox",
                        versionRegexes: [/.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/],
                        search: Qt("firefox")
                    }, {
                        name: "Safari",
                        versionRegexes: [Jt, /.*?cpu os ([0-9]+)_([0-9]+).*/],
                        search: e => (ft(e, "safari") || ft(e, "mobile/")) && ft(e, "applewebkit")
                    }],
                    to = [{
                        name: "Windows",
                        search: Qt("win"),
                        versionRegexes: [/.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/]
                    }, {
                        name: "iOS",
                        search: e => ft(e, "iphone") || ft(e, "ipad"),
                        versionRegexes: [/.*?version\/\ ?([0-9]+)\.([0-9]+).*/, /.*cpu os ([0-9]+)_([0-9]+).*/, /.*cpu iphone os ([0-9]+)_([0-9]+).*/]
                    }, {
                        name: "Android",
                        search: Qt("android"),
                        versionRegexes: [/.*?android\ ?([0-9]+)\.([0-9]+).*/]
                    }, {
                        name: "macOS",
                        search: Qt("mac os x"),
                        versionRegexes: [/.*?mac\ os\ x\ ?([0-9]+)_([0-9]+).*/]
                    }, {
                        name: "Linux",
                        search: Qt("linux"),
                        versionRegexes: []
                    }, {
                        name: "Solaris",
                        search: Qt("sunos"),
                        versionRegexes: []
                    }, {
                        name: "FreeBSD",
                        search: Qt("freebsd"),
                        versionRegexes: []
                    }, {
                        name: "ChromeOS",
                        search: Qt("cros"),
                        versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/]
                    }],
                    oo = {
                        browsers: h(eo),
                        oses: h(to)
                    },
                    no = "Edge",
                    ro = "Chromium",
                    so = "Opera",
                    ao = "Firefox",
                    io = "Safari",
                    lo = e => {
                        const t = e.current,
                            o = e.version,
                            n = e => () => t === e;
                        return {
                            current: t,
                            version: o,
                            isEdge: n(no),
                            isChromium: n(ro),
                            isIE: n("IE"),
                            isOpera: n(so),
                            isFirefox: n(ao),
                            isSafari: n(io)
                        }
                    },
                    co = () => lo({
                        current: void 0,
                        version: Yt.unknown()
                    }),
                    uo = lo,
                    mo = (h(no), h(ro), h("IE"), h(so), h(ao), h(io), "Windows"),
                    go = "Android",
                    ho = "Linux",
                    po = "macOS",
                    fo = "Solaris",
                    vo = "FreeBSD",
                    bo = "ChromeOS",
                    yo = e => {
                        const t = e.current,
                            o = e.version,
                            n = e => () => t === e;
                        return {
                            current: t,
                            version: o,
                            isWindows: n(mo),
                            isiOS: n("iOS"),
                            isAndroid: n(go),
                            isMacOS: n(po),
                            isLinux: n(ho),
                            isSolaris: n(fo),
                            isFreeBSD: n(vo),
                            isChromeOS: n(bo)
                        }
                    },
                    wo = () => yo({
                        current: void 0,
                        version: Yt.unknown()
                    }),
                    xo = yo,
                    Co = (h(mo), h("iOS"), h(go), h(ho), h(po), h(fo), h(vo), h(bo), e => window.matchMedia(e).matches);
                let So = qt((() => ((e, t, o) => {
                    const n = oo.browsers(),
                        r = oo.oses(),
                        s = t.bind((e => ((e, t) => j(t.brands, (t => {
                            const o = t.brand.toLowerCase();
                            return L(e, (e => {
                                var t;
                                return o === (null === (t = e.brand) || void 0 === t ? void 0 : t.toLowerCase())
                            })).map((e => ({
                                current: e.name,
                                version: Yt.nu(parseInt(t.version, 10), 0)
                            })))
                        })))(n, e))).orThunk((() => ((e, t) => Xt(e, t).map((e => {
                            const o = Yt.detect(e.versionRegexes, t);
                            return {
                                current: e.name,
                                version: o
                            }
                        })))(n, e))).fold(co, uo),
                        a = ((e, t) => Xt(e, t).map((e => {
                            const o = Yt.detect(e.versionRegexes, t);
                            return {
                                current: e.name,
                                version: o
                            }
                        })))(r, e).fold(wo, xo),
                        i = ((e, t, o, n) => {
                            const r = e.isiOS() && !0 === /ipad/i.test(o),
                                s = e.isiOS() && !r,
                                a = e.isiOS() || e.isAndroid(),
                                i = a || n("(pointer:coarse)"),
                                l = r || !s && a && n("(min-device-width:768px)"),
                                c = s || a && !l,
                                d = t.isSafari() && e.isiOS() && !1 === /safari/i.test(o),
                                u = !c && !l && !d;
                            return {
                                isiPad: h(r),
                                isiPhone: h(s),
                                isTablet: h(l),
                                isPhone: h(c),
                                isTouch: h(i),
                                isAndroid: e.isAndroid,
                                isiOS: e.isiOS,
                                isWebView: h(d),
                                isDesktop: h(u)
                            }
                        })(a, s, e, o);
                    return {
                        browser: s,
                        os: a,
                        deviceType: i
                    }
                })(navigator.userAgent, C.from(navigator.userAgentData), Co)));
                const ko = () => So(),
                    _o = (e, t) => {
                        const o = o => {
                                const n = t(o);
                                if (n <= 0 || null === n) {
                                    const t = _t(o, e);
                                    return parseFloat(t) || 0
                                }
                                return n
                            },
                            n = (e, t) => B(t, ((t, o) => {
                                const n = _t(e, o),
                                    r = void 0 === n ? 0 : parseInt(n, 10);
                                return isNaN(r) ? t : t + r
                            }), 0);
                        return {
                            set: (t, o) => {
                                if (!m(o) && !o.match(/^[0-9]+$/)) throw new Error(e + ".set accepts only positive integer values. Value was " + o);
                                const n = t.dom;
                                xt(n) && (n.style[e] = o + "px")
                            },
                            get: o,
                            getOuter: o,
                            aggregate: n,
                            max: (e, t, o) => {
                                const r = n(e, o);
                                return t > r ? t - r : 0
                            }
                        }
                    },
                    Oo = (e, t, o) => ((e, t) => (e => {
                        const t = parseFloat(e);
                        return isNaN(t) ? C.none() : C.some(t)
                    })(e).getOr(t))(_t(e, t), o),
                    To = _o("width", (e => e.dom.offsetWidth)),
                    Eo = e => To.get(e),
                    Ao = e => To.getOuter(e),
                    Mo = e => ((e, t) => {
                        const o = e.dom,
                            n = o.getBoundingClientRect().width || o.offsetWidth;
                        return "border-box" === t ? n : ((e, t, o, n) => t - Oo(e, `padding-${o}`, 0) - Oo(e, `padding-${n}`, 0) - Oo(e, `border-${o}-width`, 0) - Oo(e, `border-${n}-width`, 0))(e, n, "left", "right")
                    })(e, "content-box"),
                    No = (e, t, o) => {
                        const n = e.cells,
                            r = n.slice(0, t),
                            s = n.slice(t),
                            a = r.concat(o).concat(s);
                        return Bo(e, a)
                    },
                    Ro = (e, t, o) => No(e, t, [o]),
                    Do = (e, t, o) => {
                        e.cells[t] = o
                    },
                    Bo = (e, t) => Ke(e.element, t, e.section, e.isNew),
                    Lo = (e, t) => e.cells[t],
                    Ho = (e, t) => Lo(e, t).element,
                    Io = e => e.cells.length,
                    Po = e => {
                        const t = N(e, (e => "colgroup" === e.section));
                        return {
                            rows: t.fail,
                            cols: t.pass
                        }
                    },
                    zo = (e, t, o) => {
                        const n = A(e.cells, o);
                        return Ke(t(e.element), n, e.section, !0)
                    },
                    Fo = "data-snooker-locked-cols",
                    Vo = e => me(e, Fo).bind((e => C.from(e.match(/\d+/g)))).map((e => F(e, x))),
                    Zo = e => {
                        const t = B(Po(e).rows, ((e, t) => (M(t.cells, ((t, o) => {
                                t.isLocked && (e[o] = !0)
                            })), e)), {}),
                            o = Y(t, ((e, t) => parseInt(t, 10)));
                        return ((e, t) => {
                            const o = S.call(e, 0);
                            return o.sort(void 0), o
                        })(o)
                    },
                    Uo = (e, t) => e + "," + t,
                    jo = (e, t) => {
                        const o = P(e.all, (e => e.cells));
                        return R(o, t)
                    },
                    Wo = e => {
                        const t = {},
                            o = [],
                            n = Z(e).map((e => e.element)).bind(Vt).bind(Vo).getOr({});
                        let r = 0,
                            s = 0,
                            a = 0;
                        const {
                            pass: i,
                            fail: l
                        } = N(e, (e => "colgroup" === e.section));
                        M(l, (e => {
                            const i = [];
                            M(e.cells, (e => {
                                let o = 0;
                                for (; void 0 !== t[Uo(a, o)];) o++;
                                const r = ((e, t) => J(e, t) && void 0 !== e[t] && null !== e[t])(n, o.toString()),
                                    l = ((e, t, o, n, r, s) => ({
                                        element: e,
                                        rowspan: t,
                                        colspan: o,
                                        row: n,
                                        column: r,
                                        isLocked: s
                                    }))(e.element, e.rowspan, e.colspan, a, o, r);
                                for (let n = 0; n < e.colspan; n++)
                                    for (let r = 0; r < e.rowspan; r++) {
                                        const e = o + n,
                                            i = Uo(a + r, e);
                                        t[i] = l, s = Math.max(s, e + 1)
                                    }
                                i.push(l)
                            })), r++, o.push(qe(e.element, i, e.section)), a++
                        }));
                        const {
                            columns: c,
                            colgroups: d
                        } = U(i).map((e => {
                            const t = (e => {
                                    const t = {};
                                    let o = 0;
                                    return M(e.cells, (e => {
                                        const n = e.colspan;
                                        E(n, (r => {
                                            const s = o + r;
                                            t[s] = ((e, t, o) => ({
                                                element: e,
                                                colspan: t,
                                                column: o
                                            }))(e.element, n, s)
                                        })), o += n
                                    })), t
                                })(e),
                                o = ((e, t) => ({
                                    element: e,
                                    columns: t
                                }))(e.element, X(t));
                            return {
                                colgroups: [o],
                                columns: t
                            }
                        })).getOrThunk((() => ({
                            colgroups: [],
                            columns: {}
                        }))), u = ((e, t) => ({
                            rows: e,
                            columns: t
                        }))(r, s);
                        return {
                            grid: u,
                            access: t,
                            all: o,
                            columns: c,
                            colgroups: d
                        }
                    },
                    $o = e => {
                        const t = $t(e);
                        return Wo(t)
                    },
                    qo = Wo,
                    Go = (e, t, o) => C.from(e.access[Uo(t, o)]),
                    Ko = (e, t, o) => {
                        const n = jo(e, (e => o(t, e.element)));
                        return n.length > 0 ? C.some(n[0]) : C.none()
                    },
                    Yo = jo,
                    Xo = e => P(e.all, (e => e.cells)),
                    Jo = e => X(e.columns),
                    Qo = e => W(e.columns).length > 0,
                    en = (e, t) => C.from(e.columns[t]),
                    tn = (e, t = x) => {
                        const o = e.grid,
                            n = E(o.columns, p),
                            r = E(o.rows, p);
                        return A(n, (o => on((() => P(r, (t => Go(e, t, o).filter((e => e.column === o)).toArray()))), (e => 1 === e.colspan && t(e.element)), (() => Go(e, 0, o)))))
                    },
                    on = (e, t, o) => {
                        const n = e();
                        return L(n, t).orThunk((() => C.from(n[0]).orThunk(o))).map((e => e.element))
                    },
                    nn = e => {
                        const t = e.grid,
                            o = E(t.rows, p),
                            n = E(t.columns, p);
                        return A(o, (t => on((() => P(n, (o => Go(e, t, o).filter((e => e.row === t)).fold(h([]), (e => [e]))))), (e => 1 === e.rowspan), (() => Go(e, t, 0)))))
                    },
                    rn = (e, t) => o => "rtl" === sn(o) ? t : e,
                    sn = e => "rtl" === _t(e, "direction") ? "rtl" : "ltr",
                    an = _o("height", (e => {
                        const t = e.dom;
                        return et(e) ? t.getBoundingClientRect().height : t.offsetHeight
                    })),
                    ln = e => an.get(e),
                    cn = e => an.getOuter(e),
                    dn = (e, t) => ({
                        left: e,
                        top: t,
                        translate: (o, n) => dn(e + o, t + n)
                    }),
                    un = dn,
                    mn = (e, t) => void 0 !== e ? e : void 0 !== t ? t : 0,
                    gn = e => {
                        const t = e.dom.ownerDocument,
                            o = t.body,
                            n = t.defaultView,
                            r = t.documentElement;
                        if (o === e.dom) return un(o.offsetLeft, o.offsetTop);
                        const s = mn(null == n ? void 0 : n.pageYOffset, r.scrollTop),
                            a = mn(null == n ? void 0 : n.pageXOffset, r.scrollLeft),
                            i = mn(r.clientTop, o.clientTop),
                            l = mn(r.clientLeft, o.clientLeft);
                        return hn(e).translate(a - l, s - i)
                    },
                    hn = e => {
                        const t = e.dom,
                            o = t.ownerDocument.body;
                        return o === t ? un(o.offsetLeft, o.offsetTop) : et(e) ? (e => {
                            const t = e.getBoundingClientRect();
                            return un(t.left, t.top)
                        })(t) : un(0, 0)
                    },
                    pn = (e, t) => ({
                        row: e,
                        y: t
                    }),
                    fn = (e, t) => ({
                        col: e,
                        x: t
                    }),
                    vn = e => gn(e).left + Ao(e),
                    bn = e => gn(e).left,
                    yn = (e, t) => fn(e, bn(t)),
                    wn = (e, t) => fn(e, vn(t)),
                    xn = e => gn(e).top,
                    Cn = (e, t) => pn(e, xn(t)),
                    Sn = (e, t) => pn(e, xn(t) + cn(t)),
                    kn = (e, t, o) => {
                        if (0 === o.length) return [];
                        const n = A(o.slice(1), ((t, o) => t.map((t => e(o, t))))),
                            r = o[o.length - 1].map((e => t(o.length - 1, e)));
                        return n.concat([r])
                    },
                    _n = {
                        delta: p,
                        positions: e => kn(Cn, Sn, e),
                        edge: xn
                    },
                    On = rn({
                        delta: p,
                        edge: bn,
                        positions: e => kn(yn, wn, e)
                    }, {
                        delta: e => -e,
                        edge: vn,
                        positions: e => kn(wn, yn, e)
                    }),
                    Tn = {
                        delta: (e, t) => On(t).delta(e, t),
                        positions: (e, t) => On(t).positions(e, t),
                        edge: e => On(e).edge(e)
                    },
                    En = {
                        unsupportedLength: ["em", "ex", "cap", "ch", "ic", "rem", "lh", "rlh", "vw", "vh", "vi", "vb", "vmin", "vmax", "cm", "mm", "Q", "in", "pc", "pt", "px"],
                        fixed: ["px", "pt"],
                        relative: ["%"],
                        empty: [""]
                    },
                    An = (() => {
                        const e = "[0-9]+",
                            t = "[eE][+-]?" + e,
                            o = e => `(?:${e})?`,
                            n = ["Infinity", e + "\\." + o(e) + o(t), "\\." + e + o(t), e + o(t)].join("|");
                        return new RegExp(`^([+-]?(?:${n}))(.*)$`)
                    })(),
                    Mn = /(\d+(\.\d+)?)%/,
                    Nn = /(\d+(\.\d+)?)px|em/,
                    Rn = ie("col"),
                    Dn = (e, t, o) => {
                        const n = (r = e, C.from(r.dom.parentElement).map(fe.fromDom)).getOrThunk((() => tt(Se(e))));
                        var r;
                        return t(e) / o(n) * 100
                    },
                    Bn = (e, t) => {
                        St(e, "width", t + "px")
                    },
                    Ln = (e, t) => {
                        St(e, "width", t + "%")
                    },
                    Hn = (e, t) => {
                        St(e, "height", t + "px")
                    },
                    In = e => {
                        const t = (e => {
                            return Oo(t = e, "height", t.dom.offsetHeight) + "px";
                            var t
                        })(e);
                        return t ? ((e, t, o, n) => {
                            const r = parseFloat(e);
                            return bt(e, "%") && "table" !== Q(t) ? ((e, t, o, n) => {
                                const r = Vt(e).map((e => {
                                    const n = o(e);
                                    return Math.floor(t / 100 * n)
                                })).getOr(t);
                                return n(e, r), r
                            })(t, r, o, n) : r
                        })(t, e, ln, Hn) : ln(e)
                    },
                    Pn = (e, t) => Tt(e, t).orThunk((() => me(e, t).map((e => e + "px")))),
                    zn = e => Pn(e, "width"),
                    Fn = e => Dn(e, Eo, Mo),
                    Vn = e => {
                        return Rn(e) ? Eo(e) : Oo(t = e, "width", t.dom.offsetWidth);
                        var t
                    },
                    Zn = e => ((e, t, o) => o(e) / Mt(e, "rowspan"))(e, 0, In),
                    Un = (e, t, o) => {
                        St(e, "width", t + o)
                    },
                    jn = e => Dn(e, Eo, Mo) + "%",
                    Wn = h(Mn),
                    $n = ie("col"),
                    qn = e => zn(e).getOrThunk((() => Vn(e) + "px")),
                    Gn = e => {
                        return (t = e, Pn(t, "height")).getOrThunk((() => Zn(e) + "px"));
                        var t
                    },
                    Kn = (e, t, o, n, r, s) => e.filter(n).fold((() => s(((e, t) => {
                        if (t < 0 || t >= e.length - 1) return C.none();
                        const o = e[t].fold((() => {
                                const o = (e => {
                                    const t = S.call(e, 0);
                                    return t.reverse(), t
                                })(e.slice(0, t));
                                return j(o, ((e, t) => e.map((e => ({
                                    value: e,
                                    delta: t + 1
                                })))))
                            }), (e => C.some({
                                value: e,
                                delta: 0
                            }))),
                            n = e[t + 1].fold((() => {
                                const o = e.slice(t + 1);
                                return j(o, ((e, t) => e.map((e => ({
                                    value: e,
                                    delta: t + 1
                                })))))
                            }), (e => C.some({
                                value: e,
                                delta: 1
                            })));
                        return o.bind((e => n.map((t => {
                            const o = t.delta + e.delta;
                            return Math.abs(t.value - e.value) / o
                        }))))
                    })(o, t))), (e => r(e))),
                    Yn = (e, t, o, n) => {
                        const r = tn(e),
                            s = Qo(e) ? (e => A(Jo(e), (e => C.from(e.element))))(e) : r,
                            a = [C.some(Tn.edge(t))].concat(A(Tn.positions(r, t), (e => e.map((e => e.x))))),
                            i = b(Nt);
                        return A(s, ((e, t) => Kn(e, t, a, i, (e => {
                            if ((e => {
                                    const t = ko().browser,
                                        o = t.isChromium() || t.isFirefox();
                                    return !$n(e) || o
                                })(e)) return o(e); {
                                const e = null != (s = r[t]) ? p(s) : C.none();
                                return Kn(e, t, a, i, (e => n(C.some(Eo(e)))), n)
                            }
                            var s
                        }), n)))
                    },
                    Xn = e => e.map((e => e + "px")).getOr(""),
                    Jn = (e, t, o) => Yn(e, t, Vn, (e => e.getOrThunk(o.minCellWidth))),
                    Qn = (e, t, o, n, r) => {
                        const s = nn(e),
                            a = [C.some(o.edge(t))].concat(A(o.positions(s, t), (e => e.map((e => e.y)))));
                        return A(s, ((e, t) => Kn(e, t, a, b(Rt), n, r)))
                    },
                    er = (e, t) => () => et(e) ? t(e) : parseFloat(Tt(e, "width").getOr("0")),
                    tr = e => {
                        const t = er(e, (e => parseFloat(jn(e)))),
                            o = er(e, Eo);
                        return {
                            width: t,
                            pixelWidth: o,
                            getWidths: (t, o) => ((e, t, o) => Yn(e, t, Fn, (e => e.fold((() => o.minCellWidth()), (e => e / o.pixelWidth() * 100)))))(t, e, o),
                            getCellDelta: e => e / o() * 100,
                            singleColumnWidth: (e, t) => [100 - e],
                            minCellWidth: () => Bt() / o() * 100,
                            setElementWidth: Ln,
                            adjustTableWidth: o => {
                                const n = t();
                                Ln(e, n + o / 100 * n)
                            },
                            isRelative: !0,
                            label: "percent"
                        }
                    },
                    or = e => {
                        const t = er(e, Eo);
                        return {
                            width: t,
                            pixelWidth: t,
                            getWidths: (t, o) => Jn(t, e, o),
                            getCellDelta: p,
                            singleColumnWidth: (e, t) => [Math.max(Bt(), e + t) - e],
                            minCellWidth: Bt,
                            setElementWidth: Bn,
                            adjustTableWidth: o => {
                                const n = t() + o;
                                Bn(e, n)
                            },
                            isRelative: !1,
                            label: "pixel"
                        }
                    },
                    nr = e => zn(e).fold((() => (e => {
                        const t = er(e, Eo),
                            o = h(0);
                        return {
                            width: t,
                            pixelWidth: t,
                            getWidths: (t, o) => Jn(t, e, o),
                            getCellDelta: o,
                            singleColumnWidth: h([0]),
                            minCellWidth: o,
                            setElementWidth: g,
                            adjustTableWidth: g,
                            isRelative: !0,
                            label: "none"
                        }
                    })(e)), (t => ((e, t) => null !== Wn().exec(t) ? tr(e) : or(e))(e, t))),
                    rr = or,
                    sr = tr,
                    ar = (e, t, o) => {
                        const n = e[o].element,
                            r = fe.fromTag("td");
                        Be(r, fe.fromTag("br")), (t ? Be : De)(n, r)
                    },
                    ir = ((e, t) => {
                        const o = t => e(t) ? C.from(t.dom.nodeValue) : C.none();
                        return {
                            get: t => {
                                if (!e(t)) throw new Error("Can only get text value of a text node");
                                return o(t).getOr("")
                            },
                            getOption: o,
                            set: (t, o) => {
                                if (!e(t)) throw new Error("Can only set raw text value of a text node");
                                t.dom.nodeValue = o
                            }
                        }
                    })(re),
                    lr = e => ir.get(e),
                    cr = e => ir.getOption(e),
                    dr = (e, t) => ir.set(e, t),
                    ur = e => "img" === Q(e) ? 1 : cr(e).fold((() => Ae(e).length), (e => e.length)),
                    mr = ["img", "br"],
                    gr = e => cr(e).filter((e => 0 !== e.trim().length || e.indexOf("") > -1)).isSome() || O(mr, Q(e)),
                    hr = e => ((e, t) => {
                        const o = e => {
                            for (let n = 0; n < e.childNodes.length; n++) {
                                const r = fe.fromDom(e.childNodes[n]);
                                if (t(r)) return C.some(r);
                                const s = o(e.childNodes[n]);
                                if (s.isSome()) return s
                            }
                            return C.none()
                        };
                        return o(e.dom)
                    })(e, gr),
                    pr = e => fr(e, gr),
                    fr = (e, t) => {
                        const o = e => {
                            const n = Ae(e);
                            for (let e = n.length - 1; e >= 0; e--) {
                                const r = n[e];
                                if (t(r)) return C.some(r);
                                const s = o(r);
                                if (s.isSome()) return s
                            }
                            return C.none()
                        };
                        return o(e)
                    },
                    vr = {
                        scope: ["row", "col"]
                    },
                    br = e => () => {
                        const t = fe.fromTag("td", e.dom);
                        return Be(t, fe.fromTag("br", e.dom)), t
                    },
                    yr = e => () => fe.fromTag("col", e.dom),
                    wr = e => () => fe.fromTag("colgroup", e.dom),
                    xr = e => () => fe.fromTag("tr", e.dom),
                    Cr = (e, t, o) => {
                        const n = ((e, t) => {
                            const o = je(e, t),
                                n = Ae(Ue(e));
                            return Ie(o, n), o
                        })(e, t);
                        return q(o, ((e, t) => {
                            null === e ? ge(n, t) : ce(n, t, e)
                        })), n
                    },
                    Sr = e => e,
                    kr = (e, t, o) => {
                        const n = (e, t) => {
                            ((e, t) => {
                                const o = e.dom,
                                    n = t.dom;
                                xt(o) && xt(n) && (n.style.cssText = o.style.cssText)
                            })(e.element, t), Et(t, "height"), 1 !== e.colspan && Et(t, "width")
                        };
                        return {
                            col: o => {
                                const r = fe.fromTag(Q(o.element), t.dom);
                                return n(o, r), e(o.element, r), r
                            },
                            colgroup: wr(t),
                            row: xr(t),
                            cell: r => {
                                const s = fe.fromTag(Q(r.element), t.dom),
                                    a = o.getOr(["strong", "em", "b", "i", "span", "font", "h1", "h2", "h3", "h4", "h5", "h6", "p", "div"]),
                                    i = a.length > 0 ? ((e, t, o) => hr(e).map((n => {
                                        const r = o.join(","),
                                            s = nt(n, r, (t => we(t, e)));
                                        return D(s, ((e, t) => {
                                            const o = Ze(t);
                                            return ge(o, "contenteditable"), Be(e, o), o
                                        }), t)
                                    })).getOr(t))(r.element, s, a) : s;
                                return Be(i, fe.fromTag("br")), n(r, s), ((e, t) => {
                                    q(vr, ((o, n) => me(e, n).filter((e => O(o, e))).each((e => ce(t, n, e)))))
                                })(r.element, s), e(r.element, s), s
                            },
                            replace: Cr,
                            colGap: yr(t),
                            gap: br(t)
                        }
                    },
                    _r = e => ({
                        col: yr(e),
                        colgroup: wr(e),
                        row: xr(e),
                        cell: br(e),
                        replace: Sr,
                        colGap: yr(e),
                        gap: br(e)
                    }),
                    Or = e => fe.fromDom(e.getBody()),
                    Tr = e => t => we(t, Or(e)),
                    Er = e => {
                        ge(e, "data-mce-style");
                        const t = e => ge(e, "data-mce-style");
                        M(zt(e), t), M(Ft(e), t), M(Zt(e), t)
                    },
                    Ar = e => fe.fromDom(e.selection.getStart()),
                    Mr = e => e.getBoundingClientRect().width,
                    Nr = e => e.getBoundingClientRect().height,
                    Rr = (e, t) => {
                        const o = t.column,
                            n = t.column + t.colspan - 1,
                            r = t.row,
                            s = t.row + t.rowspan - 1;
                        return o <= e.finishCol && n >= e.startCol && r <= e.finishRow && s >= e.startRow
                    },
                    Dr = (e, t) => t.column >= e.startCol && t.column + t.colspan - 1 <= e.finishCol && t.row >= e.startRow && t.row + t.rowspan - 1 <= e.finishRow,
                    Br = (e, t, o) => {
                        const n = Ko(e, t, we),
                            r = Ko(e, o, we);
                        return n.bind((e => r.map((t => {
                            return o = e, n = t, {
                                startRow: Math.min(o.row, n.row),
                                startCol: Math.min(o.column, n.column),
                                finishRow: Math.max(o.row + o.rowspan - 1, n.row + n.rowspan - 1),
                                finishCol: Math.max(o.column + o.colspan - 1, n.column + n.colspan - 1)
                            };
                            var o, n
                        }))))
                    },
                    Lr = (e, t, o) => Br(e, t, o).map((t => {
                        const o = Yo(e, v(Rr, t));
                        return A(o, (e => e.element))
                    })),
                    Hr = (e, t) => Ko(e, t, ((e, t) => xe(t, e))).map((e => e.element)),
                    Ir = (e, t, o) => {
                        const n = zr(e);
                        return Lr(n, t, o)
                    },
                    Pr = (e, t, o, n, r) => {
                        const s = zr(e),
                            a = we(e, o) ? C.some(t) : Hr(s, t),
                            i = we(e, r) ? C.some(n) : Hr(s, n);
                        return a.bind((e => i.bind((t => Lr(s, e, t)))))
                    },
                    zr = $o;
                var Fr = ["body", "p", "div", "article", "aside", "figcaption", "figure", "footer", "header", "nav", "section", "ol", "ul", "li", "table", "thead", "tbody", "tfoot", "caption", "tr", "td", "th", "h1", "h2", "h3", "h4", "h5", "h6", "blockquote", "pre", "address"],
                    Vr = () => ({
                        up: h({
                            selector: lt,
                            closest: ut,
                            predicate: it,
                            all: Oe
                        }),
                        down: h({
                            selector: st,
                            predicate: ot
                        }),
                        styles: h({
                            get: _t,
                            getRaw: Tt,
                            set: St,
                            remove: Et
                        }),
                        attrs: h({
                            get: ue,
                            set: ce,
                            remove: ge,
                            copyTo: (e, t) => {
                                const o = he(e);
                                de(t, o)
                            }
                        }),
                        insert: h({
                            before: Ne,
                            after: Re,
                            afterAll: He,
                            append: Be,
                            appendAll: Ie,
                            prepend: De,
                            wrap: Le
                        }),
                        remove: h({
                            unwrap: Fe,
                            remove: ze
                        }),
                        create: h({
                            nu: fe.fromTag,
                            clone: e => fe.fromDom(e.dom.cloneNode(!1)),
                            text: fe.fromText
                        }),
                        query: h({
                            comparePosition: (e, t) => e.dom.compareDocumentPosition(t.dom),
                            prevSibling: Te,
                            nextSibling: Ee
                        }),
                        property: h({
                            children: Ae,
                            name: Q,
                            parent: _e,
                            document: e => ke(e).dom,
                            isText: re,
                            isComment: oe,
                            isElement: ne,
                            isSpecial: e => {
                                const t = Q(e);
                                return O(["script", "noscript", "iframe", "noframes", "noembed", "title", "style", "textarea", "xmp"], t)
                            },
                            getLanguage: e => ne(e) ? me(e, "lang") : C.none(),
                            getText: lr,
                            setText: dr,
                            isBoundary: e => !!ne(e) && ("body" === Q(e) || O(Fr, Q(e))),
                            isEmptyTag: e => !!ne(e) && O(["br", "img", "hr", "input"], Q(e)),
                            isNonEditable: e => ne(e) && "false" === ue(e, "contenteditable")
                        }),
                        eq: we,
                        is: Ce
                    });
                const Zr = (e, t, o, n) => {
                        const r = t(e, o);
                        return D(n, ((o, n) => {
                            const r = t(e, n);
                            return Ur(e, o, r)
                        }), r)
                    },
                    Ur = (e, t, o) => t.bind((t => o.filter(v(e.eq, t)))),
                    jr = Vr(),
                    Wr = (e, t) => ((e, t, o) => o.length > 0 ? ((e, t, o, n) => n(e, t, o[0], o.slice(1)))(e, t, o, Zr) : C.none())(jr, ((t, o) => e(o)), t),
                    $r = e => lt(e, "table"),
                    qr = (e, t, o) => {
                        const n = e => t => void 0 !== o && o(t) || we(t, e);
                        return we(e, t) ? C.some({
                            boxes: C.some([e]),
                            start: e,
                            finish: t
                        }) : $r(e).bind((r => $r(t).bind((s => {
                            if (we(r, s)) return C.some({
                                boxes: Ir(r, e, t),
                                start: e,
                                finish: t
                            });
                            if (xe(r, s)) {
                                const o = nt(t, "td,th", n(r)),
                                    a = o.length > 0 ? o[o.length - 1] : t;
                                return C.some({
                                    boxes: Pr(r, e, r, t, s),
                                    start: e,
                                    finish: a
                                })
                            }
                            if (xe(s, r)) {
                                const o = nt(e, "td,th", n(s)),
                                    a = o.length > 0 ? o[o.length - 1] : e;
                                return C.some({
                                    boxes: Pr(s, e, r, t, s),
                                    start: e,
                                    finish: a
                                })
                            }
                            return ((e, t, o) => ((e, t, o, n = w) => {
                                const r = [t].concat(e.up().all(t)),
                                    s = [o].concat(e.up().all(o)),
                                    a = e => H(e, n).fold((() => e), (t => e.slice(0, t + 1))),
                                    i = a(r),
                                    l = a(s),
                                    c = L(i, (t => T(l, ((e, t) => v(e.eq, t))(e, t))));
                                return {
                                    firstpath: i,
                                    secondpath: l,
                                    shared: c
                                }
                            })(jr, e, t, void 0))(e, t).shared.bind((a => ut(a, "table", o).bind((o => {
                                const a = nt(t, "td,th", n(o)),
                                    i = a.length > 0 ? a[a.length - 1] : t,
                                    l = nt(e, "td,th", n(o)),
                                    c = l.length > 0 ? l[l.length - 1] : e;
                                return C.some({
                                    boxes: Pr(o, e, r, t, s),
                                    start: c,
                                    finish: i
                                })
                            }))))
                        }))))
                    },
                    Gr = (e, t) => {
                        const o = st(e, t);
                        return o.length > 0 ? C.some(o) : C.none()
                    },
                    Kr = (e, t, o) => dt(e, t).bind((t => dt(e, o).bind((e => Wr($r, [t, e]).map((o => ({
                        first: t,
                        last: e,
                        table: o
                    }))))))),
                    Yr = (e, t, o, n, r) => ((e, t) => L(e, (e => ve(e, t))))(e, r).bind((e => ((e, t, o) => Vt(e).bind((n => ((e, t, o, n) => Ko(e, t, we).bind((t => {
                        const r = o > 0 ? t.row + t.rowspan - 1 : t.row,
                            s = n > 0 ? t.column + t.colspan - 1 : t.column;
                        return Go(e, r + o, s + n).map((e => e.element))
                    })))(zr(n), e, t, o))))(e, t, o).bind((e => ((e, t) => lt(e, "table").bind((o => dt(o, t).bind((t => qr(t, e).bind((e => e.boxes.map((t => ({
                        boxes: t,
                        start: e.start,
                        finish: e.finish
                    }))))))))))(e, n))))),
                    Xr = (e, t) => Gr(e, t),
                    Jr = (e, t, o) => Kr(e, t, o).bind((t => {
                        const o = t => we(e, t),
                            n = "thead,tfoot,tbody,table",
                            r = lt(t.first, n, o),
                            s = lt(t.last, n, o);
                        return r.bind((e => s.bind((o => we(e, o) ? ((e, t, o) => ((e, t, o) => Br(e, t, o).bind((t => ((e, t) => {
                            let o = !0;
                            const n = v(Dr, t);
                            for (let r = t.startRow; r <= t.finishRow; r++)
                                for (let s = t.startCol; s <= t.finishCol; s++) o = o && Go(e, r, s).exists(n);
                            return o ? C.some(t) : C.none()
                        })(e, t))))(zr(e), t, o))(t.table, t.first, t.last) : C.none()))))
                    })),
                    Qr = p,
                    es = e => {
                        const t = (e, t) => me(e, t).exists((e => parseInt(e, 10) > 1));
                        return e.length > 0 && z(e, (e => t(e, "rowspan") || t(e, "colspan"))) ? C.some(e) : C.none()
                    },
                    ts = (e, t, o) => t.length <= 1 ? C.none() : Jr(e, o.firstSelectedSelector, o.lastSelectedSelector).map((e => ({
                        bounds: e,
                        cells: t
                    }))),
                    os = "data-mce-selected",
                    ns = "td[" + os + "],th[" + os + "]",
                    rs = "[" + os + "]",
                    ss = "data-mce-first-selected",
                    as = "td[" + ss + "],th[" + ss + "]",
                    is = "data-mce-last-selected",
                    ls = "td[" + is + "],th[" + is + "]",
                    cs = rs,
                    ds = {
                        selected: os,
                        selectedSelector: ns,
                        firstSelected: ss,
                        firstSelectedSelector: as,
                        lastSelected: is,
                        lastSelectedSelector: ls
                    },
                    us = (e, t, o) => ({
                        element: o,
                        mergable: ts(t, e, ds),
                        unmergable: es(e),
                        selection: Qr(e)
                    }),
                    ms = e => (t, o) => {
                        const n = Q(t),
                            r = "col" === n || "colgroup" === n ? Vt(s = t).bind((e => Xr(e, ds.firstSelectedSelector))).fold(h(s), (e => e[0])) : t;
                        var s;
                        return ut(r, e, o)
                    },
                    gs = ms("th,td,caption"),
                    hs = ms("th,td"),
                    ps = e => {
                        return t = e.model.table.getSelectedCells(), A(t, fe.fromDom);
                        var t
                    },
                    fs = (e, t) => {
                        e.on("BeforeGetContent", (t => {
                            const o = o => {
                                t.preventDefault(), (e => Vt(e[0]).map((e => {
                                    const t = ((e, t) => {
                                        const o = e => ve(e.element, t),
                                            n = Ue(e),
                                            r = $t(n),
                                            s = nr(e),
                                            a = qo(r),
                                            i = ((e, t) => {
                                                const o = e.grid.columns;
                                                let n = e.grid.rows,
                                                    r = o,
                                                    s = 0,
                                                    a = 0;
                                                const i = [],
                                                    l = [];
                                                return q(e.access, (e => {
                                                    if (i.push(e), t(e)) {
                                                        l.push(e);
                                                        const t = e.row,
                                                            o = t + e.rowspan - 1,
                                                            i = e.column,
                                                            c = i + e.colspan - 1;
                                                        t < n ? n = t : o > s && (s = o), i < r ? r = i : c > a && (a = c)
                                                    }
                                                })), ((e, t, o, n, r, s) => ({
                                                    minRow: e,
                                                    minCol: t,
                                                    maxRow: o,
                                                    maxCol: n,
                                                    allCells: r,
                                                    selectedCells: s
                                                }))(n, r, s, a, i, l)
                                            })(a, o),
                                            l = "th:not(" + t + "),td:not(" + t + ")",
                                            c = It(n, "th,td", (e => ve(e, l)));
                                        M(c, ze), ((e, t, o, n) => {
                                            const r = R(e, (e => "colgroup" !== e.section)),
                                                s = t.grid.columns,
                                                a = t.grid.rows;
                                            for (let e = 0; e < a; e++) {
                                                let a = !1;
                                                for (let i = 0; i < s; i++) e < o.minRow || e > o.maxRow || i < o.minCol || i > o.maxCol || (Go(t, e, i).filter(n).isNone() ? ar(r, a, e) : a = !0)
                                            }
                                        })(r, a, i, o);
                                        const d = ((e, t, o, n) => {
                                            if (0 === n.minCol && t.grid.columns === n.maxCol + 1) return 0;
                                            const r = Jn(t, e, o),
                                                s = B(r, ((e, t) => e + t), 0),
                                                a = B(r.slice(n.minCol, n.maxCol + 1), ((e, t) => e + t), 0),
                                                i = a / s * o.pixelWidth() - o.pixelWidth();
                                            return o.getCellDelta(i)
                                        })(e, $o(e), s, i);
                                        return ((e, t, o, n) => {
                                            q(o.columns, (e => {
                                                (e.column < t.minCol || e.column > t.maxCol) && ze(e.element)
                                            }));
                                            const r = R(Ht(e, "tr"), (e => 0 === e.dom.childElementCount));
                                            M(r, ze), t.minCol !== t.maxCol && t.minRow !== t.maxRow || M(Ht(e, "th,td"), (e => {
                                                ge(e, "rowspan"), ge(e, "colspan")
                                            })), ge(e, Fo), ge(e, "data-snooker-col-series"), nr(e).adjustTableWidth(n)
                                        })(n, i, a, d), n
                                    })(e, cs);
                                    return Er(t), [t]
                                })))(o).each((o => {
                                    t.content = "text" === t.format ? (e => A(e, (e => e.dom.innerText)).join(""))(o) : ((e, t) => A(t, (t => e.selection.serializer.serialize(t.dom, {}))).join(""))(e, o)
                                }))
                            };
                            if (!0 === t.selection) {
                                const t = (e => R(ps(e), (e => ve(e, ds.selectedSelector))))(e);
                                t.length >= 1 && o(t)
                            }
                        })), e.on("BeforeSetContent", (o => {
                            if (!0 === o.selection && !0 === o.paste) {
                                const n = ps(e);
                                Z(n).each((n => {
                                    Vt(n).each((r => {
                                        const s = R(((e, t) => {
                                                const o = document.createElement("div");
                                                return o.innerHTML = e, Ae(fe.fromDom(o))
                                            })(o.content), (e => "meta" !== Q(e))),
                                            a = ie("table");
                                        if (1 === s.length && a(s[0])) {
                                            o.preventDefault();
                                            const a = fe.fromDom(e.getDoc()),
                                                i = _r(a),
                                                l = ((e, t, o) => ({
                                                    element: e,
                                                    clipboard: t,
                                                    generators: o
                                                }))(n, s[0], i);
                                            t.pasteCells(r, l).each((() => {
                                                e.focus()
                                            }))
                                        }
                                    }))
                                }))
                            }
                        }))
                    },
                    vs = (e, t) => ({
                        element: e,
                        offset: t
                    }),
                    bs = (e, t, o) => e.property().isText(t) && 0 === e.property().getText(t).trim().length || e.property().isComment(t) ? o(t).bind((t => bs(e, t, o).orThunk((() => C.some(t))))) : C.none(),
                    ys = (e, t) => e.property().isText(t) ? e.property().getText(t).length : e.property().children(t).length,
                    ws = (e, t) => {
                        const o = bs(e, t, e.query().prevSibling).getOr(t);
                        if (e.property().isText(o)) return vs(o, ys(e, o));
                        const n = e.property().children(o);
                        return n.length > 0 ? ws(e, n[n.length - 1]) : vs(o, ys(e, o))
                    },
                    xs = ws,
                    Cs = Vr(),
                    Ss = (e, t) => {
                        if (!Nt(e)) {
                            const o = (e => zn(e).bind((e => {
                                return t = e, o = ["fixed", "relative", "empty"], C.from(An.exec(t)).bind((e => {
                                    const t = Number(e[1]),
                                        n = e[2];
                                    return ((e, t) => T(t, (t => T(En[t], (t => e === t)))))(n, o) ? C.some({
                                        value: t,
                                        unit: n
                                    }) : C.none()
                                }));
                                var t, o
                            })))(e);
                            o.each((o => {
                                const n = o.value / 2;
                                Un(e, n, o.unit), Un(t, n, o.unit)
                            }))
                        }
                    },
                    ks = e => A(e, h(0)),
                    _s = (e, t, o, n, r) => r(e.slice(0, t)).concat(n).concat(r(e.slice(o))),
                    Os = e => (t, o, n, r) => {
                        if (e(n)) {
                            const e = Math.max(r, t[o] - Math.abs(n)),
                                s = Math.abs(e - t[o]);
                            return n >= 0 ? s : -s
                        }
                        return n
                    },
                    Ts = Os((e => e < 0)),
                    Es = Os(x),
                    As = () => {
                        const e = (e, t, o, n) => {
                                const r = (100 + o) / 100,
                                    s = Math.max(n, (e[t] + o) / r);
                                return A(e, ((e, o) => (o === t ? s : e / r) - e))
                            },
                            t = (t, o, n, r, s, a) => a ? e(t, o, r, s) : ((e, t, o, n, r) => {
                                const s = Ts(e, t, n, r);
                                return _s(e, t, o + 1, [s, 0], ks)
                            })(t, o, n, r, s);
                        return {
                            resizeTable: (e, t) => e(t),
                            clampTableDelta: Ts,
                            calcLeftEdgeDeltas: t,
                            calcMiddleDeltas: (e, o, n, r, s, a, i) => t(e, n, r, s, a, i),
                            calcRightEdgeDeltas: (t, o, n, r, s, a) => {
                                if (a) return e(t, n, r, s); {
                                    const e = Ts(t, n, r, s);
                                    return ks(t.slice(0, n)).concat([e])
                                }
                            },
                            calcRedestributedWidths: (e, t, o, n) => {
                                if (n) {
                                    const n = (t + o) / t,
                                        r = A(e, (e => e / n));
                                    return {
                                        delta: 100 * n - 100,
                                        newSizes: r
                                    }
                                }
                                return {
                                    delta: o,
                                    newSizes: e
                                }
                            }
                        }
                    },
                    Ms = () => {
                        const e = (e, t, o, n, r) => {
                            const s = Es(e, n >= 0 ? o : t, n, r);
                            return _s(e, t, o + 1, [s, -s], ks)
                        };
                        return {
                            resizeTable: (e, t, o) => {
                                o && e(t)
                            },
                            clampTableDelta: (e, t, o, n, r) => {
                                if (r) {
                                    if (o >= 0) return o; {
                                        const t = B(e, ((e, t) => e + t - n), 0);
                                        return Math.max(-t, o)
                                    }
                                }
                                return Ts(e, t, o, n)
                            },
                            calcLeftEdgeDeltas: e,
                            calcMiddleDeltas: (t, o, n, r, s, a) => e(t, n, r, s, a),
                            calcRightEdgeDeltas: (e, t, o, n, r, s) => {
                                if (s) return ks(e); {
                                    const t = n / e.length;
                                    return A(e, h(t))
                                }
                            },
                            calcRedestributedWidths: (e, t, o, n) => ({
                                delta: 0,
                                newSizes: e
                            })
                        }
                    },
                    Ns = e => $o(e).grid,
                    Rs = ie("th"),
                    Ds = e => z(e, (e => Rs(e.element))),
                    Bs = (e, t) => e && t ? "sectionCells" : e ? "section" : "cells",
                    Ls = e => {
                        const t = "thead" === e.section,
                            o = mt(Hs(e.cells), "th");
                        return "tfoot" === e.section ? {
                            type: "footer"
                        } : t || o ? {
                            type: "header",
                            subType: Bs(t, o)
                        } : {
                            type: "body"
                        }
                    },
                    Hs = e => {
                        const t = R(e, (e => Rs(e.element)));
                        return 0 === t.length ? C.some("td") : t.length === e.length ? C.some("th") : C.none()
                    },
                    Is = (e, t, o) => Ge(o(e.element, t), !0, e.isLocked),
                    Ps = (e, t) => e.section !== t ? Ke(e.element, e.cells, t, e.isNew) : e,
                    zs = () => ({
                        transformRow: Ps,
                        transformCell: (e, t, o) => {
                            const n = o(e.element, t),
                                r = "td" !== Q(n) ? ((e, t) => {
                                    const o = je(e, "td");
                                    Re(e, o);
                                    const n = Ae(e);
                                    return Ie(o, n), ze(e), o
                                })(n) : n;
                            return Ge(r, e.isNew, e.isLocked)
                        }
                    }),
                    Fs = () => ({
                        transformRow: Ps,
                        transformCell: Is
                    }),
                    Vs = () => ({
                        transformRow: (e, t) => Ps(e, "thead" === t ? "tbody" : t),
                        transformCell: Is
                    }),
                    Zs = zs,
                    Us = Fs,
                    js = Vs,
                    Ws = () => ({
                        transformRow: p,
                        transformCell: Is
                    }),
                    $s = e => ut(e, "[contenteditable]"),
                    qs = (e, t = !1) => et(e) ? e.dom.isContentEditable : $s(e).fold(h(t), (e => "true" === Gs(e))),
                    Gs = e => e.dom.contentEditable,
                    Ks = (e, t, o, n) => {
                        o === n ? ge(e, t) : ce(e, t, o)
                    },
                    Ys = (e, t, o) => {
                        U(rt(e, t)).fold((() => De(e, o)), (e => Re(e, o)))
                    },
                    Xs = (e, t) => {
                        const o = [],
                            n = [],
                            r = e => A(e, (e => {
                                e.isNew && o.push(e.element);
                                const t = e.element;
                                return Pe(t), M(e.cells, (e => {
                                    e.isNew && n.push(e.element), Ks(e.element, "colspan", e.colspan, 1), Ks(e.element, "rowspan", e.rowspan, 1), Be(t, e.element)
                                })), t
                            })),
                            s = e => P(e, (e => A(e.cells, (e => (Ks(e.element, "span", e.colspan, 1), e.element))))),
                            a = (t, o) => {
                                const n = ((e, t) => {
                                        const o = ct(e, t).getOrThunk((() => {
                                            const o = fe.fromTag(t, Se(e).dom);
                                            return "thead" === t ? Ys(e, "caption,colgroup", o) : "colgroup" === t ? Ys(e, "caption", o) : Be(e, o), o
                                        }));
                                        return Pe(o), o
                                    })(e, o),
                                    a = ("colgroup" === o ? s : r)(t);
                                Ie(n, a)
                            },
                            i = (t, o) => {
                                t.length > 0 ? a(t, o) : (t => {
                                    ct(e, t).each(ze)
                                })(o)
                            },
                            l = [],
                            c = [],
                            d = [],
                            u = [];
                        return M(t, (e => {
                            switch (e.section) {
                                case "thead":
                                    l.push(e);
                                    break;
                                case "tbody":
                                    c.push(e);
                                    break;
                                case "tfoot":
                                    d.push(e);
                                    break;
                                case "colgroup":
                                    u.push(e)
                            }
                        })), i(u, "colgroup"), i(l, "thead"), i(c, "tbody"), i(d, "tfoot"), {
                            newRows: o,
                            newCells: n
                        }
                    },
                    Js = (e, t) => {
                        if (0 === e.length) return 0;
                        const o = e[0];
                        return H(e, (e => !t(o.element, e.element))).getOr(e.length)
                    },
                    Qs = (e, t) => {
                        const o = A(e, (e => A(e.cells, w)));
                        return A(e, ((n, r) => {
                            const s = P(n.cells, ((n, s) => {
                                if (!1 === o[r][s]) {
                                    const d = ((e, t, o, n) => {
                                        const r = ((e, t) => e[t])(e, t),
                                            s = "colgroup" === r.section,
                                            a = Js(r.cells.slice(o), n),
                                            i = s ? 1 : Js(((e, t) => A(e, (e => Lo(e, t))))(e.slice(t), o), n);
                                        return {
                                            colspan: a,
                                            rowspan: i
                                        }
                                    })(e, r, s, t);
                                    return ((e, t, n, r) => {
                                        for (let s = e; s < e + n; s++)
                                            for (let e = t; e < t + r; e++) o[s][e] = !0
                                    })(r, s, d.rowspan, d.colspan), [(a = n.element, i = d.rowspan, l = d.colspan, c = n.isNew, {
                                        element: a,
                                        rowspan: i,
                                        colspan: l,
                                        isNew: c
                                    })]
                                }
                                return [];
                                var a, i, l, c
                            }));
                            return ((e, t, o, n) => ({
                                element: e,
                                cells: t,
                                section: o,
                                isNew: n
                            }))(n.element, s, n.section, n.isNew)
                        }))
                    },
                    ea = (e, t, o) => {
                        const n = [];
                        M(e.colgroups, (r => {
                            const s = [];
                            for (let n = 0; n < e.grid.columns; n++) {
                                const r = en(e, n).map((e => Ge(e.element, o, !1))).getOrThunk((() => Ge(t.colGap(), !0, !1)));
                                s.push(r)
                            }
                            n.push(Ke(r.element, s, "colgroup", o))
                        }));
                        for (let r = 0; r < e.grid.rows; r++) {
                            const s = [];
                            for (let n = 0; n < e.grid.columns; n++) {
                                const a = Go(e, r, n).map((e => Ge(e.element, o, e.isLocked))).getOrThunk((() => Ge(t.gap(), !0, !1)));
                                s.push(a)
                            }
                            const a = e.all[r],
                                i = Ke(a.element, s, a.section, o);
                            n.push(i)
                        }
                        return n
                    },
                    ta = e => Qs(e, we),
                    oa = (e, t) => j(e.all, (e => L(e.cells, (e => we(t, e.element))))),
                    na = (e, t, o) => {
                        const n = A(t.selection, (t => Pt(t).bind((t => oa(e, t))).filter(o))),
                            r = gt(n);
                        return ht(r.length > 0, r)
                    },
                    ra = (e, t, o, n, r) => (s, a, i, l) => {
                        const c = $o(s),
                            d = C.from(null == l ? void 0 : l.section).getOrThunk(Ws);
                        return t(c, a).map((t => {
                            const o = ((e, t) => ea(e, t, !1))(c, i),
                                n = e(o, t, we, r(i), d),
                                s = Zo(n.grid);
                            return {
                                info: t,
                                grid: ta(n.grid),
                                cursor: n.cursor,
                                lockedColumns: s
                            }
                        })).bind((e => {
                            const t = Xs(s, e.grid),
                                r = C.from(null == l ? void 0 : l.sizing).getOrThunk((() => nr(s))),
                                a = C.from(null == l ? void 0 : l.resize).getOrThunk(Ms);
                            return o(s, e.grid, e.info, {
                                sizing: r,
                                resize: a,
                                section: d
                            }), n(s), ge(s, Fo), e.lockedColumns.length > 0 && ce(s, Fo, e.lockedColumns.join(",")), C.some({
                                cursor: e.cursor,
                                newRows: t.newRows,
                                newCells: t.newCells
                            })
                        }))
                    },
                    sa = (e, t) => na(e, t, x).map((e => ({
                        cells: e,
                        generators: t.generators,
                        clipboard: t.clipboard
                    }))),
                    aa = (e, t) => na(e, t, x),
                    ia = (e, t) => na(e, t, (e => !e.isLocked)),
                    la = (e, t) => z(t, (t => ((e, t) => oa(e, t).exists((e => !e.isLocked)))(e, t))),
                    ca = (e, t, o, n) => {
                        const r = Po(e).rows;
                        let s = !0;
                        for (let e = 0; e < r.length; e++)
                            for (let a = 0; a < Io(r[0]); a++) {
                                const i = r[e],
                                    l = Lo(i, a),
                                    c = o(l.element, t);
                                c && !s ? Do(i, a, Ge(n(), !0, l.isLocked)) : c && (s = !1)
                            }
                        return e
                    },
                    da = e => {
                        const t = t => t(e),
                            o = h(e),
                            n = () => r,
                            r = {
                                tag: !0,
                                inner: e,
                                fold: (t, o) => o(e),
                                isValue: x,
                                isError: w,
                                map: t => ma.value(t(e)),
                                mapError: n,
                                bind: t,
                                exists: t,
                                forall: t,
                                getOr: o,
                                or: n,
                                getOrThunk: o,
                                orThunk: n,
                                getOrDie: o,
                                each: t => {
                                    t(e)
                                },
                                toOptional: () => C.some(e)
                            };
                        return r
                    },
                    ua = e => {
                        const t = () => o,
                            o = {
                                tag: !1,
                                inner: e,
                                fold: (t, o) => t(e),
                                isValue: w,
                                isError: x,
                                map: t,
                                mapError: t => ma.error(t(e)),
                                bind: t,
                                exists: w,
                                forall: x,
                                getOr: p,
                                or: p,
                                getOrThunk: y,
                                orThunk: y,
                                getOrDie: (n = String(e), () => {
                                    throw new Error(n)
                                }),
                                each: g,
                                toOptional: C.none
                            };
                        var n;
                        return o
                    },
                    ma = {
                        value: da,
                        error: ua,
                        fromOption: (e, t) => e.fold((() => ua(t)), da)
                    },
                    ga = (e, t) => ({
                        rowDelta: 0,
                        colDelta: Io(e[0]) - Io(t[0])
                    }),
                    ha = (e, t) => ({
                        rowDelta: e.length - t.length,
                        colDelta: 0
                    }),
                    pa = (e, t, o, n) => {
                        const r = "colgroup" === t.section ? o.col : o.cell;
                        return E(e, (e => Ge(r(), !0, n(e))))
                    },
                    fa = (e, t, o, n) => {
                        const r = e[e.length - 1];
                        return e.concat(E(t, (() => {
                            const e = "colgroup" === r.section ? o.colgroup : o.row,
                                t = zo(r, e, p),
                                s = pa(t.cells.length, t, o, (e => J(n, e.toString())));
                            return Bo(t, s)
                        })))
                    },
                    va = (e, t, o, n) => A(e, (e => {
                        const r = pa(t, e, o, w);
                        return No(e, n, r)
                    })),
                    ba = (e, t, o) => {
                        const n = t.colDelta < 0 ? va : p,
                            r = t.rowDelta < 0 ? fa : p,
                            s = Zo(e),
                            a = Io(e[0]),
                            i = T(s, (e => e === a - 1)),
                            l = n(e, Math.abs(t.colDelta), o, i ? a - 1 : a),
                            c = Zo(l);
                        return r(l, Math.abs(t.rowDelta), o, F(c, x))
                    },
                    ya = (e, t, o, n) => {
                        const r = v(n, Lo(e[t], o).element),
                            s = e[t];
                        return e.length > 1 && Io(s) > 1 && (o > 0 && r(Ho(s, o - 1)) || o < s.cells.length - 1 && r(Ho(s, o + 1)) || t > 0 && r(Ho(e[t - 1], o)) || t < e.length - 1 && r(Ho(e[t + 1], o)))
                    },
                    wa = (e, t, o) => R(o, (o => o >= e.column && o <= Io(t[0]) + e.column)),
                    xa = (e, t, o, n, r) => {
                        ((e, t, o, n) => {
                            t > 0 && t < e[0].cells.length && M(e, (e => {
                                const r = e.cells[t - 1];
                                let s = 0;
                                const a = n();
                                for (; e.cells.length > t + s && o(r.element, e.cells[t + s].element);) Do(e, t + s, Ge(a, !0, e.cells[t + s].isLocked)), s++
                            }))
                        })(t, e, r, n.cell);
                        const s = ha(o, t),
                            a = ba(o, s, n),
                            i = ha(t, a),
                            l = ba(t, i, n);
                        return A(l, ((t, o) => No(t, e, a[o].cells)))
                    },
                    Ca = (e, t, o, n, r) => {
                        ((e, t, o, n) => {
                            const r = Po(e).rows;
                            if (t > 0 && t < r.length) {
                                const e = ((e, t) => B(e, ((e, o) => T(e, (e => t(e.element, o.element))) ? e : e.concat([o])), []))(r[t - 1].cells, o);
                                M(e, (e => {
                                    let s = C.none();
                                    for (let a = t; a < r.length; a++)
                                        for (let t = 0; t < Io(r[0]); t++) {
                                            const i = r[a],
                                                l = Lo(i, t);
                                            o(l.element, e.element) && (s.isNone() && (s = C.some(n())), s.each((e => {
                                                Do(i, t, Ge(e, !0, l.isLocked))
                                            })))
                                        }
                                }))
                            }
                        })(t, e, r, n.cell);
                        const s = Zo(t),
                            a = ga(t, o),
                            i = { ...a,
                                colDelta: a.colDelta - s.length
                            },
                            l = ba(t, i, n),
                            {
                                cols: c,
                                rows: d
                            } = Po(l),
                            u = Zo(l),
                            m = ga(o, t),
                            g = { ...m,
                                colDelta: m.colDelta + u.length
                            },
                            h = (f = n, v = u, A(o, (e => B(v, ((t, o) => {
                                const n = pa(1, e, f, x)[0];
                                return Ro(t, o, n)
                            }), e)))),
                            p = ba(h, g, n);
                        var f, v;
                        return [...c, ...d.slice(0, e), ...p, ...d.slice(e, d.length)]
                    },
                    Sa = (e, t, o, n, r) => {
                        const {
                            rows: s,
                            cols: a
                        } = Po(e), i = s.slice(0, t), l = s.slice(t);
                        return [...a, ...i, ((e, t, o, n) => zo(e, (e => n(e, o)), t))(s[o], ((e, o) => t > 0 && t < s.length && n(Ho(s[t - 1], o), Ho(s[t], o)) ? Lo(s[t], o) : Ge(r(e.element, n), !0, e.isLocked)), n, r), ...l]
                    },
                    ka = (e, t, o, n, r) => A(e, (e => {
                        const s = t > 0 && t < Io(e) && n(Ho(e, t - 1), Ho(e, t)),
                            a = ((e, t, o, n, r, s, a) => {
                                if ("colgroup" !== o && n) return Lo(e, t); {
                                    const t = Lo(e, r);
                                    return Ge(a(t.element, s), !0, !1)
                                }
                            })(e, t, e.section, s, o, n, r);
                        return Ro(e, t, a)
                    })),
                    _a = (e, t, o, n) => ((e, t, o, n) => void 0 !== Ho(e[t], o) && t > 0 && n(Ho(e[t - 1], o), Ho(e[t], o)))(e, t, o, n) || ((e, t, o) => t > 0 && o(Ho(e, t - 1), Ho(e, t)))(e[t], o, n),
                    Oa = (e, t, o, n) => {
                        const r = e => (e => "row" === e ? Rt(t) : Nt(t))(e) ? `${e}group` : e;
                        return e ? Rs(t) ? r(o) : null : n && Rs(t) ? r("row" === o ? "col" : "row") : null
                    },
                    Ta = (e, t, o) => Ge(o(e.element, t), !0, e.isLocked),
                    Ea = (e, t, o, n, r, s, a) => A(e, ((e, i) => ((e, l) => {
                        const c = e.cells,
                            d = A(c, ((e, l) => {
                                if ((e => T(t, (t => o(e.element, t.element))))(e)) {
                                    const t = a(e, i, l) ? r(e, o, n) : e;
                                    return s(t, i, l).each((e => {
                                        var o, n;
                                        o = t.element, n = {
                                            scope: C.from(e)
                                        }, q(n, ((e, t) => {
                                            e.fold((() => {
                                                ge(o, t)
                                            }), (e => {
                                                le(o.dom, t, e)
                                            }))
                                        }))
                                    })), t
                                }
                                return e
                            }));
                        return Ke(e.element, d, e.section, e.isNew)
                    })(e))),
                    Aa = (e, t, o) => P(e, ((n, r) => _a(e, r, t, o) ? [] : [Lo(n, t)])),
                    Ma = (e, t, o, n, r) => {
                        const s = Po(e).rows,
                            a = P(t, (e => Aa(s, e, n))),
                            i = A(s, (e => Ds(e.cells))),
                            l = ((e, t) => z(t, p) && Ds(e) ? x : (e, o, n) => !("th" === Q(e.element) && t[o]))(a, i),
                            c = ((e, t) => (o, n) => C.some(Oa(e, o.element, "row", t[n])))(o, i);
                        return Ea(e, a, n, r, Ta, c, l)
                    },
                    Na = (e, t, o, n) => {
                        const r = Po(e).rows,
                            s = A(t, (e => Lo(r[e.row], e.column)));
                        return Ea(e, s, o, n, Ta, C.none, x)
                    },
                    Ra = e => {
                        if (!a(e)) throw new Error("cases must be an array");
                        if (0 === e.length) throw new Error("there must be at least one case");
                        const t = [],
                            o = {};
                        return M(e, ((n, r) => {
                            const s = W(n);
                            if (1 !== s.length) throw new Error("one and only one name per case");
                            const i = s[0],
                                l = n[i];
                            if (void 0 !== o[i]) throw new Error("duplicate key detected:" + i);
                            if ("cata" === i) throw new Error("cannot have a case named cata (sorry)");
                            if (!a(l)) throw new Error("case arguments must be an array");
                            t.push(i), o[i] = (...o) => {
                                const n = o.length;
                                if (n !== l.length) throw new Error("Wrong number of arguments to case " + i + ". Expected " + l.length + " (" + l + "), got " + n);
                                return {
                                    fold: (...t) => {
                                        if (t.length !== e.length) throw new Error("Wrong number of arguments to fold. Expected " + e.length + ", got " + t.length);
                                        return t[r].apply(null, o)
                                    },
                                    match: e => {
                                        const n = W(e);
                                        if (t.length !== n.length) throw new Error("Wrong number of arguments to match. Expected: " + t.join(",") + "\nActual: " + n.join(","));
                                        if (!z(t, (e => O(n, e)))) throw new Error("Not all branches were specified when using match. Specified: " + n.join(", ") + "\nRequired: " + t.join(", "));
                                        return e[i].apply(null, o)
                                    },
                                    log: e => {
                                        console.log(e, {
                                            constructors: t,
                                            constructor: i,
                                            params: o
                                        })
                                    }
                                }
                            }
                        })), o
                    },
                    Da = { ...Ra([{
                            none: []
                        }, {
                            only: ["index"]
                        }, {
                            left: ["index", "next"]
                        }, {
                            middle: ["prev", "index", "next"]
                        }, {
                            right: ["prev", "index"]
                        }])
                    },
                    Ba = (e, t, o) => {
                        let n = 0;
                        for (let r = e; r < t; r++) n += void 0 !== o[r] ? o[r] : 0;
                        return n
                    },
                    La = (e, t) => {
                        const o = Xo(e);
                        return A(o, (e => {
                            const o = Ba(e.row, e.row + e.rowspan, t);
                            return {
                                element: e.element,
                                height: o,
                                rowspan: e.rowspan
                            }
                        }))
                    },
                    Ha = (e, t, o) => {
                        const n = ((e, t) => Qo(e) ? ((e, t) => {
                            const o = Jo(e);
                            return A(o, ((e, o) => ({
                                element: e.element,
                                width: t[o],
                                colspan: e.colspan
                            })))
                        })(e, t) : ((e, t) => {
                            const o = Xo(e);
                            return A(o, (e => {
                                const o = Ba(e.column, e.column + e.colspan, t);
                                return {
                                    element: e.element,
                                    width: o,
                                    colspan: e.colspan
                                }
                            }))
                        })(e, t))(e, t);
                        M(n, (e => {
                            o.setElementWidth(e.element, e.width)
                        }))
                    },
                    Ia = (e, t, o, n, r) => {
                        const s = $o(e),
                            a = r.getCellDelta(t),
                            i = r.getWidths(s, r),
                            l = o === s.grid.columns - 1,
                            c = n.clampTableDelta(i, o, a, r.minCellWidth(), l),
                            d = ((e, t, o, n, r) => {
                                const s = e.slice(0),
                                    a = ((e, t) => 0 === e.length ? Da.none() : 1 === e.length ? Da.only(0) : 0 === t ? Da.left(0, 1) : t === e.length - 1 ? Da.right(t - 1, t) : t > 0 && t < e.length - 1 ? Da.middle(t - 1, t, t + 1) : Da.none())(e, t),
                                    i = h(A(s, h(0)));
                                return a.fold(i, (e => n.singleColumnWidth(s[e], o)), ((e, t) => r.calcLeftEdgeDeltas(s, e, t, o, n.minCellWidth(), n.isRelative)), ((e, t, a) => r.calcMiddleDeltas(s, e, t, a, o, n.minCellWidth(), n.isRelative)), ((e, t) => r.calcRightEdgeDeltas(s, e, t, o, n.minCellWidth(), n.isRelative)))
                            })(i, o, c, r, n),
                            u = A(d, ((e, t) => e + i[t]));
                        Ha(s, u, r), n.resizeTable(r.adjustTableWidth, c, l)
                    },
                    Pa = e => B(e, ((e, t) => T(e, (e => e.column === t.column)) ? e : e.concat([t])), []).sort(((e, t) => e.column - t.column)),
                    za = ie("col"),
                    Fa = ie("colgroup"),
                    Va = e => "tr" === Q(e) || Fa(e),
                    Za = e => ({
                        element: e,
                        colspan: At(e, "colspan", 1),
                        rowspan: At(e, "rowspan", 1)
                    }),
                    Ua = e => me(e, "scope").map((e => e.substr(0, 3))),
                    ja = (e, t = Za) => {
                        const o = o => {
                            if (Va(o)) return Fa((r = {
                                element: o
                            }).element) ? e.colgroup(r) : e.row(r); {
                                const r = o,
                                    s = (t => za(t.element) ? e.col(t) : e.cell(t))(t(r));
                                return n = C.some({
                                    item: r,
                                    replacement: s
                                }), s
                            }
                            var r
                        };
                        let n = C.none();
                        return {
                            getOrInit: (e, t) => n.fold((() => o(e)), (n => t(e, n.item) ? n.replacement : o(e)))
                        }
                    },
                    Wa = e => t => {
                        const o = [],
                            n = n => {
                                const r = "td" === e ? {
                                        scope: null
                                    } : {},
                                    s = t.replace(n, e, r);
                                return o.push({
                                    item: n,
                                    sub: s
                                }), s
                            };
                        return {
                            replaceOrInit: (e, t) => {
                                if (Va(e) || za(e)) return e; {
                                    const r = e;
                                    return ((e, t) => L(o, (o => t(o.item, e))))(r, t).fold((() => n(r)), (o => t(e, o.item) ? o.sub : n(r)))
                                }
                            }
                        }
                    },
                    $a = e => ({
                        unmerge: t => {
                            const o = Ua(t);
                            return o.each((e => ce(t, "scope", e))), () => {
                                const n = e.cell({
                                    element: t,
                                    colspan: 1,
                                    rowspan: 1
                                });
                                return Et(n, "width"), Et(t, "width"), o.each((e => ce(n, "scope", e))), n
                            }
                        },
                        merge: e => (Et(e[0], "width"), (() => {
                            const t = gt(A(e, Ua));
                            if (0 === t.length) return C.none(); {
                                const e = t[0],
                                    o = ["row", "col"];
                                return T(t, (t => t !== e && O(o, t))) ? C.none() : C.from(e)
                            }
                        })().fold((() => ge(e[0], "scope")), (t => ce(e[0], "scope", t + "group"))), h(e[0]))
                    }),
                    qa = ["body", "p", "div", "article", "aside", "figcaption", "figure", "footer", "header", "nav", "section", "ol", "ul", "table", "thead", "tfoot", "tbody", "caption", "tr", "td", "th", "h1", "h2", "h3", "h4", "h5", "h6", "blockquote", "pre", "address"],
                    Ga = Vr(),
                    Ka = e => ((e, t) => {
                        const o = e.property().name(t);
                        return O(qa, o)
                    })(Ga, e),
                    Ya = e => ((e, t) => {
                        const o = e.property().name(t);
                        return O(["ol", "ul"], o)
                    })(Ga, e),
                    Xa = e => {
                        const t = ie("br"),
                            o = e => pr(e).bind((o => {
                                const n = Ee(o).map((e => !!Ka(e) || !!((e, t) => O(["br", "img", "hr", "input"], e.property().name(t)))(Ga, e) && "img" !== Q(e))).getOr(!1);
                                return _e(o).map((r => {
                                    return !0 === n || ("li" === Q(s = r) || it(s, Ya).isSome()) || t(o) || Ka(r) && !we(e, r) ? [] : [fe.fromTag("br")];
                                    var s
                                }))
                            })).getOr([]),
                            n = (() => {
                                const n = P(e, (e => {
                                    const n = Ae(e);
                                    return (e => z(e, (e => t(e) || re(e) && 0 === lr(e).trim().length)))(n) ? [] : n.concat(o(e))
                                }));
                                return 0 === n.length ? [fe.fromTag("br")] : n
                            })();
                        Pe(e[0]), Ie(e[0], n)
                    },
                    Ja = e => qs(e, !0),
                    Qa = e => {
                        0 === zt(e).length && ze(e)
                    },
                    ei = (e, t) => ({
                        grid: e,
                        cursor: t
                    }),
                    ti = (e, t, o) => {
                        const n = ((e, t, o) => {
                            var n, r;
                            const s = Po(e).rows;
                            return C.from(null === (r = null === (n = s[t]) || void 0 === n ? void 0 : n.cells[o]) || void 0 === r ? void 0 : r.element).filter(Ja).orThunk((() => (e => j(e, (e => j(e.cells, (e => {
                                const t = e.element;
                                return ht(Ja(t), t)
                            })))))(s)))
                        })(e, t, o);
                        return ei(e, n)
                    },
                    oi = e => B(e, ((e, t) => T(e, (e => e.row === t.row)) ? e : e.concat([t])), []).sort(((e, t) => e.row - t.row)),
                    ni = (e, t) => (o, n, r, s, a) => {
                        const i = oi(n),
                            l = A(i, (e => e.row)),
                            c = ((e, t, o, n, r, s, a) => {
                                const {
                                    cols: i,
                                    rows: l
                                } = Po(e), c = l[t[0]], d = P(t, (e => ((e, t, o) => {
                                    const n = e[t];
                                    return P(n.cells, ((n, r) => _a(e, t, r, o) ? [] : [n]))
                                })(l, e, r))), u = A(c.cells, ((e, t) => Ds(Aa(l, t, r)))), m = [...l];
                                M(t, (e => {
                                    m[e] = a.transformRow(l[e], o)
                                }));
                                const g = [...i, ...m],
                                    h = ((e, t) => z(t, p) && Ds(e.cells) ? x : (e, o, n) => !("th" === Q(e.element) && t[n]))(c, u),
                                    f = ((e, t) => (o, n, r) => C.some(Oa(e, o.element, "col", t[r])))(n, u);
                                return Ea(g, d, r, s, a.transformCell, f, h)
                            })(o, l, e, t, r, s.replaceOrInit, a);
                        return ti(c, n[0].row, n[0].column)
                    },
                    ri = ni("thead", !0),
                    si = ni("tbody", !1),
                    ai = ni("tfoot", !1),
                    ii = (e, t, o) => {
                        const n = ((e, t) => jt(e, (() => t)))(e, o.section),
                            r = qo(n);
                        return ea(r, t, !0)
                    },
                    li = (e, t, o, n) => ((e, t, o, n) => {
                        const r = qo(t),
                            s = n.getWidths(r, n);
                        Ha(r, s, n)
                    })(0, t, 0, n.sizing),
                    ci = (e, t, o, n) => ((e, t, o, n, r) => {
                        const s = qo(t),
                            a = n.getWidths(s, n),
                            i = n.pixelWidth(),
                            {
                                newSizes: l,
                                delta: c
                            } = r.calcRedestributedWidths(a, i, o.pixelDelta, n.isRelative);
                        Ha(s, l, n), n.adjustTableWidth(c)
                    })(0, t, o, n.sizing, n.resize),
                    di = (e, t) => T(t, (e => 0 === e.column && e.isLocked)),
                    ui = (e, t) => T(t, (t => t.column + t.colspan >= e.grid.columns && t.isLocked)),
                    mi = (e, t) => {
                        const o = tn(e),
                            n = Pa(t);
                        return B(n, ((e, t) => e + o[t.column].map(Ao).getOr(0)), 0)
                    },
                    gi = e => (t, o) => aa(t, o).filter((o => !(e ? di : ui)(t, o))).map((e => ({
                        details: e,
                        pixelDelta: mi(t, e)
                    }))),
                    hi = e => (t, o) => sa(t, o).filter((o => !(e ? di : ui)(t, o.cells))),
                    pi = Wa("th"),
                    fi = Wa("td"),
                    vi = ra(((e, t, o, n) => {
                        const r = t[0].row,
                            s = oi(t),
                            a = D(s, ((e, t) => ({
                                grid: Sa(e.grid, r, t.row + e.delta, o, n.getOrInit),
                                delta: e.delta + 1
                            })), {
                                grid: e,
                                delta: 0
                            }).grid;
                        return ti(a, r, t[0].column)
                    }), aa, g, g, ja),
                    bi = ra(((e, t, o, n) => {
                        const r = oi(t),
                            s = r[r.length - 1],
                            a = s.row + s.rowspan,
                            i = D(r, ((e, t) => Sa(e, a, t.row, o, n.getOrInit)), e);
                        return ti(i, a, t[0].column)
                    }), aa, g, g, ja),
                    yi = ra(((e, t, o, n) => {
                        const r = t.details,
                            s = Pa(r),
                            a = s[0].column,
                            i = D(s, ((e, t) => ({
                                grid: ka(e.grid, a, t.column + e.delta, o, n.getOrInit),
                                delta: e.delta + 1
                            })), {
                                grid: e,
                                delta: 0
                            }).grid;
                        return ti(i, r[0].row, a)
                    }), gi(!0), ci, g, ja),
                    wi = ra(((e, t, o, n) => {
                        const r = t.details,
                            s = r[r.length - 1],
                            a = s.column + s.colspan,
                            i = Pa(r),
                            l = D(i, ((e, t) => ka(e, a, t.column, o, n.getOrInit)), e);
                        return ti(l, r[0].row, a)
                    }), gi(!1), ci, g, ja),
                    xi = ra(((e, t, o, n) => {
                        const r = Pa(t.details),
                            s = ((e, t) => P(e, (e => {
                                const o = e.cells,
                                    n = D(t, ((e, t) => t >= 0 && t < e.length ? e.slice(0, t).concat(e.slice(t + 1)) : e), o);
                                return n.length > 0 ? [Ke(e.element, n, e.section, e.isNew)] : []
                            })))(e, A(r, (e => e.column))),
                            a = s.length > 0 ? s[0].cells.length - 1 : 0;
                        return ti(s, r[0].row, Math.min(r[0].column, a))
                    }), ((e, t) => ia(e, t).map((t => ({
                        details: t,
                        pixelDelta: -mi(e, t)
                    })))), ci, Qa, ja),
                    Ci = ra(((e, t, o, n) => {
                        const r = oi(t),
                            s = ((e, t, o) => {
                                const {
                                    rows: n,
                                    cols: r
                                } = Po(e);
                                return [...r, ...n.slice(0, t), ...n.slice(o + 1)]
                            })(e, r[0].row, r[r.length - 1].row),
                            a = s.length > 0 ? s.length - 1 : 0;
                        return ti(s, Math.min(t[0].row, a), t[0].column)
                    }), aa, g, Qa, ja),
                    Si = ra(((e, t, o, n) => {
                        const r = Pa(t),
                            s = A(r, (e => e.column)),
                            a = Ma(e, s, !0, o, n.replaceOrInit);
                        return ti(a, t[0].row, t[0].column)
                    }), ia, g, g, pi),
                    ki = ra(((e, t, o, n) => {
                        const r = Pa(t),
                            s = A(r, (e => e.column)),
                            a = Ma(e, s, !1, o, n.replaceOrInit);
                        return ti(a, t[0].row, t[0].column)
                    }), ia, g, g, fi),
                    _i = ra(ri, ia, g, g, pi),
                    Oi = ra(si, ia, g, g, fi),
                    Ti = ra(ai, ia, g, g, fi),
                    Ei = ra(((e, t, o, n) => {
                        const r = Na(e, t, o, n.replaceOrInit);
                        return ti(r, t[0].row, t[0].column)
                    }), ia, g, g, pi),
                    Ai = ra(((e, t, o, n) => {
                        const r = Na(e, t, o, n.replaceOrInit);
                        return ti(r, t[0].row, t[0].column)
                    }), ia, g, g, fi),
                    Mi = ra(((e, t, o, n) => {
                        const r = t.cells;
                        Xa(r);
                        const s = ((e, t, o, n) => {
                            const r = Po(e).rows;
                            if (0 === r.length) return e;
                            for (let e = t.startRow; e <= t.finishRow; e++)
                                for (let o = t.startCol; o <= t.finishCol; o++) {
                                    const t = r[e],
                                        s = Lo(t, o).isLocked;
                                    Do(t, o, Ge(n(), !1, s))
                                }
                            return e
                        })(e, t.bounds, 0, n.merge(r));
                        return ei(s, C.from(r[0]))
                    }), ((e, t) => ((e, t) => t.mergable)(0, t).filter((t => la(e, t.cells)))), li, g, $a),
                    Ni = ra(((e, t, o, n) => {
                        const r = D(t, ((e, t) => ca(e, t, o, n.unmerge(t))), e);
                        return ei(r, C.from(t[0]))
                    }), ((e, t) => ((e, t) => t.unmergable)(0, t).filter((t => la(e, t)))), li, g, $a),
                    Ri = ra(((e, t, o, n) => {
                        const r = ((e, t) => {
                            const o = $o(e);
                            return ea(o, t, !0)
                        })(t.clipboard, t.generators);
                        var s, a;
                        return ((e, t, o, n, r) => {
                            const s = Zo(t),
                                a = ((e, t, o) => {
                                    const n = Io(t[0]),
                                        r = Po(t).cols.length + e.row,
                                        s = E(n - e.column, (t => t + e.column));
                                    return {
                                        row: r,
                                        column: L(s, (e => z(o, (t => t !== e)))).getOr(n - 1)
                                    }
                                })(e, t, s),
                                i = Po(o).rows,
                                l = wa(a, i, s),
                                c = ((e, t, o) => {
                                    if (e.row >= t.length || e.column > Io(t[0])) return ma.error("invalid start address out of table bounds, row: " + e.row + ", column: " + e.column);
                                    const n = t.slice(e.row),
                                        r = n[0].cells.slice(e.column),
                                        s = Io(o[0]),
                                        a = o.length;
                                    return ma.value({
                                        rowDelta: n.length - a,
                                        colDelta: r.length - s
                                    })
                                })(a, t, i);
                            return c.map((e => {
                                const o = { ...e,
                                        colDelta: e.colDelta - l.length
                                    },
                                    s = ba(t, o, n),
                                    c = Zo(s),
                                    d = wa(a, i, c);
                                return ((e, t, o, n, r, s) => {
                                    const a = e.row,
                                        i = e.column,
                                        l = a + o.length,
                                        c = i + Io(o[0]) + s.length,
                                        d = F(s, x);
                                    for (let e = a; e < l; e++) {
                                        let s = 0;
                                        for (let l = i; l < c; l++) {
                                            if (d[l]) {
                                                s++;
                                                continue
                                            }
                                            ya(t, e, l, r) && ca(t, Ho(t[e], l), r, n.cell);
                                            const c = l - i - s,
                                                u = Lo(o[e - a], c),
                                                m = u.element,
                                                g = n.replace(m);
                                            Do(t[e], l, Ge(g, !0, u.isLocked))
                                        }
                                    }
                                    return t
                                })(a, s, i, n, r, d)
                            }))
                        })((s = t.row, a = t.column, {
                            row: s,
                            column: a
                        }), e, r, t.generators, o).fold((() => ei(e, C.some(t.element))), (e => ti(e, t.row, t.column)))
                    }), ((e, t) => Pt(t.element).bind((o => oa(e, o).map((e => ({ ...e,
                        generators: t.generators,
                        clipboard: t.clipboard
                    })))))), li, g, ja),
                    Di = ra(((e, t, o, n) => {
                        const r = Po(e).rows,
                            s = t.cells[0].column,
                            a = r[t.cells[0].row],
                            i = ii(t.clipboard, t.generators, a),
                            l = xa(s, e, i, t.generators, o);
                        return ti(l, t.cells[0].row, t.cells[0].column)
                    }), hi(!0), g, g, ja),
                    Bi = ra(((e, t, o, n) => {
                        const r = Po(e).rows,
                            s = t.cells[t.cells.length - 1].column + t.cells[t.cells.length - 1].colspan,
                            a = r[t.cells[0].row],
                            i = ii(t.clipboard, t.generators, a),
                            l = xa(s, e, i, t.generators, o);
                        return ti(l, t.cells[0].row, t.cells[0].column)
                    }), hi(!1), g, g, ja),
                    Li = ra(((e, t, o, n) => {
                        const r = Po(e).rows,
                            s = t.cells[0].row,
                            a = r[s],
                            i = ii(t.clipboard, t.generators, a),
                            l = Ca(s, e, i, t.generators, o);
                        return ti(l, t.cells[0].row, t.cells[0].column)
                    }), sa, g, g, ja),
                    Hi = ra(((e, t, o, n) => {
                        const r = Po(e).rows,
                            s = t.cells[t.cells.length - 1].row + t.cells[t.cells.length - 1].rowspan,
                            a = r[t.cells[0].row],
                            i = ii(t.clipboard, t.generators, a),
                            l = Ca(s, e, i, t.generators, o);
                        return ti(l, t.cells[0].row, t.cells[0].column)
                    }), sa, g, g, ja),
                    Ii = (e, t) => {
                        const o = $o(e);
                        return aa(o, t).bind((e => {
                            const t = e[e.length - 1],
                                n = e[0].column,
                                r = t.column + t.colspan,
                                s = I(A(o.all, (e => R(e.cells, (e => e.column >= n && e.column < r)))));
                            return Hs(s)
                        })).getOr("")
                    },
                    Pi = (e, t) => {
                        const o = $o(e);
                        return aa(o, t).bind(Hs).getOr("")
                    },
                    zi = (e, t) => {
                        const o = $o(e);
                        return aa(o, t).bind((e => {
                            const t = e[e.length - 1],
                                n = e[0].row,
                                r = t.row + t.rowspan;
                            return (e => {
                                const t = A(e, (e => Ls(e).type)),
                                    o = O(t, "header"),
                                    n = O(t, "footer");
                                if (o || n) {
                                    const e = O(t, "body");
                                    return !o || e || n ? o || e || !n ? C.none() : C.some("footer") : C.some("header")
                                }
                                return C.some("body")
                            })(o.all.slice(n, r))
                        })).getOr("")
                    },
                    Fi = (e, t) => e.dispatch("NewRow", {
                        node: t
                    }),
                    Vi = (e, t) => e.dispatch("NewCell", {
                        node: t
                    }),
                    Zi = (e, t, o) => {
                        e.dispatch("TableModified", { ...o,
                            table: t
                        })
                    },
                    Ui = {
                        structure: !1,
                        style: !0
                    },
                    ji = {
                        structure: !0,
                        style: !1
                    },
                    Wi = {
                        structure: !0,
                        style: !0
                    },
                    $i = e => t => t.options.get(e),
                    qi = "100%",
                    Gi = e => {
                        var t;
                        const o = e.dom,
                            n = null !== (t = o.getParent(e.selection.getStart(), o.isBlock)) && void 0 !== t ? t : e.getBody();
                        return Mo(fe.fromDom(n)) + "px"
                    },
                    Ki = e => C.from(e.options.get("table_clone_elements")),
                    Yi = $i("table_header_type"),
                    Xi = $i("table_column_resizing"),
                    Ji = e => "preservetable" === Xi(e),
                    Qi = e => "resizetable" === Xi(e),
                    el = $i("table_sizing_mode"),
                    tl = e => "relative" === el(e),
                    ol = e => "fixed" === el(e),
                    nl = e => "responsive" === el(e),
                    rl = $i("table_resize_bars"),
                    sl = $i("table_style_by_css"),
                    al = e => {
                        const t = e.options,
                            o = t.get("table_default_attributes");
                        return t.isSet("table_default_attributes") ? o : ((e, t) => nl(e) || sl(e) ? t : ol(e) ? { ...t,
                            width: Gi(e)
                        } : { ...t,
                            width: qi
                        })(e, o)
                    },
                    il = $i("table_use_colgroups"),
                    ll = (e, t) => tl(e) ? sr(t) : ol(e) ? rr(t) : nr(t),
                    cl = (e, t, o) => {
                        const n = e => "table" === Q(Or(e)),
                            r = Ki(e),
                            s = Qi(e) ? g : Ss,
                            a = t => {
                                switch (Yi(e)) {
                                    case "section":
                                        return Zs();
                                    case "sectionCells":
                                        return Us();
                                    case "cells":
                                        return js();
                                    default:
                                        return ((e, t) => {
                                            var o;
                                            switch ((o = $o(e), j(o.all, (e => {
                                                const t = Ls(e);
                                                return "header" === t.type ? C.from(t.subType) : C.none()
                                            }))).getOr(t)) {
                                                case "section":
                                                    return zs();
                                                case "sectionCells":
                                                    return Fs();
                                                case "cells":
                                                    return Vs()
                                            }
                                        })(t, "section")
                                }
                            },
                            i = (n, s, i, l) => (c, d, u = !1) => {
                                Er(c);
                                const m = fe.fromDom(e.getDoc()),
                                    g = kr(i, m, r),
                                    h = {
                                        sizing: ll(e, c),
                                        resize: Qi(e) ? As() : Ms(),
                                        section: a(c)
                                    };
                                return s(c) ? n(c, d, g, h).bind((n => {
                                    t.refresh(c.dom), M(n.newRows, (t => {
                                        Fi(e, t.dom)
                                    })), M(n.newCells, (t => {
                                        Vi(e, t.dom)
                                    }));
                                    const r = ((t, n) => n.cursor.fold((() => {
                                        const n = zt(t);
                                        return Z(n).filter(et).map((n => {
                                            o.clearSelectedCells(t.dom);
                                            const r = e.dom.createRng();
                                            return r.selectNode(n.dom), e.selection.setRng(r), ce(n, "data-mce-selected", "1"), r
                                        }))
                                    }), (n => {
                                        const r = xs(Cs, n),
                                            s = e.dom.createRng();
                                        return s.setStart(r.element.dom, r.offset), s.setEnd(r.element.dom, r.offset), e.selection.setRng(s), o.clearSelectedCells(t.dom), C.some(s)
                                    })))(c, n);
                                    return et(c) && (Er(c), u || Zi(e, c.dom, l)), r.map((e => ({
                                        rng: e,
                                        effect: l
                                    })))
                                })) : C.none()
                            },
                            l = i(Ci, (t => !n(e) || Ns(t).rows > 1), g, ji),
                            c = i(xi, (t => !n(e) || Ns(t).columns > 1), g, ji);
                        return {
                            deleteRow: l,
                            deleteColumn: c,
                            insertRowsBefore: i(vi, x, g, ji),
                            insertRowsAfter: i(bi, x, g, ji),
                            insertColumnsBefore: i(yi, x, s, ji),
                            insertColumnsAfter: i(wi, x, s, ji),
                            mergeCells: i(Mi, x, g, ji),
                            unmergeCells: i(Ni, x, g, ji),
                            pasteColsBefore: i(Di, x, g, ji),
                            pasteColsAfter: i(Bi, x, g, ji),
                            pasteRowsBefore: i(Li, x, g, ji),
                            pasteRowsAfter: i(Hi, x, g, ji),
                            pasteCells: i(Ri, x, g, Wi),
                            makeCellsHeader: i(Ei, x, g, ji),
                            unmakeCellsHeader: i(Ai, x, g, ji),
                            makeColumnsHeader: i(Si, x, g, ji),
                            unmakeColumnsHeader: i(ki, x, g, ji),
                            makeRowsHeader: i(_i, x, g, ji),
                            makeRowsBody: i(Oi, x, g, ji),
                            makeRowsFooter: i(Ti, x, g, ji),
                            getTableRowType: zi,
                            getTableCellType: Pi,
                            getTableColType: Ii
                        }
                    },
                    dl = (e, t, o) => {
                        const n = At(e, t, 1);
                        1 === o || n <= 1 ? ge(e, t) : ce(e, t, Math.min(o, n))
                    },
                    ul = (e, t) => o => {
                        const n = o.column + o.colspan - 1,
                            r = o.column;
                        return n >= e && r < t
                    },
                    ml = Ra([{
                        invalid: ["raw"]
                    }, {
                        pixels: ["value"]
                    }, {
                        percent: ["value"]
                    }]),
                    gl = (e, t, o) => {
                        const n = o.substring(0, o.length - e.length),
                            r = parseFloat(n);
                        return n === r.toString() ? t(r) : ml.invalid(o)
                    },
                    hl = { ...ml,
                        from: e => bt(e, "%") ? gl("%", ml.percent, e) : bt(e, "px") ? gl("px", ml.pixels, e) : ml.invalid(e)
                    },
                    pl = (e, t, o) => {
                        const n = hl.from(o),
                            r = z(e, (e => "0px" === e)) ? ((e, t) => {
                                const o = e.fold((() => h("")), (e => h(e / t + "px")), (() => h(100 / t + "%")));
                                return E(t, o)
                            })(n, e.length) : ((e, t, o) => e.fold((() => t), (e => ((e, t, o) => {
                                const n = o / t;
                                return A(e, (e => hl.from(e).fold((() => e), (e => e * n + "px"), (e => e / 100 * o + "px"))))
                            })(t, o, e)), (e => ((e, t) => A(e, (e => hl.from(e).fold((() => e), (e => e / t * 100 + "%"), (e => e + "%")))))(t, o))))(n, e, t);
                        return bl(r)
                    },
                    fl = (e, t) => 0 === e.length ? t : D(e, ((e, t) => hl.from(t).fold(h(0), p, p) + e), 0),
                    vl = (e, t) => hl.from(e).fold(h(e), (e => e + t + "px"), (e => e + t + "%")),
                    bl = e => {
                        if (0 === e.length) return e;
                        const t = D(e, ((e, t) => {
                                const o = hl.from(t).fold((() => ({
                                    value: t,
                                    remainder: 0
                                })), (e => ((e, t) => {
                                    const o = Math.floor(e);
                                    return {
                                        value: o + "px",
                                        remainder: e - o
                                    }
                                })(e)), (e => ({
                                    value: e + "%",
                                    remainder: 0
                                })));
                                return {
                                    output: [o.value].concat(e.output),
                                    remainder: e.remainder + o.remainder
                                }
                            }), {
                                output: [],
                                remainder: 0
                            }),
                            o = t.output;
                        return o.slice(0, o.length - 1).concat([vl(o[o.length - 1], Math.round(t.remainder))])
                    },
                    yl = hl.from,
                    wl = e => yl(e).fold(h("px"), h("px"), h("%")),
                    xl = (e, t, o) => {
                        const n = $o(e),
                            r = n.all,
                            s = Xo(n),
                            a = Jo(n);
                        t.each((t => {
                            const o = wl(t),
                                r = Eo(e),
                                i = ((e, t) => Yn(e, t, qn, Xn))(n, e),
                                l = pl(i, r, t);
                            Qo(n) ? ((e, t, o) => {
                                M(t, ((t, n) => {
                                    const r = fl([e[n]], Bt());
                                    St(t.element, "width", r + o)
                                }))
                            })(l, a, o) : ((e, t, o) => {
                                M(t, (t => {
                                    const n = e.slice(t.column, t.colspan + t.column),
                                        r = fl(n, Bt());
                                    St(t.element, "width", r + o)
                                }))
                            })(l, s, o), St(e, "width", t)
                        })), o.each((t => {
                            const o = wl(t),
                                a = ln(e),
                                i = ((e, t, o) => Qn(e, t, o, Gn, Xn))(n, e, _n);
                            ((e, t, o, n) => {
                                M(o, (t => {
                                    const o = e.slice(t.row, t.rowspan + t.row),
                                        r = fl(o, Lt());
                                    St(t.element, "height", r + n)
                                })), M(t, ((t, o) => {
                                    St(t.element, "height", e[o])
                                }))
                            })(pl(i, a, t), r, s, o), St(e, "height", t)
                        }))
                    },
                    Cl = e => zn(e).exists((e => Mn.test(e))),
                    Sl = e => zn(e).exists((e => Nn.test(e))),
                    kl = e => zn(e).isNone(),
                    _l = e => {
                        ge(e, "width")
                    },
                    Ol = e => {
                        const t = jn(e);
                        xl(e, C.some(t), C.none()), _l(e)
                    },
                    Tl = e => {
                        const t = (e => Eo(e) + "px")(e);
                        xl(e, C.some(t), C.none()), _l(e)
                    },
                    El = e => {
                        Et(e, "width");
                        const t = Ft(e),
                            o = t.length > 0 ? t : zt(e);
                        M(o, (e => {
                            Et(e, "width"), _l(e)
                        })), _l(e)
                    },
                    Al = {
                        styles: {
                            "border-collapse": "collapse",
                            width: "100%"
                        },
                        attributes: {
                            border: "1"
                        },
                        colGroups: !1
                    },
                    Ml = (e, t, o, n) => E(e, (e => ((e, t, o, n) => {
                        const r = fe.fromTag("tr");
                        for (let s = 0; s < e; s++) {
                            const e = fe.fromTag(n < t || s < o ? "th" : "td");
                            s < o && ce(e, "scope", "row"), n < t && ce(e, "scope", "col"), Be(e, fe.fromTag("br")), Be(r, e)
                        }
                        return r
                    })(t, o, n, e))),
                    Nl = (e, t) => {
                        e.selection.select(t.dom, !0), e.selection.collapse(!0)
                    },
                    Rl = (e, t, o, n, s) => {
                        const a = (e => {
                                const t = e.options,
                                    o = t.get("table_default_styles");
                                return t.isSet("table_default_styles") ? o : ((e, t) => nl(e) || !sl(e) ? t : ol(e) ? { ...t,
                                    width: Gi(e)
                                } : { ...t,
                                    width: qi
                                })(e, o)
                            })(e),
                            i = {
                                styles: a,
                                attributes: al(e),
                                colGroups: il(e)
                            };
                        return e.undoManager.ignore((() => {
                            const r = ((e, t, o, n, r, s = Al) => {
                                const a = fe.fromTag("table"),
                                    i = "cells" !== r;
                                kt(a, s.styles), de(a, s.attributes), s.colGroups && Be(a, (e => {
                                    const t = fe.fromTag("colgroup");
                                    return E(e, (() => Be(t, fe.fromTag("col")))), t
                                })(t));
                                const l = Math.min(e, o);
                                if (i && o > 0) {
                                    const e = fe.fromTag("thead");
                                    Be(a, e);
                                    const s = Ml(o, t, "sectionCells" === r ? l : 0, n);
                                    Ie(e, s)
                                }
                                const c = fe.fromTag("tbody");
                                Be(a, c);
                                const d = Ml(i ? e - l : e, t, i ? 0 : o, n);
                                return Ie(c, d), a
                            })(o, t, s, n, Yi(e), i);
                            ce(r, "data-mce-id", "__mce");
                            const a = (e => {
                                const t = fe.fromTag("div"),
                                    o = fe.fromDom(e.dom.cloneNode(!0));
                                return Be(t, o), (e => e.dom.innerHTML)(t)
                            })(r);
                            e.insertContent(a), e.addVisual()
                        })), dt(Or(e), 'table[data-mce-id="__mce"]').map((t => (ol(e) ? Tl(t) : nl(e) ? El(t) : (tl(e) || (e => r(e) && -1 !== e.indexOf("%"))(a.width)) && Ol(t), Er(t), ge(t, "data-mce-id"), ((e, t) => {
                            M(st(t, "tr"), (t => {
                                Fi(e, t.dom), M(st(t, "th,td"), (t => {
                                    Vi(e, t.dom)
                                }))
                            }))
                        })(e, t), ((e, t) => {
                            dt(t, "td,th").each(v(Nl, e))
                        })(e, t), t.dom))).getOrNull()
                    };
                var Dl = tinymce.util.Tools.resolve("tinymce.FakeClipboard");
                const Bl = "x-tinymce/dom-table-",
                    Ll = Bl + "rows",
                    Hl = Bl + "columns",
                    Il = e => {
                        const t = Dl.FakeClipboardItem(e);
                        Dl.write([t])
                    },
                    Pl = e => {
                        var t;
                        const o = null !== (t = Dl.read()) && void 0 !== t ? t : [];
                        return j(o, (t => C.from(t.getType(e))))
                    },
                    zl = e => {
                        Pl(e).isSome() && Dl.clear()
                    },
                    Fl = e => {
                        e.fold(Zl, (e => Il({
                            [Ll]: e
                        })))
                    },
                    Vl = () => Pl(Ll),
                    Zl = () => zl(Ll),
                    Ul = e => {
                        e.fold(Wl, (e => Il({
                            [Hl]: e
                        })))
                    },
                    jl = () => Pl(Hl),
                    Wl = () => zl(Hl),
                    $l = e => gs(Ar(e), Tr(e)),
                    ql = (e, t) => {
                        const o = Tr(e),
                            n = e => Vt(e, o),
                            a = t => (e => hs(Ar(e), Tr(e)))(e).bind((e => n(e).map((o => t(o, e))))),
                            i = t => {
                                e.focus()
                            },
                            l = (t, o = !1) => a(((n, r) => {
                                const s = us(ps(e), n, r);
                                t(n, s, o).each(i)
                            })),
                            c = () => a(((t, o) => ((e, t, o) => {
                                const n = $o(e);
                                return aa(n, t).bind((e => {
                                    const t = ea(n, o, !1),
                                        r = Po(t).rows.slice(e[0].row, e[e.length - 1].row + e[e.length - 1].rowspan),
                                        s = P(r, (e => {
                                            const t = R(e.cells, (e => !e.isLocked));
                                            return t.length > 0 ? [{ ...e,
                                                cells: t
                                            }] : []
                                        })),
                                        a = ta(s);
                                    return ht(a.length > 0, a)
                                })).map((e => A(e, (e => {
                                    const t = Ze(e.element);
                                    return M(e.cells, (e => {
                                        const o = Ue(e.element);
                                        Ks(o, "colspan", e.colspan, 1), Ks(o, "rowspan", e.rowspan, 1), Be(t, o)
                                    })), t
                                }))))
                            })(t, us(ps(e), t, o), kr(g, fe.fromDom(e.getDoc()), C.none())))),
                            d = () => a(((t, o) => ((e, t) => {
                                const o = $o(e);
                                return ia(o, t).map((e => {
                                    const t = e[e.length - 1],
                                        n = e[0].column,
                                        r = t.column + t.colspan,
                                        s = ((e, t, o) => {
                                            if (Qo(e)) {
                                                const n = R(Jo(e), ul(t, o)),
                                                    r = A(n, (e => {
                                                        const n = Ue(e.element);
                                                        return dl(n, "span", o - t), n
                                                    })),
                                                    s = fe.fromTag("colgroup");
                                                return Ie(s, r), [s]
                                            }
                                            return []
                                        })(o, n, r),
                                        a = ((e, t, o) => A(e.all, (e => {
                                            const n = R(e.cells, ul(t, o)),
                                                r = A(n, (e => {
                                                    const n = Ue(e.element);
                                                    return dl(n, "colspan", o - t), n
                                                })),
                                                s = fe.fromTag("tr");
                                            return Ie(s, r), s
                                        })))(o, n, r);
                                    return [...s, ...a]
                                }))
                            })(t, us(ps(e), t, o)))),
                            u = (t, o) => o().each((o => {
                                const n = A(o, (e => Ue(e)));
                                a(((o, r) => {
                                    const s = _r(fe.fromDom(e.getDoc())),
                                        a = ((e, t, o, n) => ({
                                            selection: Qr(e),
                                            clipboard: o,
                                            generators: n
                                        }))(ps(e), 0, n, s);
                                    t(o, a).each(i)
                                }))
                            })),
                            h = e => (t, o) => ((e, t) => J(e, t) ? C.from(e[t]) : C.none())(o, "type").each((t => {
                                l(e(t), o.no_events)
                            }));
                        q({
                            mceTableSplitCells: () => l(t.unmergeCells),
                            mceTableMergeCells: () => l(t.mergeCells),
                            mceTableInsertRowBefore: () => l(t.insertRowsBefore),
                            mceTableInsertRowAfter: () => l(t.insertRowsAfter),
                            mceTableInsertColBefore: () => l(t.insertColumnsBefore),
                            mceTableInsertColAfter: () => l(t.insertColumnsAfter),
                            mceTableDeleteCol: () => l(t.deleteColumn),
                            mceTableDeleteRow: () => l(t.deleteRow),
                            mceTableCutCol: () => d().each((e => {
                                Ul(e), l(t.deleteColumn)
                            })),
                            mceTableCutRow: () => c().each((e => {
                                Fl(e), l(t.deleteRow)
                            })),
                            mceTableCopyCol: () => d().each((e => Ul(e))),
                            mceTableCopyRow: () => c().each((e => Fl(e))),
                            mceTablePasteColBefore: () => u(t.pasteColsBefore, jl),
                            mceTablePasteColAfter: () => u(t.pasteColsAfter, jl),
                            mceTablePasteRowBefore: () => u(t.pasteRowsBefore, Vl),
                            mceTablePasteRowAfter: () => u(t.pasteRowsAfter, Vl),
                            mceTableDelete: () => $l(e).each((t => {
                                Vt(t, o).filter(b(o)).each((t => {
                                    const o = fe.fromText("");
                                    if (Re(t, o), ze(t), e.dom.isEmpty(e.getBody())) e.setContent(""), e.selection.setCursorLocation();
                                    else {
                                        const t = e.dom.createRng();
                                        t.setStart(o.dom, 0), t.setEnd(o.dom, 0), e.selection.setRng(t), e.nodeChanged()
                                    }
                                }))
                            })),
                            mceTableCellToggleClass: (t, o) => {
                                a((t => {
                                    const n = ps(e),
                                        r = z(n, (t => e.formatter.match("tablecellclass", {
                                            value: o
                                        }, t.dom))),
                                        s = r ? e.formatter.remove : e.formatter.apply;
                                    M(n, (e => s("tablecellclass", {
                                        value: o
                                    }, e.dom))), Zi(e, t.dom, Ui)
                                }))
                            },
                            mceTableToggleClass: (t, o) => {
                                a((t => {
                                    e.formatter.toggle("tableclass", {
                                        value: o
                                    }, t.dom), Zi(e, t.dom, Ui)
                                }))
                            },
                            mceTableToggleCaption: () => {
                                $l(e).each((t => {
                                    Vt(t, o).each((o => {
                                        ct(o, "caption").fold((() => {
                                            const t = fe.fromTag("caption");
                                            Be(t, fe.fromText("Caption")), ((e, t, o) => {
                                                Me(e, 0).fold((() => {
                                                    Be(e, t)
                                                }), (e => {
                                                    Ne(e, t)
                                                }))
                                            })(o, t), e.selection.setCursorLocation(t.dom, 0)
                                        }), (n => {
                                            ie("caption")(t) && ye("td", o).each((t => e.selection.setCursorLocation(t.dom, 0))), ze(n)
                                        })), Zi(e, o.dom, ji)
                                    }))
                                }))
                            },
                            mceTableSizingMode: (t, n) => (t => $l(e).each((n => {
                                nl(e) || ol(e) || tl(e) || Vt(n, o).each((o => {
                                    "relative" !== t || Cl(o) ? "fixed" !== t || Sl(o) ? "responsive" !== t || kl(o) || El(o) : Tl(o) : Ol(o), Er(o), Zi(e, o.dom, ji)
                                }))
                            })))(n),
                            mceTableCellType: h((e => "th" === e ? t.makeCellsHeader : t.unmakeCellsHeader)),
                            mceTableColType: h((e => "th" === e ? t.makeColumnsHeader : t.unmakeColumnsHeader)),
                            mceTableRowType: h((e => {
                                switch (e) {
                                    case "header":
                                        return t.makeRowsHeader;
                                    case "footer":
                                        return t.makeRowsFooter;
                                    default:
                                        return t.makeRowsBody
                                }
                            }))
                        }, ((t, o) => e.addCommand(o, t))), e.addCommand("mceInsertTable", ((t, o) => {
                            ((e, t, o, n = {}) => {
                                const r = e => m(e) && e > 0;
                                if (r(t) && r(o)) {
                                    const r = n.headerRows || 0,
                                        s = n.headerColumns || 0;
                                    return Rl(e, o, t, s, r)
                                }
                                console.error("Invalid values for mceInsertTable - rows and columns values are required to insert a table.")
                            })(e, o.rows, o.columns, o.options)
                        })), e.addCommand("mceTableApplyCellStyle", ((t, o) => {
                            const a = e => "tablecell" + e.toLowerCase().replace("-", "");
                            if (!s(o)) return;
                            const i = ps(e);
                            if (0 === i.length) return;
                            const l = ((e, t) => {
                                const o = {};
                                return ((e, t, o, n) => {
                                    q(e, ((e, r) => {
                                        (t(e, r) ? o : n)(e, r)
                                    }))
                                })(e, t, (e => (t, o) => {
                                    e[o] = t
                                })(o), g), o
                            })(o, ((t, o) => e.formatter.has(a(o)) && r(t)));
                            (e => {
                                for (const t in e)
                                    if ($.call(e, t)) return !1;
                                return !0
                            })(l) || (q(l, ((t, o) => {
                                const n = a(o);
                                M(i, (o => {
                                    "" === t ? e.formatter.remove(n, {
                                        value: null
                                    }, o.dom, !0) : e.formatter.apply(n, {
                                        value: t
                                    }, o.dom)
                                }))
                            })), n(i[0]).each((t => Zi(e, t.dom, Ui))))
                        }))
                    },
                    Gl = Ra([{
                        before: ["element"]
                    }, {
                        on: ["element", "offset"]
                    }, {
                        after: ["element"]
                    }]),
                    Kl = {
                        before: Gl.before,
                        on: Gl.on,
                        after: Gl.after,
                        cata: (e, t, o, n) => e.fold(t, o, n),
                        getStart: e => e.fold(p, p, p)
                    },
                    Yl = (e, t) => ({
                        selection: e,
                        kill: t
                    }),
                    Xl = (e, t) => {
                        const o = e.document.createRange();
                        return o.selectNode(t.dom), o
                    },
                    Jl = (e, t) => {
                        const o = e.document.createRange();
                        return Ql(o, t), o
                    },
                    Ql = (e, t) => e.selectNodeContents(t.dom),
                    ec = (e, t, o) => {
                        const n = e.document.createRange();
                        var r;
                        return r = n, t.fold((e => {
                            r.setStartBefore(e.dom)
                        }), ((e, t) => {
                            r.setStart(e.dom, t)
                        }), (e => {
                            r.setStartAfter(e.dom)
                        })), ((e, t) => {
                            t.fold((t => {
                                e.setEndBefore(t.dom)
                            }), ((t, o) => {
                                e.setEnd(t.dom, o)
                            }), (t => {
                                e.setEndAfter(t.dom)
                            }))
                        })(n, o), n
                    },
                    tc = (e, t, o, n, r) => {
                        const s = e.document.createRange();
                        return s.setStart(t.dom, o), s.setEnd(n.dom, r), s
                    },
                    oc = e => ({
                        left: e.left,
                        top: e.top,
                        right: e.right,
                        bottom: e.bottom,
                        width: e.width,
                        height: e.height
                    }),
                    nc = Ra([{
                        ltr: ["start", "soffset", "finish", "foffset"]
                    }, {
                        rtl: ["start", "soffset", "finish", "foffset"]
                    }]),
                    rc = (e, t, o) => t(fe.fromDom(o.startContainer), o.startOffset, fe.fromDom(o.endContainer), o.endOffset),
                    sc = (e, t) => {
                        const o = ((e, t) => t.match({
                            domRange: e => ({
                                ltr: h(e),
                                rtl: C.none
                            }),
                            relative: (t, o) => ({
                                ltr: qt((() => ec(e, t, o))),
                                rtl: qt((() => C.some(ec(e, o, t))))
                            }),
                            exact: (t, o, n, r) => ({
                                ltr: qt((() => tc(e, t, o, n, r))),
                                rtl: qt((() => C.some(tc(e, n, r, t, o))))
                            })
                        }))(e, t);
                        return ((e, t) => {
                            const o = t.ltr();
                            return o.collapsed ? t.rtl().filter((e => !1 === e.collapsed)).map((e => nc.rtl(fe.fromDom(e.endContainer), e.endOffset, fe.fromDom(e.startContainer), e.startOffset))).getOrThunk((() => rc(0, nc.ltr, o))) : rc(0, nc.ltr, o)
                        })(0, o)
                    },
                    ac = (e, t) => sc(e, t).match({
                        ltr: (t, o, n, r) => {
                            const s = e.document.createRange();
                            return s.setStart(t.dom, o), s.setEnd(n.dom, r), s
                        },
                        rtl: (t, o, n, r) => {
                            const s = e.document.createRange();
                            return s.setStart(n.dom, r), s.setEnd(t.dom, o), s
                        }
                    });
                nc.ltr, nc.rtl;
                const ic = (e, t, o, n) => ({
                        start: e,
                        soffset: t,
                        finish: o,
                        foffset: n
                    }),
                    lc = (e, t, o, n) => ({
                        start: Kl.on(e, t),
                        finish: Kl.on(o, n)
                    }),
                    cc = (e, t) => {
                        const o = ac(e, t);
                        return ic(fe.fromDom(o.startContainer), o.startOffset, fe.fromDom(o.endContainer), o.endOffset)
                    },
                    dc = lc,
                    uc = (e, t, o, n, r) => we(o, n) ? C.none() : qr(o, n, t).bind((t => {
                        const n = t.boxes.getOr([]);
                        return n.length > 1 ? (r(e, n, t.start, t.finish), C.some(Yl(C.some(dc(o, 0, o, ur(o))), !0))) : C.none()
                    })),
                    mc = (e, t) => ({
                        item: e,
                        mode: t
                    }),
                    gc = (e, t, o, n = hc) => e.property().parent(t).map((e => mc(e, n))),
                    hc = (e, t, o, n = pc) => o.sibling(e, t).map((e => mc(e, n))),
                    pc = (e, t, o, n = pc) => {
                        const r = e.property().children(t);
                        return o.first(r).map((e => mc(e, n)))
                    },
                    fc = [{
                        current: gc,
                        next: hc,
                        fallback: C.none()
                    }, {
                        current: hc,
                        next: pc,
                        fallback: C.some(gc)
                    }, {
                        current: pc,
                        next: pc,
                        fallback: C.some(hc)
                    }],
                    vc = (e, t, o, n, r = fc) => L(r, (e => e.current === o)).bind((o => o.current(e, t, n, o.next).orThunk((() => o.fallback.bind((o => vc(e, t, o, n))))))),
                    bc = (e, t, o, n, r, s) => vc(e, t, n, r).bind((t => s(t.item) ? C.none() : o(t.item) ? C.some(t.item) : bc(e, t.item, o, t.mode, r, s))),
                    yc = e => t => 0 === e.property().children(t).length,
                    wc = (e, t, o, n) => bc(e, t, o, hc, {
                        sibling: (e, t) => e.query().prevSibling(t),
                        first: e => e.length > 0 ? C.some(e[e.length - 1]) : C.none()
                    }, n),
                    xc = (e, t, o, n) => bc(e, t, o, hc, {
                        sibling: (e, t) => e.query().nextSibling(t),
                        first: e => e.length > 0 ? C.some(e[0]) : C.none()
                    }, n),
                    Cc = Vr(),
                    Sc = (e, t) => ((e, t, o) => wc(e, t, yc(e), o))(Cc, e, t),
                    kc = (e, t) => ((e, t, o) => xc(e, t, yc(e), o))(Cc, e, t),
                    _c = Ra([{
                        none: ["message"]
                    }, {
                        success: []
                    }, {
                        failedUp: ["cell"]
                    }, {
                        failedDown: ["cell"]
                    }]),
                    Oc = e => ut(e, "tr"),
                    Tc = { ..._c,
                        verify: (e, t, o, n, r, s, a) => ut(n, "td,th", a).bind((o => ut(t, "td,th", a).map((t => we(o, t) ? we(n, o) && ur(o) === r ? s(t) : _c.none("in same cell") : Wr(Oc, [o, t]).fold((() => ((e, t, o) => {
                            const n = e.getRect(t),
                                r = e.getRect(o);
                            return r.right > n.left && r.left < n.right
                        })(e, t, o) ? _c.success() : s(t)), (e => s(t))))))).getOr(_c.none("default")),
                        cata: (e, t, o, n, r) => e.fold(t, o, n, r)
                    },
                    Ec = ie("br"),
                    Ac = (e, t, o) => t(e, o).bind((e => re(e) && 0 === lr(e).trim().length ? Ac(e, t, o) : C.some(e))),
                    Mc = (e, t, o, n) => ((e, t) => Me(e, t).filter(Ec).orThunk((() => Me(e, t - 1).filter(Ec))))(t, o).bind((t => n.traverse(t).fold((() => Ac(t, n.gather, e).map(n.relative)), (e => (e => _e(e).bind((t => {
                        const o = Ae(t);
                        return ((e, t) => H(e, v(we, t)))(o, e).map((n => ((e, t, o, n) => ({
                            parent: e,
                            children: t,
                            element: o,
                            index: n
                        }))(t, o, e, n)))
                    })))(e).map((e => Kl.on(e.parent, e.index))))))),
                    Nc = (e, t) => ({
                        left: e.left,
                        top: e.top + t,
                        right: e.right,
                        bottom: e.bottom + t
                    }),
                    Rc = (e, t) => ({
                        left: e.left,
                        top: e.top - t,
                        right: e.right,
                        bottom: e.bottom - t
                    }),
                    Dc = (e, t, o) => ({
                        left: e.left + t,
                        top: e.top + o,
                        right: e.right + t,
                        bottom: e.bottom + o
                    }),
                    Bc = e => ({
                        left: e.left,
                        top: e.top,
                        right: e.right,
                        bottom: e.bottom
                    }),
                    Lc = (e, t) => C.some(e.getRect(t)),
                    Hc = (e, t, o) => ne(t) ? Lc(e, t).map(Bc) : re(t) ? ((e, t, o) => o >= 0 && o < ur(t) ? e.getRangedRect(t, o, t, o + 1) : o > 0 ? e.getRangedRect(t, o - 1, t, o) : C.none())(e, t, o).map(Bc) : C.none(),
                    Ic = (e, t) => ne(t) ? Lc(e, t).map(Bc) : re(t) ? e.getRangedRect(t, 0, t, ur(t)).map(Bc) : C.none(),
                    Pc = Ra([{
                        none: []
                    }, {
                        retry: ["caret"]
                    }]),
                    zc = (e, t, o) => {
                        return (n = t, r = Ka, at(((e, t) => t(e)), it, n, r, undefined)).fold(w, (t => Ic(e, t).exists((e => ((e, t) => e.left < t.left || Math.abs(t.right - e.left) < 1 || e.left > t.right)(o, e)))));
                        var n, r
                    },
                    Fc = {
                        point: e => e.bottom,
                        adjuster: (e, t, o, n, r) => {
                            const s = Nc(r, 5);
                            return Math.abs(o.bottom - n.bottom) < 1 || o.top > r.bottom ? Pc.retry(s) : o.top === r.bottom ? Pc.retry(Nc(r, 1)) : zc(e, t, r) ? Pc.retry(Dc(s, 5, 0)) : Pc.none()
                        },
                        move: Nc,
                        gather: kc
                    },
                    Vc = (e, t, o, n, r) => 0 === r ? C.some(n) : ((e, t, o) => e.elementFromPoint(t, o).filter((e => "table" === Q(e))).isSome())(e, n.left, t.point(n)) ? ((e, t, o, n, r) => Vc(e, t, o, t.move(n, 5), r))(e, t, o, n, r - 1) : e.situsFromPoint(n.left, t.point(n)).bind((s => s.start.fold(C.none, (s => Ic(e, s).bind((a => t.adjuster(e, s, a, o, n).fold(C.none, (n => Vc(e, t, o, n, r - 1))))).orThunk((() => C.some(n)))), C.none))),
                    Zc = (e, t, o) => {
                        const n = e.move(o, 5),
                            r = Vc(t, e, o, n, 100).getOr(n);
                        return ((e, t, o) => e.point(t) > o.getInnerHeight() ? C.some(e.point(t) - o.getInnerHeight()) : e.point(t) < 0 ? C.some(-e.point(t)) : C.none())(e, r, t).fold((() => t.situsFromPoint(r.left, e.point(r))), (o => (t.scrollBy(0, o), t.situsFromPoint(r.left, e.point(r) - o))))
                    },
                    Uc = {
                        tryUp: v(Zc, {
                            point: e => e.top,
                            adjuster: (e, t, o, n, r) => {
                                const s = Rc(r, 5);
                                return Math.abs(o.top - n.top) < 1 || o.bottom < r.top ? Pc.retry(s) : o.bottom === r.top ? Pc.retry(Rc(r, 1)) : zc(e, t, r) ? Pc.retry(Dc(s, 5, 0)) : Pc.none()
                            },
                            move: Rc,
                            gather: Sc
                        }),
                        tryDown: v(Zc, Fc),
                        getJumpSize: h(5)
                    },
                    jc = (e, t, o) => e.getSelection().bind((n => ((e, t, o, n) => {
                        const r = Ec(t) ? ((e, t, o) => o.traverse(t).orThunk((() => Ac(t, o.gather, e))).map(o.relative))(e, t, n) : Mc(e, t, o, n);
                        return r.map((e => ({
                            start: e,
                            finish: e
                        })))
                    })(t, n.finish, n.foffset, o).fold((() => C.some(vs(n.finish, n.foffset))), (r => {
                        const s = e.fromSitus(r);
                        return a = Tc.verify(e, n.finish, n.foffset, s.finish, s.foffset, o.failure, t), Tc.cata(a, (e => C.none()), (() => C.none()), (e => C.some(vs(e, 0))), (e => C.some(vs(e, ur(e)))));
                        var a
                    })))),
                    Wc = (e, t, o, n, r, s) => 0 === s ? C.none() : Gc(e, t, o, n, r).bind((a => {
                        const i = e.fromSitus(a),
                            l = Tc.verify(e, o, n, i.finish, i.foffset, r.failure, t);
                        return Tc.cata(l, (() => C.none()), (() => C.some(a)), (a => we(o, a) && 0 === n ? $c(e, o, n, Rc, r) : Wc(e, t, a, 0, r, s - 1)), (a => we(o, a) && n === ur(a) ? $c(e, o, n, Nc, r) : Wc(e, t, a, ur(a), r, s - 1)))
                    })),
                    $c = (e, t, o, n, r) => Hc(e, t, o).bind((t => qc(e, r, n(t, Uc.getJumpSize())))),
                    qc = (e, t, o) => {
                        const n = ko().browser;
                        return n.isChromium() || n.isSafari() || n.isFirefox() ? t.retry(e, o) : C.none()
                    },
                    Gc = (e, t, o, n, r) => Hc(e, o, n).bind((t => qc(e, r, t))),
                    Kc = (e, t, o, n, r) => ut(n, "td,th", t).bind((n => ut(n, "table", t).bind((s => ((e, t) => it(e, (e => _e(e).exists((e => we(e, t)))), void 0).isSome())(r, s) ? ((e, t, o) => jc(e, t, o).bind((n => Wc(e, t, n.element, n.offset, o, 20).map(e.fromSitus))))(e, t, o).bind((e => ut(e.finish, "td,th", t).map((t => ({
                        start: n,
                        finish: t,
                        range: e
                    }))))) : C.none())))),
                    Yc = (e, t, o, n, r, s) => s(n, t).orThunk((() => Kc(e, t, o, n, r).map((e => {
                        const t = e.range;
                        return Yl(C.some(dc(t.start, t.soffset, t.finish, t.foffset)), !0)
                    })))),
                    Xc = (e, t) => ut(e, "tr", t).bind((e => ut(e, "table", t).bind((o => {
                        const n = st(o, "tr");
                        return we(e, n[0]) ? ((e, t, o) => wc(Cc, e, (e => pr(e).isSome()), o))(o, 0, t).map((e => {
                            const t = ur(e);
                            return Yl(C.some(dc(e, t, e, t)), !0)
                        })) : C.none()
                    })))),
                    Jc = (e, t) => ut(e, "tr", t).bind((e => ut(e, "table", t).bind((o => {
                        const n = st(o, "tr");
                        return we(e, n[n.length - 1]) ? ((e, t, o) => xc(Cc, e, (e => hr(e).isSome()), o))(o, 0, t).map((e => Yl(C.some(dc(e, 0, e, 0)), !0))) : C.none()
                    })))),
                    Qc = (e, t, o, n, r, s, a) => Kc(e, o, n, r, s).bind((e => uc(t, o, e.start, e.finish, a))),
                    ed = e => {
                        let t = e;
                        return {
                            get: () => t,
                            set: e => {
                                t = e
                            }
                        }
                    },
                    td = () => {
                        const e = (e => {
                            const t = ed(C.none()),
                                o = () => t.get().each(e);
                            return {
                                clear: () => {
                                    o(), t.set(C.none())
                                },
                                isSet: () => t.get().isSome(),
                                get: () => t.get(),
                                set: e => {
                                    o(), t.set(C.some(e))
                                }
                            }
                        })(g);
                        return { ...e,
                            on: t => e.get().each(t)
                        }
                    },
                    od = (e, t) => ut(e, "td,th", t),
                    nd = {
                        traverse: Ee,
                        gather: kc,
                        relative: Kl.before,
                        retry: Uc.tryDown,
                        failure: Tc.failedDown
                    },
                    rd = {
                        traverse: Te,
                        gather: Sc,
                        relative: Kl.before,
                        retry: Uc.tryUp,
                        failure: Tc.failedUp
                    },
                    sd = e => t => t === e,
                    ad = sd(38),
                    id = sd(40),
                    ld = e => e >= 37 && e <= 40,
                    cd = {
                        isBackward: sd(37),
                        isForward: sd(39)
                    },
                    dd = {
                        isBackward: sd(39),
                        isForward: sd(37)
                    },
                    ud = Ra([{
                        domRange: ["rng"]
                    }, {
                        relative: ["startSitu", "finishSitu"]
                    }, {
                        exact: ["start", "soffset", "finish", "foffset"]
                    }]),
                    md = {
                        domRange: ud.domRange,
                        relative: ud.relative,
                        exact: ud.exact,
                        exactFromRange: e => ud.exact(e.start, e.soffset, e.finish, e.foffset),
                        getWin: e => {
                            const t = (e => e.match({
                                domRange: e => fe.fromDom(e.startContainer),
                                relative: (e, t) => Kl.getStart(e),
                                exact: (e, t, o, n) => e
                            }))(e);
                            return fe.fromDom(ke(t).dom.defaultView)
                        },
                        range: ic
                    },
                    gd = document.caretPositionFromPoint ? (e, t, o) => {
                        var n, r;
                        return C.from(null === (r = (n = e.dom).caretPositionFromPoint) || void 0 === r ? void 0 : r.call(n, t, o)).bind((t => {
                            if (null === t.offsetNode) return C.none();
                            const o = e.dom.createRange();
                            return o.setStart(t.offsetNode, t.offset), o.collapse(), C.some(o)
                        }))
                    } : document.caretRangeFromPoint ? (e, t, o) => {
                        var n, r;
                        return C.from(null === (r = (n = e.dom).caretRangeFromPoint) || void 0 === r ? void 0 : r.call(n, t, o))
                    } : C.none,
                    hd = (e, t) => {
                        const o = Q(e);
                        return "input" === o ? Kl.after(e) : O(["br", "img"], o) ? 0 === t ? Kl.before(e) : Kl.after(e) : Kl.on(e, t)
                    },
                    pd = e => C.from(e.getSelection()),
                    fd = (e, t) => {
                        pd(e).each((e => {
                            e.removeAllRanges(), e.addRange(t)
                        }))
                    },
                    vd = (e, t, o, n, r) => {
                        const s = tc(e, t, o, n, r);
                        fd(e, s)
                    },
                    bd = (e, t) => sc(e, t).match({
                        ltr: (t, o, n, r) => {
                            vd(e, t, o, n, r)
                        },
                        rtl: (t, o, n, r) => {
                            pd(e).each((s => {
                                if (s.setBaseAndExtent) s.setBaseAndExtent(t.dom, o, n.dom, r);
                                else if (s.extend) try {
                                    ((e, t, o, n, r, s) => {
                                        t.collapse(o.dom, n), t.extend(r.dom, s)
                                    })(0, s, t, o, n, r)
                                } catch (s) {
                                    vd(e, n, r, t, o)
                                } else vd(e, n, r, t, o)
                            }))
                        }
                    }),
                    yd = (e, t, o, n, r) => {
                        const s = ((e, t, o, n) => {
                            const r = hd(e, t),
                                s = hd(o, n);
                            return md.relative(r, s)
                        })(t, o, n, r);
                        bd(e, s)
                    },
                    wd = (e, t, o) => {
                        const n = ((e, t) => {
                            const o = e.fold(Kl.before, hd, Kl.after),
                                n = t.fold(Kl.before, hd, Kl.after);
                            return md.relative(o, n)
                        })(t, o);
                        bd(e, n)
                    },
                    xd = e => {
                        if (e.rangeCount > 0) {
                            const t = e.getRangeAt(0),
                                o = e.getRangeAt(e.rangeCount - 1);
                            return C.some(ic(fe.fromDom(t.startContainer), t.startOffset, fe.fromDom(o.endContainer), o.endOffset))
                        }
                        return C.none()
                    },
                    Cd = e => {
                        if (null === e.anchorNode || null === e.focusNode) return xd(e); {
                            const t = fe.fromDom(e.anchorNode),
                                o = fe.fromDom(e.focusNode);
                            return ((e, t, o, n) => {
                                const r = ((e, t, o, n) => {
                                        const r = Se(e).dom.createRange();
                                        return r.setStart(e.dom, t), r.setEnd(o.dom, n), r
                                    })(e, t, o, n),
                                    s = we(e, o) && t === n;
                                return r.collapsed && !s
                            })(t, e.anchorOffset, o, e.focusOffset) ? C.some(ic(t, e.anchorOffset, o, e.focusOffset)) : xd(e)
                        }
                    },
                    Sd = (e, t, o = !0) => {
                        const n = (o ? Jl : Xl)(e, t);
                        fd(e, n)
                    },
                    kd = e => (e => pd(e).filter((e => e.rangeCount > 0)).bind(Cd))(e).map((e => md.exact(e.start, e.soffset, e.finish, e.foffset))),
                    _d = e => ({
                        elementFromPoint: (t, o) => fe.fromPoint(fe.fromDom(e.document), t, o),
                        getRect: e => e.dom.getBoundingClientRect(),
                        getRangedRect: (t, o, n, r) => {
                            const s = md.exact(t, o, n, r);
                            return ((e, t) => (e => {
                                const t = e.getClientRects(),
                                    o = t.length > 0 ? t[0] : e.getBoundingClientRect();
                                return o.width > 0 || o.height > 0 ? C.some(o).map(oc) : C.none()
                            })(ac(e, t)))(e, s)
                        },
                        getSelection: () => kd(e).map((t => cc(e, t))),
                        fromSitus: t => {
                            const o = md.relative(t.start, t.finish);
                            return cc(e, o)
                        },
                        situsFromPoint: (t, o) => ((e, t, o) => ((e, t, o) => {
                            const n = fe.fromDom(e.document);
                            return gd(n, t, o).map((e => ic(fe.fromDom(e.startContainer), e.startOffset, fe.fromDom(e.endContainer), e.endOffset)))
                        })(e, t, o))(e, t, o).map((e => lc(e.start, e.soffset, e.finish, e.foffset))),
                        clearSelection: () => {
                            (e => {
                                pd(e).each((e => e.removeAllRanges()))
                            })(e)
                        },
                        collapseSelection: (t = !1) => {
                            kd(e).each((o => o.fold((e => e.collapse(t)), ((o, n) => {
                                const r = t ? o : n;
                                wd(e, r, r)
                            }), ((o, n, r, s) => {
                                const a = t ? o : r,
                                    i = t ? n : s;
                                yd(e, a, i, a, i)
                            }))))
                        },
                        setSelection: t => {
                            yd(e, t.start, t.soffset, t.finish, t.foffset)
                        },
                        setRelativeSelection: (t, o) => {
                            wd(e, t, o)
                        },
                        selectNode: t => {
                            Sd(e, t, !1)
                        },
                        selectContents: t => {
                            Sd(e, t)
                        },
                        getInnerHeight: () => e.innerHeight,
                        getScrollY: () => (e => {
                            const t = void 0 !== e ? e.dom : document,
                                o = t.body.scrollLeft || t.documentElement.scrollLeft,
                                n = t.body.scrollTop || t.documentElement.scrollTop;
                            return un(o, n)
                        })(fe.fromDom(e.document)).top,
                        scrollBy: (t, o) => {
                            ((e, t, o) => {
                                const n = (void 0 !== o ? o.dom : document).defaultView;
                                n && n.scrollBy(e, t)
                            })(t, o, fe.fromDom(e.document))
                        }
                    }),
                    Od = (e, t) => ({
                        rows: e,
                        cols: t
                    }),
                    Td = e => void 0 !== e.dom.classList,
                    Ed = (e, t) => ((e, t, o) => {
                        const n = ((e, t) => {
                            const o = ue(e, t);
                            return void 0 === o || "" === o ? [] : o.split(" ")
                        })(e, t).concat([o]);
                        return ce(e, t, n.join(" ")), !0
                    })(e, "class", t),
                    Ad = (e, t) => {
                        Td(e) ? e.dom.classList.add(t) : Ed(e, t)
                    },
                    Md = (e, t) => Td(e) && e.dom.classList.contains(t),
                    Nd = () => ({
                        tag: "none"
                    }),
                    Rd = e => ({
                        tag: "multiple",
                        elements: e
                    }),
                    Dd = e => ({
                        tag: "single",
                        element: e
                    }),
                    Bd = e => {
                        const t = fe.fromDom((e => {
                                if (Xe() && d(e.target)) {
                                    const t = fe.fromDom(e.target);
                                    if (ne(t) && d(t.dom.shadowRoot) && e.composed && e.composedPath) {
                                        const t = e.composedPath();
                                        if (t) return Z(t)
                                    }
                                }
                                return C.from(e.target)
                            })(e).getOr(e.target)),
                            o = () => e.stopPropagation(),
                            n = () => e.preventDefault(),
                            r = (s = n, a = o, (...e) => s(a.apply(null, e)));
                        var s, a;
                        return ((e, t, o, n, r, s, a) => ({
                            target: e,
                            x: t,
                            y: o,
                            stop: n,
                            prevent: r,
                            kill: s,
                            raw: a
                        }))(t, e.clientX, e.clientY, o, n, r, e)
                    },
                    Ld = (e, t, o, n) => {
                        e.dom.removeEventListener(t, o, n)
                    },
                    Hd = x,
                    Id = (e, t, o) => ((e, t, o, n) => ((e, t, o, n, r) => {
                        const s = ((e, t) => o => {
                            e(o) && t(Bd(o))
                        })(o, n);
                        return e.dom.addEventListener(t, s, r), {
                            unbind: v(Ld, e, t, s, r)
                        }
                    })(e, t, o, n, !1))(e, t, Hd, o),
                    Pd = Bd,
                    zd = e => !Md(fe.fromDom(e.target), "ephox-snooker-resizer-bar"),
                    Fd = (e, t) => {
                        const o = (r = ds.selectedSelector, {
                                get: () => Xr(fe.fromDom(e.getBody()), r).fold((() => hs(Ar(e), Tr(e)).fold(Nd, Dd)), Rd)
                            }),
                            n = ((e, t, o) => {
                                const n = t => {
                                        ge(t, e.selected), ge(t, e.firstSelected), ge(t, e.lastSelected)
                                    },
                                    r = t => {
                                        ce(t, e.selected, "1")
                                    },
                                    s = e => {
                                        a(e), o()
                                    },
                                    a = t => {
                                        const o = st(t, `${e.selectedSelector},${e.firstSelectedSelector},${e.lastSelectedSelector}`);
                                        M(o, n)
                                    };
                                return {
                                    clearBeforeUpdate: a,
                                    clear: s,
                                    selectRange: (o, n, a, i) => {
                                        s(o), M(n, r), ce(a, e.firstSelected, "1"), ce(i, e.lastSelected, "1"), t(n, a, i)
                                    },
                                    selectedSelector: e.selectedSelector,
                                    firstSelectedSelector: e.firstSelectedSelector,
                                    lastSelectedSelector: e.lastSelectedSelector
                                }
                            })(ds, ((t, o, n) => {
                                Vt(o).each((r => {
                                    const s = Ki(e),
                                        a = kr(g, fe.fromDom(e.getDoc()), s),
                                        i = ((e, t, o) => {
                                            const n = $o(e);
                                            return aa(n, t).map((e => {
                                                const t = ea(n, o, !1),
                                                    {
                                                        rows: r
                                                    } = Po(t),
                                                    s = ((e, t) => {
                                                        const o = e.slice(0, t[t.length - 1].row + 1),
                                                            n = ta(o);
                                                        return P(n, (e => {
                                                            const o = e.cells.slice(0, t[t.length - 1].column + 1);
                                                            return A(o, (e => e.element))
                                                        }))
                                                    })(r, e),
                                                    a = ((e, t) => {
                                                        const o = e.slice(t[0].row + t[0].rowspan - 1, e.length),
                                                            n = ta(o);
                                                        return P(n, (e => {
                                                            const o = e.cells.slice(t[0].column + t[0].colspan - 1, e.cells.length);
                                                            return A(o, (e => e.element))
                                                        }))
                                                    })(r, e);
                                                return {
                                                    upOrLeftCells: s,
                                                    downOrRightCells: a
                                                }
                                            }))
                                        })(r, {
                                            selection: ps(e)
                                        }, a);
                                    ((e, t, o, n, r) => {
                                        e.dispatch("TableSelectionChange", {
                                            cells: t,
                                            start: o,
                                            finish: n,
                                            otherCells: r
                                        })
                                    })(e, t, o, n, i)
                                }))
                            }), (() => (e => {
                                e.dispatch("TableSelectionClear")
                            })(e)));
                        var r;
                        return e.on("init", (o => {
                            const r = e.getWin(),
                                s = Or(e),
                                a = Tr(e),
                                i = ((e, t, o, n) => {
                                    const r = ((e, t, o, n) => {
                                        const r = td(),
                                            s = r.clear,
                                            a = s => {
                                                r.on((r => {
                                                    n.clearBeforeUpdate(t), od(s.target, o).each((a => {
                                                        qr(r, a, o).each((o => {
                                                            const r = o.boxes.getOr([]);
                                                            if (1 === r.length) {
                                                                const o = r[0],
                                                                    a = "false" === Gs(o),
                                                                    i = mt($s(s.target), o, we);
                                                                a && i && (n.selectRange(t, r, o, o), e.selectContents(o))
                                                            } else r.length > 1 && (n.selectRange(t, r, o.start, o.finish), e.selectContents(a))
                                                        }))
                                                    }))
                                                }))
                                            };
                                        return {
                                            clearstate: s,
                                            mousedown: e => {
                                                n.clear(t), od(e.target, o).each(r.set)
                                            },
                                            mouseover: e => {
                                                a(e)
                                            },
                                            mouseup: e => {
                                                a(e), s()
                                            }
                                        }
                                    })(_d(e), t, o, n);
                                    return {
                                        clearstate: r.clearstate,
                                        mousedown: r.mousedown,
                                        mouseover: r.mouseover,
                                        mouseup: r.mouseup
                                    }
                                })(r, s, a, n),
                                l = ((e, t, o, n) => {
                                    const r = _d(e),
                                        s = () => (n.clear(t), C.none());
                                    return {
                                        keydown: (e, a, i, l, c, d) => {
                                            const u = e.raw,
                                                m = u.which,
                                                g = !0 === u.shiftKey,
                                                h = Gr(t, n.selectedSelector).fold((() => (ld(m) && !g && n.clearBeforeUpdate(t), id(m) && g ? v(Qc, r, t, o, nd, l, a, n.selectRange) : ad(m) && g ? v(Qc, r, t, o, rd, l, a, n.selectRange) : id(m) ? v(Yc, r, o, nd, l, a, Jc) : ad(m) ? v(Yc, r, o, rd, l, a, Xc) : C.none)), (e => {
                                                    const o = o => () => {
                                                        const s = j(o, (o => ((e, t, o, n, r) => Yr(n, e, t, r.firstSelectedSelector, r.lastSelectedSelector).map((e => (r.clearBeforeUpdate(o), r.selectRange(o, e.boxes, e.start, e.finish), e.boxes))))(o.rows, o.cols, t, e, n)));
                                                        return s.fold((() => Kr(t, n.firstSelectedSelector, n.lastSelectedSelector).map((e => {
                                                            const o = id(m) || d.isForward(m) ? Kl.after : Kl.before;
                                                            return r.setRelativeSelection(Kl.on(e.first, 0), o(e.table)), n.clear(t), Yl(C.none(), !0)
                                                        }))), (e => C.some(Yl(C.none(), !0))))
                                                    };
                                                    return id(m) && g ? o([Od(1, 0)]) : ad(m) && g ? o([Od(-1, 0)]) : d.isBackward(m) && g ? o([Od(0, -1), Od(-1, 0)]) : d.isForward(m) && g ? o([Od(0, 1), Od(1, 0)]) : ld(m) && !g ? s : C.none
                                                }));
                                            return h()
                                        },
                                        keyup: (e, r, s, a, i) => Gr(t, n.selectedSelector).fold((() => {
                                            const l = e.raw,
                                                c = l.which;
                                            return !0 === l.shiftKey && ld(c) ? ((e, t, o, n, r, s, a) => we(o, r) && n === s ? C.none() : ut(o, "td,th", t).bind((o => ut(r, "td,th", t).bind((n => uc(e, t, o, n, a))))))(t, o, r, s, a, i, n.selectRange) : C.none()
                                        }), C.none)
                                    }
                                })(r, s, a, n),
                                c = ((e, t, o, n) => {
                                    const r = _d(e);
                                    return (e, s) => {
                                        n.clearBeforeUpdate(t), qr(e, s, o).each((e => {
                                            const o = e.boxes.getOr([]);
                                            n.selectRange(t, o, e.start, e.finish), r.selectContents(s), r.collapseSelection()
                                        }))
                                    }
                                })(r, s, a, n);
                            e.on("TableSelectorChange", (e => c(e.start, e.finish)));
                            const d = (t, o) => {
                                    (e => !0 === e.raw.shiftKey)(t) && (o.kill && t.kill(), o.selection.each((t => {
                                        const o = md.relative(t.start, t.finish),
                                            n = ac(r, o);
                                        e.selection.setRng(n)
                                    })))
                                },
                                u = e => 0 === e.button,
                                m = (() => {
                                    const e = ed(fe.fromDom(s)),
                                        t = ed(0);
                                    return {
                                        touchEnd: o => {
                                            const n = fe.fromDom(o.target);
                                            if (ie("td")(n) || ie("th")(n)) {
                                                const r = e.get(),
                                                    s = t.get();
                                                we(r, n) && o.timeStamp - s < 300 && (o.preventDefault(), c(n, n))
                                            }
                                            e.set(n), t.set(o.timeStamp)
                                        }
                                    }
                                })();
                            e.on("dragstart", (e => {
                                i.clearstate()
                            })), e.on("mousedown", (e => {
                                u(e) && zd(e) && i.mousedown(Pd(e))
                            })), e.on("mouseover", (e => {
                                var t;
                                void 0 !== (t = e).buttons && 0 == (1 & t.buttons) || !zd(e) || i.mouseover(Pd(e))
                            })), e.on("mouseup", (e => {
                                u(e) && zd(e) && i.mouseup(Pd(e))
                            })), e.on("touchend", m.touchEnd), e.on("keyup", (t => {
                                const o = Pd(t);
                                if (o.raw.shiftKey && ld(o.raw.which)) {
                                    const t = e.selection.getRng(),
                                        n = fe.fromDom(t.startContainer),
                                        r = fe.fromDom(t.endContainer);
                                    l.keyup(o, n, t.startOffset, r, t.endOffset).each((e => {
                                        d(o, e)
                                    }))
                                }
                            })), e.on("keydown", (o => {
                                const n = Pd(o);
                                t.hide();
                                const r = e.selection.getRng(),
                                    s = fe.fromDom(r.startContainer),
                                    a = fe.fromDom(r.endContainer),
                                    i = rn(cd, dd)(fe.fromDom(e.selection.getStart()));
                                l.keydown(n, s, r.startOffset, a, r.endOffset, i).each((e => {
                                    d(n, e)
                                })), t.show()
                            })), e.on("NodeChange", (() => {
                                const t = e.selection,
                                    o = fe.fromDom(t.getStart()),
                                    r = fe.fromDom(t.getEnd());
                                Wr(Vt, [o, r]).fold((() => n.clear(s)), g)
                            }))
                        })), e.on("PreInit", (() => {
                            e.serializer.addTempAttr(ds.firstSelected), e.serializer.addTempAttr(ds.lastSelected)
                        })), {
                            getSelectedCells: () => ((e, t, o, n) => {
                                switch (e.tag) {
                                    case "none":
                                        return t();
                                    case "single":
                                        return (e => [e.dom])(e.element);
                                    case "multiple":
                                        return (e => A(e, (e => e.dom)))(e.elements)
                                }
                            })(o.get(), h([])),
                            clearSelectedCells: e => n.clear(fe.fromDom(e))
                        }
                    },
                    Vd = e => {
                        let t = [];
                        return {
                            bind: e => {
                                if (void 0 === e) throw new Error("Event bind error: undefined handler");
                                t.push(e)
                            },
                            unbind: e => {
                                t = R(t, (t => t !== e))
                            },
                            trigger: (...o) => {
                                const n = {};
                                M(e, ((e, t) => {
                                    n[e] = o[t]
                                })), M(t, (e => {
                                    e(n)
                                }))
                            }
                        }
                    },
                    Zd = e => ({
                        registry: G(e, (e => ({
                            bind: e.bind,
                            unbind: e.unbind
                        }))),
                        trigger: G(e, (e => e.trigger))
                    }),
                    Ud = e => e.slice(0).sort(),
                    jd = (e, t) => {
                        const o = R(t, (t => !O(e, t)));
                        o.length > 0 && (e => {
                            throw new Error("Unsupported keys for object: " + Ud(e).join(", "))
                        })(o)
                    },
                    Wd = e => ((e, t) => ((e, t, o) => {
                        if (0 === t.length) throw new Error("You must specify at least one required field.");
                        return ((e, t) => {
                            if (!a(t)) throw new Error("The " + e + " fields must be an array. Was: " + t + ".");
                            M(t, (t => {
                                if (!r(t)) throw new Error("The value " + t + " in the " + e + " fields was not a string.")
                            }))
                        })("required", t), (e => {
                            const t = Ud(e);
                            L(t, ((e, o) => o < t.length - 1 && e === t[o + 1])).each((e => {
                                throw new Error("The field: " + e + " occurs more than once in the combined fields: [" + t.join(", ") + "].")
                            }))
                        })(t), n => {
                            const r = W(n);
                            z(t, (e => O(r, e))) || ((e, t) => {
                                throw new Error("All required keys (" + Ud(e).join(", ") + ") were not specified. Specified keys were: " + Ud(t).join(", ") + ".")
                            })(t, r), e(t, r);
                            const s = R(t, (e => !o.validate(n[e], e)));
                            return s.length > 0 && ((e, t) => {
                                throw new Error("All values need to be of type: " + t + ". Keys (" + Ud(e).join(", ") + ") were not.")
                            })(s, o.label), n
                        }
                    })(e, t, {
                        validate: u,
                        label: "function"
                    }))(jd, e),
                    $d = Wd(["compare", "extract", "mutate", "sink"]),
                    qd = Wd(["element", "start", "stop", "destroy"]),
                    Gd = Wd(["forceDrop", "drop", "move", "delayDrop"]),
                    Kd = () => {
                        const e = (() => {
                                const e = Zd({
                                    move: Vd(["info"])
                                });
                                return {
                                    onEvent: g,
                                    reset: g,
                                    events: e.registry
                                }
                            })(),
                            t = (() => {
                                let e = C.none();
                                const t = Zd({
                                    move: Vd(["info"])
                                });
                                return {
                                    onEvent: (o, n) => {
                                        n.extract(o).each((o => {
                                            const r = ((t, o) => {
                                                const n = e.map((e => t.compare(e, o)));
                                                return e = C.some(o), n
                                            })(n, o);
                                            r.each((e => {
                                                t.trigger.move(e)
                                            }))
                                        }))
                                    },
                                    reset: () => {
                                        e = C.none()
                                    },
                                    events: t.registry
                                }
                            })();
                        let o = e;
                        return {
                            on: () => {
                                o.reset(), o = t
                            },
                            off: () => {
                                o.reset(), o = e
                            },
                            isOn: () => o === t,
                            onEvent: (e, t) => {
                                o.onEvent(e, t)
                            },
                            events: t.events
                        }
                    },
                    Yd = e => {
                        const t = e.replace(/\./g, "-");
                        return {
                            resolve: e => t + "-" + e
                        }
                    },
                    Xd = Yd("ephox-dragster").resolve;
                var Jd = $d({
                    compare: (e, t) => un(t.left - e.left, t.top - e.top),
                    extract: e => C.some(un(e.x, e.y)),
                    sink: (e, t) => {
                        const o = (e => {
                                const t = {
                                        layerClass: Xd("blocker"),
                                        ...e
                                    },
                                    o = fe.fromTag("div");
                                return ce(o, "role", "presentation"), kt(o, {
                                    position: "fixed",
                                    left: "0px",
                                    top: "0px",
                                    width: "100%",
                                    height: "100%"
                                }), Ad(o, Xd("blocker")), Ad(o, t.layerClass), {
                                    element: h(o),
                                    destroy: () => {
                                        ze(o)
                                    }
                                }
                            })(t),
                            n = Id(o.element(), "mousedown", e.forceDrop),
                            r = Id(o.element(), "mouseup", e.drop),
                            s = Id(o.element(), "mousemove", e.move),
                            a = Id(o.element(), "mouseout", e.delayDrop);
                        return qd({
                            element: o.element,
                            start: e => {
                                Be(e, o.element())
                            },
                            stop: () => {
                                ze(o.element())
                            },
                            destroy: () => {
                                o.destroy(), r.unbind(), s.unbind(), a.unbind(), n.unbind()
                            }
                        })
                    },
                    mutate: (e, t) => {
                        e.mutate(t.left, t.top)
                    }
                });
                const Qd = Yd("ephox-snooker").resolve,
                    eu = Qd("resizer-bar"),
                    tu = Qd("resizer-rows"),
                    ou = Qd("resizer-cols"),
                    nu = e => {
                        const t = st(e.parent(), "." + eu);
                        M(t, ze)
                    },
                    ru = (e, t, o) => {
                        const n = e.origin();
                        M(t, (t => {
                            t.each((t => {
                                const r = o(n, t);
                                Ad(r, eu), Be(e.parent(), r)
                            }))
                        }))
                    },
                    su = (e, t, o, n, r) => {
                        const s = gn(o),
                            a = t.isResizable,
                            i = n.length > 0 ? _n.positions(n, o) : [],
                            l = i.length > 0 ? ((e, t) => P(e.all, ((e, o) => t(e.element) ? [o] : [])))(e, a) : [];
                        ((e, t, o, n) => {
                            ru(e, t, ((e, t) => {
                                const r = ((e, t, o, n, r) => {
                                    const s = fe.fromTag("div");
                                    return kt(s, {
                                        position: "absolute",
                                        left: t + "px",
                                        top: o - 3.5 + "px",
                                        height: "7px",
                                        width: n + "px"
                                    }), de(s, {
                                        "data-row": e,
                                        role: "presentation"
                                    }), s
                                })(t.row, o.left - e.left, t.y - e.top, n);
                                return Ad(r, tu), r
                            }))
                        })(t, R(i, ((e, t) => T(l, (e => t === e)))), s, Ao(o));
                        const c = r.length > 0 ? Tn.positions(r, o) : [],
                            d = c.length > 0 ? ((e, t) => {
                                const o = [];
                                return E(e.grid.columns, (n => {
                                    en(e, n).map((e => e.element)).forall(t) && o.push(n)
                                })), R(o, (o => {
                                    const n = Yo(e, (e => e.column === o));
                                    return z(n, (e => t(e.element)))
                                }))
                            })(e, a) : [];
                        ((e, t, o, n) => {
                            ru(e, t, ((e, t) => {
                                const r = ((e, t, o, n, r) => {
                                    const s = fe.fromTag("div");
                                    return kt(s, {
                                        position: "absolute",
                                        left: t - 3.5 + "px",
                                        top: o + "px",
                                        height: r + "px",
                                        width: "7px"
                                    }), de(s, {
                                        "data-column": e,
                                        role: "presentation"
                                    }), s
                                })(t.col, t.x - e.left, o.top - e.top, 0, n);
                                return Ad(r, ou), r
                            }))
                        })(t, R(c, ((e, t) => T(d, (e => t === e)))), s, cn(o))
                    },
                    au = (e, t) => {
                        if (nu(e), e.isResizable(t)) {
                            const o = $o(t),
                                n = nn(o),
                                r = tn(o);
                            su(o, e, t, n, r)
                        }
                    },
                    iu = (e, t) => {
                        const o = st(e.parent(), "." + eu);
                        M(o, t)
                    },
                    lu = e => {
                        iu(e, (e => {
                            St(e, "display", "none")
                        }))
                    },
                    cu = e => {
                        iu(e, (e => {
                            St(e, "display", "block")
                        }))
                    },
                    du = Qd("resizer-bar-dragging"),
                    uu = e => {
                        const t = (() => {
                                const e = Zd({
                                    drag: Vd(["xDelta", "yDelta", "target"])
                                });
                                let t = C.none();
                                const o = (() => {
                                    const e = Zd({
                                        drag: Vd(["xDelta", "yDelta"])
                                    });
                                    return {
                                        mutate: (t, o) => {
                                            e.trigger.drag(t, o)
                                        },
                                        events: e.registry
                                    }
                                })();
                                return o.events.drag.bind((o => {
                                    t.each((t => {
                                        e.trigger.drag(o.xDelta, o.yDelta, t)
                                    }))
                                })), {
                                    assign: e => {
                                        t = C.some(e)
                                    },
                                    get: () => t,
                                    mutate: o.mutate,
                                    events: e.registry
                                }
                            })(),
                            o = ((e, t = {}) => {
                                var o;
                                return ((e, t, o) => {
                                    let n = !1;
                                    const r = Zd({
                                            start: Vd([]),
                                            stop: Vd([])
                                        }),
                                        s = Kd(),
                                        a = () => {
                                            d.stop(), s.isOn() && (s.off(), r.trigger.stop())
                                        },
                                        l = ((e, t) => {
                                            let o = null;
                                            const n = () => {
                                                i(o) || (clearTimeout(o), o = null)
                                            };
                                            return {
                                                cancel: n,
                                                throttle: (...t) => {
                                                    n(), o = setTimeout((() => {
                                                        o = null, e.apply(null, t)
                                                    }), 200)
                                                }
                                            }
                                        })(a);
                                    s.events.move.bind((o => {
                                        t.mutate(e, o.info)
                                    }));
                                    const c = e => (...t) => {
                                            n && e.apply(null, t)
                                        },
                                        d = t.sink(Gd({
                                            forceDrop: a,
                                            drop: c(a),
                                            move: c((e => {
                                                l.cancel(), s.onEvent(e, t)
                                            })),
                                            delayDrop: c(l.throttle)
                                        }), o);
                                    return {
                                        element: d.element,
                                        go: e => {
                                            d.start(e), s.on(), r.trigger.start()
                                        },
                                        on: () => {
                                            n = !0
                                        },
                                        off: () => {
                                            n = !1
                                        },
                                        destroy: () => {
                                            d.destroy()
                                        },
                                        events: r.registry
                                    }
                                })(e, null !== (o = t.mode) && void 0 !== o ? o : Jd, t)
                            })(t, {});
                        let n = C.none();
                        const r = (e, t) => C.from(ue(e, t));
                        t.events.drag.bind((e => {
                            r(e.target, "data-row").each((t => {
                                const o = Dt(e.target, "top");
                                St(e.target, "top", o + e.yDelta + "px")
                            })), r(e.target, "data-column").each((t => {
                                const o = Dt(e.target, "left");
                                St(e.target, "left", o + e.xDelta + "px")
                            }))
                        }));
                        const s = (e, t) => Dt(e, t) - At(e, "data-initial-" + t, 0);
                        o.events.stop.bind((() => {
                            t.get().each((t => {
                                n.each((o => {
                                    r(t, "data-row").each((e => {
                                        const n = s(t, "top");
                                        ge(t, "data-initial-top"), u.trigger.adjustHeight(o, n, parseInt(e, 10))
                                    })), r(t, "data-column").each((e => {
                                        const n = s(t, "left");
                                        ge(t, "data-initial-left"), u.trigger.adjustWidth(o, n, parseInt(e, 10))
                                    })), au(e, o)
                                }))
                            }))
                        }));
                        const a = (n, r) => {
                                u.trigger.startAdjust(), t.assign(n), ce(n, "data-initial-" + r, Dt(n, r)), Ad(n, du), St(n, "opacity", "0.2"), o.go(e.parent())
                            },
                            l = Id(e.parent(), "mousedown", (e => {
                                var t;
                                t = e.target, Md(t, tu) && a(e.target, "top"), (e => Md(e, ou))(e.target) && a(e.target, "left")
                            })),
                            c = t => we(t, e.view()),
                            d = Id(e.view(), "mouseover", (t => {
                                var o;
                                (o = t.target, ut(o, "table", c).filter(qs)).fold((() => {
                                    et(t.target) && nu(e)
                                }), (t => {
                                    n = C.some(t), au(e, t)
                                }))
                            })),
                            u = Zd({
                                adjustHeight: Vd(["table", "delta", "row"]),
                                adjustWidth: Vd(["table", "delta", "column"]),
                                startAdjust: Vd([])
                            });
                        return {
                            destroy: () => {
                                l.unbind(), d.unbind(), o.destroy(), nu(e)
                            },
                            refresh: t => {
                                au(e, t)
                            },
                            on: o.on,
                            off: o.off,
                            hideBars: v(lu, e),
                            showBars: v(cu, e),
                            events: u.registry
                        }
                    },
                    mu = (e, t, o) => {
                        const n = _n,
                            r = Tn,
                            s = uu(e),
                            a = Zd({
                                beforeResize: Vd(["table", "type"]),
                                afterResize: Vd(["table", "type"]),
                                startDrag: Vd([])
                            });
                        return s.events.adjustHeight.bind((e => {
                            const t = e.table;
                            a.trigger.beforeResize(t, "row");
                            ((e, t, o, n) => {
                                const r = $o(e),
                                    s = ((e, t, o) => Qn(e, t, o, Zn, (e => e.getOrThunk(Lt))))(r, e, n),
                                    a = A(s, ((e, n) => o === n ? Math.max(t + e, Lt()) : e)),
                                    i = La(r, a),
                                    l = ((e, t) => A(e.all, ((e, o) => ({
                                        element: e.element,
                                        height: t[o]
                                    }))))(r, a);
                                M(l, (e => {
                                    Hn(e.element, e.height)
                                })), M(i, (e => {
                                    Hn(e.element, e.height)
                                }));
                                const c = D(a, ((e, t) => e + t), 0);
                                Hn(e, c)
                            })(t, n.delta(e.delta, t), e.row, n), a.trigger.afterResize(t, "row")
                        })), s.events.startAdjust.bind((e => {
                            a.trigger.startDrag()
                        })), s.events.adjustWidth.bind((e => {
                            const n = e.table;
                            a.trigger.beforeResize(n, "col");
                            const s = r.delta(e.delta, n),
                                i = o(n);
                            Ia(n, s, e.column, t, i), a.trigger.afterResize(n, "col")
                        })), {
                            on: s.on,
                            off: s.off,
                            refreshBars: s.refresh,
                            hideBars: s.hideBars,
                            showBars: s.showBars,
                            destroy: s.destroy,
                            events: a.registry
                        }
                    },
                    gu = e => d(e) && "TABLE" === e.nodeName,
                    hu = "bar-",
                    pu = e => "false" !== ue(e, "data-mce-resize"),
                    fu = e => {
                        const t = td(),
                            o = td(),
                            n = td();
                        let r, s;
                        const a = t => ll(e, t),
                            i = () => Ji(e) ? Ms() : As();
                        return e.on("init", (() => {
                            const r = ((e, t) => e.inline ? ((e, t, o) => ({
                                parent: h(t),
                                view: h(e),
                                origin: h(un(0, 0)),
                                isResizable: o
                            }))(fe.fromDom(e.getBody()), (() => {
                                const e = fe.fromTag("div");
                                return kt(e, {
                                    position: "static",
                                    height: "0",
                                    width: "0",
                                    padding: "0",
                                    margin: "0",
                                    border: "0"
                                }), Be(tt(fe.fromDom(document)), e), e
                            })(), t) : ((e, t) => {
                                const o = se(e) ? (e => fe.fromDom(ke(e).dom.documentElement))(e) : e;
                                return {
                                    parent: h(o),
                                    view: h(e),
                                    origin: h(un(0, 0)),
                                    isResizable: t
                                }
                            })(fe.fromDom(e.getDoc()), t))(e, pu);
                            if (n.set(r), (e => {
                                    const t = e.options.get("object_resizing");
                                    return O(t.split(","), "table")
                                })(e) && rl(e)) {
                                const n = i(),
                                    s = mu(r, n, a);
                                s.on(), s.events.startDrag.bind((o => {
                                    t.set(e.selection.getRng())
                                })), s.events.beforeResize.bind((t => {
                                    const o = t.table.dom;
                                    ((e, t, o, n, r) => {
                                        e.dispatch("ObjectResizeStart", {
                                            target: t,
                                            width: o,
                                            height: n,
                                            origin: r
                                        })
                                    })(e, o, Mr(o), Nr(o), hu + t.type)
                                })), s.events.afterResize.bind((o => {
                                    const n = o.table,
                                        r = n.dom;
                                    Er(n), t.on((t => {
                                        e.selection.setRng(t), e.focus()
                                    })), ((e, t, o, n, r) => {
                                        e.dispatch("ObjectResized", {
                                            target: t,
                                            width: o,
                                            height: n,
                                            origin: r
                                        })
                                    })(e, r, Mr(r), Nr(r), hu + o.type), e.undoManager.add()
                                })), o.set(s)
                            }
                        })), e.on("ObjectResizeStart", (t => {
                            const o = t.target;
                            if (gu(o)) {
                                const n = fe.fromDom(o);
                                M(e.dom.select(".mce-clonedresizable"), (t => {
                                    e.dom.addClass(t, "mce-" + Xi(e) + "-columns")
                                })), !Sl(n) && ol(e) ? Tl(n) : !Cl(n) && tl(e) && Ol(n), kl(n) && vt(t.origin, hu) && Ol(n), r = t.width, s = nl(e) ? "" : ((e, t) => {
                                    const o = e.dom.getStyle(t, "width") || e.dom.getAttrib(t, "width");
                                    return C.from(o).filter(wt)
                                })(e, o).getOr("")
                            }
                        })), e.on("ObjectResized", (t => {
                            const o = t.target;
                            if (gu(o)) {
                                const n = fe.fromDom(o),
                                    l = t.origin;
                                vt(l, "corner-") && ((t, o, n) => {
                                    const l = bt(o, "e");
                                    if ("" === s && Ol(t), n !== r && "" !== s) {
                                        St(t, "width", s);
                                        const o = i(),
                                            c = a(t),
                                            d = Ji(e) || l ? (e => Ns(e).columns)(t) - 1 : 0;
                                        Ia(t, n - r, d, o, c)
                                    } else if ((e => /^(\d+(\.\d+)?)%$/.test(e))(s)) {
                                        const e = parseFloat(s.replace("%", ""));
                                        St(t, "width", n * e / r + "%")
                                    }(e => /^(\d+(\.\d+)?)px$/.test(e))(s) && (e => {
                                        const t = $o(e);
                                        Qo(t) || M(zt(e), (e => {
                                            const t = _t(e, "width");
                                            St(e, "width", t), ge(e, "width")
                                        }))
                                    })(t)
                                })(n, l, t.width), Er(n), Zi(e, n.dom, Ui)
                            }
                        })), e.on("SwitchMode", (() => {
                            o.on((t => {
                                e.mode.isReadOnly() ? t.hideBars() : t.showBars()
                            }))
                        })), e.on("remove", (() => {
                            o.on((e => {
                                e.destroy()
                            })), n.on((t => {
                                ((e, t) => {
                                    e.inline && ze(t.parent())
                                })(e, t)
                            }))
                        })), {
                            refresh: e => {
                                o.on((t => t.refreshBars(fe.fromDom(e))))
                            },
                            hide: () => {
                                o.on((e => e.hideBars()))
                            },
                            show: () => {
                                o.on((e => e.showBars()))
                            }
                        }
                    },
                    vu = e => {
                        (e => {
                            const t = e.options.register;
                            t("table_clone_elements", {
                                processor: "string[]"
                            }), t("table_use_colgroups", {
                                processor: "boolean",
                                default: !0
                            }), t("table_header_type", {
                                processor: e => {
                                    const t = O(["section", "cells", "sectionCells", "auto"], e);
                                    return t ? {
                                        value: e,
                                        valid: t
                                    } : {
                                        valid: !1,
                                        message: "Must be one of: section, cells, sectionCells or auto."
                                    }
                                },
                                default: "section"
                            }), t("table_sizing_mode", {
                                processor: "string",
                                default: "auto"
                            }), t("table_default_attributes", {
                                processor: "object",
                                default: {
                                    border: "1"
                                }
                            }), t("table_default_styles", {
                                processor: "object",
                                default: {
                                    "border-collapse": "collapse"
                                }
                            }), t("table_column_resizing", {
                                processor: e => {
                                    const t = O(["preservetable", "resizetable"], e);
                                    return t ? {
                                        value: e,
                                        valid: t
                                    } : {
                                        valid: !1,
                                        message: "Must be preservetable, or resizetable."
                                    }
                                },
                                default: "preservetable"
                            }), t("table_resize_bars", {
                                processor: "boolean",
                                default: !0
                            }), t("table_style_by_css", {
                                processor: "boolean",
                                default: !0
                            })
                        })(e);
                        const t = fu(e),
                            o = Fd(e, t),
                            n = cl(e, t, o);
                        return ql(e, n), ((e, t) => {
                            const o = Tr(e),
                                n = t => hs(Ar(e)).bind((n => Vt(n, o).map((o => {
                                    const r = us(ps(e), o, n);
                                    return t(o, r)
                                })))).getOr("");
                            q({
                                mceTableRowType: () => n(t.getTableRowType),
                                mceTableCellType: () => n(t.getTableCellType),
                                mceTableColType: () => n(t.getTableColType)
                            }, ((t, o) => e.addQueryValueHandler(o, t)))
                        })(e, n), fs(e, n), {
                            getSelectedCells: o.getSelectedCells,
                            clearSelectedCells: o.clearSelectedCells
                        }
                    };
                e.add("dom", (e => ({
                    table: vu(e)
                })))
            }()
        },
        15209: function(e, t, o) {
            o(78578)
        },
        78578: function() {
            ! function() {
                "use strict";
                var e = tinymce.util.Tools.resolve("tinymce.PluginManager"),
                    t = tinymce.util.Tools.resolve("tinymce.Env");
                const o = e => t => t.options.get(e),
                    n = o("min_height"),
                    r = o("max_height"),
                    s = o("autoresize_overflow_padding"),
                    a = o("autoresize_bottom_margin"),
                    i = (e, t) => {
                        const o = e.getBody();
                        o && (o.style.overflowY = t ? "" : "hidden", t || (o.scrollTop = 0))
                    },
                    l = (e, t, o, n) => {
                        var r;
                        const s = parseInt(null !== (r = e.getStyle(t, o, n)) && void 0 !== r ? r : "", 10);
                        return isNaN(s) ? 0 : s
                    },
                    c = (e, o, s) => {
                        var d;
                        const u = e.dom,
                            m = e.getDoc();
                        if (!m) return;
                        if ((e => e.plugins.fullscreen && e.plugins.fullscreen.isFullscreen())(e)) return void i(e, !0);
                        const g = m.documentElement,
                            h = a(e),
                            p = null !== (d = n(e)) && void 0 !== d ? d : e.getElement().offsetHeight;
                        let f = p;
                        const v = l(u, g, "margin-top", !0),
                            b = l(u, g, "margin-bottom", !0);
                        let y = g.offsetHeight + v + b + h;
                        y < 0 && (y = 0);
                        const w = e.getContainer().offsetHeight - e.getContentAreaContainer().offsetHeight;
                        y + w > p && (f = y + w);
                        const x = r(e);
                        if (x && f > x ? (f = x, i(e, !0)) : i(e, !1), f !== o.get()) {
                            const n = f - o.get();
                            if (u.setStyle(e.getContainer(), "height", f + "px"), o.set(f), (e => {
                                    e.dispatch("ResizeEditor")
                                })(e), t.browser.isSafari() && (t.os.isMacOS() || t.os.isiOS())) {
                                const t = e.getWin();
                                t.scrollTo(t.pageXOffset, t.pageYOffset)
                            }
                            e.hasFocus() && (e => {
                                if ("setcontent" === (null == e ? void 0 : e.type.toLowerCase())) {
                                    const t = e;
                                    return !0 === t.selection || !0 === t.paste
                                }
                                return !1
                            })(s) && e.selection.scrollIntoView(), (t.browser.isSafari() || t.browser.isChromium()) && n < 0 && c(e, o, s)
                        }
                    };
                e.add("autoresize", (e => {
                    if ((e => {
                            const t = e.options.register;
                            t("autoresize_overflow_padding", {
                                processor: "number",
                                default: 1
                            }), t("autoresize_bottom_margin", {
                                processor: "number",
                                default: 50
                            })
                        })(e), e.options.isSet("resize") || e.options.set("resize", !1), !e.inline) {
                        const t = (e => {
                            let t = 0;
                            return {
                                get: () => t,
                                set: e => {
                                    t = e
                                }
                            }
                        })();
                        ((e, t) => {
                            e.addCommand("mceAutoResize", (() => {
                                c(e, t)
                            }))
                        })(e, t), ((e, t) => {
                            e.on("init", (() => {
                                const t = s(e),
                                    o = e.dom;
                                o.setStyles(e.getDoc().documentElement, {
                                    height: "auto"
                                }), o.setStyles(e.getBody(), {
                                    paddingLeft: t,
                                    paddingRight: t,
                                    "min-height": 0
                                })
                            })), e.on("NodeChange SetContent keyup FullscreenStateChanged ResizeContent", (o => {
                                c(e, t, o)
                            }))
                        })(e, t)
                    }
                }))
            }()
        },
        17259: function(e, t, o) {
            o(38492)
        },
        38492: function() {
            ! function() {
                "use strict";
                var e = tinymce.util.Tools.resolve("tinymce.PluginManager");
                const t = e => t => typeof t === e,
                    o = e => "string" === (e => {
                        const t = typeof e;
                        return null === e ? "null" : "object" === t && Array.isArray(e) ? "array" : "object" === t && (o = n = e, (r = String).prototype.isPrototypeOf(o) || (null === (s = n.constructor) || void 0 === s ? void 0 : s.name) === r.name) ? "string" : t;
                        var o, n, r, s
                    })(e),
                    n = t("boolean"),
                    r = e => !(e => null == e)(e),
                    s = t("function"),
                    a = t("number"),
                    i = (!1, () => false);
                class l {
                    constructor(e, t) {
                        this.tag = e, this.value = t
                    }
                    static some(e) {
                        return new l(!0, e)
                    }
                    static none() {
                        return l.singletonNone
                    }
                    fold(e, t) {
                        return this.tag ? t(this.value) : e()
                    }
                    isSome() {
                        return this.tag
                    }
                    isNone() {
                        return !this.tag
                    }
                    map(e) {
                        return this.tag ? l.some(e(this.value)) : l.none()
                    }
                    bind(e) {
                        return this.tag ? e(this.value) : l.none()
                    }
                    exists(e) {
                        return this.tag && e(this.value)
                    }
                    forall(e) {
                        return !this.tag || e(this.value)
                    }
                    filter(e) {
                        return !this.tag || e(this.value) ? this : l.none()
                    }
                    getOr(e) {
                        return this.tag ? this.value : e
                    }
                    or(e) {
                        return this.tag ? this : e
                    }
                    getOrThunk(e) {
                        return this.tag ? this.value : e()
                    }
                    orThunk(e) {
                        return this.tag ? this : e()
                    }
                    getOrDie(e) {
                        if (this.tag) return this.value;
                        throw new Error(null != e ? e : "Called getOrDie on None")
                    }
                    static from(e) {
                        return r(e) ? l.some(e) : l.none()
                    }
                    getOrNull() {
                        return this.tag ? this.value : null
                    }
                    getOrUndefined() {
                        return this.value
                    }
                    each(e) {
                        this.tag && e(this.value)
                    }
                    toArray() {
                        return this.tag ? [this.value] : []
                    }
                    toString() {
                        return this.tag ? `some(${this.value})` : "none()"
                    }
                }
                l.singletonNone = new l(!1);
                const c = (e, t) => {
                        for (let o = 0, n = e.length; o < n; o++) t(e[o], o)
                    },
                    d = e => {
                        if (null == e) throw new Error("Node cannot be null or undefined");
                        return {
                            dom: e
                        }
                    },
                    u = d,
                    m = (e, t) => {
                        const o = e.dom;
                        if (1 !== o.nodeType) return !1; {
                            const e = o;
                            if (void 0 !== e.matches) return e.matches(t);
                            if (void 0 !== e.msMatchesSelector) return e.msMatchesSelector(t);
                            if (void 0 !== e.webkitMatchesSelector) return e.webkitMatchesSelector(t);
                            if (void 0 !== e.mozMatchesSelector) return e.mozMatchesSelector(t);
                            throw new Error("Browser lacks native selectors")
                        }
                    };
                "undefined" != typeof window ? window : Function("return this;")();
                const g = e => t => (e => e.dom.nodeType)(t) === e,
                    h = g(1),
                    p = g(3),
                    f = g(9),
                    v = g(11),
                    b = (e, t) => {
                        e.dom.removeAttribute(t)
                    },
                    y = s(Element.prototype.attachShadow) && s(Node.prototype.getRootNode) ? e => u(e.dom.getRootNode()) : e => f(e) ? e : u(e.dom.ownerDocument),
                    w = e => u(e.dom.host),
                    x = e => {
                        const t = p(e) ? e.dom.parentNode : e.dom;
                        if (null == t || null === t.ownerDocument) return !1;
                        const o = t.ownerDocument;
                        return (e => {
                            const t = y(e);
                            return v(o = t) && r(o.dom.host) ? l.some(t) : l.none();
                            var o
                        })(u(t)).fold((() => o.body.contains(t)), (n = x, s = w, e => n(s(e))));
                        var n, s
                    },
                    C = e => "rtl" === ((e, t) => {
                        const o = e.dom,
                            n = window.getComputedStyle(o).getPropertyValue(t);
                        return "" !== n || x(e) ? n : ((e, t) => (e => void 0 !== e.style && s(e.style.getPropertyValue))(e) ? e.style.getPropertyValue(t) : "")(o, t)
                    })(e, "direction") ? "rtl" : "ltr",
                    S = (e, t) => ((e, o) => ((e, t) => {
                        const o = [];
                        for (let n = 0, r = e.length; n < r; n++) {
                            const r = e[n];
                            t(r, n) && o.push(r)
                        }
                        return o
                    })(((e, t) => {
                        const o = e.length,
                            n = new Array(o);
                        for (let r = 0; r < o; r++) {
                            const o = e[r];
                            n[r] = t(o, r)
                        }
                        return n
                    })(e.dom.childNodes, u), (e => m(e, t))))(e),
                    k = ("li", e => h(e) && "li" === e.dom.nodeName.toLowerCase());
                const _ = (e, t) => {
                        const r = e.selection.getSelectedBlocks();
                        r.length > 0 && (c(r, (e => {
                            const r = u(e),
                                d = k(r),
                                g = ((e, t) => {
                                    return (t ? (o = e, n = "ol,ul", ((e, t, o) => {
                                        let r = e.dom;
                                        const a = s(o) ? o : i;
                                        for (; r.parentNode;) {
                                            r = r.parentNode;
                                            const e = u(r);
                                            if (m(e, n)) return l.some(e);
                                            if (a(e)) break
                                        }
                                        return l.none()
                                    })(o, 0, r)) : l.some(e)).getOr(e);
                                    var o, n, r
                                })(r, d);
                            var p;
                            (p = g, (e => l.from(e.dom.parentNode).map(u))(p).filter(h)).each((e => {
                                if (C(e) !== t ? ((e, t, r) => {
                                        ((e, t, r) => {
                                            if (!(o(r) || n(r) || a(r))) throw console.error("Invalid call to Attribute.set. Key ", t, ":: Value ", r, ":: Element ", e), new Error("Attribute value was not simple");
                                            e.setAttribute(t, r + "")
                                        })(e.dom, t, r)
                                    })(g, "dir", t) : C(g) !== t && b(g, "dir"), d) {
                                    const e = S(g, "li[dir]");
                                    c(e, (e => b(e, "dir")))
                                }
                            }))
                        })), e.nodeChanged())
                    },
                    O = (e, t) => o => {
                        const n = e => {
                            const n = u(e.element);
                            o.setActive(C(n) === t)
                        };
                        return e.on("NodeChange", n), () => e.off("NodeChange", n)
                    };
                e.add("directionality", (e => {
                    (e => {
                        e.addCommand("mceDirectionLTR", (() => {
                            _(e, "ltr")
                        })), e.addCommand("mceDirectionRTL", (() => {
                            _(e, "rtl")
                        }))
                    })(e), (e => {
                        e.ui.registry.addToggleButton("ltr", {
                            tooltip: "Left to right",
                            icon: "ltr",
                            onAction: () => e.execCommand("mceDirectionLTR"),
                            onSetup: O(e, "ltr")
                        }), e.ui.registry.addToggleButton("rtl", {
                            tooltip: "Right to left",
                            icon: "rtl",
                            onAction: () => e.execCommand("mceDirectionRTL"),
                            onSetup: O(e, "rtl")
                        })
                    })(e)
                }))
            }()
        },
        72170: function(e, t, o) {
            o(53302)
        },
        53302: function() {
            ! function() {
                "use strict";
                var e = tinymce.util.Tools.resolve("tinymce.PluginManager");
                const t = Object.getPrototypeOf,
                    o = (e, t, o) => {
                        var n;
                        return !!o(e, t.prototype) || (null === (n = e.constructor) || void 0 === n ? void 0 : n.name) === t.name
                    },
                    n = e => t => (e => {
                        const t = typeof e;
                        return null === e ? "null" : "object" === t && Array.isArray(e) ? "array" : "object" === t && o(e, String, ((e, t) => t.isPrototypeOf(e))) ? "string" : t
                    })(t) === e,
                    r = e => t => typeof t === e,
                    s = n("string"),
                    a = n("object"),
                    i = e => ((e, n) => a(e) && o(e, n, ((e, o) => t(e) === o)))(e, Object),
                    l = n("array"),
                    c = (null, e => null === e);
                const d = r("boolean"),
                    u = e => !(e => null == e)(e),
                    m = r("function"),
                    g = r("number"),
                    h = () => {};
                class p {
                    constructor(e, t) {
                        this.tag = e, this.value = t
                    }
                    static some(e) {
                        return new p(!0, e)
                    }
                    static none() {
                        return p.singletonNone
                    }
                    fold(e, t) {
                        return this.tag ? t(this.value) : e()
                    }
                    isSome() {
                        return this.tag
                    }
                    isNone() {
                        return !this.tag
                    }
                    map(e) {
                        return this.tag ? p.some(e(this.value)) : p.none()
                    }
                    bind(e) {
                        return this.tag ? e(this.value) : p.none()
                    }
                    exists(e) {
                        return this.tag && e(this.value)
                    }
                    forall(e) {
                        return !this.tag || e(this.value)
                    }
                    filter(e) {
                        return !this.tag || e(this.value) ? this : p.none()
                    }
                    getOr(e) {
                        return this.tag ? this.value : e
                    }
                    or(e) {
                        return this.tag ? this : e
                    }
                    getOrThunk(e) {
                        return this.tag ? this.value : e()
                    }
                    orThunk(e) {
                        return this.tag ? this : e()
                    }
                    getOrDie(e) {
                        if (this.tag) return this.value;
                        throw new Error(null != e ? e : "Called getOrDie on None")
                    }
                    static from(e) {
                        return u(e) ? p.some(e) : p.none()
                    }
                    getOrNull() {
                        return this.tag ? this.value : null
                    }
                    getOrUndefined() {
                        return this.value
                    }
                    each(e) {
                        this.tag && e(this.value)
                    }
                    toArray() {
                        return this.tag ? [this.value] : []
                    }
                    toString() {
                        return this.tag ? `some(${this.value})` : "none()"
                    }
                }
                p.singletonNone = new p(!1);
                const f = Object.keys,
                    v = Object.hasOwnProperty,
                    b = (e, t) => v.call(e, t),
                    y = Array.prototype.push,
                    w = e => {
                        const t = [];
                        for (let o = 0, n = e.length; o < n; ++o) {
                            if (!l(e[o])) throw new Error("Arr.flatten item " + o + " was not an array, input: " + e);
                            y.apply(t, e[o])
                        }
                        return t
                    };
                "undefined" != typeof window ? window : Function("return this;")();
                const x = (e, t, o) => {
                        ((e, t, o) => {
                            if (!(s(o) || d(o) || g(o))) throw console.error("Invalid call to Attribute.set. Key ", t, ":: Value ", o, ":: Element ", e), new Error("Attribute value was not simple");
                            e.setAttribute(t, o + "")
                        })(e.dom, t, o)
                    },
                    C = e => {
                        if (null == e) throw new Error("Node cannot be null or undefined");
                        return {
                            dom: e
                        }
                    },
                    S = C;
                var k = tinymce.util.Tools.resolve("tinymce.dom.DOMUtils"),
                    _ = tinymce.util.Tools.resolve("tinymce.util.URI");
                const O = e => e.length > 0,
                    T = e => t => t.options.get(e),
                    E = T("image_dimensions"),
                    A = T("image_advtab"),
                    M = T("image_uploadtab"),
                    N = T("image_prepend_url"),
                    R = T("image_class_list"),
                    D = T("image_description"),
                    B = T("image_title"),
                    L = T("image_caption"),
                    H = T("image_list"),
                    I = T("a11y_advanced_options"),
                    P = T("automatic_uploads"),
                    z = (e, t) => Math.max(parseInt(e, 10), parseInt(t, 10)),
                    F = e => (e && (e = e.replace(/px$/, "")), e),
                    V = e => (e.length > 0 && /^[0-9]+$/.test(e) && (e += "px"), e),
                    Z = e => "IMG" === e.nodeName && (e.hasAttribute("data-mce-object") || e.hasAttribute("data-mce-placeholder")),
                    U = (e, t) => {
                        const o = e.options.get;
                        return _.isDomSafe(t, "img", {
                            allow_html_data_urls: o("allow_html_data_urls"),
                            allow_script_urls: o("allow_script_urls"),
                            allow_svg_data_urls: o("allow_svg_data_urls")
                        })
                    },
                    j = k.DOM,
                    W = e => e.style.marginLeft && e.style.marginRight && e.style.marginLeft === e.style.marginRight ? F(e.style.marginLeft) : "",
                    $ = e => e.style.marginTop && e.style.marginBottom && e.style.marginTop === e.style.marginBottom ? F(e.style.marginTop) : "",
                    q = e => e.style.borderWidth ? F(e.style.borderWidth) : "",
                    G = (e, t) => {
                        var o;
                        return e.hasAttribute(t) && null !== (o = e.getAttribute(t)) && void 0 !== o ? o : ""
                    },
                    K = e => null !== e.parentNode && "FIGURE" === e.parentNode.nodeName,
                    Y = (e, t, o) => {
                        "" === o || null === o ? e.removeAttribute(t) : e.setAttribute(t, o)
                    },
                    X = (e, t) => {
                        const o = e.getAttribute("style"),
                            n = t(null !== o ? o : "");
                        n.length > 0 ? (e.setAttribute("style", n), e.setAttribute("data-mce-style", n)) : e.removeAttribute("style")
                    },
                    J = (e, t) => (e, o, n) => {
                        const r = e.style;
                        r[o] ? (r[o] = V(n), X(e, t)) : Y(e, o, n)
                    },
                    Q = (e, t) => e.style[t] ? F(e.style[t]) : G(e, t),
                    ee = (e, t) => {
                        const o = V(t);
                        e.style.marginLeft = o, e.style.marginRight = o
                    },
                    te = (e, t) => {
                        const o = V(t);
                        e.style.marginTop = o, e.style.marginBottom = o
                    },
                    oe = (e, t) => {
                        const o = V(t);
                        e.style.borderWidth = o
                    },
                    ne = (e, t) => {
                        e.style.borderStyle = t
                    },
                    re = e => {
                        var t;
                        return null !== (t = e.style.borderStyle) && void 0 !== t ? t : ""
                    },
                    se = e => u(e) && "FIGURE" === e.nodeName,
                    ae = e => 0 === j.getAttrib(e, "alt").length && "presentation" === j.getAttrib(e, "role"),
                    ie = e => ae(e) ? "" : G(e, "alt"),
                    le = (e, t) => {
                        var o;
                        const n = document.createElement("img");
                        return Y(n, "style", t.style), (W(n) || "" !== t.hspace) && ee(n, t.hspace), ($(n) || "" !== t.vspace) && te(n, t.vspace), (q(n) || "" !== t.border) && oe(n, t.border), (re(n) || "" !== t.borderStyle) && ne(n, t.borderStyle), e(null !== (o = n.getAttribute("style")) && void 0 !== o ? o : "")
                    },
                    ce = (e, t) => ({
                        src: G(t, "src"),
                        alt: ie(t),
                        title: G(t, "title"),
                        width: Q(t, "width"),
                        height: Q(t, "height"),
                        class: G(t, "class"),
                        style: e(G(t, "style")),
                        caption: K(t),
                        hspace: W(t),
                        vspace: $(t),
                        border: q(t),
                        borderStyle: re(t),
                        isDecorative: ae(t)
                    }),
                    de = (e, t, o, n, r) => {
                        o[n] !== t[n] && r(e, n, String(o[n]))
                    },
                    ue = (e, t, o) => {
                        if (o) {
                            j.setAttrib(e, "role", "presentation");
                            const t = S(e);
                            x(t, "alt", "")
                        } else {
                            if (c(t)) {
                                "alt",
                                S(e).dom.removeAttribute("alt")
                            }
                            else {
                                const o = S(e);
                                x(o, "alt", t)
                            }
                            "presentation" === j.getAttrib(e, "role") && j.setAttrib(e, "role", "")
                        }
                    },
                    me = (e, t) => (o, n, r) => {
                        e(o, r), X(o, t)
                    },
                    ge = (e, t, o) => {
                        const n = ce(e, o);
                        de(o, n, t, "caption", ((e, t, o) => (e => {
                            K(e) ? (e => {
                                const t = e.parentNode;
                                u(t) && (j.insertAfter(e, t), j.remove(t))
                            })(e) : (e => {
                                const t = j.create("figure", {
                                    class: "image"
                                });
                                j.insertAfter(t, e), t.appendChild(e), t.appendChild(j.create("figcaption", {
                                    contentEditable: "true"
                                }, "Caption")), t.contentEditable = "false"
                            })(e)
                        })(e))), de(o, n, t, "src", Y), de(o, n, t, "title", Y), de(o, n, t, "width", J(0, e)), de(o, n, t, "height", J(0, e)), de(o, n, t, "class", Y), de(o, n, t, "style", me(((e, t) => Y(e, "style", t)), e)), de(o, n, t, "hspace", me(ee, e)), de(o, n, t, "vspace", me(te, e)), de(o, n, t, "border", me(oe, e)), de(o, n, t, "borderStyle", me(ne, e)), ((e, t, o) => {
                            o.alt === t.alt && o.isDecorative === t.isDecorative || ue(e, o.alt, o.isDecorative)
                        })(o, n, t)
                    },
                    he = (e, t) => {
                        const o = (e => {
                                if (e.margin) {
                                    const t = String(e.margin).split(" ");
                                    switch (t.length) {
                                        case 1:
                                            e["margin-top"] = e["margin-top"] || t[0], e["margin-right"] = e["margin-right"] || t[0], e["margin-bottom"] = e["margin-bottom"] || t[0], e["margin-left"] = e["margin-left"] || t[0];
                                            break;
                                        case 2:
                                            e["margin-top"] = e["margin-top"] || t[0], e["margin-right"] = e["margin-right"] || t[1], e["margin-bottom"] = e["margin-bottom"] || t[0], e["margin-left"] = e["margin-left"] || t[1];
                                            break;
                                        case 3:
                                            e["margin-top"] = e["margin-top"] || t[0], e["margin-right"] = e["margin-right"] || t[1], e["margin-bottom"] = e["margin-bottom"] || t[2], e["margin-left"] = e["margin-left"] || t[1];
                                            break;
                                        case 4:
                                            e["margin-top"] = e["margin-top"] || t[0], e["margin-right"] = e["margin-right"] || t[1], e["margin-bottom"] = e["margin-bottom"] || t[2], e["margin-left"] = e["margin-left"] || t[3]
                                    }
                                    delete e.margin
                                }
                                return e
                            })(e.dom.styles.parse(t)),
                            n = e.dom.styles.parse(e.dom.styles.serialize(o));
                        return e.dom.styles.serialize(n)
                    },
                    pe = e => {
                        const t = e.selection.getNode(),
                            o = e.dom.getParent(t, "figure.image");
                        return o ? e.dom.select("img", o)[0] : t && ("IMG" !== t.nodeName || Z(t)) ? null : t
                    },
                    fe = (e, t) => {
                        var o;
                        const n = e.dom,
                            r = ((t, o) => {
                                const n = {};
                                var r;
                                return ((e, t, o, n) => {
                                    ((e, t) => {
                                        const o = f(e);
                                        for (let n = 0, r = o.length; n < r; n++) {
                                            const r = o[n];
                                            t(e[r], r)
                                        }
                                    })(e, ((e, r) => {
                                        (t(e, r) ? o : n)(e, r)
                                    }))
                                })(t, ((t, o) => !e.schema.isValidChild(o, "figure")), (r = n, (e, t) => {
                                    r[t] = e
                                }), h), n
                            })(e.schema.getTextBlockElements()),
                            s = n.getParent(t.parentNode, (e => {
                                return t = r, o = e.nodeName, b(t, o) && void 0 !== t[o] && null !== t[o];
                                var t, o
                            }), e.getBody());
                        return s && null !== (o = n.split(s, t)) && void 0 !== o ? o : t
                    },
                    ve = (e, t) => {
                        const o = ((t, o) => {
                            const n = document.createElement("img");
                            if (ge((t => he(e, t)), { ...o,
                                    caption: !1
                                }, n), ue(n, o.alt, o.isDecorative), o.caption) {
                                const e = j.create("figure", {
                                    class: "image"
                                });
                                return e.appendChild(n), e.appendChild(j.create("figcaption", {
                                    contentEditable: "true"
                                }, "Caption")), e.contentEditable = "false", e
                            }
                            return n
                        })(0, t);
                        e.dom.setAttrib(o, "data-mce-id", "__mcenew"), e.focus(), e.selection.setContent(o.outerHTML);
                        const n = e.dom.select('*[data-mce-id="__mcenew"]')[0];
                        if (e.dom.setAttrib(n, "data-mce-id", null), se(n)) {
                            const t = fe(e, n);
                            e.selection.select(t)
                        } else e.selection.select(n)
                    },
                    be = (e, t) => {
                        const o = pe(e);
                        if (o) {
                            const n = { ...ce((t => he(e, t)), o),
                                    ...t
                                },
                                r = ((e, t) => {
                                    const o = t.src;
                                    return { ...t,
                                        src: U(e, o) ? o : ""
                                    }
                                })(e, n);
                            n.src ? ((e, t) => {
                                const o = pe(e);
                                if (o)
                                    if (ge((t => he(e, t)), t, o), ((e, t) => {
                                            e.dom.setAttrib(t, "src", t.getAttribute("src"))
                                        })(e, o), se(o.parentNode)) {
                                        const t = o.parentNode;
                                        fe(e, t), e.selection.select(o.parentNode)
                                    } else e.selection.select(o), ((e, t, o) => {
                                        const n = () => {
                                            o.onload = o.onerror = null, e.selection && (e.selection.select(o), e.nodeChanged())
                                        };
                                        o.onload = () => {
                                            t.width || t.height || !E(e) || e.dom.setAttribs(o, {
                                                width: String(o.clientWidth),
                                                height: String(o.clientHeight)
                                            }), n()
                                        }, o.onerror = n
                                    })(e, t, o)
                            })(e, r) : ((e, t) => {
                                if (t) {
                                    const o = e.dom.is(t.parentNode, "figure.image") ? t.parentNode : t;
                                    e.dom.remove(o), e.focus(), e.nodeChanged(), e.dom.isEmpty(e.getBody()) && (e.setContent(""), e.selection.setCursorLocation())
                                }
                            })(e, o)
                        } else t.src && ve(e, {
                            src: "",
                            alt: "",
                            title: "",
                            width: "",
                            height: "",
                            class: "",
                            style: "",
                            caption: !1,
                            hspace: "",
                            vspace: "",
                            border: "",
                            borderStyle: "",
                            isDecorative: !1,
                            ...t
                        })
                    },
                    ye = (we = (e, t) => i(e) && i(t) ? ye(e, t) : t, (...e) => {
                        if (0 === e.length) throw new Error("Can't merge zero objects");
                        const t = {};
                        for (let o = 0; o < e.length; o++) {
                            const n = e[o];
                            for (const e in n) b(n, e) && (t[e] = we(t[e], n[e]))
                        }
                        return t
                    });
                var we, xe = tinymce.util.Tools.resolve("tinymce.util.ImageUploader"),
                    Ce = tinymce.util.Tools.resolve("tinymce.util.Tools");
                const Se = e => s(e.value) ? e.value : "",
                    ke = (e, t) => {
                        const o = [];
                        return Ce.each(e, (e => {
                            const n = (e => s(e.text) ? e.text : s(e.title) ? e.title : "")(e);
                            if (void 0 !== e.menu) {
                                const r = ke(e.menu, t);
                                o.push({
                                    text: n,
                                    items: r
                                })
                            } else {
                                const r = t(e);
                                o.push({
                                    text: n,
                                    value: r
                                })
                            }
                        })), o
                    },
                    _e = (e = Se) => t => t ? p.from(t).map((t => ke(t, e))) : p.none(),
                    Oe = (e, t) => ((e, o) => {
                        for (let o = 0; o < e.length; o++) {
                            const r = (e => b(e, "items"))(n = e[o]) ? Oe(n.items, t) : n.value === t ? p.some(n) : p.none();
                            if (r.isSome()) return r
                        }
                        var n;
                        return p.none()
                    })(e),
                    Te = _e,
                    Ee = (e, t) => e.bind((e => Oe(e, t))),
                    Ae = e => {
                        const t = Te((t => e.convertURL(t.value || t.url || "", "src"))),
                            o = new Promise((o => {
                                ((e, t) => {
                                    const o = H(e);
                                    s(o) ? fetch(o).then((e => {
                                        e.ok && e.json().then(t)
                                    })) : m(o) ? o(t) : t(o)
                                })(e, (e => {
                                    o(t(e).map((e => w([
                                        [{
                                            text: "None",
                                            value: ""
                                        }], e
                                    ]))))
                                }))
                            })),
                            n = (x = R(e), _e(Se)(x)),
                            r = A(e),
                            a = M(e),
                            i = (e => O(e.options.get("images_upload_url")))(e),
                            l = (e => u(e.options.get("images_upload_handler")))(e),
                            c = (e => {
                                const t = pe(e);
                                return t ? ce((t => he(e, t)), t) : {
                                    src: "",
                                    alt: "",
                                    title: "",
                                    width: "",
                                    height: "",
                                    class: "",
                                    style: "",
                                    caption: !1,
                                    hspace: "",
                                    vspace: "",
                                    border: "",
                                    borderStyle: "",
                                    isDecorative: !1
                                }
                            })(e),
                            d = D(e),
                            g = B(e),
                            h = E(e),
                            f = L(e),
                            v = I(e),
                            b = P(e),
                            y = p.some(N(e)).filter((e => s(e) && e.length > 0));
                        var x;
                        return o.then((e => ({
                            image: c,
                            imageList: e,
                            classList: n,
                            hasAdvTab: r,
                            hasUploadTab: a,
                            hasUploadUrl: i,
                            hasUploadHandler: l,
                            hasDescription: d,
                            hasImageTitle: g,
                            hasDimensions: h,
                            hasImageCaption: f,
                            prependURL: y,
                            hasAccessibilityOptions: v,
                            automaticUploads: b
                        })))
                    },
                    Me = e => {
                        const t = e.imageList.map((e => ({
                                name: "images",
                                type: "listbox",
                                label: "Image list",
                                items: e
                            }))),
                            o = {
                                name: "alt",
                                type: "input",
                                label: "Alternative description",
                                enabled: !(e.hasAccessibilityOptions && e.image.isDecorative)
                            },
                            n = e.classList.map((e => ({
                                name: "classes",
                                type: "listbox",
                                label: "Class",
                                items: e
                            })));
                        return w([
                            [{
                                name: "src",
                                type: "urlinput",
                                filetype: "image",
                                label: "Source"
                            }], t.toArray(), e.hasAccessibilityOptions && e.hasDescription ? [{
                                type: "label",
                                label: "Accessibility",
                                items: [{
                                    name: "isDecorative",
                                    type: "checkbox",
                                    label: "Image is decorative"
                                }]
                            }] : [], e.hasDescription ? [o] : [], e.hasImageTitle ? [{
                                name: "title",
                                type: "input",
                                label: "Image title"
                            }] : [], e.hasDimensions ? [{
                                name: "dimensions",
                                type: "sizeinput"
                            }] : [],
                            [{ ...(r = e.classList.isSome() && e.hasImageCaption, r ? {
                                    type: "grid",
                                    columns: 2
                                } : {
                                    type: "panel"
                                }),
                                items: w([n.toArray(), e.hasImageCaption ? [{
                                    type: "label",
                                    label: "Caption",
                                    items: [{
                                        type: "checkbox",
                                        name: "caption",
                                        label: "Show caption"
                                    }]
                                }] : []])
                            }]
                        ]);
                        var r
                    },
                    Ne = e => ({
                        title: "General",
                        name: "general",
                        items: Me(e)
                    }),
                    Re = Me,
                    De = e => ({
                        src: {
                            value: e.src,
                            meta: {}
                        },
                        images: e.src,
                        alt: e.alt,
                        title: e.title,
                        dimensions: {
                            width: e.width,
                            height: e.height
                        },
                        classes: e.class,
                        caption: e.caption,
                        style: e.style,
                        vspace: e.vspace,
                        border: e.border,
                        hspace: e.hspace,
                        borderstyle: e.borderStyle,
                        fileinput: [],
                        isDecorative: e.isDecorative
                    }),
                    Be = (e, t) => ({
                        src: e.src.value,
                        alt: null !== e.alt && 0 !== e.alt.length || !t ? e.alt : null,
                        title: e.title,
                        width: e.dimensions.width,
                        height: e.dimensions.height,
                        class: e.classes,
                        style: e.style,
                        caption: e.caption,
                        hspace: e.hspace,
                        vspace: e.vspace,
                        border: e.border,
                        borderStyle: e.borderstyle,
                        isDecorative: e.isDecorative
                    }),
                    Le = (e, t, o, n) => {
                        ((e, t) => {
                            const o = t.getData();
                            ((e, t) => /^(?:[a-zA-Z]+:)?\/\//.test(t) ? p.none() : e.prependURL.bind((e => t.substring(0, e.length) !== e ? p.some(e + t) : p.none())))(e, o.src.value).each((e => {
                                t.setData({
                                    src: {
                                        value: e,
                                        meta: o.src.meta
                                    }
                                })
                            }))
                        })(t, n), ((e, t) => {
                            const o = t.getData(),
                                n = o.src.meta;
                            if (void 0 !== n) {
                                const r = ye({}, o);
                                ((e, t, o) => {
                                    e.hasDescription && s(o.alt) && (t.alt = o.alt), e.hasAccessibilityOptions && (t.isDecorative = o.isDecorative || t.isDecorative || !1), e.hasImageTitle && s(o.title) && (t.title = o.title), e.hasDimensions && (s(o.width) && (t.dimensions.width = o.width), s(o.height) && (t.dimensions.height = o.height)), s(o.class) && Ee(e.classList, o.class).each((e => {
                                        t.classes = e.value
                                    })), e.hasImageCaption && d(o.caption) && (t.caption = o.caption), e.hasAdvTab && (s(o.style) && (t.style = o.style), s(o.vspace) && (t.vspace = o.vspace), s(o.border) && (t.border = o.border), s(o.hspace) && (t.hspace = o.hspace), s(o.borderstyle) && (t.borderstyle = o.borderstyle))
                                })(e, r, n), t.setData(r)
                            }
                        })(t, n), ((e, t, o, n) => {
                            const r = n.getData(),
                                s = r.src.value,
                                a = r.src.meta || {};
                            a.width || a.height || !t.hasDimensions || (O(s) ? e.imageSize(s).then((e => {
                                o.open && n.setData({
                                    dimensions: e
                                })
                            })).catch((e => console.error(e))) : n.setData({
                                dimensions: {
                                    width: "",
                                    height: ""
                                }
                            }))
                        })(e, t, o, n), ((e, t, o) => {
                            const n = o.getData(),
                                r = Ee(e.imageList, n.src.value);
                            t.prevImage = r, o.setData({
                                images: r.map((e => e.value)).getOr("")
                            })
                        })(t, o, n)
                    },
                    He = (e, t, o, n) => {
                        const r = n.getData();
                        var s;
                        n.block("Uploading image"), (s = r.fileinput, ((e, t) => 0 < e.length ? p.some(e[0]) : p.none())(s)).fold((() => {
                            n.unblock()
                        }), (r => {
                            const s = URL.createObjectURL(r),
                                a = () => {
                                    n.unblock(), URL.revokeObjectURL(s)
                                },
                                i = r => {
                                    n.setData({
                                        src: {
                                            value: r,
                                            meta: {}
                                        }
                                    }), n.showTab("general"), Le(e, t, o, n)
                                };
                            var l;
                            (l = r, new Promise(((e, t) => {
                                const o = new FileReader;
                                o.onload = () => {
                                    e(o.result)
                                }, o.onerror = () => {
                                    var e;
                                    t(null === (e = o.error) || void 0 === e ? void 0 : e.message)
                                }, o.readAsDataURL(l)
                            }))).then((o => {
                                const l = e.createBlobCache(r, s, o);
                                t.automaticUploads ? e.uploadImage(l).then((e => {
                                    i(e.url), a()
                                })).catch((t => {
                                    a(), e.alertErr(t)
                                })) : (e.addToBlobCache(l), i(l.blobUri()), n.unblock())
                            }))
                        }))
                    },
                    Ie = (e, t, o) => (n, r) => {
                        "src" === r.name ? Le(e, t, o, n) : "images" === r.name ? ((e, t, o, n) => {
                            const r = n.getData(),
                                s = Ee(t.imageList, r.images);
                            s.each((e => {
                                const t = "" === r.alt || o.prevImage.map((e => e.text === r.alt)).getOr(!1);
                                t ? "" === e.value ? n.setData({
                                    src: e,
                                    alt: o.prevAlt
                                }) : n.setData({
                                    src: e,
                                    alt: e.text
                                }) : n.setData({
                                    src: e
                                })
                            })), o.prevImage = s, Le(e, t, o, n)
                        })(e, t, o, n) : "alt" === r.name ? o.prevAlt = n.getData().alt : "fileinput" === r.name ? He(e, t, o, n) : "isDecorative" === r.name && n.setEnabled("alt", !n.getData().isDecorative)
                    },
                    Pe = e => () => {
                        e.open = !1
                    },
                    ze = e => e.hasAdvTab || e.hasUploadUrl || e.hasUploadHandler ? {
                        type: "tabpanel",
                        tabs: w([
                            [Ne(e)], e.hasAdvTab ? [{
                                title: "Advanced",
                                name: "advanced",
                                items: [{
                                    type: "grid",
                                    columns: 2,
                                    items: [{
                                        type: "input",
                                        label: "Vertical space",
                                        name: "vspace",
                                        inputMode: "numeric"
                                    }, {
                                        type: "input",
                                        label: "Horizontal space",
                                        name: "hspace",
                                        inputMode: "numeric"
                                    }, {
                                        type: "input",
                                        label: "Border width",
                                        name: "border",
                                        inputMode: "numeric"
                                    }, {
                                        type: "listbox",
                                        name: "borderstyle",
                                        label: "Border style",
                                        items: [{
                                            text: "Select...",
                                            value: ""
                                        }, {
                                            text: "Solid",
                                            value: "solid"
                                        }, {
                                            text: "Dotted",
                                            value: "dotted"
                                        }, {
                                            text: "Dashed",
                                            value: "dashed"
                                        }, {
                                            text: "Double",
                                            value: "double"
                                        }, {
                                            text: "Groove",
                                            value: "groove"
                                        }, {
                                            text: "Ridge",
                                            value: "ridge"
                                        }, {
                                            text: "Inset",
                                            value: "inset"
                                        }, {
                                            text: "Outset",
                                            value: "outset"
                                        }, {
                                            text: "None",
                                            value: "none"
                                        }, {
                                            text: "Hidden",
                                            value: "hidden"
                                        }]
                                    }]
                                }]
                            }] : [], e.hasUploadTab && (e.hasUploadUrl || e.hasUploadHandler) ? [{
                                title: "Upload",
                                name: "upload",
                                items: [{
                                    type: "dropzone",
                                    name: "fileinput"
                                }]
                            }] : []
                        ])
                    } : {
                        type: "panel",
                        items: Re(e)
                    },
                    Fe = (e, t, o) => n => {
                        const r = ye(De(t.image), n.getData()),
                            s = { ...r,
                                style: le(o.normalizeCss, Be(r, !1))
                            };
                        e.execCommand("mceUpdateImage", !1, Be(s, t.hasAccessibilityOptions)), e.editorUpload.uploadImagesAuto(), n.close()
                    },
                    Ve = e => t => U(e, t) ? (e => new Promise((t => {
                        const o = document.createElement("img"),
                            n = e => {
                                o.onload = o.onerror = null, o.parentNode && o.parentNode.removeChild(o), t(e)
                            };
                        o.onload = () => {
                            const e = {
                                width: z(o.width, o.clientWidth),
                                height: z(o.height, o.clientHeight)
                            };
                            n(Promise.resolve(e))
                        }, o.onerror = () => {
                            n(Promise.reject(`Failed to get image dimensions for: ${e}`))
                        };
                        const r = o.style;
                        r.visibility = "hidden", r.position = "fixed", r.bottom = r.left = "0px", r.width = r.height = "auto", document.body.appendChild(o), o.src = e
                    })))(e.documentBaseURI.toAbsolute(t)).then((e => ({
                        width: String(e.width),
                        height: String(e.height)
                    }))) : Promise.resolve({
                        width: "",
                        height: ""
                    }),
                    Ze = e => (t, o, n) => {
                        var r;
                        return e.editorUpload.blobCache.create({
                            blob: t,
                            blobUri: o,
                            name: null === (r = t.name) || void 0 === r ? void 0 : r.replace(/\.[^\.]+$/, ""),
                            filename: t.name,
                            base64: n.split(",")[1]
                        })
                    },
                    Ue = e => t => {
                        e.editorUpload.blobCache.add(t)
                    },
                    je = e => t => {
                        e.windowManager.alert(t)
                    },
                    We = e => t => he(e, t),
                    $e = e => t => e.dom.parseStyle(t),
                    qe = e => (t, o) => e.dom.serializeStyle(t, o),
                    Ge = e => t => xe(e).upload([t], !1).then((e => {
                        var t;
                        return 0 === e.length ? Promise.reject("Failed to upload image") : !1 === e[0].status ? Promise.reject(null === (t = e[0].error) || void 0 === t ? void 0 : t.message) : e[0]
                    })),
                    Ke = e => {
                        const t = {
                            imageSize: Ve(e),
                            addToBlobCache: Ue(e),
                            createBlobCache: Ze(e),
                            alertErr: je(e),
                            normalizeCss: We(e),
                            parseStyle: $e(e),
                            serializeStyle: qe(e),
                            uploadImage: Ge(e)
                        };
                        return {
                            open: () => {
                                Ae(e).then((o => {
                                    const n = (e => ({
                                        prevImage: Ee(e.imageList, e.image.src),
                                        prevAlt: e.image.alt,
                                        open: !0
                                    }))(o);
                                    return {
                                        title: "Insert/Edit Image",
                                        size: "normal",
                                        body: ze(o),
                                        buttons: [{
                                            type: "cancel",
                                            name: "cancel",
                                            text: "Cancel"
                                        }, {
                                            type: "submit",
                                            name: "save",
                                            text: "Save",
                                            primary: !0
                                        }],
                                        initialData: De(o.image),
                                        onSubmit: Fe(e, o, t),
                                        onChange: Ie(t, o, n),
                                        onClose: Pe(n)
                                    }
                                })).then(e.windowManager.open)
                            }
                        }
                    },
                    Ye = e => {
                        const t = e.attr("class");
                        return u(t) && /\bimage\b/.test(t)
                    },
                    Xe = e => t => {
                        let o = t.length;
                        const n = t => {
                            t.attr("contenteditable", e ? "true" : null)
                        };
                        for (; o--;) {
                            const r = t[o];
                            Ye(r) && (r.attr("contenteditable", e ? "false" : null), Ce.each(r.getAll("figcaption"), n))
                        }
                    };
                e.add("image", (e => {
                    (e => {
                        const t = e.options.register;
                        t("image_dimensions", {
                            processor: "boolean",
                            default: !0
                        }), t("image_advtab", {
                            processor: "boolean",
                            default: !1
                        }), t("image_uploadtab", {
                            processor: "boolean",
                            default: !0
                        }), t("image_prepend_url", {
                            processor: "string",
                            default: ""
                        }), t("image_class_list", {
                            processor: "object[]"
                        }), t("image_description", {
                            processor: "boolean",
                            default: !0
                        }), t("image_title", {
                            processor: "boolean",
                            default: !1
                        }), t("image_caption", {
                            processor: "boolean",
                            default: !1
                        }), t("image_list", {
                            processor: e => {
                                const t = !1 === e || s(e) || ((e, t) => {
                                    if (l(e)) {
                                        for (let o = 0, n = e.length; o < n; ++o)
                                            if (!t(e[o])) return !1;
                                        return !0
                                    }
                                    return !1
                                })(e, a) || m(e);
                                return t ? {
                                    value: e,
                                    valid: t
                                } : {
                                    valid: !1,
                                    message: "Must be false, a string, an array or a function."
                                }
                            },
                            default: !1
                        })
                    })(e), (e => {
                        e.on("PreInit", (() => {
                            e.parser.addNodeFilter("figure", Xe(!0)), e.serializer.addNodeFilter("figure", Xe(!1))
                        }))
                    })(e), (e => {
                        e.ui.registry.addToggleButton("image", {
                            icon: "image",
                            tooltip: "Insert/edit image",
                            onAction: Ke(e).open,
                            onSetup: t => (t.setActive(u(pe(e))), e.selection.selectorChangedWithUnbind("img:not([data-mce-object]):not([data-mce-placeholder]),figure.image", t.setActive).unbind)
                        }), e.ui.registry.addMenuItem("image", {
                            icon: "image",
                            text: "Image...",
                            onAction: Ke(e).open
                        }), e.ui.registry.addContextMenu("image", {
                            update: e => se(e) || "IMG" === e.nodeName && !Z(e) ? ["image"] : []
                        })
                    })(e), (e => {
                        e.addCommand("mceImage", Ke(e).open), e.addCommand("mceUpdateImage", ((t, o) => {
                            e.undoManager.transact((() => be(e, o)))
                        }))
                    })(e)
                }))
            }()
        },
        72682: function(e, t, o) {
            o(27384)
        },
        27384: function() {
            ! function() {
                "use strict";
                var e = tinymce.util.Tools.resolve("tinymce.PluginManager");
                const t = e => t => (e => {
                        const t = typeof e;
                        return null === e ? "null" : "object" === t && Array.isArray(e) ? "array" : "object" === t && (o = n = e, (r = String).prototype.isPrototypeOf(o) || (null === (s = n.constructor) || void 0 === s ? void 0 : s.name) === r.name) ? "string" : t;
                        var o, n, r, s
                    })(t) === e,
                    o = e => t => typeof t === e,
                    n = t("string"),
                    r = t("object"),
                    s = t("array"),
                    a = (null, e => null === e);
                const i = o("boolean"),
                    l = e => !(e => null == e)(e),
                    c = o("function"),
                    d = (e, t) => {
                        if (s(e)) {
                            for (let o = 0, n = e.length; o < n; ++o)
                                if (!t(e[o])) return !1;
                            return !0
                        }
                        return !1
                    },
                    u = () => {},
                    m = (e, t) => e === t;
                class g {
                    constructor(e, t) {
                        this.tag = e, this.value = t
                    }
                    static some(e) {
                        return new g(!0, e)
                    }
                    static none() {
                        return g.singletonNone
                    }
                    fold(e, t) {
                        return this.tag ? t(this.value) : e()
                    }
                    isSome() {
                        return this.tag
                    }
                    isNone() {
                        return !this.tag
                    }
                    map(e) {
                        return this.tag ? g.some(e(this.value)) : g.none()
                    }
                    bind(e) {
                        return this.tag ? e(this.value) : g.none()
                    }
                    exists(e) {
                        return this.tag && e(this.value)
                    }
                    forall(e) {
                        return !this.tag || e(this.value)
                    }
                    filter(e) {
                        return !this.tag || e(this.value) ? this : g.none()
                    }
                    getOr(e) {
                        return this.tag ? this.value : e
                    }
                    or(e) {
                        return this.tag ? this : e
                    }
                    getOrThunk(e) {
                        return this.tag ? this.value : e()
                    }
                    orThunk(e) {
                        return this.tag ? this : e()
                    }
                    getOrDie(e) {
                        if (this.tag) return this.value;
                        throw new Error(null != e ? e : "Called getOrDie on None")
                    }
                    static from(e) {
                        return l(e) ? g.some(e) : g.none()
                    }
                    getOrNull() {
                        return this.tag ? this.value : null
                    }
                    getOrUndefined() {
                        return this.value
                    }
                    each(e) {
                        this.tag && e(this.value)
                    }
                    toArray() {
                        return this.tag ? [this.value] : []
                    }
                    toString() {
                        return this.tag ? `some(${this.value})` : "none()"
                    }
                }
                g.singletonNone = new g(!1);
                const h = Array.prototype.indexOf,
                    p = Array.prototype.push,
                    f = e => {
                        const t = [];
                        for (let o = 0, n = e.length; o < n; ++o) {
                            if (!s(e[o])) throw new Error("Arr.flatten item " + o + " was not an array, input: " + e);
                            p.apply(t, e[o])
                        }
                        return t
                    },
                    v = (e, t) => {
                        for (let o = 0; o < e.length; o++) {
                            const n = t(e[o], o);
                            if (n.isSome()) return n
                        }
                        return g.none()
                    },
                    b = (e, t, o = m) => e.exists((e => o(e, t))),
                    y = e => {
                        const t = [],
                            o = e => {
                                t.push(e)
                            };
                        for (let t = 0; t < e.length; t++) e[t].each(o);
                        return t
                    },
                    w = (e, t) => e ? g.some(t) : g.none(),
                    x = e => t => t.options.get(e),
                    C = x("link_assume_external_targets"),
                    S = x("link_context_toolbar"),
                    k = x("link_list"),
                    _ = x("link_default_target"),
                    O = x("link_default_protocol"),
                    T = x("link_target_list"),
                    E = x("link_rel_list"),
                    A = x("link_class_list"),
                    M = x("link_title"),
                    N = x("allow_unsafe_link_target"),
                    R = x("link_quicklink");
                var D = tinymce.util.Tools.resolve("tinymce.util.Tools");
                const B = e => n(e.value) ? e.value : "",
                    L = (e, t) => {
                        const o = [];
                        return D.each(e, (e => {
                            const r = (e => n(e.text) ? e.text : n(e.title) ? e.title : "")(e);
                            if (void 0 !== e.menu) {
                                const n = L(e.menu, t);
                                o.push({
                                    text: r,
                                    items: n
                                })
                            } else {
                                const n = t(e);
                                o.push({
                                    text: r,
                                    value: n
                                })
                            }
                        })), o
                    },
                    H = (e = B) => t => g.from(t).map((t => L(t, e))),
                    I = e => H(B)(e),
                    P = H,
                    z = (e, t) => o => ({
                        name: e,
                        type: "listbox",
                        label: t,
                        items: o
                    }),
                    F = B,
                    V = Object.keys,
                    Z = Object.hasOwnProperty,
                    U = (e, t) => Z.call(e, t);
                var j = tinymce.util.Tools.resolve("tinymce.dom.TreeWalker"),
                    W = tinymce.util.Tools.resolve("tinymce.util.URI");
                const $ = e => l(e) && "a" === e.nodeName.toLowerCase(),
                    q = e => $(e) && !!Y(e),
                    G = (e, t) => {
                        if (e.collapsed) return []; {
                            const o = e.cloneContents(),
                                n = o.firstChild,
                                r = new j(n, o),
                                s = [];
                            let a = n;
                            do {
                                t(a) && s.push(a)
                            } while (a = r.next());
                            return s
                        }
                    },
                    K = e => /^\w+:/i.test(e),
                    Y = e => {
                        var t, o;
                        return null !== (o = null !== (t = e.getAttribute("data-mce-href")) && void 0 !== t ? t : e.getAttribute("href")) && void 0 !== o ? o : ""
                    },
                    X = (e, t) => {
                        const o = ["noopener"],
                            n = e ? e.split(/\s+/) : [],
                            r = e => e.filter((e => -1 === D.inArray(o, e))),
                            s = t ? (e => (e = r(e)).length > 0 ? e.concat(o) : o)(n) : r(n);
                        return s.length > 0 ? (e => D.trim(e.sort().join(" ")))(s) : ""
                    },
                    J = (e, t) => (t = t || e.selection.getNode(), ne(t) ? g.from(e.dom.select("a[href]", t)[0]) : g.from(e.dom.getParent(t, "a[href]"))),
                    Q = (e, t) => J(e, t).isSome(),
                    ee = (e, t) => t.fold((() => e.getContent({
                        format: "text"
                    })), (e => e.innerText || e.textContent || "")).replace(/\uFEFF/g, ""),
                    te = e => D.grep(e, q).length > 0,
                    oe = e => {
                        const t = e.schema.getTextInlineElements();
                        if (J(e).exists((e => e.hasAttribute("data-mce-block")))) return !1;
                        const o = e.selection.getRng();
                        return !!o.collapsed || 0 === G(o, (e => 1 === e.nodeType && !$(e) && !U(t, e.nodeName.toLowerCase()))).length
                    },
                    ne = e => l(e) && "FIGURE" === e.nodeName && /\bimage\b/i.test(e.className),
                    re = (e, t, o) => {
                        const n = e.selection.getNode(),
                            r = J(e, n),
                            s = ((e, t) => {
                                const o = { ...t
                                };
                                if (0 === E(e).length && !N(e)) {
                                    const e = X(o.rel, "_blank" === o.target);
                                    o.rel = e || null
                                }
                                return g.from(o.target).isNone() && !1 === T(e) && (o.target = _(e)), o.href = ((e, t) => "http" !== t && "https" !== t || K(e) ? e : t + "://" + e)(o.href, C(e)), o
                            })(e, (e => {
                                return t = ["title", "rel", "class", "target"], o = (t, o) => (e[o].each((e => {
                                    t[o] = e.length > 0 ? e : null
                                })), t), n = {
                                    href: e.href
                                }, ((e, t) => {
                                    for (let o = 0, n = e.length; o < n; o++) t(e[o], o)
                                })(t, ((e, t) => {
                                    n = o(n, e)
                                })), n;
                                var t, o, n
                            })(o));
                        e.undoManager.transact((() => {
                            o.href === t.href && t.attach(), r.fold((() => {
                                ((e, t, o, n) => {
                                    const r = e.dom;
                                    ne(t) ? ce(r, t, n) : o.fold((() => {
                                        e.execCommand("mceInsertLink", !1, n)
                                    }), (t => {
                                        e.insertContent(r.createHTML("a", n, r.encode(t)))
                                    }))
                                })(e, n, o.text, s)
                            }), (t => {
                                e.focus(), ((e, t, o, n) => {
                                    o.each((e => {
                                        U(t, "innerText") ? t.innerText = e : t.textContent = e
                                    })), e.dom.setAttribs(t, n), e.selection.select(t)
                                })(e, t, o.text, s)
                            }))
                        }))
                    },
                    se = e => {
                        const {
                            class: t,
                            href: o,
                            rel: n,
                            target: r,
                            text: s,
                            title: i
                        } = e;
                        return ((e, t) => {
                            const o = {};
                            var n;
                            return ((e, t, o, n) => {
                                ((e, t) => {
                                    const o = V(e);
                                    for (let n = 0, r = o.length; n < r; n++) {
                                        const r = o[n];
                                        t(e[r], r)
                                    }
                                })(e, ((e, r) => {
                                    (t(e, r) ? o : n)(e, r)
                                }))
                            })(e, ((e, t) => !1 === a(e)), (n = o, (e, t) => {
                                n[t] = e
                            }), u), o
                        })({
                            class: t.getOrNull(),
                            href: o,
                            rel: n.getOrNull(),
                            target: r.getOrNull(),
                            text: s.getOrNull(),
                            title: i.getOrNull()
                        })
                    },
                    ae = (e, t, o) => {
                        const n = ((e, t) => {
                            const o = e.options.get,
                                n = {
                                    allow_html_data_urls: o("allow_html_data_urls"),
                                    allow_script_urls: o("allow_script_urls"),
                                    allow_svg_data_urls: o("allow_svg_data_urls")
                                },
                                r = t.href;
                            return { ...t,
                                href: W.isDomSafe(r, "a", n) ? r : ""
                            }
                        })(e, o);
                        e.hasPlugin("rtc", !0) ? e.execCommand("createlink", !1, se(n)) : re(e, t, n)
                    },
                    ie = e => {
                        e.hasPlugin("rtc", !0) ? e.execCommand("unlink") : (e => {
                            e.undoManager.transact((() => {
                                const t = e.selection.getNode();
                                ne(t) ? le(e, t) : (e => {
                                    const t = e.dom,
                                        o = e.selection,
                                        n = o.getBookmark(),
                                        r = o.getRng().cloneRange(),
                                        s = t.getParent(r.startContainer, "a[href]", e.getBody()),
                                        a = t.getParent(r.endContainer, "a[href]", e.getBody());
                                    s && r.setStartBefore(s), a && r.setEndAfter(a), o.setRng(r), e.execCommand("unlink"), o.moveToBookmark(n)
                                })(e), e.focus()
                            }))
                        })(e)
                    },
                    le = (e, t) => {
                        var o;
                        const n = e.dom.select("img", t)[0];
                        if (n) {
                            const r = e.dom.getParents(n, "a[href]", t)[0];
                            r && (null === (o = r.parentNode) || void 0 === o || o.insertBefore(n, r), e.dom.remove(r))
                        }
                    },
                    ce = (e, t, o) => {
                        var n;
                        const r = e.select("img", t)[0];
                        if (r) {
                            const t = e.create("a", o);
                            null === (n = r.parentNode) || void 0 === n || n.insertBefore(t, r), t.appendChild(r)
                        }
                    },
                    de = (e, t) => v(t, (t => (e => {
                        return U(t = e, o = "items") && void 0 !== t[o] && null !== t[o];
                        var t, o
                    })(t) ? de(e, t.items) : w(t.value === e, t))),
                    ue = (e, t) => {
                        const o = {
                                text: e.text,
                                title: e.title
                            },
                            n = (e, n) => {
                                const r = (s = t, a = n, "link" === a ? s.link : "anchor" === a ? s.anchor : g.none()).getOr([]);
                                var s, a;
                                return ((e, t, o, n) => {
                                    const r = n[t],
                                        s = e.length > 0;
                                    return void 0 !== r ? de(r, o).map((t => ({
                                        url: {
                                            value: t.value,
                                            meta: {
                                                text: s ? e : t.text,
                                                attach: u
                                            }
                                        },
                                        text: s ? e : t.text
                                    }))) : g.none()
                                })(o.text, n, r, e)
                            };
                        return {
                            onChange: (e, t) => {
                                const r = t.name;
                                return "url" === r ? (e => {
                                    const t = (n = e.url, w(o.text.length <= 0, g.from(null === (r = n.meta) || void 0 === r ? void 0 : r.text).getOr(n.value)));
                                    var n, r;
                                    const s = (e => {
                                        var t;
                                        return w(o.title.length <= 0, g.from(null === (t = e.meta) || void 0 === t ? void 0 : t.title).getOr(""))
                                    })(e.url);
                                    return t.isSome() || s.isSome() ? g.some({ ...t.map((e => ({
                                            text: e
                                        }))).getOr({}),
                                        ...s.map((e => ({
                                            title: e
                                        }))).getOr({})
                                    }) : g.none()
                                })(e()) : ((e, t) => h.call(e, t))(["anchor", "link"], r) > -1 ? n(e(), r) : "text" === r || "title" === r ? (o[r] = e()[r], g.none()) : g.none()
                            }
                        }
                    };
                var me = tinymce.util.Tools.resolve("tinymce.util.Delay");
                const ge = e => {
                        const t = e.href;
                        return t.indexOf("@") > 0 && -1 === t.indexOf("/") && -1 === t.indexOf("mailto:") ? g.some({
                            message: "The URL you entered seems to be an email address. Do you want to add the required mailto: prefix?",
                            preprocess: e => ({ ...e,
                                href: "mailto:" + t
                            })
                        }) : g.none()
                    },
                    he = (e, t) => o => {
                        const n = o.href;
                        return 1 === e && !K(n) || 0 === e && /^\s*www(\.|\d\.)/i.test(n) ? g.some({
                            message: `The URL you entered seems to be an external link. Do you want to add the required ${t}:// prefix?`,
                            preprocess: e => ({ ...e,
                                href: t + "://" + n
                            })
                        }) : g.none()
                    },
                    pe = e => {
                        const t = e.dom.select("a:not([href])"),
                            o = f(((e, t) => {
                                const o = e.length,
                                    n = new Array(o);
                                for (let r = 0; r < o; r++) {
                                    const o = e[r];
                                    n[r] = t(o, r)
                                }
                                return n
                            })(t, (e => {
                                const t = e.name || e.id;
                                return t ? [{
                                    text: t,
                                    value: "#" + t
                                }] : []
                            })));
                        return o.length > 0 ? g.some([{
                            text: "None",
                            value: ""
                        }].concat(o)) : g.none()
                    },
                    fe = e => {
                        const t = A(e);
                        return t.length > 0 ? I(t) : g.none()
                    },
                    ve = e => {
                        try {
                            return g.some(JSON.parse(e))
                        } catch (e) {
                            return g.none()
                        }
                    },
                    be = (e, t) => {
                        const o = E(e);
                        if (o.length > 0) {
                            const n = b(t, "_blank"),
                                r = e => X(F(e), n);
                            return (!1 === N(e) ? P(r) : I)(o)
                        }
                        return g.none()
                    },
                    ye = [{
                        text: "Current window",
                        value: ""
                    }, {
                        text: "New window",
                        value: "_blank"
                    }],
                    we = e => {
                        const t = T(e);
                        return s(t) ? I(t).orThunk((() => g.some(ye))) : !1 === t ? g.none() : g.some(ye)
                    },
                    xe = (e, t, o) => {
                        const n = e.getAttrib(t, o);
                        return null !== n && n.length > 0 ? g.some(n) : g.none()
                    },
                    Ce = (e, t) => (e => {
                        const t = t => e.convertURL(t.value || t.url || "", "href"),
                            o = k(e);
                        return new Promise((e => {
                            n(o) ? fetch(o).then((e => e.ok ? e.text().then(ve) : Promise.reject())).then(e, (() => e(g.none()))) : c(o) ? o((t => e(g.some(t)))) : e(g.from(o))
                        })).then((e => e.bind(P(t)).map((e => e.length > 0 ? [{
                            text: "None",
                            value: ""
                        }].concat(e) : e))))
                    })(e).then((o => {
                        const n = ((e, t) => {
                            const o = e.dom,
                                n = oe(e) ? g.some(ee(e.selection, t)) : g.none(),
                                r = t.bind((e => g.from(o.getAttrib(e, "href")))),
                                s = t.bind((e => g.from(o.getAttrib(e, "target")))),
                                a = t.bind((e => xe(o, e, "rel"))),
                                i = t.bind((e => xe(o, e, "class")));
                            return {
                                url: r,
                                text: n,
                                title: t.bind((e => xe(o, e, "title"))),
                                target: s,
                                rel: a,
                                linkClass: i
                            }
                        })(e, t);
                        return {
                            anchor: n,
                            catalogs: {
                                targets: we(e),
                                rels: be(e, n.target),
                                classes: fe(e),
                                anchor: pe(e),
                                link: o
                            },
                            optNode: t,
                            flags: {
                                titleEnabled: M(e)
                            }
                        }
                    })),
                    Se = e => {
                        const t = (e => {
                            const t = J(e);
                            return Ce(e, t)
                        })(e);
                        t.then((t => {
                            const o = ((e, t) => o => {
                                const n = o.getData();
                                if (!n.url.value) return ie(e), void o.close();
                                const r = e => g.from(n[e]).filter((o => !b(t.anchor[e], o))),
                                    s = {
                                        href: n.url.value,
                                        text: r("text"),
                                        target: r("target"),
                                        rel: r("rel"),
                                        class: r("linkClass"),
                                        title: r("title")
                                    },
                                    a = {
                                        href: n.url.value,
                                        attach: void 0 !== n.url.meta && n.url.meta.attach ? n.url.meta.attach : u
                                    };
                                ((e, t) => v([ge, he(C(e), O(e))], (e => e(t))).fold((() => Promise.resolve(t)), (o => new Promise((n => {
                                    ((e, t, o) => {
                                        const n = e.selection.getRng();
                                        me.setEditorTimeout(e, (() => {
                                            e.windowManager.confirm(t, (t => {
                                                e.selection.setRng(n), o(t)
                                            }))
                                        }))
                                    })(e, o.message, (e => {
                                        n(e ? o.preprocess(t) : t)
                                    }))
                                })))))(e, s).then((t => {
                                    ae(e, a, t)
                                })), o.close()
                            })(e, t);
                            return ((e, t, o) => {
                                const n = e.anchor.text.map((() => ({
                                        name: "text",
                                        type: "input",
                                        label: "Text to display"
                                    }))).toArray(),
                                    r = e.flags.titleEnabled ? [{
                                        name: "title",
                                        type: "input",
                                        label: "Title"
                                    }] : [],
                                    s = ((e, t) => {
                                        const o = e.anchor,
                                            n = o.url.getOr("");
                                        return {
                                            url: {
                                                value: n,
                                                meta: {
                                                    original: {
                                                        value: n
                                                    }
                                                }
                                            },
                                            text: o.text.getOr(""),
                                            title: o.title.getOr(""),
                                            anchor: n,
                                            link: n,
                                            rel: o.rel.getOr(""),
                                            target: o.target.or(t).getOr(""),
                                            linkClass: o.linkClass.getOr("")
                                        }
                                    })(e, g.from(_(o))),
                                    a = e.catalogs,
                                    i = ue(s, a);
                                return {
                                    title: "Insert/Edit Link",
                                    size: "normal",
                                    body: {
                                        type: "panel",
                                        items: f([
                                            [{
                                                name: "url",
                                                type: "urlinput",
                                                filetype: "file",
                                                label: "URL"
                                            }], n, r, y([a.anchor.map(z("anchor", "Anchors")), a.rels.map(z("rel", "Rel")), a.targets.map(z("target", "Open link in...")), a.link.map(z("link", "Link list")), a.classes.map(z("linkClass", "Class"))])
                                        ])
                                    },
                                    buttons: [{
                                        type: "cancel",
                                        name: "cancel",
                                        text: "Cancel"
                                    }, {
                                        type: "submit",
                                        name: "save",
                                        text: "Save",
                                        primary: !0
                                    }],
                                    initialData: s,
                                    onChange: (e, {
                                        name: t
                                    }) => {
                                        i.onChange(e.getData, {
                                            name: t
                                        }).each((t => {
                                            e.setData(t)
                                        }))
                                    },
                                    onSubmit: t
                                }
                            })(t, o, e)
                        })).then((t => {
                            e.windowManager.open(t)
                        }))
                    };
                var ke = tinymce.util.Tools.resolve("tinymce.util.VK");
                const _e = (e, t) => e.dom.getParent(t, "a[href]"),
                    Oe = e => _e(e, e.selection.getStart()),
                    Te = (e, t) => {
                        if (t) {
                            const o = Y(t);
                            if (/^#/.test(o)) {
                                const t = e.dom.select(o);
                                t.length && e.selection.scrollIntoView(t[0], !0)
                            } else(e => {
                                const t = document.createElement("a");
                                t.target = "_blank", t.href = e, t.rel = "noreferrer noopener";
                                const o = document.createEvent("MouseEvents");
                                o.initMouseEvent("click", !0, !0, window, 0, 0, 0, 0, 0, !1, !1, !1, !1, 0, null), ((e, t) => {
                                    document.body.appendChild(e), e.dispatchEvent(t), document.body.removeChild(e)
                                })(t, o)
                            })(t.href)
                        }
                    },
                    Ee = e => () => {
                        e.execCommand("mceLink", !1, {
                            dialog: !0
                        })
                    },
                    Ae = e => () => {
                        Te(e, Oe(e))
                    },
                    Me = (e, t) => (e.on("NodeChange", t), () => e.off("NodeChange", t)),
                    Ne = e => t => {
                        const o = () => t.setActive(!e.mode.isReadOnly() && Q(e, e.selection.getNode()));
                        return o(), Me(e, o)
                    },
                    Re = e => t => {
                        const o = () => t.setEnabled(Q(e, e.selection.getNode()));
                        return o(), Me(e, o)
                    },
                    De = e => t => {
                        const o = t => {
                                return te(t) || (o = e.selection.getRng(), G(o, q).length > 0);
                                var o
                            },
                            n = e.dom.getParents(e.selection.getStart());
                        return t.setEnabled(o(n)), Me(e, (e => t.setEnabled(o(e.parents))))
                    };
                e.add("link", (e => {
                    (e => {
                        const t = e.options.register;
                        t("link_assume_external_targets", {
                            processor: e => {
                                const t = n(e) || i(e);
                                return t ? !0 === e ? {
                                    value: 1,
                                    valid: t
                                } : "http" === e || "https" === e ? {
                                    value: e,
                                    valid: t
                                } : {
                                    value: 0,
                                    valid: t
                                } : {
                                    valid: !1,
                                    message: "Must be a string or a boolean."
                                }
                            },
                            default: !1
                        }), t("link_context_toolbar", {
                            processor: "boolean",
                            default: !1
                        }), t("link_list", {
                            processor: e => n(e) || c(e) || d(e, r)
                        }), t("link_default_target", {
                            processor: "string"
                        }), t("link_default_protocol", {
                            processor: "string",
                            default: "https"
                        }), t("link_target_list", {
                            processor: e => i(e) || d(e, r),
                            default: !0
                        }), t("link_rel_list", {
                            processor: "object[]",
                            default: []
                        }), t("link_class_list", {
                            processor: "object[]",
                            default: []
                        }), t("link_title", {
                            processor: "boolean",
                            default: !0
                        }), t("allow_unsafe_link_target", {
                            processor: "boolean",
                            default: !1
                        }), t("link_quicklink", {
                            processor: "boolean",
                            default: !1
                        })
                    })(e), (e => {
                        e.ui.registry.addToggleButton("link", {
                            icon: "link",
                            tooltip: "Insert/edit link",
                            onAction: Ee(e),
                            onSetup: Ne(e)
                        }), e.ui.registry.addButton("openlink", {
                            icon: "new-tab",
                            tooltip: "Open link",
                            onAction: Ae(e),
                            onSetup: Re(e)
                        }), e.ui.registry.addButton("unlink", {
                            icon: "unlink",
                            tooltip: "Remove link",
                            onAction: () => ie(e),
                            onSetup: De(e)
                        })
                    })(e), (e => {
                        e.ui.registry.addMenuItem("openlink", {
                            text: "Open link",
                            icon: "new-tab",
                            onAction: Ae(e),
                            onSetup: Re(e)
                        }), e.ui.registry.addMenuItem("link", {
                            icon: "link",
                            text: "Link...",
                            shortcut: "Meta+K",
                            onAction: Ee(e)
                        }), e.ui.registry.addMenuItem("unlink", {
                            icon: "unlink",
                            text: "Remove link",
                            onAction: () => ie(e),
                            onSetup: De(e)
                        })
                    })(e), (e => {
                        e.ui.registry.addContextMenu("link", {
                            update: t => te(e.dom.getParents(t, "a")) ? "link unlink openlink" : "link"
                        })
                    })(e), (e => {
                        const t = t => {
                            const o = e.selection.getNode();
                            return t.setEnabled(Q(e, o)), u
                        };
                        e.ui.registry.addContextForm("quicklink", {
                            launch: {
                                type: "contextformtogglebutton",
                                icon: "link",
                                tooltip: "Link",
                                onSetup: Ne(e)
                            },
                            label: "Link",
                            predicate: t => S(e) && Q(e, t),
                            initValue: () => J(e).fold((() => ""), Y),
                            commands: [{
                                type: "contextformtogglebutton",
                                icon: "link",
                                tooltip: "Link",
                                primary: !0,
                                onSetup: t => {
                                    const o = e.selection.getNode();
                                    return t.setActive(Q(e, o)), Ne(e)(t)
                                },
                                onAction: t => {
                                    const o = t.getValue(),
                                        n = (t => {
                                            const o = J(e),
                                                n = oe(e);
                                            if (o.isNone() && n) {
                                                const n = ee(e.selection, o);
                                                return g.some(n.length > 0 ? n : t)
                                            }
                                            return g.none()
                                        })(o);
                                    ae(e, {
                                        href: o,
                                        attach: u
                                    }, {
                                        href: o,
                                        text: n,
                                        title: g.none(),
                                        rel: g.none(),
                                        target: g.none(),
                                        class: g.none()
                                    }), (e => {
                                        e.selection.collapse(!1)
                                    })(e), t.hide()
                                }
                            }, {
                                type: "contextformbutton",
                                icon: "unlink",
                                tooltip: "Remove link",
                                onSetup: t,
                                onAction: t => {
                                    ie(e), t.hide()
                                }
                            }, {
                                type: "contextformbutton",
                                icon: "new-tab",
                                tooltip: "Open link",
                                onSetup: t,
                                onAction: t => {
                                    Ae(e)(), t.hide()
                                }
                            }]
                        })
                    })(e), (e => {
                        e.on("click", (t => {
                            const o = _e(e, t.target);
                            o && ke.metaKeyPressed(t) && (t.preventDefault(), Te(e, o))
                        })), e.on("keydown", (t => {
                            if (!t.isDefaultPrevented() && 13 === t.keyCode && (e => !0 === e.altKey && !1 === e.shiftKey && !1 === e.ctrlKey && !1 === e.metaKey)(t)) {
                                const o = Oe(e);
                                o && (t.preventDefault(), Te(e, o))
                            }
                        }))
                    })(e), (e => {
                        e.addCommand("mceLink", ((t, o) => {
                            !0 !== (null == o ? void 0 : o.dialog) && R(e) ? e.dispatch("contexttoolbar-show", {
                                toolbarKey: "quicklink"
                            }) : Se(e)
                        }))
                    })(e), (e => {
                        e.addShortcut("Meta+K", "", (() => {
                            e.execCommand("mceLink")
                        }))
                    })(e)
                }))
            }()
        },
        1236: function(e, t, o) {
            o(77585)
        },
        77585: function() {
            ! function() {
                "use strict";
                var e = tinymce.util.Tools.resolve("tinymce.PluginManager");
                const t = e => t => (e => {
                        const t = typeof e;
                        return null === e ? "null" : "object" === t && Array.isArray(e) ? "array" : "object" === t && (o = n = e, (r = String).prototype.isPrototypeOf(o) || (null === (s = n.constructor) || void 0 === s ? void 0 : s.name) === r.name) ? "string" : t;
                        var o, n, r, s
                    })(t) === e,
                    o = e => t => typeof t === e,
                    n = t("string"),
                    r = t("object"),
                    s = t("array"),
                    a = o("boolean"),
                    i = e => !(e => null == e)(e),
                    l = o("function"),
                    c = o("number"),
                    d = () => {},
                    u = (e, t) => e === t,
                    m = e => t => !e(t),
                    g = (!1, () => false);
                class h {
                    constructor(e, t) {
                        this.tag = e, this.value = t
                    }
                    static some(e) {
                        return new h(!0, e)
                    }
                    static none() {
                        return h.singletonNone
                    }
                    fold(e, t) {
                        return this.tag ? t(this.value) : e()
                    }
                    isSome() {
                        return this.tag
                    }
                    isNone() {
                        return !this.tag
                    }
                    map(e) {
                        return this.tag ? h.some(e(this.value)) : h.none()
                    }
                    bind(e) {
                        return this.tag ? e(this.value) : h.none()
                    }
                    exists(e) {
                        return this.tag && e(this.value)
                    }
                    forall(e) {
                        return !this.tag || e(this.value)
                    }
                    filter(e) {
                        return !this.tag || e(this.value) ? this : h.none()
                    }
                    getOr(e) {
                        return this.tag ? this.value : e
                    }
                    or(e) {
                        return this.tag ? this : e
                    }
                    getOrThunk(e) {
                        return this.tag ? this.value : e()
                    }
                    orThunk(e) {
                        return this.tag ? this : e()
                    }
                    getOrDie(e) {
                        if (this.tag) return this.value;
                        throw new Error(null != e ? e : "Called getOrDie on None")
                    }
                    static from(e) {
                        return i(e) ? h.some(e) : h.none()
                    }
                    getOrNull() {
                        return this.tag ? this.value : null
                    }
                    getOrUndefined() {
                        return this.value
                    }
                    each(e) {
                        this.tag && e(this.value)
                    }
                    toArray() {
                        return this.tag ? [this.value] : []
                    }
                    toString() {
                        return this.tag ? `some(${this.value})` : "none()"
                    }
                }
                h.singletonNone = new h(!1);
                const p = Array.prototype.slice,
                    f = Array.prototype.indexOf,
                    v = Array.prototype.push,
                    b = (e, t) => {
                        return o = e, n = t, f.call(o, n) > -1;
                        var o, n
                    },
                    y = (e, t) => {
                        for (let o = 0, n = e.length; o < n; o++)
                            if (t(e[o], o)) return !0;
                        return !1
                    },
                    w = (e, t) => {
                        const o = e.length,
                            n = new Array(o);
                        for (let r = 0; r < o; r++) {
                            const o = e[r];
                            n[r] = t(o, r)
                        }
                        return n
                    },
                    x = (e, t) => {
                        for (let o = 0, n = e.length; o < n; o++) t(e[o], o)
                    },
                    C = (e, t) => {
                        const o = [];
                        for (let n = 0, r = e.length; n < r; n++) {
                            const r = e[n];
                            t(r, n) && o.push(r)
                        }
                        return o
                    },
                    S = (e, t, o) => (x(e, ((e, n) => {
                        o = t(o, e, n)
                    })), o),
                    k = (e, t, o) => {
                        for (let n = 0, r = e.length; n < r; n++) {
                            const r = e[n];
                            if (t(r, n)) return h.some(r);
                            if (o(r, n)) break
                        }
                        return h.none()
                    },
                    _ = (e, t) => k(e, t, g),
                    O = (e, t) => (e => {
                        const t = [];
                        for (let o = 0, n = e.length; o < n; ++o) {
                            if (!s(e[o])) throw new Error("Arr.flatten item " + o + " was not an array, input: " + e);
                            v.apply(t, e[o])
                        }
                        return t
                    })(w(e, t)),
                    T = e => {
                        const t = p.call(e, 0);
                        return t.reverse(), t
                    },
                    E = (e, t) => t >= 0 && t < e.length ? h.some(e[t]) : h.none(),
                    A = e => E(e, 0),
                    M = e => E(e, e.length - 1),
                    N = (e, t) => {
                        const o = [],
                            n = l(t) ? e => y(o, (o => t(o, e))) : e => b(o, e);
                        for (let t = 0, r = e.length; t < r; t++) {
                            const r = e[t];
                            n(r) || o.push(r)
                        }
                        return o
                    },
                    R = (e, t, o = u) => e.exists((e => o(e, t))),
                    D = (e, t, o) => e.isSome() && t.isSome() ? h.some(o(e.getOrDie(), t.getOrDie())) : h.none(),
                    B = e => {
                        if (null == e) throw new Error("Node cannot be null or undefined");
                        return {
                            dom: e
                        }
                    },
                    L = (e, t) => {
                        const o = (t || document).createElement(e);
                        return B(o)
                    },
                    H = B,
                    I = (e, t) => e.dom === t.dom;
                "undefined" != typeof window ? window : Function("return this;")();
                const P = e => e.dom.nodeName.toLowerCase(),
                    z = (1, e => 1 === (e => e.dom.nodeType)(e));
                const F = e => t => z(t) && P(t) === e,
                    V = e => h.from(e.dom.parentNode).map(H),
                    Z = e => w(e.dom.childNodes, H),
                    U = (e, t) => {
                        const o = e.dom.childNodes;
                        return h.from(o[t]).map(H)
                    },
                    j = e => U(e, 0),
                    W = e => U(e, e.dom.childNodes.length - 1),
                    $ = (e, t, o) => {
                        let n = e.dom;
                        const r = l(o) ? o : g;
                        for (; n.parentNode;) {
                            n = n.parentNode;
                            const e = H(n);
                            if (t(e)) return h.some(e);
                            if (r(e)) break
                        }
                        return h.none()
                    },
                    q = (e, t, o) => ((e, t, o, n, r) => n(o) ? h.some(o) : l(r) && r(o) ? h.none() : t(o, n, r))(0, $, e, t, o),
                    G = (e, t) => {
                        V(e).each((o => {
                            o.dom.insertBefore(t.dom, e.dom)
                        }))
                    },
                    K = (e, t) => {
                        e.dom.appendChild(t.dom)
                    },
                    Y = (e, t) => {
                        x(t, (t => {
                            K(e, t)
                        }))
                    },
                    X = e => {
                        e.dom.textContent = "", x(Z(e), (e => {
                            J(e)
                        }))
                    },
                    J = e => {
                        const t = e.dom;
                        null !== t.parentNode && t.parentNode.removeChild(t)
                    };
                var Q = tinymce.util.Tools.resolve("tinymce.dom.RangeUtils"),
                    ee = tinymce.util.Tools.resolve("tinymce.dom.TreeWalker"),
                    te = tinymce.util.Tools.resolve("tinymce.util.VK");
                const oe = e => w(e, H),
                    ne = Object.keys,
                    re = (e, t) => {
                        const o = ne(e);
                        for (let n = 0, r = o.length; n < r; n++) {
                            const r = o[n];
                            t(e[r], r)
                        }
                    },
                    se = (e, t) => {
                        const o = e.dom;
                        re(t, ((e, t) => {
                            ((e, t, o) => {
                                if (!(n(o) || a(o) || c(o))) throw console.error("Invalid call to Attribute.set. Key ", t, ":: Value ", o, ":: Element ", e), new Error("Attribute value was not simple");
                                e.setAttribute(t, o + "")
                            })(o, t, e)
                        }))
                    },
                    ae = e => S(e.dom.attributes, ((e, t) => (e[t.name] = t.value, e)), {}),
                    ie = e => ((e, t) => H(e.dom.cloneNode(!0)))(e),
                    le = (e, t) => {
                        const o = ((e, t) => {
                            const o = L(t),
                                n = ae(e);
                            return se(o, n), o
                        })(e, t);
                        var n, r;
                        r = o, (e => h.from(e.dom.nextSibling).map(H))(n = e).fold((() => {
                            V(n).each((e => {
                                K(e, r)
                            }))
                        }), (e => {
                            G(e, r)
                        }));
                        const s = Z(e);
                        return Y(o, s), J(e), o
                    };
                var ce = tinymce.util.Tools.resolve("tinymce.dom.DOMUtils"),
                    de = tinymce.util.Tools.resolve("tinymce.util.Tools");
                const ue = e => t => i(t) && t.nodeName.toLowerCase() === e,
                    me = e => t => i(t) && e.test(t.nodeName),
                    ge = e => i(e) && 3 === e.nodeType,
                    he = e => i(e) && 1 === e.nodeType,
                    pe = me(/^(OL|UL|DL)$/),
                    fe = me(/^(OL|UL)$/),
                    ve = ue("ol"),
                    be = me(/^(LI|DT|DD)$/),
                    ye = me(/^(DT|DD)$/),
                    we = me(/^(TH|TD)$/),
                    xe = ue("br"),
                    Ce = (e, t) => i(t) && t.nodeName in e.schema.getTextBlockElements(),
                    Se = (e, t) => i(e) && e.nodeName in t,
                    ke = (e, t, o) => {
                        const n = e.isEmpty(t);
                        return !(o && e.select("span[data-mce-type=bookmark]", t).length > 0) && n
                    },
                    _e = (e, t) => e.isChildOf(t, e.getRoot()),
                    Oe = e => t => t.options.get(e),
                    Te = Oe("lists_indent_on_tab"),
                    Ee = Oe("forced_root_block"),
                    Ae = Oe("forced_root_block_attrs"),
                    Me = (e, t) => {
                        const o = e.dom,
                            n = e.schema.getBlockElements(),
                            r = o.createFragment(),
                            s = Ee(e),
                            a = Ae(e);
                        let i, l, c = !1;
                        for (l = o.create(s, a), Se(t.firstChild, n) || r.appendChild(l); i = t.firstChild;) {
                            const e = i.nodeName;
                            c || "SPAN" === e && "bookmark" === i.getAttribute("data-mce-type") || (c = !0), Se(i, n) ? (r.appendChild(i), l = null) : (l || (l = o.create(s, a), r.appendChild(l)), l.appendChild(i))
                        }
                        return !c && l && l.appendChild(o.create("br", {
                            "data-mce-bogus": "1"
                        })), r
                    },
                    Ne = ce.DOM,
                    Re = F("dd"),
                    De = F("dt"),
                    Be = (e, t) => {
                        var o;
                        Re(t) ? le(t, "dt") : De(t) && (o = t, h.from(o.dom.parentElement).map(H)).each((o => ((e, t, o) => {
                            const n = Ne.select('span[data-mce-type="bookmark"]', t),
                                r = Me(e, o),
                                s = Ne.createRng();
                            s.setStartAfter(o), s.setEndAfter(t);
                            const a = s.extractContents();
                            for (let t = a.firstChild; t; t = t.firstChild)
                                if ("LI" === t.nodeName && e.dom.isEmpty(t)) {
                                    Ne.remove(t);
                                    break
                                }
                            e.dom.isEmpty(a) || Ne.insertAfter(a, t), Ne.insertAfter(r, t);
                            const i = o.parentElement;
                            i && ke(e.dom, i) && (e => {
                                const t = e.parentNode;
                                t && de.each(n, (e => {
                                    t.insertBefore(e, o.parentNode)
                                })), Ne.remove(e)
                            })(i), Ne.remove(o), ke(e.dom, t) && Ne.remove(t)
                        })(e, o.dom, t.dom)))
                    },
                    Le = e => {
                        De(e) && le(e, "dd")
                    },
                    He = (e, t) => {
                        if (ge(e)) return {
                            container: e,
                            offset: t
                        };
                        const o = Q.getNode(e, t);
                        return ge(o) ? {
                            container: o,
                            offset: t >= e.childNodes.length ? o.data.length : 0
                        } : o.previousSibling && ge(o.previousSibling) ? {
                            container: o.previousSibling,
                            offset: o.previousSibling.data.length
                        } : o.nextSibling && ge(o.nextSibling) ? {
                            container: o.nextSibling,
                            offset: 0
                        } : {
                            container: e,
                            offset: t
                        }
                    },
                    Ie = e => {
                        const t = e.cloneRange(),
                            o = He(e.startContainer, e.startOffset);
                        t.setStart(o.container, o.offset);
                        const n = He(e.endContainer, e.endOffset);
                        return t.setEnd(n.container, n.offset), t
                    },
                    Pe = ["OL", "UL", "DL"],
                    ze = Pe.join(","),
                    Fe = (e, t) => {
                        const o = t || e.selection.getStart(!0);
                        return e.dom.getParent(o, ze, Ue(e, o))
                    },
                    Ve = e => {
                        const t = e.selection.getSelectedBlocks();
                        return C(((e, t) => {
                            const o = de.map(t, (t => e.dom.getParent(t, "li,dd,dt", Ue(e, t)) || t));
                            return N(o)
                        })(e, t), be)
                    },
                    Ze = (e, t) => {
                        const o = e.dom.getParents(t, "TD,TH");
                        return o.length > 0 ? o[0] : e.getBody()
                    },
                    Ue = (e, t) => {
                        const o = e.dom.getParents(t, e.dom.isBlock),
                            n = _(o, (t => {
                                return o = e.schema, !pe(n = t) && !be(n) && y(Pe, (e => o.isValidChild(n.nodeName, e)));
                                var o, n
                            }));
                        return n.getOr(e.getBody())
                    },
                    je = (e, t) => {
                        const o = e.dom.getParents(t, "ol,ul", Ue(e, t));
                        return M(o)
                    },
                    We = (e, t) => {
                        const o = w(t, (t => je(e, t).getOr(t)));
                        return N(o)
                    },
                    $e = e => /\btox\-/.test(e.className),
                    qe = (e, t) => k(e, pe, we).exists((e => e.nodeName === t && !$e(e))),
                    Ge = (e, t) => null !== t && "false" === e.dom.getContentEditableParent(t),
                    Ke = (e, t) => {
                        const o = e.dom.getParent(t, "ol,ul,dl");
                        return Ge(e, o)
                    },
                    Ye = (e, t) => {
                        const o = e.selection.getNode();
                        return t({
                            parents: e.dom.getParents(o),
                            element: o
                        }), e.on("NodeChange", t), () => e.off("NodeChange", t)
                    },
                    Xe = (e, t, o) => e.dispatch("ListMutation", {
                        action: t,
                        element: o
                    }),
                    Je = (Qe = /^\s+|\s+$/g, e => e.replace(Qe, ""));
                var Qe;
                const et = (e, t, o) => {
                        ((e, t, o) => {
                            if (!n(o)) throw console.error("Invalid call to CSS.set. Property ", t, ":: Value ", o, ":: Element ", e), new Error("CSS value must be a string: " + o);
                            (e => void 0 !== e.style && l(e.style.getPropertyValue))(e) && e.style.setProperty(t, o)
                        })(e.dom, t, o)
                    },
                    tt = (e, t) => {
                        K(e.item, t.list)
                    },
                    ot = (e, t) => {
                        const o = {
                            list: L(t, e),
                            item: L("li", e)
                        };
                        return K(o.list, o.item), o
                    },
                    nt = e => ((e, t) => {
                        const o = e.dom;
                        if (1 !== o.nodeType) return !1; {
                            const e = o;
                            if (void 0 !== e.matches) return e.matches(t);
                            if (void 0 !== e.msMatchesSelector) return e.msMatchesSelector(t);
                            if (void 0 !== e.webkitMatchesSelector) return e.webkitMatchesSelector(t);
                            if (void 0 !== e.mozMatchesSelector) return e.mozMatchesSelector(t);
                            throw new Error("Browser lacks native selectors")
                        }
                    })(e, "OL,UL"),
                    rt = e => j(e).exists(nt),
                    st = e => e.depth > 0,
                    at = e => e.isSelected,
                    it = e => {
                        const t = Z(e),
                            o = W(e).exists(nt) ? t.slice(0, -1) : t;
                        return w(o, ie)
                    },
                    lt = e => (x(e, ((t, o) => {
                        ((e, t) => {
                            const o = e[t].depth,
                                n = e => e.depth === o && !e.dirty,
                                r = e => e.depth < o;
                            return k(T(e.slice(0, t)), n, r).orThunk((() => k(e.slice(t + 1), n, r)))
                        })(e, o).fold((() => {
                            t.dirty && (e => {
                                e.listAttributes = ((e, t) => {
                                    const o = {};
                                    var n;
                                    return ((e, t, o, n) => {
                                        re(e, ((e, r) => {
                                            (t(e, r) ? o : n)(e, r)
                                        }))
                                    })(e, t, (n = o, (e, t) => {
                                        n[t] = e
                                    }), d), o
                                })(e.listAttributes, ((e, t) => "start" !== t))
                            })(t)
                        }), (e => {
                            return n = e, (o = t).listType = n.listType, void(o.listAttributes = { ...n.listAttributes
                            });
                            var o, n
                        }))
                    })), e),
                    ct = (e, t, o, n) => j(n).filter(nt).fold((() => {
                        t.each((e => {
                            I(e.start, n) && o.set(!0)
                        }));
                        const r = ((e, t, o) => V(e).filter(z).map((n => ({
                            depth: t,
                            dirty: !1,
                            isSelected: o,
                            content: it(e),
                            itemAttributes: ae(e),
                            listAttributes: ae(n),
                            listType: P(n)
                        }))))(n, e, o.get());
                        t.each((e => {
                            I(e.end, n) && o.set(!1)
                        }));
                        const s = W(n).filter(nt).map((n => dt(e, t, o, n))).getOr([]);
                        return r.toArray().concat(s)
                    }), (n => dt(e, t, o, n))),
                    dt = (e, t, o, n) => O(Z(n), (n => (nt(n) ? dt : ct)(e + 1, t, o, n))),
                    ut = (e, t) => {
                        const o = lt(t);
                        return ((e, t) => {
                            const o = S(t, ((t, o) => o.depth > t.length ? ((e, t, o) => {
                                const n = ((e, t, o) => {
                                    const n = [];
                                    for (let r = 0; r < o; r++) n.push(ot(e, t.listType));
                                    return n
                                })(e, o, o.depth - t.length);
                                var r;
                                return (e => {
                                    for (let t = 1; t < e.length; t++) tt(e[t - 1], e[t])
                                })(n), ((e, t) => {
                                    for (let t = 0; t < e.length - 1; t++) et(e[t].item, "list-style-type", "none");
                                    M(e).each((e => {
                                        se(e.list, t.listAttributes), se(e.item, t.itemAttributes), Y(e.item, t.content)
                                    }))
                                })(n, o), r = n, D(M(t), A(r), tt), t.concat(n)
                            })(e, t, o) : ((e, t, o) => {
                                const n = t.slice(0, o.depth);
                                return M(n).each((t => {
                                    const n = ((e, t, o) => {
                                        const n = L("li", e);
                                        return se(n, t), Y(n, o), n
                                    })(e, o.itemAttributes, o.content);
                                    ((e, t) => {
                                        K(e.list, t), e.item = t
                                    })(t, n), ((e, t) => {
                                        P(e.list) !== t.listType && (e.list = le(e.list, t.listType)), se(e.list, t.listAttributes)
                                    })(t, o)
                                })), n
                            })(e, t, o)), []);
                            return A(o).map((e => e.list))
                        })(e.contentDocument, o).toArray()
                    },
                    mt = (e, t, o) => {
                        const n = ((e, t) => {
                            const o = (e => {
                                let t = !1;
                                return {
                                    get: () => t,
                                    set: e => {
                                        t = e
                                    }
                                }
                            })();
                            return w(e, (e => ({
                                sourceList: e,
                                entries: dt(0, t, o, e)
                            })))
                        })(t, (e => {
                            const t = w(Ve(e), H);
                            return D(_(t, m(rt)), _(T(t), m(rt)), ((e, t) => ({
                                start: e,
                                end: t
                            })))
                        })(e));
                        x(n, (t => {
                            ((e, t) => {
                                x(C(e, at), (e => ((e, t) => {
                                    switch (e) {
                                        case "Indent":
                                            t.depth++;
                                            break;
                                        case "Outdent":
                                            t.depth--;
                                            break;
                                        case "Flatten":
                                            t.depth = 0
                                    }
                                    t.dirty = !0
                                })(t, e)))
                            })(t.entries, o);
                            const n = ((e, t) => O(((e, t) => {
                                if (0 === e.length) return []; {
                                    let o = t(e[0]);
                                    const n = [];
                                    let r = [];
                                    for (let s = 0, a = e.length; s < a; s++) {
                                        const a = e[s],
                                            i = t(a);
                                        i !== o && (n.push(r), r = []), o = i, r.push(a)
                                    }
                                    return 0 !== r.length && n.push(r), n
                                }
                            })(t, st), (t => A(t).exists(st) ? ut(e, t) : ((e, t) => {
                                const o = lt(t);
                                return w(o, (t => {
                                    const o = ((e, t) => {
                                        const o = document.createDocumentFragment();
                                        return x(e, (e => {
                                            o.appendChild(e.dom)
                                        })), H(o)
                                    })(t.content);
                                    return H(Me(e, o.dom))
                                }))
                            })(e, t))))(e, t.entries);
                            var r;
                            x(n, (t => {
                                Xe(e, "Indent" === o ? "IndentList" : "OutdentList", t.dom)
                            })), r = t.sourceList, x(n, (e => {
                                G(r, e)
                            })), J(t.sourceList)
                        }))
                    },
                    gt = (e, t) => {
                        const o = oe((e => {
                                const t = (e => {
                                    const t = je(e, e.selection.getStart()),
                                        o = C(e.selection.getSelectedBlocks(), fe);
                                    return t.toArray().concat(o)
                                })(e);
                                return We(e, t)
                            })(e)),
                            n = oe((e => C(Ve(e), ye))(e));
                        let r = !1;
                        if (o.length || n.length) {
                            const s = e.selection.getBookmark();
                            mt(e, o, t), ((e, t, o) => {
                                x(o, "Indent" === t ? Le : t => Be(e, t))
                            })(e, t, n), e.selection.moveToBookmark(s), e.selection.setRng(Ie(e.selection.getRng())), e.nodeChanged(), r = !0
                        }
                        return r
                    },
                    ht = (e, t) => !(e => {
                        const t = Fe(e);
                        return Ge(e, t)
                    })(e) && gt(e, t),
                    pt = e => ht(e, "Indent"),
                    ft = e => ht(e, "Outdent"),
                    vt = e => ht(e, "Flatten");
                var bt = tinymce.util.Tools.resolve("tinymce.dom.BookmarkManager");
                const yt = ce.DOM,
                    wt = e => {
                        const t = {},
                            o = o => {
                                let n = e[o ? "startContainer" : "endContainer"],
                                    r = e[o ? "startOffset" : "endOffset"];
                                if (he(n)) {
                                    const e = yt.create("span", {
                                        "data-mce-type": "bookmark"
                                    });
                                    n.hasChildNodes() ? (r = Math.min(r, n.childNodes.length - 1), o ? n.insertBefore(e, n.childNodes[r]) : yt.insertAfter(e, n.childNodes[r])) : n.appendChild(e), n = e, r = 0
                                }
                                t[o ? "startContainer" : "endContainer"] = n, t[o ? "startOffset" : "endOffset"] = r
                            };
                        return o(!0), e.collapsed || o(), t
                    },
                    xt = e => {
                        const t = t => {
                            let o = e[t ? "startContainer" : "endContainer"],
                                n = e[t ? "startOffset" : "endOffset"];
                            if (o) {
                                if (he(o) && o.parentNode) {
                                    const e = o;
                                    n = (e => {
                                        var t;
                                        let o = null === (t = e.parentNode) || void 0 === t ? void 0 : t.firstChild,
                                            n = 0;
                                        for (; o;) {
                                            if (o === e) return n;
                                            he(o) && "bookmark" === o.getAttribute("data-mce-type") || n++, o = o.nextSibling
                                        }
                                        return -1
                                    })(o), o = o.parentNode, yt.remove(e), !o.hasChildNodes() && yt.isBlock(o) && o.appendChild(yt.create("br"))
                                }
                                e[t ? "startContainer" : "endContainer"] = o, e[t ? "startOffset" : "endOffset"] = n
                            }
                        };
                        t(!0), t();
                        const o = yt.createRng();
                        return o.setStart(e.startContainer, e.startOffset), e.endContainer && o.setEnd(e.endContainer, e.endOffset), Ie(o)
                    },
                    Ct = e => {
                        switch (e) {
                            case "UL":
                                return "ToggleUlList";
                            case "OL":
                                return "ToggleOlList";
                            case "DL":
                                return "ToggleDLList"
                        }
                    },
                    St = (e, t) => {
                        de.each(t, ((t, o) => {
                            e.setAttribute(o, t)
                        }))
                    },
                    kt = (e, t, o) => {
                        ((e, t, o) => {
                            const n = o["list-style-type"] ? o["list-style-type"] : null;
                            e.setStyle(t, "list-style-type", n)
                        })(e, t, o), ((e, t, o) => {
                            St(t, o["list-attributes"]), de.each(e.select("li", t), (e => {
                                St(e, o["list-item-attributes"])
                            }))
                        })(e, t, o)
                    },
                    _t = (e, t, o, n) => {
                        let r = t[o ? "startContainer" : "endContainer"];
                        const s = t[o ? "startOffset" : "endOffset"];
                        for (he(r) && (r = r.childNodes[Math.min(s, r.childNodes.length - 1)] || r), !o && xe(r.nextSibling) && (r = r.nextSibling); r.parentNode !== n;) {
                            const t = r.parentNode;
                            if (Ce(e, r)) return r;
                            if (/^(TD|TH)$/.test(t.nodeName)) return r;
                            r = t
                        }
                        return r
                    },
                    Ot = (e, t, o) => {
                        const n = e.selection.getRng();
                        let r = "LI";
                        const s = Ue(e, e.selection.getStart(!0)),
                            a = e.dom;
                        if ("false" === a.getContentEditable(e.selection.getNode())) return;
                        "DL" === (t = t.toUpperCase()) && (r = "DT");
                        const i = wt(n),
                            l = ((e, t, o) => {
                                const n = [],
                                    r = e.dom,
                                    s = _t(e, t, !0, o),
                                    a = _t(e, t, !1, o);
                                let i;
                                const l = [];
                                for (let e = s; e && (l.push(e), e !== a); e = e.nextSibling);
                                return de.each(l, (t => {
                                    var s;
                                    if (Ce(e, t)) return n.push(t), void(i = null);
                                    if (r.isBlock(t) || xe(t)) return xe(t) && r.remove(t), void(i = null);
                                    const a = t.nextSibling;
                                    bt.isBookmarkNode(t) && (pe(a) || Ce(e, a) || !a && t.parentNode === o) ? i = null : (i || (i = r.create("p"), null === (s = t.parentNode) || void 0 === s || s.insertBefore(i, t), n.push(i)), i.appendChild(t))
                                })), n
                            })(e, n, s);
                        de.each(l, (n => {
                            let s;
                            const i = n.previousSibling,
                                l = n.parentNode;
                            be(l) || (i && pe(i) && i.nodeName === t && ((e, t, o) => {
                                const n = e.getStyle(t, "list-style-type");
                                let r = o ? o["list-style-type"] : "";
                                return r = null === r ? "" : r, n === r
                            })(a, i, o) ? (s = i, n = a.rename(n, r), i.appendChild(n)) : (s = a.create(t), l.insertBefore(s, n), s.appendChild(n), n = a.rename(n, r)), ((e, t, o) => {
                                de.each(["margin", "margin-right", "margin-bottom", "margin-left", "margin-top", "padding", "padding-right", "padding-bottom", "padding-left", "padding-top"], (o => e.setStyle(t, o, "")))
                            })(a, n), kt(a, s, o), Et(e.dom, s))
                        })), e.selection.setRng(xt(i))
                    },
                    Tt = (e, t, o) => {
                        return ((e, t) => pe(e) && e.nodeName === (null == t ? void 0 : t.nodeName))(t, o) && ((e, t, o) => e.getStyle(t, "list-style-type", !0) === e.getStyle(o, "list-style-type", !0))(e, t, o) && (n = o, t.className === n.className);
                        var n
                    },
                    Et = (e, t) => {
                        let o, n = t.nextSibling;
                        if (Tt(e, t, n)) {
                            const r = n;
                            for (; o = r.firstChild;) t.appendChild(o);
                            e.remove(r)
                        }
                        if (n = t.previousSibling, Tt(e, t, n)) {
                            const r = n;
                            for (; o = r.lastChild;) t.insertBefore(o, t.firstChild);
                            e.remove(r)
                        }
                    },
                    At = e => "list-style-type" in e,
                    Mt = (e, t, o) => {
                        const n = Fe(e);
                        if (Ke(e, n)) return;
                        const s = (e => {
                                const t = Fe(e),
                                    o = e.selection.getSelectedBlocks();
                                return ((e, t) => i(e) && 1 === t.length && t[0] === e)(t, o) ? (e => C(e.querySelectorAll(ze), pe))(t) : C(o, (e => pe(e) && t !== e))
                            })(e),
                            a = r(o) ? o : {};
                        s.length > 0 ? ((e, t, o, n, r) => {
                            const s = pe(t);
                            if (s && t.nodeName === n && !At(r)) vt(e);
                            else {
                                Ot(e, n, r);
                                const a = wt(e.selection.getRng()),
                                    i = s ? [t, ...o] : o;
                                de.each(i, (t => {
                                    ((e, t, o, n) => {
                                        if (t.nodeName !== o) {
                                            const r = e.dom.rename(t, o);
                                            kt(e.dom, r, n), Xe(e, Ct(o), r)
                                        } else kt(e.dom, t, n), Xe(e, Ct(o), t)
                                    })(e, t, n, r)
                                })), e.selection.setRng(xt(a))
                            }
                        })(e, n, s, t, a) : ((e, t, o, n) => {
                            if (t !== e.getBody())
                                if (t)
                                    if (t.nodeName !== o || At(n) || $e(t)) {
                                        const r = wt(e.selection.getRng());
                                        kt(e.dom, t, n);
                                        const s = e.dom.rename(t, o);
                                        Et(e.dom, s), e.selection.setRng(xt(r)), Ot(e, o, n), Xe(e, Ct(o), s)
                                    } else vt(e);
                            else Ot(e, o, n), Xe(e, Ct(o), t)
                        })(e, n, t, a)
                    },
                    Nt = ce.DOM,
                    Rt = (e, t) => {
                        const o = de.grep(e.select("ol,ul", t));
                        de.each(o, (t => {
                            ((e, t) => {
                                const o = t.parentElement;
                                if (o && "LI" === o.nodeName && o.firstChild === t) {
                                    const n = o.previousSibling;
                                    n && "LI" === n.nodeName ? (n.appendChild(t), ke(e, o) && Nt.remove(o)) : Nt.setStyle(o, "listStyleType", "none")
                                }
                                if (pe(o)) {
                                    const e = o.previousSibling;
                                    e && "LI" === e.nodeName && e.appendChild(t)
                                }
                            })(e, t)
                        }))
                    },
                    Dt = (e, t, o, n) => {
                        let r = t.startContainer;
                        const s = t.startOffset;
                        if (ge(r) && (o ? s < r.data.length : s > 0)) return r;
                        const a = e.schema.getNonEmptyElements();
                        he(r) && (r = Q.getNode(r, s));
                        const i = new ee(r, n);
                        o && ((e, t) => !!xe(t) && e.isBlock(t.nextSibling) && !xe(t.previousSibling))(e.dom, r) && i.next();
                        const l = o ? i.next.bind(i) : i.prev2.bind(i);
                        for (; r = l();) {
                            if ("LI" === r.nodeName && !r.hasChildNodes()) return r;
                            if (a[r.nodeName]) return r;
                            if (ge(r) && r.data.length > 0) return r
                        }
                        return null
                    },
                    Bt = (e, t) => {
                        const o = t.childNodes;
                        return 1 === o.length && !pe(o[0]) && e.isBlock(o[0])
                    },
                    Lt = (e, t, o) => {
                        let n;
                        const r = t.parentNode;
                        if (!_e(e, t) || !_e(e, o)) return;
                        pe(o.lastChild) && (n = o.lastChild), r === o.lastChild && xe(r.previousSibling) && e.remove(r.previousSibling);
                        const s = o.lastChild;
                        s && xe(s) && t.hasChildNodes() && e.remove(s), ke(e, o, !0) && X(H(o)), ((e, t, o) => {
                            let n;
                            const r = Bt(e, o) ? o.firstChild : o;
                            if (((e, t) => {
                                    Bt(e, t) && e.remove(t.firstChild, !0)
                                })(e, t), !ke(e, t, !0))
                                for (; n = t.firstChild;) r.appendChild(n)
                        })(e, t, o), n && o.appendChild(n);
                        const a = ((e, t) => {
                            const o = e.dom,
                                n = t.dom;
                            return o !== n && o.contains(n)
                        })(H(o), H(t)) ? e.getParents(t, pe, o) : [];
                        e.remove(t), x(a, (t => {
                            ke(e, t) && t !== e.getRoot() && e.remove(t)
                        }))
                    },
                    Ht = (e, t) => {
                        const o = e.dom,
                            n = e.selection,
                            r = n.getStart(),
                            s = Ze(e, r),
                            a = o.getParent(n.getStart(), "LI", s);
                        if (a) {
                            const r = a.parentElement;
                            if (r === e.getBody() && ke(o, r)) return !0;
                            const i = Ie(n.getRng()),
                                l = o.getParent(Dt(e, i, t, s), "LI", s);
                            if (l && l !== a) return e.undoManager.transact((() => {
                                var o, n;
                                t ? ((e, t, o, n) => {
                                    const r = e.dom;
                                    if (r.isEmpty(n))((e, t, o) => {
                                        X(H(o)), Lt(e.dom, t, o), e.selection.setCursorLocation(o, 0)
                                    })(e, o, n);
                                    else {
                                        const s = wt(t);
                                        Lt(r, o, n), e.selection.setRng(xt(s))
                                    }
                                })(e, i, l, a) : (null === (n = (o = a).parentNode) || void 0 === n ? void 0 : n.firstChild) === o ? ft(e) : ((e, t, o, n) => {
                                    const r = wt(t);
                                    Lt(e.dom, o, n);
                                    const s = xt(r);
                                    e.selection.setRng(s)
                                })(e, i, a, l)
                            })), !0;
                            if (!l && !t && 0 === i.startOffset && 0 === i.endOffset) return e.undoManager.transact((() => {
                                vt(e)
                            })), !0
                        }
                        return !1
                    },
                    It = e => {
                        const t = e.selection.getStart(),
                            o = Ze(e, t);
                        return e.dom.getParent(t, "LI,DT,DD", o) || Ve(e).length > 0
                    },
                    Pt = (e, t) => {
                        const o = e.selection;
                        return !Ke(e, o.getNode()) && (o.isCollapsed() ? ((e, t) => Ht(e, t) || ((e, t) => {
                            const o = e.dom,
                                n = e.selection.getStart(),
                                r = Ze(e, n),
                                s = o.getParent(n, o.isBlock, r);
                            if (s && o.isEmpty(s)) {
                                const n = Ie(e.selection.getRng()),
                                    a = o.getParent(Dt(e, n, t, r), "LI", r);
                                if (a) {
                                    const i = e => b(["td", "th", "caption"], P(e)),
                                        l = e => e.dom === r;
                                    return !!((e, t, o = u) => D(e, t, o).getOr(e.isNone() && t.isNone()))(q(H(a), i, l), q(H(n.startContainer), i, l), I) && (e.undoManager.transact((() => {
                                        ((e, t, o) => {
                                            const n = e.getParent(t.parentNode, e.isBlock, o);
                                            e.remove(t), n && e.isEmpty(n) && e.remove(n)
                                        })(o, s, r), Et(o, a.parentNode), e.selection.select(a, !0), e.selection.collapse(t)
                                    })), !0)
                                }
                            }
                            return !1
                        })(e, t))(e, t) : (e => !!It(e) && (e.undoManager.transact((() => {
                            e.execCommand("Delete"), Rt(e.dom, e.getBody())
                        })), !0))(e))
                    },
                    zt = e => {
                        const t = T(Je(e).split("")),
                            o = w(t, ((e, t) => {
                                const o = e.toUpperCase().charCodeAt(0) - "A".charCodeAt(0) + 1;
                                return Math.pow(26, t) * o
                            }));
                        return S(o, ((e, t) => e + t), 0)
                    },
                    Ft = e => {
                        if (--e < 0) return ""; {
                            const t = e % 26,
                                o = Math.floor(e / 26);
                            return Ft(o) + String.fromCharCode("A".charCodeAt(0) + t)
                        }
                    },
                    Vt = e => {
                        const t = parseInt(e.start, 10);
                        return R(e.listStyleType, "upper-alpha") ? Ft(t) : R(e.listStyleType, "lower-alpha") ? Ft(t).toLowerCase() : e.start
                    },
                    Zt = (e, t) => () => {
                        const o = Fe(e);
                        return i(o) && o.nodeName === t
                    },
                    Ut = e => {
                        e.addCommand("mceListProps", (() => {
                            (e => {
                                const t = Fe(e);
                                ve(t) && !Ke(e, t) && e.windowManager.open({
                                    title: "List Properties",
                                    body: {
                                        type: "panel",
                                        items: [{
                                            type: "input",
                                            name: "start",
                                            label: "Start list at number",
                                            inputMode: "numeric"
                                        }]
                                    },
                                    initialData: {
                                        start: Vt({
                                            start: e.dom.getAttrib(t, "start", "1"),
                                            listStyleType: h.from(e.dom.getStyle(t, "list-style-type"))
                                        })
                                    },
                                    buttons: [{
                                        type: "cancel",
                                        name: "cancel",
                                        text: "Cancel"
                                    }, {
                                        type: "submit",
                                        name: "save",
                                        text: "Save",
                                        primary: !0
                                    }],
                                    onSubmit: t => {
                                        (e => {
                                            switch ((e => /^[0-9]+$/.test(e) ? 2 : /^[A-Z]+$/.test(e) ? 0 : /^[a-z]+$/.test(e) ? 1 : e.length > 0 ? 4 : 3)(e)) {
                                                case 2:
                                                    return h.some({
                                                        listStyleType: h.none(),
                                                        start: e
                                                    });
                                                case 0:
                                                    return h.some({
                                                        listStyleType: h.some("upper-alpha"),
                                                        start: zt(e).toString()
                                                    });
                                                case 1:
                                                    return h.some({
                                                        listStyleType: h.some("lower-alpha"),
                                                        start: zt(e).toString()
                                                    });
                                                case 3:
                                                    return h.some({
                                                        listStyleType: h.none(),
                                                        start: ""
                                                    });
                                                case 4:
                                                    return h.none()
                                            }
                                        })(t.getData().start).each((t => {
                                            e.execCommand("mceListUpdate", !1, {
                                                attrs: {
                                                    start: "1" === t.start ? "" : t.start
                                                },
                                                styles: {
                                                    "list-style-type": t.listStyleType.getOr("")
                                                }
                                            })
                                        })), t.close()
                                    }
                                })
                            })(e)
                        }))
                    },
                    jt = (e, t) => o => Ye(e, (n => {
                        o.setActive(qe(n.parents, t)), o.setEnabled(!Ke(e, n.element))
                    })),
                    Wt = (e, t) => o => Ye(e, (n => o.setEnabled(qe(n.parents, t) && !Ke(e, n.element))));
                e.add("lists", (e => ((e => {
                    (0, e.options.register)("lists_indent_on_tab", {
                        processor: "boolean",
                        default: !0
                    })
                })(e), e.hasPlugin("rtc", !0) ? Ut(e) : ((e => {
                    Te(e) && (e => {
                        e.on("keydown", (t => {
                            t.keyCode !== te.TAB || te.metaKeyPressed(t) || e.undoManager.transact((() => {
                                (t.shiftKey ? ft(e) : pt(e)) && t.preventDefault()
                            }))
                        }))
                    })(e), (e => {
                        e.on("ExecCommand", (t => {
                            const o = t.command.toLowerCase();
                            "delete" !== o && "forwarddelete" !== o || !It(e) || Rt(e.dom, e.getBody())
                        })), e.on("keydown", (t => {
                            t.keyCode === te.BACKSPACE ? Pt(e, !1) && t.preventDefault() : t.keyCode === te.DELETE && Pt(e, !0) && t.preventDefault()
                        }))
                    })(e)
                })(e), (e => {
                    e.on("BeforeExecCommand", (t => {
                        const o = t.command.toLowerCase();
                        "indent" === o ? pt(e) : "outdent" === o && ft(e)
                    })), e.addCommand("InsertUnorderedList", ((t, o) => {
                        Mt(e, "UL", o)
                    })), e.addCommand("InsertOrderedList", ((t, o) => {
                        Mt(e, "OL", o)
                    })), e.addCommand("InsertDefinitionList", ((t, o) => {
                        Mt(e, "DL", o)
                    })), e.addCommand("RemoveList", (() => {
                        vt(e)
                    })), Ut(e), e.addCommand("mceListUpdate", ((t, o) => {
                        r(o) && ((e, t) => {
                            const o = Fe(e);
                            null === o || Ke(e, o) || e.undoManager.transact((() => {
                                r(t.styles) && e.dom.setStyles(o, t.styles), r(t.attrs) && re(t.attrs, ((t, n) => e.dom.setAttrib(o, n, t)))
                            }))
                        })(e, o)
                    })), e.addQueryStateHandler("InsertUnorderedList", Zt(e, "UL")), e.addQueryStateHandler("InsertOrderedList", Zt(e, "OL")), e.addQueryStateHandler("InsertDefinitionList", Zt(e, "DL"))
                })(e)), (e => {
                    const t = t => () => e.execCommand(t);
                    e.hasPlugin("advlist") || (e.ui.registry.addToggleButton("numlist", {
                        icon: "ordered-list",
                        active: !1,
                        tooltip: "Numbered list",
                        onAction: t("InsertOrderedList"),
                        onSetup: jt(e, "OL")
                    }), e.ui.registry.addToggleButton("bullist", {
                        icon: "unordered-list",
                        active: !1,
                        tooltip: "Bullet list",
                        onAction: t("InsertUnorderedList"),
                        onSetup: jt(e, "UL")
                    }))
                })(e), (e => {
                    const t = {
                        text: "List properties...",
                        icon: "ordered-list",
                        onAction: () => e.execCommand("mceListProps"),
                        onSetup: Wt(e, "OL")
                    };
                    e.ui.registry.addMenuItem("listprops", t), e.ui.registry.addContextMenu("lists", {
                        update: t => {
                            const o = Fe(e, t);
                            return ve(o) ? ["listprops"] : []
                        }
                    })
                })(e), (e => ({
                    backspaceDelete: t => {
                        Pt(e, t)
                    }
                }))(e))))
            }()
        },
        78843: function(e, t, o) {
            o(40243)
        },
        40243: function() {
            ! function() {
                "use strict";
                var e = tinymce.util.Tools.resolve("tinymce.PluginManager"),
                    t = tinymce.util.Tools.resolve("tinymce.Env");
                const o = e => t => t.options.get(e),
                    n = o("pagebreak_separator"),
                    r = o("pagebreak_split_block"),
                    s = "mce-pagebreak",
                    a = e => {
                        const o = `<img src="${t.transparentSrc}" class="${s}" data-mce-resize="false" data-mce-placeholder />`;
                        return e ? `<p>${o}</p>` : o
                    };
                e.add("pagebreak", (e => {
                    (e => {
                        const t = e.options.register;
                        t("pagebreak_separator", {
                            processor: "string",
                            default: "\x3c!-- pagebreak --\x3e"
                        }), t("pagebreak_split_block", {
                            processor: "boolean",
                            default: !1
                        })
                    })(e), (e => {
                        e.addCommand("mcePageBreak", (() => {
                            e.insertContent(a(r(e)))
                        }))
                    })(e), (e => {
                        const t = () => e.execCommand("mcePageBreak");
                        e.ui.registry.addButton("pagebreak", {
                            icon: "page-break",
                            tooltip: "Page break",
                            onAction: t
                        }), e.ui.registry.addMenuItem("pagebreak", {
                            text: "Page break",
                            icon: "page-break",
                            onAction: t
                        })
                    })(e), (e => {
                        const t = n(e),
                            o = () => r(e),
                            i = new RegExp(t.replace(/[\?\.\*\[\]\(\)\{\}\+\^\$\:]/g, (e => "\\" + e)), "gi");
                        e.on("BeforeSetContent", (e => {
                            e.content = e.content.replace(i, a(o()))
                        })), e.on("PreInit", (() => {
                            e.serializer.addNodeFilter("img", (n => {
                                let r, a, i = n.length;
                                for (; i--;)
                                    if (r = n[i], a = r.attr("class"), a && -1 !== a.indexOf(s)) {
                                        const n = r.parent;
                                        if (n && e.schema.getBlockElements()[n.name] && o()) {
                                            n.type = 3, n.value = t, n.raw = !0, r.remove();
                                            continue
                                        }
                                        r.type = 3, r.value = t, r.raw = !0
                                    }
                            }))
                        }))
                    })(e), (e => {
                        e.on("ResolveName", (t => {
                            "IMG" === t.target.nodeName && e.dom.hasClass(t.target, s) && (t.name = "pagebreak")
                        }))
                    })(e)
                }))
            }()
        },
        38619: function(e, t, o) {
            o(42590)
        },
        42590: function() {
            ! function() {
                "use strict";
                var e = tinymce.util.Tools.resolve("tinymce.PluginManager");
                const t = e => t => (e => {
                        const t = typeof e;
                        return null === e ? "null" : "object" === t && Array.isArray(e) ? "array" : "object" === t && (o = n = e, (r = String).prototype.isPrototypeOf(o) || (null === (s = n.constructor) || void 0 === s ? void 0 : s.name) === r.name) ? "string" : t;
                        var o, n, r, s
                    })(t) === e,
                    o = e => t => typeof t === e,
                    n = t("string"),
                    r = t("array"),
                    s = o("boolean"),
                    a = (void 0, e => undefined === e);
                const i = e => !(e => null == e)(e),
                    l = o("function"),
                    c = o("number"),
                    d = () => {},
                    u = e => () => e,
                    m = e => e,
                    g = (e, t) => e === t;

                function h(e, ...t) {
                    return (...o) => {
                        const n = t.concat(o);
                        return e.apply(null, n)
                    }
                }
                const p = e => {
                        e()
                    },
                    f = u(!1),
                    v = u(!0);
                class b {
                    constructor(e, t) {
                        this.tag = e, this.value = t
                    }
                    static some(e) {
                        return new b(!0, e)
                    }
                    static none() {
                        return b.singletonNone
                    }
                    fold(e, t) {
                        return this.tag ? t(this.value) : e()
                    }
                    isSome() {
                        return this.tag
                    }
                    isNone() {
                        return !this.tag
                    }
                    map(e) {
                        return this.tag ? b.some(e(this.value)) : b.none()
                    }
                    bind(e) {
                        return this.tag ? e(this.value) : b.none()
                    }
                    exists(e) {
                        return this.tag && e(this.value)
                    }
                    forall(e) {
                        return !this.tag || e(this.value)
                    }
                    filter(e) {
                        return !this.tag || e(this.value) ? this : b.none()
                    }
                    getOr(e) {
                        return this.tag ? this.value : e
                    }
                    or(e) {
                        return this.tag ? this : e
                    }
                    getOrThunk(e) {
                        return this.tag ? this.value : e()
                    }
                    orThunk(e) {
                        return this.tag ? this : e()
                    }
                    getOrDie(e) {
                        if (this.tag) return this.value;
                        throw new Error(null != e ? e : "Called getOrDie on None")
                    }
                    static from(e) {
                        return i(e) ? b.some(e) : b.none()
                    }
                    getOrNull() {
                        return this.tag ? this.value : null
                    }
                    getOrUndefined() {
                        return this.value
                    }
                    each(e) {
                        this.tag && e(this.value)
                    }
                    toArray() {
                        return this.tag ? [this.value] : []
                    }
                    toString() {
                        return this.tag ? `some(${this.value})` : "none()"
                    }
                }
                b.singletonNone = new b(!1);
                const y = Object.keys,
                    w = Object.hasOwnProperty,
                    x = (e, t) => {
                        const o = y(e);
                        for (let n = 0, r = o.length; n < r; n++) {
                            const r = o[n];
                            t(e[r], r)
                        }
                    },
                    C = (e, t) => {
                        const o = {};
                        var n;
                        return ((e, t, o, n) => {
                            x(e, ((e, r) => {
                                (t(e, r) ? o : n)(e, r)
                            }))
                        })(e, t, (n = o, (e, t) => {
                            n[t] = e
                        }), d), o
                    },
                    S = e => y(e).length,
                    k = (e, t) => _(e, t) ? b.from(e[t]) : b.none(),
                    _ = (e, t) => w.call(e, t),
                    O = (e, t) => _(e, t) && void 0 !== e[t] && null !== e[t],
                    T = Array.prototype.indexOf,
                    E = Array.prototype.push,
                    A = (e, t) => ((e, t) => T.call(e, t))(e, t) > -1,
                    M = (e, t) => {
                        for (let o = 0, n = e.length; o < n; o++)
                            if (t(e[o], o)) return !0;
                        return !1
                    },
                    N = (e, t) => {
                        const o = [];
                        for (let n = 0; n < e; n++) o.push(t(n));
                        return o
                    },
                    R = (e, t) => {
                        const o = e.length,
                            n = new Array(o);
                        for (let r = 0; r < o; r++) {
                            const o = e[r];
                            n[r] = t(o, r)
                        }
                        return n
                    },
                    D = (e, t) => {
                        for (let o = 0, n = e.length; o < n; o++) t(e[o], o)
                    },
                    B = (e, t) => {
                        const o = [];
                        for (let n = 0, r = e.length; n < r; n++) {
                            const r = e[n];
                            t(r, n) && o.push(r)
                        }
                        return o
                    },
                    L = (e, t, o) => (D(e, ((e, n) => {
                        o = t(o, e, n)
                    })), o),
                    H = (e, t) => ((e, t, o) => {
                        for (let n = 0, r = e.length; n < r; n++) {
                            const r = e[n];
                            if (t(r, n)) return b.some(r);
                            if (o(r, n)) break
                        }
                        return b.none()
                    })(e, t, f),
                    I = (e, t) => (e => {
                        const t = [];
                        for (let o = 0, n = e.length; o < n; ++o) {
                            if (!r(e[o])) throw new Error("Arr.flatten item " + o + " was not an array, input: " + e);
                            E.apply(t, e[o])
                        }
                        return t
                    })(R(e, t)),
                    P = (e, t) => {
                        for (let o = 0, n = e.length; o < n; ++o)
                            if (!0 !== t(e[o], o)) return !1;
                        return !0
                    },
                    z = (e, t) => t >= 0 && t < e.length ? b.some(e[t]) : b.none(),
                    F = (e, t) => {
                        for (let o = 0; o < e.length; o++) {
                            const n = t(e[o], o);
                            if (n.isSome()) return n
                        }
                        return b.none()
                    },
                    V = e => {
                        if (null == e) throw new Error("Node cannot be null or undefined");
                        return {
                            dom: e
                        }
                    },
                    Z = {
                        fromHtml: (e, t) => {
                            const o = (t || document).createElement("div");
                            if (o.innerHTML = e, !o.hasChildNodes() || o.childNodes.length > 1) {
                                const t = "HTML does not have a single root node";
                                throw console.error(t, e), new Error(t)
                            }
                            return V(o.childNodes[0])
                        },
                        fromTag: (e, t) => {
                            const o = (t || document).createElement(e);
                            return V(o)
                        },
                        fromText: (e, t) => {
                            const o = (t || document).createTextNode(e);
                            return V(o)
                        },
                        fromDom: V,
                        fromPoint: (e, t, o) => b.from(e.dom.elementFromPoint(t, o)).map(V)
                    };
                "undefined" != typeof window ? window : Function("return this;")();
                const U = e => e.dom.nodeName.toLowerCase(),
                    j = e => e.dom.nodeType,
                    W = e => t => j(t) === e,
                    $ = W(1),
                    q = W(3),
                    G = W(9),
                    K = W(11),
                    Y = e => t => $(t) && U(t) === e,
                    X = (e, t) => {
                        const o = e.dom;
                        if (1 !== o.nodeType) return !1; {
                            const e = o;
                            if (void 0 !== e.matches) return e.matches(t);
                            if (void 0 !== e.msMatchesSelector) return e.msMatchesSelector(t);
                            if (void 0 !== e.webkitMatchesSelector) return e.webkitMatchesSelector(t);
                            if (void 0 !== e.mozMatchesSelector) return e.mozMatchesSelector(t);
                            throw new Error("Browser lacks native selectors")
                        }
                    },
                    J = e => 1 !== e.nodeType && 9 !== e.nodeType && 11 !== e.nodeType || 0 === e.childElementCount,
                    Q = (e, t) => e.dom === t.dom,
                    ee = X,
                    te = e => G(e) ? e : Z.fromDom(e.dom.ownerDocument),
                    oe = e => b.from(e.dom.parentNode).map(Z.fromDom),
                    ne = e => b.from(e.dom.nextSibling).map(Z.fromDom),
                    re = e => R(e.dom.childNodes, Z.fromDom),
                    se = l(Element.prototype.attachShadow) && l(Node.prototype.getRootNode) ? e => Z.fromDom(e.dom.getRootNode()) : te,
                    ae = e => Z.fromDom(e.dom.host),
                    ie = e => {
                        const t = q(e) ? e.dom.parentNode : e.dom;
                        if (null == t || null === t.ownerDocument) return !1;
                        const o = t.ownerDocument;
                        return (e => {
                            const t = se(e);
                            return K(o = t) && i(o.dom.host) ? b.some(t) : b.none();
                            var o
                        })(Z.fromDom(t)).fold((() => o.body.contains(t)), (n = ie, r = ae, e => n(r(e))));
                        var n, r
                    },
                    le = (e, t) => {
                        let o = [];
                        return D(re(e), (e => {
                            t(e) && (o = o.concat([e])), o = o.concat(le(e, t))
                        })), o
                    },
                    ce = (e, t) => ((e, o) => B(re(e), (e => X(e, t))))(e),
                    de = (e, t) => ((e, t) => {
                        const o = void 0 === t ? document : t.dom;
                        return J(o) ? [] : R(o.querySelectorAll(e), Z.fromDom)
                    })(t, e),
                    ue = (e, t, o) => {
                        let n = e.dom;
                        const r = l(o) ? o : f;
                        for (; n.parentNode;) {
                            n = n.parentNode;
                            const e = Z.fromDom(n);
                            if (t(e)) return b.some(e);
                            if (r(e)) break
                        }
                        return b.none()
                    },
                    me = (e, t, o) => ue(e, (e => X(e, t)), o),
                    ge = (e, t) => ((e, o) => H(e.dom.childNodes, (e => {
                        return o = Z.fromDom(e), X(o, t);
                        var o
                    })).map(Z.fromDom))(e),
                    he = (e, t) => ((e, t) => {
                        const o = void 0 === t ? document : t.dom;
                        return J(o) ? b.none() : b.from(o.querySelector(e)).map(Z.fromDom)
                    })(t, e),
                    pe = (e, t, o) => ((e, t, o, n, r) => ((e, t) => X(e, t))(o, n) ? b.some(o) : l(r) && r(o) ? b.none() : t(o, n, r))(0, me, e, t, o),
                    fe = (e, t, o) => {
                        if (!(n(o) || s(o) || c(o))) throw console.error("Invalid call to Attribute.set. Key ", t, ":: Value ", o, ":: Element ", e), new Error("Attribute value was not simple");
                        e.setAttribute(t, o + "")
                    },
                    ve = (e, t) => {
                        const o = e.dom.getAttribute(t);
                        return null === o ? void 0 : o
                    },
                    be = (e, t) => b.from(ve(e, t)),
                    ye = (e, t) => {
                        e.dom.removeAttribute(t)
                    },
                    we = (e, t, o = g) => e.exists((e => o(e, t))),
                    xe = (e, t, o) => e.isSome() && t.isSome() ? b.some(o(e.getOrDie(), t.getOrDie())) : b.none(),
                    Ce = (e, t) => ((e, t, o) => "" === t || e.length >= t.length && e.substr(0, 0 + t.length) === t)(e, t),
                    Se = (ke = /^\s+|\s+$/g, e => e.replace(ke, ""));
                var ke;
                const _e = e => e.length > 0,
                    Oe = (e, t = 10) => {
                        const o = parseInt(e, t);
                        return isNaN(o) ? b.none() : b.some(o)
                    },
                    Te = e => void 0 !== e.style && l(e.style.getPropertyValue),
                    Ee = (e, t) => {
                        const o = e.dom,
                            n = window.getComputedStyle(o).getPropertyValue(t);
                        return "" !== n || ie(e) ? n : Ae(o, t)
                    },
                    Ae = (e, t) => Te(e) ? e.style.getPropertyValue(t) : "",
                    Me = (e, t) => {
                        const o = e.dom,
                            n = Ae(o, t);
                        return b.from(n).filter((e => e.length > 0))
                    },
                    Ne = (e, t, o = 0) => be(e, t).map((e => parseInt(e, 10))).getOr(o),
                    Re = (e, t) => De(e, t, v),
                    De = (e, t, o) => I(re(e), (e => X(e, t) ? o(e) ? [e] : [] : De(e, t, o))),
                    Be = ["tfoot", "thead", "tbody", "colgroup"],
                    Le = (e, t, o) => ({
                        element: e,
                        rowspan: t,
                        colspan: o
                    }),
                    He = (e, t, o) => ({
                        element: e,
                        cells: t,
                        section: o
                    }),
                    Ie = (e, t) => pe(e, "table", t),
                    Pe = e => Re(e, "tr"),
                    ze = e => Ie(e).fold(u([]), (e => ce(e, "colgroup"))),
                    Fe = e => oe(e).map((e => {
                        const t = U(e);
                        return (e => A(Be, e))(t) ? t : "tbody"
                    })).getOr("tbody"),
                    Ve = e => be(e, "data-snooker-locked-cols").bind((e => b.from(e.match(/\d+/g)))).map((e => ((e, t) => {
                        const o = {};
                        for (let n = 0, r = e.length; n < r; n++) {
                            const r = e[n];
                            o[String(r)] = t(r, n)
                        }
                        return o
                    })(e, v))),
                    Ze = (e, t) => e + "," + t,
                    Ue = e => {
                        const t = {},
                            o = [];
                        var n;
                        const r = (n = e, z(n, 0)).map((e => e.element)).bind(Ie).bind(Ve).getOr({});
                        let s = 0,
                            a = 0,
                            i = 0;
                        const {
                            pass: l,
                            fail: c
                        } = ((e, t) => {
                            const o = [],
                                n = [];
                            for (let t = 0, s = e.length; t < s; t++) {
                                const s = e[t];
                                (r = s, "colgroup" === r.section ? o : n).push(s)
                            }
                            var r;
                            return {
                                pass: o,
                                fail: n
                            }
                        })(e);
                        D(c, (e => {
                            const n = [];
                            D(e.cells, (e => {
                                let o = 0;
                                for (; void 0 !== t[Ze(i, o)];) o++;
                                const s = O(r, o.toString()),
                                    l = ((e, t, o, n, r, s) => ({
                                        element: e,
                                        rowspan: t,
                                        colspan: o,
                                        row: n,
                                        column: r,
                                        isLocked: s
                                    }))(e.element, e.rowspan, e.colspan, i, o, s);
                                for (let n = 0; n < e.colspan; n++)
                                    for (let r = 0; r < e.rowspan; r++) {
                                        const e = o + n,
                                            s = Ze(i + r, e);
                                        t[s] = l, a = Math.max(a, e + 1)
                                    }
                                n.push(l)
                            })), s++, o.push(He(e.element, n, e.section)), i++
                        }));
                        const {
                            columns: d,
                            colgroups: u
                        } = (e => z(e, e.length - 1))(l).map((e => {
                            const t = (e => {
                                    const t = {};
                                    let o = 0;
                                    return D(e.cells, (e => {
                                        const n = e.colspan;
                                        N(n, (r => {
                                            const s = o + r;
                                            t[s] = ((e, t, o) => ({
                                                element: e,
                                                colspan: t,
                                                column: o
                                            }))(e.element, n, s)
                                        })), o += n
                                    })), t
                                })(e),
                                o = ((e, t) => ({
                                    element: e,
                                    columns: t
                                }))(e.element, ((e, t) => {
                                    const o = [];
                                    return x(e, ((e, n) => {
                                        o.push(t(e, n))
                                    })), o
                                })(t, m));
                            return {
                                colgroups: [o],
                                columns: t
                            }
                        })).getOrThunk((() => ({
                            colgroups: [],
                            columns: {}
                        }))), g = ((e, t) => ({
                            rows: e,
                            columns: t
                        }))(s, a);
                        return {
                            grid: g,
                            access: t,
                            all: o,
                            columns: d,
                            colgroups: u
                        }
                    },
                    je = e => {
                        const t = (e => {
                            const t = Pe(e);
                            return ((e, t) => R(e, (e => {
                                if ("colgroup" === U(e)) {
                                    const t = R((e => X(e, "colgroup") ? ce(e, "col") : I(ze(e), (e => ce(e, "col"))))(e), (e => {
                                        const t = Ne(e, "span", 1);
                                        return Le(e, 1, t)
                                    }));
                                    return He(e, t, "colgroup")
                                } {
                                    const o = R((e => Re(e, "th,td"))(e), (e => {
                                        const t = Ne(e, "rowspan", 1),
                                            o = Ne(e, "colspan", 1);
                                        return Le(e, t, o)
                                    }));
                                    return He(e, o, t(e))
                                }
                            })))([...ze(e), ...t], Fe)
                        })(e);
                        return Ue(t)
                    },
                    We = (e, t, o) => b.from(e.access[Ze(t, o)]),
                    $e = (e, t, o) => {
                        const n = ((e, t) => {
                            const o = I(e.all, (e => e.cells));
                            return B(o, t)
                        })(e, (e => o(t, e.element)));
                        return n.length > 0 ? b.some(n[0]) : b.none()
                    },
                    qe = (e, t) => b.from(e.columns[t]);
                var Ge = tinymce.util.Tools.resolve("tinymce.util.Tools");
                const Ke = (e, t, o) => {
                        const n = e.select("td,th", t);
                        let r;
                        for (let t = 0; t < n.length; t++) {
                            const s = e.getStyle(n[t], o);
                            if (a(r) && (r = s), r !== s) return ""
                        }
                        return r
                    },
                    Ye = (e, t, o) => {
                        Ge.each("left center right".split(" "), (n => {
                            n !== o && e.formatter.remove("align" + n, {}, t)
                        })), o && e.formatter.apply("align" + o, {}, t)
                    },
                    Xe = (e, t, o) => {
                        e.dispatch("TableModified", { ...o,
                            table: t
                        })
                    },
                    Je = (e, t, o) => ((e, t) => (e => {
                        const t = parseFloat(e);
                        return isNaN(t) ? b.none() : b.some(t)
                    })(e).getOr(t))(Ee(e, t), o),
                    Qe = e => ((e, t) => {
                        const o = e.dom,
                            n = o.getBoundingClientRect().width || o.offsetWidth;
                        return "border-box" === t ? n : ((e, t, o, n) => t - Je(e, `padding-${o}`, 0) - Je(e, `padding-${n}`, 0) - Je(e, `border-${o}-width`, 0) - Je(e, `border-${n}-width`, 0))(e, n, "left", "right")
                    })(e, "content-box");
                var et = tinymce.util.Tools.resolve("tinymce.Env");
                const tt = N(5, (e => {
                        const t = `${e+1}px`;
                        return {
                            title: t,
                            value: t
                        }
                    })),
                    ot = R(["Solid", "Dotted", "Dashed", "Double", "Groove", "Ridge", "Inset", "Outset", "None", "Hidden"], (e => ({
                        title: e,
                        value: e.toLowerCase()
                    }))),
                    nt = "100%",
                    rt = e => {
                        var t;
                        const o = e.dom,
                            n = null !== (t = o.getParent(e.selection.getStart(), o.isBlock)) && void 0 !== t ? t : e.getBody();
                        return Qe(Z.fromDom(n)) + "px"
                    },
                    st = e => t => t.options.get(e),
                    at = st("table_sizing_mode"),
                    it = st("table_border_widths"),
                    lt = st("table_border_styles"),
                    ct = st("table_cell_advtab"),
                    dt = st("table_row_advtab"),
                    ut = st("table_advtab"),
                    mt = st("table_appearance_options"),
                    gt = st("table_grid"),
                    ht = st("table_style_by_css"),
                    pt = st("table_cell_class_list"),
                    ft = st("table_row_class_list"),
                    vt = st("table_class_list"),
                    bt = st("table_toolbar"),
                    yt = st("table_background_color_map"),
                    wt = st("table_border_color_map"),
                    xt = e => "fixed" === at(e),
                    Ct = e => "responsive" === at(e),
                    St = e => {
                        const t = e.options,
                            o = t.get("table_default_styles");
                        return t.isSet("table_default_styles") ? o : ((e, t) => Ct(e) || !ht(e) ? t : xt(e) ? { ...t,
                            width: rt(e)
                        } : { ...t,
                            width: nt
                        })(e, o)
                    },
                    kt = e => {
                        const t = e.options,
                            o = t.get("table_default_attributes");
                        return t.isSet("table_default_attributes") ? o : ((e, t) => Ct(e) || ht(e) ? t : xt(e) ? { ...t,
                            width: rt(e)
                        } : { ...t,
                            width: nt
                        })(e, o)
                    },
                    _t = e => t => Q(t, (e => Z.fromDom(e.getBody()))(e)),
                    Ot = e => /^\d+(\.\d+)?$/.test(e) ? e + "px" : e,
                    Tt = e => Z.fromDom(e.selection.getStart()),
                    Et = (e, t) => t.column >= e.startCol && t.column + t.colspan - 1 <= e.finishCol && t.row >= e.startRow && t.row + t.rowspan - 1 <= e.finishRow,
                    At = (e, t, o) => ((e, t, o) => {
                        const n = $e(e, t, Q),
                            r = $e(e, o, Q);
                        return n.bind((e => r.map((t => {
                            return o = e, n = t, {
                                startRow: Math.min(o.row, n.row),
                                startCol: Math.min(o.column, n.column),
                                finishRow: Math.max(o.row + o.rowspan - 1, n.row + n.rowspan - 1),
                                finishCol: Math.max(o.column + o.colspan - 1, n.column + n.colspan - 1)
                            };
                            var o, n
                        }))))
                    })(e, t, o).bind((t => ((e, t) => {
                        let o = !0;
                        const n = h(Et, t);
                        for (let r = t.startRow; r <= t.finishRow; r++)
                            for (let s = t.startCol; s <= t.finishCol; s++) o = o && We(e, r, s).exists(n);
                        return o ? b.some(t) : b.none()
                    })(e, t))),
                    Mt = je,
                    Nt = (e, t) => {
                        oe(e).each((o => {
                            o.dom.insertBefore(t.dom, e.dom)
                        }))
                    },
                    Rt = (e, t) => {
                        ne(e).fold((() => {
                            oe(e).each((e => {
                                Dt(e, t)
                            }))
                        }), (e => {
                            Nt(e, t)
                        }))
                    },
                    Dt = (e, t) => {
                        e.dom.appendChild(t.dom)
                    },
                    Bt = (e, t) => {
                        D(t, ((o, n) => {
                            const r = 0 === n ? e : t[n - 1];
                            Rt(r, o)
                        }))
                    },
                    Lt = e => {
                        const t = e.dom;
                        null !== t.parentNode && t.parentNode.removeChild(t)
                    },
                    Ht = ((e, t) => {
                        const o = t => e(t) ? b.from(t.dom.nodeValue) : b.none();
                        return {
                            get: t => {
                                if (!e(t)) throw new Error("Can only get text value of a text node");
                                return o(t).getOr("")
                            },
                            getOption: o,
                            set: (t, o) => {
                                if (!e(t)) throw new Error("Can only set raw text value of a text node");
                                t.dom.nodeValue = o
                            }
                        }
                    })(q);
                var It = ["body", "p", "div", "article", "aside", "figcaption", "figure", "footer", "header", "nav", "section", "ol", "ul", "li", "table", "thead", "tbody", "tfoot", "caption", "tr", "td", "th", "h1", "h2", "h3", "h4", "h5", "h6", "blockquote", "pre", "address"];
                const Pt = (e, t, o, n) => {
                        const r = t(e, o);
                        return s = (o, n) => {
                            const r = t(e, n);
                            return zt(e, o, r)
                        }, a = r, ((e, t) => {
                            for (let o = e.length - 1; o >= 0; o--) t(e[o], o)
                        })(n, ((e, t) => {
                            a = s(a, e)
                        })), a;
                        var s, a
                    },
                    zt = (e, t, o) => t.bind((t => o.filter(h(e.eq, t)))),
                    Ft = {
                        up: u({
                            selector: me,
                            closest: pe,
                            predicate: ue,
                            all: (e, t) => {
                                const o = l(t) ? t : f;
                                let n = e.dom;
                                const r = [];
                                for (; null !== n.parentNode && void 0 !== n.parentNode;) {
                                    const e = n.parentNode,
                                        t = Z.fromDom(e);
                                    if (r.push(t), !0 === o(t)) break;
                                    n = e
                                }
                                return r
                            }
                        }),
                        down: u({
                            selector: de,
                            predicate: le
                        }),
                        styles: u({
                            get: Ee,
                            getRaw: Me,
                            set: (e, t, o) => {
                                ((e, t, o) => {
                                    if (!n(o)) throw console.error("Invalid call to CSS.set. Property ", t, ":: Value ", o, ":: Element ", e), new Error("CSS value must be a string: " + o);
                                    Te(e) && e.style.setProperty(t, o)
                                })(e.dom, t, o)
                            },
                            remove: (e, t) => {
                                ((e, t) => {
                                    Te(e) && e.style.removeProperty(t)
                                })(e.dom, t), we(be(e, "style").map(Se), "") && ye(e, "style")
                            }
                        }),
                        attrs: u({
                            get: ve,
                            set: (e, t, o) => {
                                fe(e.dom, t, o)
                            },
                            remove: ye,
                            copyTo: (e, t) => {
                                ((e, t) => {
                                    const o = e.dom;
                                    x(t, ((e, t) => {
                                        fe(o, t, e)
                                    }))
                                })(t, L(e.dom.attributes, ((e, t) => (e[t.name] = t.value, e)), {}))
                            }
                        }),
                        insert: u({
                            before: Nt,
                            after: Rt,
                            afterAll: Bt,
                            append: Dt,
                            appendAll: (e, t) => {
                                D(t, (t => {
                                    Dt(e, t)
                                }))
                            },
                            prepend: (e, t) => {
                                (e => ((e, t) => {
                                    const o = e.dom.childNodes;
                                    return b.from(o[0]).map(Z.fromDom)
                                })(e))(e).fold((() => {
                                    Dt(e, t)
                                }), (o => {
                                    e.dom.insertBefore(t.dom, o.dom)
                                }))
                            },
                            wrap: (e, t) => {
                                Nt(e, t), Dt(t, e)
                            }
                        }),
                        remove: u({
                            unwrap: e => {
                                const t = re(e);
                                t.length > 0 && Bt(e, t), Lt(e)
                            },
                            remove: Lt
                        }),
                        create: u({
                            nu: Z.fromTag,
                            clone: e => Z.fromDom(e.dom.cloneNode(!1)),
                            text: Z.fromText
                        }),
                        query: u({
                            comparePosition: (e, t) => e.dom.compareDocumentPosition(t.dom),
                            prevSibling: e => b.from(e.dom.previousSibling).map(Z.fromDom),
                            nextSibling: ne
                        }),
                        property: u({
                            children: re,
                            name: U,
                            parent: oe,
                            document: e => te(e).dom,
                            isText: q,
                            isComment: e => 8 === j(e) || "#comment" === U(e),
                            isElement: $,
                            isSpecial: e => {
                                const t = U(e);
                                return A(["script", "noscript", "iframe", "noframes", "noembed", "title", "style", "textarea", "xmp"], t)
                            },
                            getLanguage: e => $(e) ? be(e, "lang") : b.none(),
                            getText: e => Ht.get(e),
                            setText: (e, t) => Ht.set(e, t),
                            isBoundary: e => !!$(e) && ("body" === U(e) || A(It, U(e))),
                            isEmptyTag: e => !!$(e) && A(["br", "img", "hr", "input"], U(e)),
                            isNonEditable: e => $(e) && "false" === ve(e, "contenteditable")
                        }),
                        eq: Q,
                        is: ee
                    },
                    Vt = e => me(e, "table"),
                    Zt = (e, t, o) => he(e, t).bind((t => he(e, o).bind((e => {
                        return (o = Vt, n = [t, e], ((e, t, o) => o.length > 0 ? ((e, t, o, n) => n(e, t, o[0], o.slice(1)))(e, t, o, Pt) : b.none())(Ft, ((e, t) => o(t)), n)).map((o => ({
                            first: t,
                            last: e,
                            table: o
                        })));
                        var o, n
                    })))),
                    Ut = e => R(e, Z.fromDom),
                    jt = "data-mce-selected",
                    Wt = "data-mce-first-selected",
                    $t = "data-mce-last-selected",
                    qt = {
                        selected: jt,
                        selectedSelector: "td[" + jt + "],th[" + jt + "]",
                        firstSelected: Wt,
                        firstSelectedSelector: "td[" + Wt + "],th[" + Wt + "]",
                        lastSelected: $t,
                        lastSelectedSelector: "td[" + $t + "],th[" + $t + "]"
                    },
                    Gt = e => (t, o) => {
                        const n = U(t),
                            r = "col" === n || "colgroup" === n ? Ie(s = t).bind((e => ((e, t) => ((e, t) => {
                                const o = de(e, t);
                                return o.length > 0 ? b.some(o) : b.none()
                            })(e, t))(e, qt.firstSelectedSelector))).fold(u(s), (e => e[0])) : t;
                        var s;
                        return pe(r, e, o)
                    },
                    Kt = Gt("th,td,caption"),
                    Yt = Gt("th,td"),
                    Xt = e => Ut(e.model.table.getSelectedCells()),
                    Jt = (e, t) => {
                        const o = Yt(e),
                            n = o.bind((e => Ie(e))).map((e => Pe(e)));
                        return xe(o, n, ((e, o) => B(o, (o => M(Ut(o.dom.cells), (o => "1" === ve(o, t) || Q(o, e))))))).getOr([])
                    },
                    Qt = [{
                        text: "None",
                        value: ""
                    }, {
                        text: "Top",
                        value: "top"
                    }, {
                        text: "Middle",
                        value: "middle"
                    }, {
                        text: "Bottom",
                        value: "bottom"
                    }],
                    eo = /^#?([a-f\d])([a-f\d])([a-f\d])$/i,
                    to = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i,
                    oo = e => {
                        return (t = e, "#", Ce(t, "#") ? ((e, t) => e.substring(t))(t, "#".length) : t).toUpperCase();
                        var t
                    },
                    no = e => {
                        const t = e.toString(16);
                        return (1 === t.length ? "0" + t : t).toUpperCase()
                    },
                    ro = e => ({
                        value: no(e.red) + no(e.green) + no(e.blue)
                    }),
                    so = /^\s*rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)\s*$/i,
                    ao = /^\s*rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d?(?:\.\d+)?)\s*\)\s*$/i,
                    io = (e, t, o, n) => ({
                        red: e,
                        green: t,
                        blue: o,
                        alpha: n
                    }),
                    lo = (e, t, o, n) => {
                        const r = parseInt(e, 10),
                            s = parseInt(t, 10),
                            a = parseInt(o, 10),
                            i = parseFloat(n);
                        return io(r, s, a, i)
                    },
                    co = e => {
                        if ("transparent" === e) return b.some(io(0, 0, 0, 0));
                        const t = so.exec(e);
                        if (null !== t) return b.some(lo(t[1], t[2], t[3], "1"));
                        const o = ao.exec(e);
                        return null !== o ? b.some(lo(o[1], o[2], o[3], o[4])) : b.none()
                    },
                    uo = e => {
                        let t = e;
                        return {
                            get: () => t,
                            set: e => {
                                t = e
                            }
                        }
                    },
                    mo = (e, t, o) => n => {
                        const r = (e => {
                                const t = uo(b.none()),
                                    o = () => t.get().each(e);
                                return {
                                    clear: () => {
                                        o(), t.set(b.none())
                                    },
                                    isSet: () => t.get().isSome(),
                                    get: () => t.get(),
                                    set: e => {
                                        o(), t.set(b.some(e))
                                    }
                                }
                            })((e => e.unbind())),
                            s = !_e(o),
                            a = () => {
                                const a = Xt(e),
                                    i = n => e.formatter.match(t, {
                                        value: o
                                    }, n.dom, s);
                                s ? (n.setActive(!M(a, i)), r.set(e.formatter.formatChanged(t, (e => n.setActive(!e)), !0))) : (n.setActive(P(a, i)), r.set(e.formatter.formatChanged(t, n.setActive, !1, {
                                    value: o
                                })))
                            };
                        return e.initialized ? a() : e.on("init", a), r.clear
                    },
                    go = e => O(e, "menu"),
                    ho = e => R(e, (e => {
                        const t = e.text || e.title || "";
                        return go(e) ? {
                            text: t,
                            items: ho(e.menu)
                        } : {
                            text: t,
                            value: e.value
                        }
                    })),
                    po = (e, t, o, n) => R(t, (t => {
                        const r = t.text || t.title;
                        return go(t) ? {
                            type: "nestedmenuitem",
                            text: r,
                            getSubmenuItems: () => po(e, t.menu, o, n)
                        } : {
                            text: r,
                            type: "togglemenuitem",
                            onAction: () => n(t.value),
                            onSetup: mo(e, o, t.value)
                        }
                    })),
                    fo = (e, t) => o => {
                        e.execCommand("mceTableApplyCellStyle", !1, {
                            [t]: o
                        })
                    },
                    vo = e => I(e, (e => go(e) ? [{ ...e,
                        menu: vo(e.menu)
                    }] : _e(e.value) ? [e] : [])),
                    bo = (e, t, o, n) => r => r(po(e, t, o, n)),
                    yo = (e, t, o) => {
                        const n = R(t, (e => {
                            return {
                                text: e.title,
                                value: "#" + (o = e.value, (t = o, (e => eo.test(e) || to.test(e))(t) ? b.some({
                                    value: oo(t)
                                }) : b.none()).orThunk((() => co(o).map(ro))).getOrThunk((() => {
                                    const e = document.createElement("canvas");
                                    e.height = 1, e.width = 1;
                                    const t = e.getContext("2d");
                                    t.clearRect(0, 0, e.width, e.height), t.fillStyle = "#FFFFFF", t.fillStyle = o, t.fillRect(0, 0, 1, 1);
                                    const n = t.getImageData(0, 0, 1, 1).data,
                                        r = n[0],
                                        s = n[1],
                                        a = n[2],
                                        i = n[3];
                                    return ro(io(r, s, a, i))
                                }))).value,
                                type: "choiceitem"
                            };
                            var t, o
                        }));
                        return [{
                            type: "fancymenuitem",
                            fancytype: "colorswatch",
                            initData: {
                                colors: n.length > 0 ? n : void 0,
                                allowCustomColors: !1
                            },
                            onAction: t => {
                                const n = "remove" === t.value ? "" : t.value;
                                e.execCommand("mceTableApplyCellStyle", !1, {
                                    [o]: n
                                })
                            }
                        }]
                    },
                    wo = e => () => {
                        const t = "header" === e.queryCommandValue("mceTableRowType") ? "body" : "header";
                        e.execCommand("mceTableRowType", !1, {
                            type: t
                        })
                    },
                    xo = e => () => {
                        const t = "th" === e.queryCommandValue("mceTableColType") ? "td" : "th";
                        e.execCommand("mceTableColType", !1, {
                            type: t
                        })
                    },
                    Co = [{
                        name: "width",
                        type: "input",
                        label: "Width"
                    }, {
                        name: "height",
                        type: "input",
                        label: "Height"
                    }, {
                        name: "celltype",
                        type: "listbox",
                        label: "Cell type",
                        items: [{
                            text: "Cell",
                            value: "td"
                        }, {
                            text: "Header cell",
                            value: "th"
                        }]
                    }, {
                        name: "scope",
                        type: "listbox",
                        label: "Scope",
                        items: [{
                            text: "None",
                            value: ""
                        }, {
                            text: "Row",
                            value: "row"
                        }, {
                            text: "Column",
                            value: "col"
                        }, {
                            text: "Row group",
                            value: "rowgroup"
                        }, {
                            text: "Column group",
                            value: "colgroup"
                        }]
                    }, {
                        name: "halign",
                        type: "listbox",
                        label: "Horizontal align",
                        items: [{
                            text: "None",
                            value: ""
                        }, {
                            text: "Left",
                            value: "left"
                        }, {
                            text: "Center",
                            value: "center"
                        }, {
                            text: "Right",
                            value: "right"
                        }]
                    }, {
                        name: "valign",
                        type: "listbox",
                        label: "Vertical align",
                        items: Qt
                    }],
                    So = e => Co.concat((e => {
                        const t = ho(pt(e));
                        return t.length > 0 ? b.some({
                            name: "class",
                            type: "listbox",
                            label: "Class",
                            items: t
                        }) : b.none()
                    })(e).toArray()),
                    ko = (e, t) => {
                        const o = [{
                            name: "borderstyle",
                            type: "listbox",
                            label: "Border style",
                            items: [{
                                text: "Select...",
                                value: ""
                            }].concat(ho(lt(e)))
                        }, {
                            name: "bordercolor",
                            type: "colorinput",
                            label: "Border color"
                        }, {
                            name: "backgroundcolor",
                            type: "colorinput",
                            label: "Background color"
                        }];
                        return {
                            title: "Advanced",
                            name: "advanced",
                            items: "cell" === t ? [{
                                name: "borderwidth",
                                type: "input",
                                label: "Border width"
                            }].concat(o) : o
                        }
                    },
                    _o = (e, t) => {
                        const o = e.dom;
                        return {
                            setAttrib: (e, n) => {
                                o.setAttrib(t, e, n)
                            },
                            setStyle: (e, n) => {
                                o.setStyle(t, e, n)
                            },
                            setFormat: (o, n) => {
                                "" === n ? e.formatter.remove(o, {
                                    value: null
                                }, t, !0) : e.formatter.apply(o, {
                                    value: n
                                }, t)
                            }
                        }
                    },
                    Oo = Y("th"),
                    To = (e, t) => e && t ? "sectionCells" : e ? "section" : "cells",
                    Eo = e => {
                        const t = R(e, (e => (e => {
                                const t = "thead" === e.section,
                                    o = we((e => {
                                        const t = B(e, (e => Oo(e.element)));
                                        return 0 === t.length ? b.some("td") : t.length === e.length ? b.some("th") : b.none()
                                    })(e.cells), "th");
                                return "tfoot" === e.section ? {
                                    type: "footer"
                                } : t || o ? {
                                    type: "header",
                                    subType: To(t, o)
                                } : {
                                    type: "body"
                                }
                            })(e).type)),
                            o = A(t, "header"),
                            n = A(t, "footer");
                        if (o || n) {
                            const e = A(t, "body");
                            return !o || e || n ? o || e || !n ? b.none() : b.some("footer") : b.some("header")
                        }
                        return b.some("body")
                    },
                    Ao = (e, t) => F(e.all, (e => H(e.cells, (e => Q(t, e.element))))),
                    Mo = (e, t, o) => {
                        const n = (e => {
                            const t = [],
                                o = e => {
                                    t.push(e)
                                };
                            for (let t = 0; t < e.length; t++) e[t].each(o);
                            return t
                        })(R(t.selection, (t => {
                            return (n = t, ((e, t, o = f) => o(t) ? b.none() : A(e, U(t)) ? b.some(t) : me(t, e.join(","), (e => X(e, "table") || o(e))))(["td", "th"], n, r)).bind((t => Ao(e, t))).filter(o);
                            var n, r
                        })));
                        return r = n, n.length > 0 ? b.some(r) : b.none();
                        var r
                    },
                    No = (e, t) => Mo(e, t, v),
                    Ro = (e, t) => P(t, (t => ((e, t) => Ao(e, t).exists((e => !e.isLocked)))(e, t))),
                    Do = (e, t) => ((e, t) => t.mergable)(0, t).filter((t => Ro(e, t.cells))),
                    Bo = (e, t) => ((e, t) => t.unmergable)(0, t).filter((t => Ro(e, t))),
                    Lo = ((e => {
                        if (!r(e)) throw new Error("cases must be an array");
                        if (0 === e.length) throw new Error("there must be at least one case");
                        const t = [],
                            o = {};
                        D(e, ((n, s) => {
                            const a = y(n);
                            if (1 !== a.length) throw new Error("one and only one name per case");
                            const i = a[0],
                                l = n[i];
                            if (void 0 !== o[i]) throw new Error("duplicate key detected:" + i);
                            if ("cata" === i) throw new Error("cannot have a case named cata (sorry)");
                            if (!r(l)) throw new Error("case arguments must be an array");
                            t.push(i), o[i] = (...o) => {
                                const n = o.length;
                                if (n !== l.length) throw new Error("Wrong number of arguments to case " + i + ". Expected " + l.length + " (" + l + "), got " + n);
                                return {
                                    fold: (...t) => {
                                        if (t.length !== e.length) throw new Error("Wrong number of arguments to fold. Expected " + e.length + ", got " + t.length);
                                        return t[s].apply(null, o)
                                    },
                                    match: e => {
                                        const n = y(e);
                                        if (t.length !== n.length) throw new Error("Wrong number of arguments to match. Expected: " + t.join(",") + "\nActual: " + n.join(","));
                                        if (!P(t, (e => A(n, e)))) throw new Error("Not all branches were specified when using match. Specified: " + n.join(", ") + "\nRequired: " + t.join(", "));
                                        return e[i].apply(null, o)
                                    },
                                    log: e => {
                                        console.log(e, {
                                            constructors: t,
                                            constructor: i,
                                            params: o
                                        })
                                    }
                                }
                            }
                        }))
                    })([{
                        none: []
                    }, {
                        only: ["index"]
                    }, {
                        left: ["index", "next"]
                    }, {
                        middle: ["prev", "index", "next"]
                    }, {
                        right: ["prev", "index"]
                    }]), (e, t) => {
                        const o = je(e);
                        return No(o, t).bind((e => {
                            const t = e[e.length - 1],
                                n = e[0].row,
                                r = t.row + t.rowspan,
                                s = o.all.slice(n, r);
                            return Eo(s)
                        })).getOr("")
                    }),
                    Ho = e => {
                        return Ce(e, "rgb") ? co(t = e).map(ro).map((e => "#" + e.value)).getOr(t) : e;
                        var t
                    },
                    Io = e => {
                        const t = Z.fromDom(e);
                        return {
                            borderwidth: Me(t, "border-width").getOr(""),
                            borderstyle: Me(t, "border-style").getOr(""),
                            bordercolor: Me(t, "border-color").map(Ho).getOr(""),
                            backgroundcolor: Me(t, "background-color").map(Ho).getOr("")
                        }
                    },
                    Po = e => {
                        const t = e[0],
                            o = e.slice(1);
                        return D(o, (e => {
                            D(y(t), (o => {
                                x(e, ((e, n) => {
                                    const r = t[o];
                                    "" !== r && o === n && r !== e && (t[o] = "")
                                }))
                            }))
                        })), t
                    },
                    zo = (e, t, o, n) => H(e, (e => !a(o.formatter.matchNode(n, t + e)))).getOr(""),
                    Fo = h(zo, ["left", "center", "right"], "align"),
                    Vo = h(zo, ["top", "middle", "bottom"], "valign"),
                    Zo = e => Ie(Z.fromDom(e)).map((t => {
                        const o = {
                            selection: Ut(e.cells)
                        };
                        return Lo(t, o)
                    })).getOr(""),
                    Uo = (e, t) => {
                        const o = je(e),
                            n = (e => I(e.all, (e => e.cells)))(o),
                            r = B(n, (e => M(t, (t => Q(e.element, t)))));
                        return R(r, (e => ({
                            element: e.element.dom,
                            column: qe(o, e.column).map((e => e.element.dom))
                        })))
                    },
                    jo = (e, t, o, n) => {
                        const r = n.getData();
                        n.close(), e.undoManager.transact((() => {
                            ((e, t, o, n) => {
                                const r = C(n, ((e, t) => o[t] !== e));
                                S(r) > 0 && t.length >= 1 && Ie(t[0]).each((o => {
                                    const s = Uo(o, t),
                                        a = S(C(r, ((e, t) => "scope" !== t && "celltype" !== t))) > 0,
                                        i = _(r, "celltype");
                                    (a || _(r, "scope")) && ((e, t, o, n) => {
                                        const r = 1 === t.length;
                                        D(t, (t => {
                                            const s = t.element,
                                                a = r ? v : n,
                                                i = _o(e, s);
                                            ((e, t, o, n) => {
                                                n("scope") && e.setAttrib("scope", o.scope), n("class") && e.setAttrib("class", o.class), n("height") && e.setStyle("height", Ot(o.height)), n("width") && t.setStyle("width", Ot(o.width))
                                            })(i, t.column.map((t => _o(e, t))).getOr(i), o, a), ct(e) && ((e, t, o) => {
                                                o("backgroundcolor") && e.setFormat("tablecellbackgroundcolor", t.backgroundcolor), o("bordercolor") && e.setFormat("tablecellbordercolor", t.bordercolor), o("borderstyle") && e.setFormat("tablecellborderstyle", t.borderstyle), o("borderwidth") && e.setFormat("tablecellborderwidth", Ot(t.borderwidth))
                                            })(i, o, a), n("halign") && Ye(e, s, o.halign), n("valign") && ((e, t, o) => {
                                                Ge.each("top middle bottom".split(" "), (n => {
                                                    n !== o && e.formatter.remove("valign" + n, {}, t)
                                                })), o && e.formatter.apply("valign" + o, {}, t)
                                            })(e, s, o.valign)
                                        }))
                                    })(e, s, n, h(_, r)), i && ((e, t) => {
                                        e.execCommand("mceTableCellType", !1, {
                                            type: t.celltype,
                                            no_events: !0
                                        })
                                    })(e, n), Xe(e, o.dom, {
                                        structure: i,
                                        style: a
                                    })
                                }))
                            })(e, t, o, r), e.focus()
                        }))
                    },
                    Wo = e => {
                        const t = Xt(e);
                        if (0 === t.length) return;
                        const o = ((e, t) => {
                                const o = Ie(t[0]).map((o => R(Uo(o, t), (t => ((e, t, o, n) => {
                                    const r = e.dom,
                                        s = (e, t) => r.getStyle(e, t) || r.getAttrib(e, t);
                                    return {
                                        width: s(n.getOr(t), "width"),
                                        height: s(t, "height"),
                                        scope: r.getAttrib(t, "scope"),
                                        celltype: (a = t, a.nodeName.toLowerCase()),
                                        class: r.getAttrib(t, "class", ""),
                                        halign: Fo(e, t),
                                        valign: Vo(e, t),
                                        ...o ? Io(t) : {}
                                    };
                                    var a
                                })(e, t.element, ct(e), t.column)))));
                                return Po(o.getOrDie())
                            })(e, t),
                            n = {
                                type: "tabpanel",
                                tabs: [{
                                    title: "General",
                                    name: "general",
                                    items: So(e)
                                }, ko(e, "cell")]
                            },
                            r = {
                                type: "panel",
                                items: [{
                                    type: "grid",
                                    columns: 2,
                                    items: So(e)
                                }]
                            };
                        e.windowManager.open({
                            title: "Cell Properties",
                            size: "normal",
                            body: ct(e) ? n : r,
                            buttons: [{
                                type: "cancel",
                                name: "cancel",
                                text: "Cancel"
                            }, {
                                type: "submit",
                                name: "save",
                                text: "Save",
                                primary: !0
                            }],
                            initialData: o,
                            onSubmit: h(jo, e, t, o)
                        })
                    },
                    $o = [{
                        type: "listbox",
                        name: "type",
                        label: "Row type",
                        items: [{
                            text: "Header",
                            value: "header"
                        }, {
                            text: "Body",
                            value: "body"
                        }, {
                            text: "Footer",
                            value: "footer"
                        }]
                    }, {
                        type: "listbox",
                        name: "align",
                        label: "Alignment",
                        items: [{
                            text: "None",
                            value: ""
                        }, {
                            text: "Left",
                            value: "left"
                        }, {
                            text: "Center",
                            value: "center"
                        }, {
                            text: "Right",
                            value: "right"
                        }]
                    }, {
                        label: "Height",
                        name: "height",
                        type: "input"
                    }],
                    qo = e => $o.concat((e => {
                        const t = ho(ft(e));
                        return t.length > 0 ? b.some({
                            name: "class",
                            type: "listbox",
                            label: "Class",
                            items: t
                        }) : b.none()
                    })(e).toArray()),
                    Go = (e, t, o, n) => {
                        const r = n.getData();
                        n.close(), e.undoManager.transact((() => {
                            ((e, t, o, n) => {
                                const r = C(n, ((e, t) => o[t] !== e));
                                if (S(r) > 0) {
                                    const o = _(r, "type"),
                                        s = !o || S(r) > 1;
                                    s && ((e, t, o, n) => {
                                        const r = 1 === t.length ? v : n;
                                        D(t, (t => {
                                            const s = _o(e, t);
                                            ((e, t, o) => {
                                                o("class") && e.setAttrib("class", t.class), o("height") && e.setStyle("height", Ot(t.height))
                                            })(s, o, r), dt(e) && ((e, t, o) => {
                                                o("backgroundcolor") && e.setStyle("background-color", t.backgroundcolor), o("bordercolor") && e.setStyle("border-color", t.bordercolor), o("borderstyle") && e.setStyle("border-style", t.borderstyle)
                                            })(s, o, r), n("align") && Ye(e, t, o.align)
                                        }))
                                    })(e, t, n, h(_, r)), o && ((e, t) => {
                                        e.execCommand("mceTableRowType", !1, {
                                            type: t.type,
                                            no_events: !0
                                        })
                                    })(e, n), Ie(Z.fromDom(t[0])).each((t => Xe(e, t.dom, {
                                        structure: o,
                                        style: s
                                    })))
                                }
                            })(e, t, o, r), e.focus()
                        }))
                    },
                    Ko = e => {
                        const t = Jt(Tt(e), qt.selected);
                        if (0 === t.length) return;
                        const o = R(t, (t => ((e, t, o) => {
                                const n = e.dom;
                                return {
                                    height: n.getStyle(t, "height") || n.getAttrib(t, "height"),
                                    class: n.getAttrib(t, "class", ""),
                                    type: Zo(t),
                                    align: Fo(e, t),
                                    ...o ? Io(t) : {}
                                }
                            })(e, t.dom, dt(e)))),
                            n = Po(o),
                            r = {
                                type: "tabpanel",
                                tabs: [{
                                    title: "General",
                                    name: "general",
                                    items: qo(e)
                                }, ko(e, "row")]
                            },
                            s = {
                                type: "panel",
                                items: [{
                                    type: "grid",
                                    columns: 2,
                                    items: qo(e)
                                }]
                            };
                        e.windowManager.open({
                            title: "Row Properties",
                            size: "normal",
                            body: dt(e) ? r : s,
                            buttons: [{
                                type: "cancel",
                                name: "cancel",
                                text: "Cancel"
                            }, {
                                type: "submit",
                                name: "save",
                                text: "Save",
                                primary: !0
                            }],
                            initialData: n,
                            onSubmit: h(Go, e, R(t, (e => e.dom)), n)
                        })
                    },
                    Yo = (e, t, o) => {
                        const n = o ? [{
                                type: "input",
                                name: "cols",
                                label: "Cols",
                                inputMode: "numeric"
                            }, {
                                type: "input",
                                name: "rows",
                                label: "Rows",
                                inputMode: "numeric"
                            }] : [],
                            r = mt(e) ? [{
                                type: "input",
                                name: "cellspacing",
                                label: "Cell spacing",
                                inputMode: "numeric"
                            }, {
                                type: "input",
                                name: "cellpadding",
                                label: "Cell padding",
                                inputMode: "numeric"
                            }, {
                                type: "input",
                                name: "border",
                                label: "Border width"
                            }, {
                                type: "label",
                                label: "Caption",
                                items: [{
                                    type: "checkbox",
                                    name: "caption",
                                    label: "Show caption"
                                }]
                            }] : [],
                            s = t.length > 0 ? [{
                                type: "listbox",
                                name: "class",
                                label: "Class",
                                items: t
                            }] : [];
                        return n.concat([{
                            type: "input",
                            name: "width",
                            label: "Width"
                        }, {
                            type: "input",
                            name: "height",
                            label: "Height"
                        }]).concat(r).concat([{
                            type: "listbox",
                            name: "align",
                            label: "Alignment",
                            items: [{
                                text: "None",
                                value: ""
                            }, {
                                text: "Left",
                                value: "left"
                            }, {
                                text: "Center",
                                value: "center"
                            }, {
                                text: "Right",
                                value: "right"
                            }]
                        }]).concat(s)
                    },
                    Xo = (e, t, o, r) => {
                        if ("TD" === t.tagName || "TH" === t.tagName) n(o) && i(r) ? e.setStyle(t, o, r) : e.setStyles(t, o);
                        else if (t.children)
                            for (let n = 0; n < t.children.length; n++) Xo(e, t.children[n], o, r)
                    },
                    Jo = (e, t, o, n) => {
                        const r = e.dom,
                            s = n.getData(),
                            i = C(s, ((e, t) => o[t] !== e));
                        n.close(), "" === s.class && delete s.class, e.undoManager.transact((() => {
                            if (!t) {
                                const o = Oe(s.cols).getOr(1),
                                    n = Oe(s.rows).getOr(1);
                                e.execCommand("mceInsertTable", !1, {
                                    rows: n,
                                    columns: o
                                }), t = Yt(Tt(e), _t(e)).bind((t => Ie(t, _t(e)))).map((e => e.dom)).getOrDie()
                            }
                            if (S(i) > 0) {
                                ((e, t, o) => {
                                    const n = e.dom,
                                        r = {},
                                        s = {};
                                    if (a(o.class) || (r.class = o.class), s.height = Ot(o.height), ht(e) ? s.width = Ot(o.width) : n.getAttrib(t, "width") && (r.width = (e => e ? e.replace(/px$/, "") : "")(o.width)), ht(e) ? (s["border-width"] = Ot(o.border), s["border-spacing"] = Ot(o.cellspacing)) : (r.border = o.border, r.cellpadding = o.cellpadding, r.cellspacing = o.cellspacing), ht(e) && t.children)
                                        for (let r = 0; r < t.children.length; r++) Xo(n, t.children[r], {
                                            "border-width": Ot(o.border),
                                            padding: Ot(o.cellpadding)
                                        }), ut(e) && Xo(n, t.children[r], {
                                            "border-color": o.bordercolor
                                        });
                                    if (ut(e)) {
                                        const e = o;
                                        s["background-color"] = e.backgroundcolor, s["border-color"] = e.bordercolor, s["border-style"] = e.borderstyle
                                    }
                                    r.style = n.serializeStyle({ ...St(e),
                                        ...s
                                    }), n.setAttribs(t, { ...kt(e),
                                        ...r
                                    })
                                })(e, t, s);
                                const o = r.select("caption", t)[0];
                                (o && !s.caption || !o && s.caption) && e.execCommand("mceTableToggleCaption"), Ye(e, t, s.align)
                            }
                            if (e.focus(), e.addVisual(), S(i) > 0) {
                                const o = _(i, "caption"),
                                    n = !o || S(i) > 1;
                                Xe(e, t, {
                                    structure: o,
                                    style: n
                                })
                            }
                        }))
                    },
                    Qo = (e, t) => {
                        const o = e.dom;
                        let n, r = ((e, t) => {
                            const o = St(e),
                                n = kt(e),
                                r = t ? {
                                    borderstyle: k(o, "border-style").getOr(""),
                                    bordercolor: Ho(k(o, "border-color").getOr("")),
                                    backgroundcolor: Ho(k(o, "background-color").getOr(""))
                                } : {};
                            return {
                                height: "",
                                width: "100%",
                                cellspacing: "",
                                cellpadding: "",
                                caption: !1,
                                class: "",
                                align: "",
                                border: "",
                                ...o,
                                ...n,
                                ...r,
                                ...(() => {
                                    const t = o["border-width"];
                                    return ht(e) && t ? {
                                        border: t
                                    } : k(n, "border").fold((() => ({})), (e => ({
                                        border: e
                                    })))
                                })(),
                                ...{ ...k(o, "border-spacing").or(k(n, "cellspacing")).fold((() => ({})), (e => ({
                                        cellspacing: e
                                    }))),
                                    ...k(o, "border-padding").or(k(n, "cellpadding")).fold((() => ({})), (e => ({
                                        cellpadding: e
                                    })))
                                }
                            }
                        })(e, ut(e));
                        t ? (r.cols = "1", r.rows = "1", ut(e) && (r.borderstyle = "", r.bordercolor = "", r.backgroundcolor = "")) : (n = o.getParent(e.selection.getStart(), "table", e.getBody()), n ? r = ((e, t, o) => {
                            const n = e.dom,
                                r = ht(e) ? n.getStyle(t, "border-spacing") || n.getAttrib(t, "cellspacing") : n.getAttrib(t, "cellspacing") || n.getStyle(t, "border-spacing"),
                                s = ht(e) ? Ke(n, t, "padding") || n.getAttrib(t, "cellpadding") : n.getAttrib(t, "cellpadding") || Ke(n, t, "padding");
                            return {
                                width: n.getStyle(t, "width") || n.getAttrib(t, "width"),
                                height: n.getStyle(t, "height") || n.getAttrib(t, "height"),
                                cellspacing: null != r ? r : "",
                                cellpadding: null != s ? s : "",
                                border: ((t, o) => {
                                    const n = Me(Z.fromDom(o), "border-width");
                                    return ht(e) && n.isSome() ? n.getOr("") : t.getAttrib(o, "border") || Ke(e.dom, o, "border-width") || Ke(e.dom, o, "border") || ""
                                })(n, t),
                                caption: !!n.select("caption", t)[0],
                                class: n.getAttrib(t, "class", ""),
                                align: Fo(e, t),
                                ...o ? Io(t) : {}
                            }
                        })(e, n, ut(e)) : ut(e) && (r.borderstyle = "", r.bordercolor = "", r.backgroundcolor = ""));
                        const s = ho(vt(e));
                        s.length > 0 && r.class && (r.class = r.class.replace(/\s*mce\-item\-table\s*/g, ""));
                        const a = {
                                type: "grid",
                                columns: 2,
                                items: Yo(e, s, t)
                            },
                            i = ut(e) ? {
                                type: "tabpanel",
                                tabs: [{
                                    title: "General",
                                    name: "general",
                                    items: [a]
                                }, ko(e, "table")]
                            } : {
                                type: "panel",
                                items: [a]
                            };
                        e.windowManager.open({
                            title: "Table Properties",
                            size: "normal",
                            body: i,
                            onSubmit: h(Jo, e, n, r),
                            buttons: [{
                                type: "cancel",
                                name: "cancel",
                                text: "Cancel"
                            }, {
                                type: "submit",
                                name: "save",
                                text: "Save",
                                primary: !0
                            }],
                            initialData: r
                        })
                    },
                    en = m,
                    tn = e => {
                        const t = (e, t) => be(e, t).exists((e => parseInt(e, 10) > 1));
                        return e.length > 0 && P(e, (e => t(e, "rowspan") || t(e, "colspan"))) ? b.some(e) : b.none()
                    },
                    on = (e, t, o) => {
                        return t.length <= 1 ? b.none() : (n = e, r = o.firstSelectedSelector, s = o.lastSelectedSelector, Zt(n, r, s).bind((e => {
                            const t = e => Q(n, e),
                                o = "thead,tfoot,tbody,table",
                                r = me(e.first, o, t),
                                s = me(e.last, o, t);
                            return r.bind((t => s.bind((o => Q(t, o) ? ((e, t, o) => {
                                const n = Mt(e);
                                return At(n, t, o)
                            })(e.table, e.first, e.last) : b.none()))))
                        }))).map((e => ({
                            bounds: e,
                            cells: t
                        })));
                        var n, r, s
                    },
                    nn = e => {
                        const t = uo(b.none()),
                            o = uo([]);
                        let n = b.none();
                        const r = Y("caption"),
                            s = e => n.forall((t => !t[e])),
                            a = () => Kt(Tt(e), _t(e)).bind((t => {
                                return o = xe(Ie(t), Kt((e => Z.fromDom(e.selection.getEnd()))(e), _t(e)).bind(Ie), ((o, n) => Q(o, n) ? r(t) ? b.some((e => ({
                                    element: e,
                                    mergable: b.none(),
                                    unmergable: b.none(),
                                    selection: [e]
                                }))(t)) : b.some(((e, t, o) => ({
                                    element: o,
                                    mergable: on(t, e, qt),
                                    unmergable: tn(e),
                                    selection: en(e)
                                }))(Xt(e), o, t)) : b.none())), o.bind(m);
                                var o
                            })),
                            i = e => Ie(e.element).map((t => {
                                const o = je(t),
                                    n = No(o, e).getOr([]),
                                    r = L(n, ((e, t) => (t.isLocked && (e.onAny = !0, 0 === t.column ? e.onFirst = !0 : t.column + t.colspan >= o.grid.columns && (e.onLast = !0)), e)), {
                                        onAny: !1,
                                        onFirst: !1,
                                        onLast: !1
                                    });
                                return {
                                    mergeable: Do(o, e).isSome(),
                                    unmergeable: Bo(o, e).isSome(),
                                    locked: r
                                }
                            })),
                            l = () => {
                                t.set((e => {
                                    let t, o = !1;
                                    return (...n) => (o || (o = !0, t = e.apply(null, n)), t)
                                })(a)()), n = t.get().bind(i), D(o.get(), p)
                            },
                            c = e => (e(), o.set(o.get().concat([e])), () => {
                                o.set(B(o.get(), (t => t !== e)))
                            }),
                            d = (e, o) => c((() => t.get().fold((() => {
                                e.setEnabled(!1)
                            }), (t => {
                                e.setEnabled(!o(t))
                            })))),
                            u = (e, o, n) => c((() => t.get().fold((() => {
                                e.setEnabled(!1), e.setActive(!1)
                            }), (t => {
                                e.setEnabled(!o(t)), e.setActive(n(t))
                            })))),
                            g = e => n.exists((t => t.locked[e])),
                            h = (t, o) => n => u(n, (e => r(e.element)), (() => e.queryCommandValue(t) === o)),
                            v = h("mceTableRowType", "header"),
                            y = h("mceTableColType", "th");
                        return e.on("NodeChange ExecCommand TableSelectorChange", l), {
                            onSetupTable: e => d(e, (e => !1)),
                            onSetupCellOrRow: e => d(e, (e => r(e.element))),
                            onSetupColumn: e => t => d(t, (t => r(t.element) || g(e))),
                            onSetupPasteable: e => t => d(t, (t => r(t.element) || e().isNone())),
                            onSetupPasteableColumn: (e, t) => o => d(o, (o => r(o.element) || e().isNone() || g(t))),
                            onSetupMergeable: e => d(e, (e => s("mergeable"))),
                            onSetupUnmergeable: e => d(e, (e => s("unmergeable"))),
                            resetTargets: l,
                            onSetupTableWithCaption: t => u(t, f, (t => Ie(t.element, _t(e)).exists((e => ge(e, "caption").isSome())))),
                            onSetupTableRowHeaders: v,
                            onSetupTableColumnHeaders: y,
                            targets: t.get
                        }
                    };
                var rn = tinymce.util.Tools.resolve("tinymce.FakeClipboard");
                const sn = "x-tinymce/dom-table-",
                    an = sn + "rows",
                    ln = sn + "columns",
                    cn = e => {
                        var t;
                        const o = null !== (t = rn.read()) && void 0 !== t ? t : [];
                        return F(o, (t => b.from(t.getType(e))))
                    },
                    dn = () => cn(an),
                    un = () => cn(ln);
                e.add("table", (e => {
                    const t = nn(e);
                    (e => {
                        const t = e.options.register;
                        t("table_border_widths", {
                            processor: "object[]",
                            default: tt
                        }), t("table_border_styles", {
                            processor: "object[]",
                            default: ot
                        }), t("table_cell_advtab", {
                            processor: "boolean",
                            default: !0
                        }), t("table_row_advtab", {
                            processor: "boolean",
                            default: !0
                        }), t("table_advtab", {
                            processor: "boolean",
                            default: !0
                        }), t("table_appearance_options", {
                            processor: "boolean",
                            default: !0
                        }), t("table_grid", {
                            processor: "boolean",
                            default: !et.deviceType.isTouch()
                        }), t("table_cell_class_list", {
                            processor: "object[]",
                            default: []
                        }), t("table_row_class_list", {
                            processor: "object[]",
                            default: []
                        }), t("table_class_list", {
                            processor: "object[]",
                            default: []
                        }), t("table_toolbar", {
                            processor: "string",
                            default: "tableprops tabledelete | tableinsertrowbefore tableinsertrowafter tabledeleterow | tableinsertcolbefore tableinsertcolafter tabledeletecol"
                        }), t("table_background_color_map", {
                            processor: "object[]",
                            default: []
                        }), t("table_border_color_map", {
                            processor: "object[]",
                            default: []
                        })
                    })(e), (e => {
                        x({
                            mceTableProps: h(Qo, e, !1),
                            mceTableRowProps: h(Ko, e),
                            mceTableCellProps: h(Wo, e)
                        }, ((t, o) => e.addCommand(o, (() => t())))), e.addCommand("mceInsertTableDialog", (t => {
                            Qo(e, !0)
                        }))
                    })(e), ((e, t) => {
                        const o = t => () => e.execCommand(t),
                            n = (t, n) => !!e.queryCommandSupported(n.command) && (e.ui.registry.addMenuItem(t, { ...n,
                                onAction: l(n.onAction) ? n.onAction : o(n.command)
                            }), !0),
                            r = (t, n) => {
                                e.queryCommandSupported(n.command) && e.ui.registry.addToggleMenuItem(t, { ...n,
                                    onAction: l(n.onAction) ? n.onAction : o(n.command)
                                })
                            },
                            s = t => {
                                e.execCommand("mceInsertTable", !1, {
                                    rows: t.numRows,
                                    columns: t.numColumns
                                })
                            },
                            a = [n("tableinsertrowbefore", {
                                text: "Insert row before",
                                icon: "table-insert-row-above",
                                command: "mceTableInsertRowBefore",
                                onSetup: t.onSetupCellOrRow
                            }), n("tableinsertrowafter", {
                                text: "Insert row after",
                                icon: "table-insert-row-after",
                                command: "mceTableInsertRowAfter",
                                onSetup: t.onSetupCellOrRow
                            }), n("tabledeleterow", {
                                text: "Delete row",
                                icon: "table-delete-row",
                                command: "mceTableDeleteRow",
                                onSetup: t.onSetupCellOrRow
                            }), n("tablerowprops", {
                                text: "Row properties",
                                icon: "table-row-properties",
                                command: "mceTableRowProps",
                                onSetup: t.onSetupCellOrRow
                            }), n("tablecutrow", {
                                text: "Cut row",
                                icon: "cut-row",
                                command: "mceTableCutRow",
                                onSetup: t.onSetupCellOrRow
                            }), n("tablecopyrow", {
                                text: "Copy row",
                                icon: "duplicate-row",
                                command: "mceTableCopyRow",
                                onSetup: t.onSetupCellOrRow
                            }), n("tablepasterowbefore", {
                                text: "Paste row before",
                                icon: "paste-row-before",
                                command: "mceTablePasteRowBefore",
                                onSetup: t.onSetupPasteable(dn)
                            }), n("tablepasterowafter", {
                                text: "Paste row after",
                                icon: "paste-row-after",
                                command: "mceTablePasteRowAfter",
                                onSetup: t.onSetupPasteable(dn)
                            })],
                            i = [n("tableinsertcolumnbefore", {
                                text: "Insert column before",
                                icon: "table-insert-column-before",
                                command: "mceTableInsertColBefore",
                                onSetup: t.onSetupColumn("onFirst")
                            }), n("tableinsertcolumnafter", {
                                text: "Insert column after",
                                icon: "table-insert-column-after",
                                command: "mceTableInsertColAfter",
                                onSetup: t.onSetupColumn("onLast")
                            }), n("tabledeletecolumn", {
                                text: "Delete column",
                                icon: "table-delete-column",
                                command: "mceTableDeleteCol",
                                onSetup: t.onSetupColumn("onAny")
                            }), n("tablecutcolumn", {
                                text: "Cut column",
                                icon: "cut-column",
                                command: "mceTableCutCol",
                                onSetup: t.onSetupColumn("onAny")
                            }), n("tablecopycolumn", {
                                text: "Copy column",
                                icon: "duplicate-column",
                                command: "mceTableCopyCol",
                                onSetup: t.onSetupColumn("onAny")
                            }), n("tablepastecolumnbefore", {
                                text: "Paste column before",
                                icon: "paste-column-before",
                                command: "mceTablePasteColBefore",
                                onSetup: t.onSetupPasteableColumn(un, "onFirst")
                            }), n("tablepastecolumnafter", {
                                text: "Paste column after",
                                icon: "paste-column-after",
                                command: "mceTablePasteColAfter",
                                onSetup: t.onSetupPasteableColumn(un, "onLast")
                            })],
                            c = [n("tablecellprops", {
                                text: "Cell properties",
                                icon: "table-cell-properties",
                                command: "mceTableCellProps",
                                onSetup: t.onSetupCellOrRow
                            }), n("tablemergecells", {
                                text: "Merge cells",
                                icon: "table-merge-cells",
                                command: "mceTableMergeCells",
                                onSetup: t.onSetupMergeable
                            }), n("tablesplitcells", {
                                text: "Split cell",
                                icon: "table-split-cells",
                                command: "mceTableSplitCells",
                                onSetup: t.onSetupUnmergeable
                            })];
                        gt(e) ? e.ui.registry.addNestedMenuItem("inserttable", {
                            text: "Table",
                            icon: "table",
                            getSubmenuItems: () => [{
                                type: "fancymenuitem",
                                fancytype: "inserttable",
                                onAction: s
                            }]
                        }) : e.ui.registry.addMenuItem("inserttable", {
                            text: "Table",
                            icon: "table",
                            onAction: o("mceInsertTableDialog")
                        }), e.ui.registry.addMenuItem("inserttabledialog", {
                            text: "Insert table",
                            icon: "table",
                            onAction: o("mceInsertTableDialog")
                        }), n("tableprops", {
                            text: "Table properties",
                            onSetup: t.onSetupTable,
                            command: "mceTableProps"
                        }), n("deletetable", {
                            text: "Delete table",
                            icon: "table-delete-table",
                            onSetup: t.onSetupTable,
                            command: "mceTableDelete"
                        }), A(a, !0) && e.ui.registry.addNestedMenuItem("row", {
                            type: "nestedmenuitem",
                            text: "Row",
                            getSubmenuItems: u("tableinsertrowbefore tableinsertrowafter tabledeleterow tablerowprops | tablecutrow tablecopyrow tablepasterowbefore tablepasterowafter")
                        }), A(i, !0) && e.ui.registry.addNestedMenuItem("column", {
                            type: "nestedmenuitem",
                            text: "Column",
                            getSubmenuItems: u("tableinsertcolumnbefore tableinsertcolumnafter tabledeletecolumn | tablecutcolumn tablecopycolumn tablepastecolumnbefore tablepastecolumnafter")
                        }), A(c, !0) && e.ui.registry.addNestedMenuItem("cell", {
                            type: "nestedmenuitem",
                            text: "Cell",
                            getSubmenuItems: u("tablecellprops tablemergecells tablesplitcells")
                        }), e.ui.registry.addContextMenu("table", {
                            update: () => (t.resetTargets(), t.targets().fold(u(""), (e => "caption" === U(e.element) ? "tableprops deletetable" : "cell row column | advtablesort | tableprops deletetable")))
                        });
                        const d = vo(vt(e));
                        0 !== d.length && e.queryCommandSupported("mceTableToggleClass") && e.ui.registry.addNestedMenuItem("tableclass", {
                            icon: "table-classes",
                            text: "Table styles",
                            getSubmenuItems: () => po(e, d, "tableclass", (t => e.execCommand("mceTableToggleClass", !1, t))),
                            onSetup: t.onSetupTable
                        });
                        const m = vo(pt(e));
                        0 !== m.length && e.queryCommandSupported("mceTableCellToggleClass") && e.ui.registry.addNestedMenuItem("tablecellclass", {
                            icon: "table-cell-classes",
                            text: "Cell styles",
                            getSubmenuItems: () => po(e, m, "tablecellclass", (t => e.execCommand("mceTableCellToggleClass", !1, t))),
                            onSetup: t.onSetupCellOrRow
                        }), e.queryCommandSupported("mceTableApplyCellStyle") && (e.ui.registry.addNestedMenuItem("tablecellvalign", {
                            icon: "vertical-align",
                            text: "Vertical align",
                            getSubmenuItems: () => po(e, Qt, "tablecellverticalalign", fo(e, "vertical-align")),
                            onSetup: t.onSetupCellOrRow
                        }), e.ui.registry.addNestedMenuItem("tablecellborderwidth", {
                            icon: "border-width",
                            text: "Border width",
                            getSubmenuItems: () => po(e, it(e), "tablecellborderwidth", fo(e, "border-width")),
                            onSetup: t.onSetupCellOrRow
                        }), e.ui.registry.addNestedMenuItem("tablecellborderstyle", {
                            icon: "border-style",
                            text: "Border style",
                            getSubmenuItems: () => po(e, lt(e), "tablecellborderstyle", fo(e, "border-style")),
                            onSetup: t.onSetupCellOrRow
                        }), e.ui.registry.addNestedMenuItem("tablecellbackgroundcolor", {
                            icon: "cell-background-color",
                            text: "Background color",
                            getSubmenuItems: () => yo(e, yt(e), "background-color"),
                            onSetup: t.onSetupCellOrRow
                        }), e.ui.registry.addNestedMenuItem("tablecellbordercolor", {
                            icon: "cell-border-color",
                            text: "Border color",
                            getSubmenuItems: () => yo(e, wt(e), "border-color"),
                            onSetup: t.onSetupCellOrRow
                        })), r("tablecaption", {
                            icon: "table-caption",
                            text: "Table caption",
                            command: "mceTableToggleCaption",
                            onSetup: t.onSetupTableWithCaption
                        }), r("tablerowheader", {
                            text: "Row header",
                            icon: "table-top-header",
                            command: "mceTableRowType",
                            onAction: wo(e),
                            onSetup: t.onSetupTableRowHeaders
                        }), r("tablecolheader", {
                            text: "Column header",
                            icon: "table-left-header",
                            command: "mceTableColType",
                            onAction: xo(e),
                            onSetup: t.onSetupTableRowHeaders
                        })
                    })(e, t), ((e, t) => {
                        e.ui.registry.addMenuButton("table", {
                            tooltip: "Table",
                            icon: "table",
                            fetch: e => e("inserttable | cell row column | advtablesort | tableprops deletetable")
                        });
                        const o = t => () => e.execCommand(t),
                            n = (t, n) => {
                                e.queryCommandSupported(n.command) && e.ui.registry.addButton(t, { ...n,
                                    onAction: l(n.onAction) ? n.onAction : o(n.command)
                                })
                            },
                            r = (t, n) => {
                                e.queryCommandSupported(n.command) && e.ui.registry.addToggleButton(t, { ...n,
                                    onAction: l(n.onAction) ? n.onAction : o(n.command)
                                })
                            };
                        n("tableprops", {
                            tooltip: "Table properties",
                            command: "mceTableProps",
                            icon: "table",
                            onSetup: t.onSetupTable
                        }), n("tabledelete", {
                            tooltip: "Delete table",
                            command: "mceTableDelete",
                            icon: "table-delete-table",
                            onSetup: t.onSetupTable
                        }), n("tablecellprops", {
                            tooltip: "Cell properties",
                            command: "mceTableCellProps",
                            icon: "table-cell-properties",
                            onSetup: t.onSetupCellOrRow
                        }), n("tablemergecells", {
                            tooltip: "Merge cells",
                            command: "mceTableMergeCells",
                            icon: "table-merge-cells",
                            onSetup: t.onSetupMergeable
                        }), n("tablesplitcells", {
                            tooltip: "Split cell",
                            command: "mceTableSplitCells",
                            icon: "table-split-cells",
                            onSetup: t.onSetupUnmergeable
                        }), n("tableinsertrowbefore", {
                            tooltip: "Insert row before",
                            command: "mceTableInsertRowBefore",
                            icon: "table-insert-row-above",
                            onSetup: t.onSetupCellOrRow
                        }), n("tableinsertrowafter", {
                            tooltip: "Insert row after",
                            command: "mceTableInsertRowAfter",
                            icon: "table-insert-row-after",
                            onSetup: t.onSetupCellOrRow
                        }), n("tabledeleterow", {
                            tooltip: "Delete row",
                            command: "mceTableDeleteRow",
                            icon: "table-delete-row",
                            onSetup: t.onSetupCellOrRow
                        }), n("tablerowprops", {
                            tooltip: "Row properties",
                            command: "mceTableRowProps",
                            icon: "table-row-properties",
                            onSetup: t.onSetupCellOrRow
                        }), n("tableinsertcolbefore", {
                            tooltip: "Insert column before",
                            command: "mceTableInsertColBefore",
                            icon: "table-insert-column-before",
                            onSetup: t.onSetupColumn("onFirst")
                        }), n("tableinsertcolafter", {
                            tooltip: "Insert column after",
                            command: "mceTableInsertColAfter",
                            icon: "table-insert-column-after",
                            onSetup: t.onSetupColumn("onLast")
                        }), n("tabledeletecol", {
                            tooltip: "Delete column",
                            command: "mceTableDeleteCol",
                            icon: "table-delete-column",
                            onSetup: t.onSetupColumn("onAny")
                        }), n("tablecutrow", {
                            tooltip: "Cut row",
                            command: "mceTableCutRow",
                            icon: "cut-row",
                            onSetup: t.onSetupCellOrRow
                        }), n("tablecopyrow", {
                            tooltip: "Copy row",
                            command: "mceTableCopyRow",
                            icon: "duplicate-row",
                            onSetup: t.onSetupCellOrRow
                        }), n("tablepasterowbefore", {
                            tooltip: "Paste row before",
                            command: "mceTablePasteRowBefore",
                            icon: "paste-row-before",
                            onSetup: t.onSetupPasteable(dn)
                        }), n("tablepasterowafter", {
                            tooltip: "Paste row after",
                            command: "mceTablePasteRowAfter",
                            icon: "paste-row-after",
                            onSetup: t.onSetupPasteable(dn)
                        }), n("tablecutcol", {
                            tooltip: "Cut column",
                            command: "mceTableCutCol",
                            icon: "cut-column",
                            onSetup: t.onSetupColumn("onAny")
                        }), n("tablecopycol", {
                            tooltip: "Copy column",
                            command: "mceTableCopyCol",
                            icon: "duplicate-column",
                            onSetup: t.onSetupColumn("onAny")
                        }), n("tablepastecolbefore", {
                            tooltip: "Paste column before",
                            command: "mceTablePasteColBefore",
                            icon: "paste-column-before",
                            onSetup: t.onSetupPasteableColumn(un, "onFirst")
                        }), n("tablepastecolafter", {
                            tooltip: "Paste column after",
                            command: "mceTablePasteColAfter",
                            icon: "paste-column-after",
                            onSetup: t.onSetupPasteableColumn(un, "onLast")
                        }), n("tableinsertdialog", {
                            tooltip: "Insert table",
                            command: "mceInsertTableDialog",
                            icon: "table"
                        });
                        const s = vo(vt(e));
                        0 !== s.length && e.queryCommandSupported("mceTableToggleClass") && e.ui.registry.addMenuButton("tableclass", {
                            icon: "table-classes",
                            tooltip: "Table styles",
                            fetch: bo(e, s, "tableclass", (t => e.execCommand("mceTableToggleClass", !1, t))),
                            onSetup: t.onSetupTable
                        });
                        const a = vo(pt(e));
                        0 !== a.length && e.queryCommandSupported("mceTableCellToggleClass") && e.ui.registry.addMenuButton("tablecellclass", {
                            icon: "table-cell-classes",
                            tooltip: "Cell styles",
                            fetch: bo(e, a, "tablecellclass", (t => e.execCommand("mceTableCellToggleClass", !1, t))),
                            onSetup: t.onSetupCellOrRow
                        }), e.queryCommandSupported("mceTableApplyCellStyle") && (e.ui.registry.addMenuButton("tablecellvalign", {
                            icon: "vertical-align",
                            tooltip: "Vertical align",
                            fetch: bo(e, Qt, "tablecellverticalalign", fo(e, "vertical-align")),
                            onSetup: t.onSetupCellOrRow
                        }), e.ui.registry.addMenuButton("tablecellborderwidth", {
                            icon: "border-width",
                            tooltip: "Border width",
                            fetch: bo(e, it(e), "tablecellborderwidth", fo(e, "border-width")),
                            onSetup: t.onSetupCellOrRow
                        }), e.ui.registry.addMenuButton("tablecellborderstyle", {
                            icon: "border-style",
                            tooltip: "Border style",
                            fetch: bo(e, lt(e), "tablecellborderstyle", fo(e, "border-style")),
                            onSetup: t.onSetupCellOrRow
                        }), e.ui.registry.addMenuButton("tablecellbackgroundcolor", {
                            icon: "cell-background-color",
                            tooltip: "Background color",
                            fetch: t => t(yo(e, yt(e), "background-color")),
                            onSetup: t.onSetupCellOrRow
                        }), e.ui.registry.addMenuButton("tablecellbordercolor", {
                            icon: "cell-border-color",
                            tooltip: "Border color",
                            fetch: t => t(yo(e, wt(e), "border-color")),
                            onSetup: t.onSetupCellOrRow
                        })), r("tablecaption", {
                            tooltip: "Table caption",
                            icon: "table-caption",
                            command: "mceTableToggleCaption",
                            onSetup: t.onSetupTableWithCaption
                        }), r("tablerowheader", {
                            tooltip: "Row header",
                            icon: "table-top-header",
                            command: "mceTableRowType",
                            onAction: wo(e),
                            onSetup: t.onSetupTableRowHeaders
                        }), r("tablecolheader", {
                            tooltip: "Column header",
                            icon: "table-left-header",
                            command: "mceTableColType",
                            onAction: xo(e),
                            onSetup: t.onSetupTableColumnHeaders
                        })
                    })(e, t), (e => {
                        const t = bt(e);
                        t.length > 0 && e.ui.registry.addContextToolbar("table", {
                            predicate: t => e.dom.is(t, "table") && e.getBody().contains(t),
                            items: t,
                            scope: "node",
                            position: "node"
                        })
                    })(e)
                }))
            }()
        },
        38860: function(e, t, o) {
            o(51768)
        },
        51768: function() {
            ! function() {
                "use strict";
                const e = Object.getPrototypeOf,
                    t = (e, t, o) => {
                        var n;
                        return !!o(e, t.prototype) || (null === (n = e.constructor) || void 0 === n ? void 0 : n.name) === t.name
                    },
                    o = e => o => (e => {
                        const o = typeof e;
                        return null === e ? "null" : "object" === o && Array.isArray(e) ? "array" : "object" === o && t(e, String, ((e, t) => t.isPrototypeOf(e))) ? "string" : o
                    })(o) === e,
                    n = e => t => typeof t === e,
                    r = e => t => e === t,
                    s = o("string"),
                    a = o("object"),
                    i = o => ((o, n) => a(o) && t(o, n, ((t, o) => e(t) === o)))(o, Object),
                    l = o("array"),
                    c = r(null),
                    d = n("boolean"),
                    u = r(void 0),
                    m = e => null == e,
                    g = e => !m(e),
                    h = n("function"),
                    p = n("number"),
                    f = (e, t) => {
                        if (l(e)) {
                            for (let o = 0, n = e.length; o < n; ++o)
                                if (!t(e[o])) return !1;
                            return !0
                        }
                        return !1
                    },
                    v = () => {},
                    b = (e, t) => (...o) => e(t.apply(null, o)),
                    y = e => () => e,
                    w = e => e,
                    x = (e, t) => e === t;

                function C(e, ...t) {
                    return (...o) => {
                        const n = t.concat(o);
                        return e.apply(null, n)
                    }
                }
                const S = e => t => !e(t),
                    k = e => () => {
                        throw new Error(e)
                    },
                    _ = e => e(),
                    O = y(!1),
                    T = y(!0);
                var E = tinymce.util.Tools.resolve("tinymce.ThemeManager");
                class A {
                    constructor(e, t) {
                        this.tag = e, this.value = t
                    }
                    static some(e) {
                        return new A(!0, e)
                    }
                    static none() {
                        return A.singletonNone
                    }
                    fold(e, t) {
                        return this.tag ? t(this.value) : e()
                    }
                    isSome() {
                        return this.tag
                    }
                    isNone() {
                        return !this.tag
                    }
                    map(e) {
                        return this.tag ? A.some(e(this.value)) : A.none()
                    }
                    bind(e) {
                        return this.tag ? e(this.value) : A.none()
                    }
                    exists(e) {
                        return this.tag && e(this.value)
                    }
                    forall(e) {
                        return !this.tag || e(this.value)
                    }
                    filter(e) {
                        return !this.tag || e(this.value) ? this : A.none()
                    }
                    getOr(e) {
                        return this.tag ? this.value : e
                    }
                    or(e) {
                        return this.tag ? this : e
                    }
                    getOrThunk(e) {
                        return this.tag ? this.value : e()
                    }
                    orThunk(e) {
                        return this.tag ? this : e()
                    }
                    getOrDie(e) {
                        if (this.tag) return this.value;
                        throw new Error(null != e ? e : "Called getOrDie on None")
                    }
                    static from(e) {
                        return g(e) ? A.some(e) : A.none()
                    }
                    getOrNull() {
                        return this.tag ? this.value : null
                    }
                    getOrUndefined() {
                        return this.value
                    }
                    each(e) {
                        this.tag && e(this.value)
                    }
                    toArray() {
                        return this.tag ? [this.value] : []
                    }
                    toString() {
                        return this.tag ? `some(${this.value})` : "none()"
                    }
                }
                A.singletonNone = new A(!1);
                const M = Array.prototype.slice,
                    N = Array.prototype.indexOf,
                    R = Array.prototype.push,
                    D = (e, t) => N.call(e, t),
                    B = (e, t) => {
                        const o = D(e, t);
                        return -1 === o ? A.none() : A.some(o)
                    },
                    L = (e, t) => D(e, t) > -1,
                    H = (e, t) => {
                        for (let o = 0, n = e.length; o < n; o++)
                            if (t(e[o], o)) return !0;
                        return !1
                    },
                    I = (e, t) => {
                        const o = [];
                        for (let n = 0; n < e; n++) o.push(t(n));
                        return o
                    },
                    P = (e, t) => {
                        const o = [];
                        for (let n = 0; n < e.length; n += t) {
                            const r = M.call(e, n, n + t);
                            o.push(r)
                        }
                        return o
                    },
                    z = (e, t) => {
                        const o = e.length,
                            n = new Array(o);
                        for (let r = 0; r < o; r++) {
                            const o = e[r];
                            n[r] = t(o, r)
                        }
                        return n
                    },
                    F = (e, t) => {
                        for (let o = 0, n = e.length; o < n; o++) t(e[o], o)
                    },
                    V = (e, t) => {
                        const o = [],
                            n = [];
                        for (let r = 0, s = e.length; r < s; r++) {
                            const s = e[r];
                            (t(s, r) ? o : n).push(s)
                        }
                        return {
                            pass: o,
                            fail: n
                        }
                    },
                    Z = (e, t) => {
                        const o = [];
                        for (let n = 0, r = e.length; n < r; n++) {
                            const r = e[n];
                            t(r, n) && o.push(r)
                        }
                        return o
                    },
                    U = (e, t, o) => (((e, t) => {
                        for (let o = e.length - 1; o >= 0; o--) t(e[o], o)
                    })(e, ((e, n) => {
                        o = t(o, e, n)
                    })), o),
                    j = (e, t, o) => (F(e, ((e, n) => {
                        o = t(o, e, n)
                    })), o),
                    W = (e, t) => ((e, t, o) => {
                        for (let n = 0, r = e.length; n < r; n++) {
                            const r = e[n];
                            if (t(r, n)) return A.some(r);
                            if (o(r, n)) break
                        }
                        return A.none()
                    })(e, t, O),
                    $ = (e, t) => {
                        for (let o = 0, n = e.length; o < n; o++)
                            if (t(e[o], o)) return A.some(o);
                        return A.none()
                    },
                    q = e => {
                        const t = [];
                        for (let o = 0, n = e.length; o < n; ++o) {
                            if (!l(e[o])) throw new Error("Arr.flatten item " + o + " was not an array, input: " + e);
                            R.apply(t, e[o])
                        }
                        return t
                    },
                    G = (e, t) => q(z(e, t)),
                    K = (e, t) => {
                        for (let o = 0, n = e.length; o < n; ++o)
                            if (!0 !== t(e[o], o)) return !1;
                        return !0
                    },
                    Y = e => {
                        const t = M.call(e, 0);
                        return t.reverse(), t
                    },
                    X = (e, t) => Z(e, (e => !L(t, e))),
                    J = (e, t) => {
                        const o = {};
                        for (let n = 0, r = e.length; n < r; n++) {
                            const r = e[n];
                            o[String(r)] = t(r, n)
                        }
                        return o
                    },
                    Q = e => [e],
                    ee = (e, t) => {
                        const o = M.call(e, 0);
                        return o.sort(t), o
                    },
                    te = (e, t) => t >= 0 && t < e.length ? A.some(e[t]) : A.none(),
                    oe = e => te(e, 0),
                    ne = e => te(e, e.length - 1),
                    re = h(Array.from) ? Array.from : e => M.call(e),
                    se = (e, t) => {
                        for (let o = 0; o < e.length; o++) {
                            const n = t(e[o], o);
                            if (n.isSome()) return n
                        }
                        return A.none()
                    },
                    ae = Object.keys,
                    ie = Object.hasOwnProperty,
                    le = (e, t) => {
                        const o = ae(e);
                        for (let n = 0, r = o.length; n < r; n++) {
                            const r = o[n];
                            t(e[r], r)
                        }
                    },
                    ce = (e, t) => de(e, ((e, o) => ({
                        k: o,
                        v: t(e, o)
                    }))),
                    de = (e, t) => {
                        const o = {};
                        return le(e, ((e, n) => {
                            const r = t(e, n);
                            o[r.k] = r.v
                        })), o
                    },
                    ue = e => (t, o) => {
                        e[o] = t
                    },
                    me = (e, t, o, n) => {
                        le(e, ((e, r) => {
                            (t(e, r) ? o : n)(e, r)
                        }))
                    },
                    ge = (e, t) => {
                        const o = {};
                        return me(e, t, ue(o), v), o
                    },
                    he = (e, t) => {
                        const o = [];
                        return le(e, ((e, n) => {
                            o.push(t(e, n))
                        })), o
                    },
                    pe = (e, t) => {
                        const o = ae(e);
                        for (let n = 0, r = o.length; n < r; n++) {
                            const r = o[n],
                                s = e[r];
                            if (t(s, r, e)) return A.some(s)
                        }
                        return A.none()
                    },
                    fe = e => he(e, w),
                    ve = (e, t) => be(e, t) ? A.from(e[t]) : A.none(),
                    be = (e, t) => ie.call(e, t),
                    ye = (e, t) => be(e, t) && void 0 !== e[t] && null !== e[t],
                    we = (e, t, o = x) => e.exists((e => o(e, t))),
                    xe = e => {
                        const t = [],
                            o = e => {
                                t.push(e)
                            };
                        for (let t = 0; t < e.length; t++) e[t].each(o);
                        return t
                    },
                    Ce = (e, t, o) => e.isSome() && t.isSome() ? A.some(o(e.getOrDie(), t.getOrDie())) : A.none(),
                    Se = (e, t) => e ? A.some(t) : A.none(),
                    ke = (e, t, o) => "" === t || e.length >= t.length && e.substr(o, o + t.length) === t,
                    _e = (e, t, o = 0, n) => {
                        const r = e.indexOf(t, o);
                        return -1 !== r && (!!u(n) || r + t.length <= n)
                    },
                    Oe = (e, t) => ke(e, t, e.length - t.length),
                    Te = (ko = /^\s+|\s+$/g, e => e.replace(ko, "")),
                    Ee = e => e.length > 0,
                    Ae = e => void 0 !== e.style && h(e.style.getPropertyValue),
                    Me = e => {
                        if (null == e) throw new Error("Node cannot be null or undefined");
                        return {
                            dom: e
                        }
                    },
                    Ne = (e, t) => {
                        const o = (t || document).createElement("div");
                        if (o.innerHTML = e, !o.hasChildNodes() || o.childNodes.length > 1) {
                            const t = "HTML does not have a single root node";
                            throw console.error(t, e), new Error(t)
                        }
                        return Me(o.childNodes[0])
                    },
                    Re = (e, t) => {
                        const o = (t || document).createElement(e);
                        return Me(o)
                    },
                    De = (e, t) => {
                        const o = (t || document).createTextNode(e);
                        return Me(o)
                    },
                    Be = Me,
                    Le = "undefined" != typeof window ? window : Function("return this;")(),
                    He = (e, t) => ((e, t) => {
                        let o = null != t ? t : Le;
                        for (let t = 0; t < e.length && null != o; ++t) o = o[e[t]];
                        return o
                    })(e.split("."), t),
                    Ie = Object.getPrototypeOf,
                    Pe = e => {
                        const t = He("ownerDocument.defaultView", e);
                        return a(e) && ((e => ((e, t) => {
                            const o = ((e, t) => He(e, t))(e, t);
                            if (null == o) throw new Error(e + " not available on this browser");
                            return o
                        })("HTMLElement", e))(t).prototype.isPrototypeOf(e) || /^HTML\w*Element$/.test(Ie(e).constructor.name))
                    },
                    ze = e => e.dom.nodeName.toLowerCase(),
                    Fe = e => t => (e => e.dom.nodeType)(t) === e,
                    Ve = Fe(1),
                    Ze = Fe(3),
                    Ue = Fe(9),
                    je = Fe(11),
                    We = e => t => Ve(t) && ze(t) === e,
                    $e = (e, t) => {
                        const o = e.dom;
                        if (1 !== o.nodeType) return !1; {
                            const e = o;
                            if (void 0 !== e.matches) return e.matches(t);
                            if (void 0 !== e.msMatchesSelector) return e.msMatchesSelector(t);
                            if (void 0 !== e.webkitMatchesSelector) return e.webkitMatchesSelector(t);
                            if (void 0 !== e.mozMatchesSelector) return e.mozMatchesSelector(t);
                            throw new Error("Browser lacks native selectors")
                        }
                    },
                    qe = e => 1 !== e.nodeType && 9 !== e.nodeType && 11 !== e.nodeType || 0 === e.childElementCount,
                    Ge = (e, t) => e.dom === t.dom,
                    Ke = (e, t) => {
                        const o = e.dom,
                            n = t.dom;
                        return o !== n && o.contains(n)
                    },
                    Ye = e => Be(e.dom.ownerDocument),
                    Xe = e => Ue(e) ? e : Ye(e),
                    Je = e => Be(Xe(e).dom.documentElement),
                    Qe = e => Be(Xe(e).dom.defaultView),
                    et = e => A.from(e.dom.parentNode).map(Be),
                    tt = e => A.from(e.dom.parentElement).map(Be),
                    ot = e => A.from(e.dom.offsetParent).map(Be),
                    nt = e => z(e.dom.childNodes, Be),
                    rt = (e, t) => {
                        const o = e.dom.childNodes;
                        return A.from(o[t]).map(Be)
                    },
                    st = (e, t) => ({
                        element: e,
                        offset: t
                    }),
                    at = (e, t) => {
                        const o = nt(e);
                        return o.length > 0 && t < o.length ? st(o[t], 0) : st(e, t)
                    },
                    it = e => je(e) && g(e.dom.host),
                    lt = h(Element.prototype.attachShadow) && h(Node.prototype.getRootNode),
                    ct = y(lt),
                    dt = lt ? e => Be(e.dom.getRootNode()) : Xe,
                    ut = e => it(e) ? e : Be(Xe(e).dom.body),
                    mt = e => {
                        const t = dt(e);
                        return it(t) ? A.some(t) : A.none()
                    },
                    gt = e => Be(e.dom.host),
                    ht = e => {
                        const t = Ze(e) ? e.dom.parentNode : e.dom;
                        if (null == t || null === t.ownerDocument) return !1;
                        const o = t.ownerDocument;
                        return mt(Be(t)).fold((() => o.body.contains(t)), (n = ht, r = gt, e => n(r(e))));
                        var n, r
                    },
                    pt = () => ft(Be(document)),
                    ft = e => {
                        const t = e.dom.body;
                        if (null == t) throw new Error("Body is not available yet");
                        return Be(t)
                    },
                    vt = (e, t, o) => {
                        if (!(s(o) || d(o) || p(o))) throw console.error("Invalid call to Attribute.set. Key ", t, ":: Value ", o, ":: Element ", e), new Error("Attribute value was not simple");
                        e.setAttribute(t, o + "")
                    },
                    bt = (e, t, o) => {
                        vt(e.dom, t, o)
                    },
                    yt = (e, t) => {
                        const o = e.dom;
                        le(t, ((e, t) => {
                            vt(o, t, e)
                        }))
                    },
                    wt = (e, t) => {
                        const o = e.dom.getAttribute(t);
                        return null === o ? void 0 : o
                    },
                    xt = (e, t) => A.from(wt(e, t)),
                    Ct = (e, t) => {
                        const o = e.dom;
                        return !(!o || !o.hasAttribute) && o.hasAttribute(t)
                    },
                    St = (e, t) => {
                        e.dom.removeAttribute(t)
                    },
                    kt = (e, t, o) => {
                        if (!s(o)) throw console.error("Invalid call to CSS.set. Property ", t, ":: Value ", o, ":: Element ", e), new Error("CSS value must be a string: " + o);
                        Ae(e) && e.style.setProperty(t, o)
                    },
                    _t = (e, t) => {
                        Ae(e) && e.style.removeProperty(t)
                    },
                    Ot = (e, t, o) => {
                        const n = e.dom;
                        kt(n, t, o)
                    },
                    Tt = (e, t) => {
                        const o = e.dom;
                        le(t, ((e, t) => {
                            kt(o, t, e)
                        }))
                    },
                    Et = (e, t) => {
                        const o = e.dom;
                        le(t, ((e, t) => {
                            e.fold((() => {
                                _t(o, t)
                            }), (e => {
                                kt(o, t, e)
                            }))
                        }))
                    },
                    At = (e, t) => {
                        const o = e.dom,
                            n = window.getComputedStyle(o).getPropertyValue(t);
                        return "" !== n || ht(e) ? n : Mt(o, t)
                    },
                    Mt = (e, t) => Ae(e) ? e.style.getPropertyValue(t) : "",
                    Nt = (e, t) => {
                        const o = e.dom,
                            n = Mt(o, t);
                        return A.from(n).filter((e => e.length > 0))
                    },
                    Rt = e => {
                        const t = {},
                            o = e.dom;
                        if (Ae(o))
                            for (let e = 0; e < o.style.length; e++) {
                                const n = o.style.item(e);
                                t[n] = o.style[n]
                            }
                        return t
                    },
                    Dt = (e, t, o) => {
                        const n = Re(e);
                        return Ot(n, t, o), Nt(n, t).isSome()
                    },
                    Bt = (e, t) => {
                        const o = e.dom;
                        _t(o, t), we(xt(e, "style").map(Te), "") && St(e, "style")
                    },
                    Lt = e => e.dom.offsetWidth,
                    Ht = (e, t) => {
                        const o = o => {
                                const n = t(o);
                                if (n <= 0 || null === n) {
                                    const t = At(o, e);
                                    return parseFloat(t) || 0
                                }
                                return n
                            },
                            n = (e, t) => j(t, ((t, o) => {
                                const n = At(e, o),
                                    r = void 0 === n ? 0 : parseInt(n, 10);
                                return isNaN(r) ? t : t + r
                            }), 0);
                        return {
                            set: (t, o) => {
                                if (!p(o) && !o.match(/^[0-9]+$/)) throw new Error(e + ".set accepts only positive integer values. Value was " + o);
                                const n = t.dom;
                                Ae(n) && (n.style[e] = o + "px")
                            },
                            get: o,
                            getOuter: o,
                            aggregate: n,
                            max: (e, t, o) => {
                                const r = n(e, o);
                                return t > r ? t - r : 0
                            }
                        }
                    },
                    It = Ht("height", (e => {
                        const t = e.dom;
                        return ht(e) ? t.getBoundingClientRect().height : t.offsetHeight
                    })),
                    Pt = e => It.get(e),
                    zt = e => It.getOuter(e),
                    Ft = (e, t) => ({
                        left: e,
                        top: t,
                        translate: (o, n) => Ft(e + o, t + n)
                    }),
                    Vt = Ft,
                    Zt = (e, t) => void 0 !== e ? e : void 0 !== t ? t : 0,
                    Ut = e => {
                        const t = e.dom.ownerDocument,
                            o = t.body,
                            n = t.defaultView,
                            r = t.documentElement;
                        if (o === e.dom) return Vt(o.offsetLeft, o.offsetTop);
                        const s = Zt(null == n ? void 0 : n.pageYOffset, r.scrollTop),
                            a = Zt(null == n ? void 0 : n.pageXOffset, r.scrollLeft),
                            i = Zt(r.clientTop, o.clientTop),
                            l = Zt(r.clientLeft, o.clientLeft);
                        return jt(e).translate(a - l, s - i)
                    },
                    jt = e => {
                        const t = e.dom,
                            o = t.ownerDocument.body;
                        return o === t ? Vt(o.offsetLeft, o.offsetTop) : ht(e) ? (e => {
                            const t = e.getBoundingClientRect();
                            return Vt(t.left, t.top)
                        })(t) : Vt(0, 0)
                    },
                    Wt = Ht("width", (e => e.dom.offsetWidth)),
                    $t = e => Wt.get(e),
                    qt = e => Wt.getOuter(e),
                    Gt = e => {
                        let t, o = !1;
                        return (...n) => (o || (o = !0, t = e.apply(null, n)), t)
                    },
                    Kt = () => Yt(0, 0),
                    Yt = (e, t) => ({
                        major: e,
                        minor: t
                    }),
                    Xt = {
                        nu: Yt,
                        detect: (e, t) => {
                            const o = String(t).toLowerCase();
                            return 0 === e.length ? Kt() : ((e, t) => {
                                const o = ((e, t) => {
                                    for (let o = 0; o < e.length; o++) {
                                        const n = e[o];
                                        if (n.test(t)) return n
                                    }
                                })(e, t);
                                if (!o) return {
                                    major: 0,
                                    minor: 0
                                };
                                const n = e => Number(t.replace(o, "$" + e));
                                return Yt(n(1), n(2))
                            })(e, o)
                        },
                        unknown: Kt
                    },
                    Jt = (e, t) => {
                        const o = String(t).toLowerCase();
                        return W(e, (e => e.search(o)))
                    },
                    Qt = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/,
                    eo = e => t => _e(t, e),
                    to = [{
                        name: "Edge",
                        versionRegexes: [/.*?edge\/ ?([0-9]+)\.([0-9]+)$/],
                        search: e => _e(e, "edge/") && _e(e, "chrome") && _e(e, "safari") && _e(e, "applewebkit")
                    }, {
                        name: "Chromium",
                        brand: "Chromium",
                        versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/, Qt],
                        search: e => _e(e, "chrome") && !_e(e, "chromeframe")
                    }, {
                        name: "IE",
                        versionRegexes: [/.*?msie\ ?([0-9]+)\.([0-9]+).*/, /.*?rv:([0-9]+)\.([0-9]+).*/],
                        search: e => _e(e, "msie") || _e(e, "trident")
                    }, {
                        name: "Opera",
                        versionRegexes: [Qt, /.*?opera\/([0-9]+)\.([0-9]+).*/],
                        search: eo("opera")
                    }, {
                        name: "Firefox",
                        versionRegexes: [/.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/],
                        search: eo("firefox")
                    }, {
                        name: "Safari",
                        versionRegexes: [Qt, /.*?cpu os ([0-9]+)_([0-9]+).*/],
                        search: e => (_e(e, "safari") || _e(e, "mobile/")) && _e(e, "applewebkit")
                    }],
                    oo = [{
                        name: "Windows",
                        search: eo("win"),
                        versionRegexes: [/.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/]
                    }, {
                        name: "iOS",
                        search: e => _e(e, "iphone") || _e(e, "ipad"),
                        versionRegexes: [/.*?version\/\ ?([0-9]+)\.([0-9]+).*/, /.*cpu os ([0-9]+)_([0-9]+).*/, /.*cpu iphone os ([0-9]+)_([0-9]+).*/]
                    }, {
                        name: "Android",
                        search: eo("android"),
                        versionRegexes: [/.*?android\ ?([0-9]+)\.([0-9]+).*/]
                    }, {
                        name: "macOS",
                        search: eo("mac os x"),
                        versionRegexes: [/.*?mac\ os\ x\ ?([0-9]+)_([0-9]+).*/]
                    }, {
                        name: "Linux",
                        search: eo("linux"),
                        versionRegexes: []
                    }, {
                        name: "Solaris",
                        search: eo("sunos"),
                        versionRegexes: []
                    }, {
                        name: "FreeBSD",
                        search: eo("freebsd"),
                        versionRegexes: []
                    }, {
                        name: "ChromeOS",
                        search: eo("cros"),
                        versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/]
                    }],
                    no = {
                        browsers: y(to),
                        oses: y(oo)
                    },
                    ro = "Edge",
                    so = "Chromium",
                    ao = "Opera",
                    io = "Firefox",
                    lo = "Safari",
                    co = e => {
                        const t = e.current,
                            o = e.version,
                            n = e => () => t === e;
                        return {
                            current: t,
                            version: o,
                            isEdge: n(ro),
                            isChromium: n(so),
                            isIE: n("IE"),
                            isOpera: n(ao),
                            isFirefox: n(io),
                            isSafari: n(lo)
                        }
                    },
                    uo = () => co({
                        current: void 0,
                        version: Xt.unknown()
                    }),
                    mo = co,
                    go = (y(ro), y(so), y("IE"), y(ao), y(io), y(lo), "Windows"),
                    ho = "Android",
                    po = "Linux",
                    fo = "macOS",
                    vo = "Solaris",
                    bo = "FreeBSD",
                    yo = "ChromeOS",
                    wo = e => {
                        const t = e.current,
                            o = e.version,
                            n = e => () => t === e;
                        return {
                            current: t,
                            version: o,
                            isWindows: n(go),
                            isiOS: n("iOS"),
                            isAndroid: n(ho),
                            isMacOS: n(fo),
                            isLinux: n(po),
                            isSolaris: n(vo),
                            isFreeBSD: n(bo),
                            isChromeOS: n(yo)
                        }
                    },
                    xo = () => wo({
                        current: void 0,
                        version: Xt.unknown()
                    }),
                    Co = wo,
                    So = (y(go), y("iOS"), y(ho), y(po), y(fo), y(vo), y(bo), y(yo), e => window.matchMedia(e).matches);
                var ko;
                let _o = Gt((() => ((e, t, o) => {
                    const n = no.browsers(),
                        r = no.oses(),
                        s = t.bind((e => ((e, t) => se(t.brands, (t => {
                            const o = t.brand.toLowerCase();
                            return W(e, (e => {
                                var t;
                                return o === (null === (t = e.brand) || void 0 === t ? void 0 : t.toLowerCase())
                            })).map((e => ({
                                current: e.name,
                                version: Xt.nu(parseInt(t.version, 10), 0)
                            })))
                        })))(n, e))).orThunk((() => ((e, t) => Jt(e, t).map((e => {
                            const o = Xt.detect(e.versionRegexes, t);
                            return {
                                current: e.name,
                                version: o
                            }
                        })))(n, e))).fold(uo, mo),
                        a = ((e, t) => Jt(e, t).map((e => {
                            const o = Xt.detect(e.versionRegexes, t);
                            return {
                                current: e.name,
                                version: o
                            }
                        })))(r, e).fold(xo, Co),
                        i = ((e, t, o, n) => {
                            const r = e.isiOS() && !0 === /ipad/i.test(o),
                                s = e.isiOS() && !r,
                                a = e.isiOS() || e.isAndroid(),
                                i = a || n("(pointer:coarse)"),
                                l = r || !s && a && n("(min-device-width:768px)"),
                                c = s || a && !l,
                                d = t.isSafari() && e.isiOS() && !1 === /safari/i.test(o),
                                u = !c && !l && !d;
                            return {
                                isiPad: y(r),
                                isiPhone: y(s),
                                isTablet: y(l),
                                isPhone: y(c),
                                isTouch: y(i),
                                isAndroid: e.isAndroid,
                                isiOS: e.isiOS,
                                isWebView: y(d),
                                isDesktop: y(u)
                            }
                        })(a, s, e, o);
                    return {
                        browser: s,
                        os: a,
                        deviceType: i
                    }
                })(navigator.userAgent, A.from(navigator.userAgentData), So)));
                const Oo = () => _o(),
                    To = e => {
                        const t = Be((e => {
                                if (ct() && g(e.target)) {
                                    const t = Be(e.target);
                                    if (Ve(t) && (e => g(e.dom.shadowRoot))(t) && e.composed && e.composedPath) {
                                        const t = e.composedPath();
                                        if (t) return oe(t)
                                    }
                                }
                                return A.from(e.target)
                            })(e).getOr(e.target)),
                            o = () => e.stopPropagation(),
                            n = () => e.preventDefault(),
                            r = b(n, o);
                        return ((e, t, o, n, r, s, a) => ({
                            target: e,
                            x: t,
                            y: o,
                            stop: n,
                            prevent: r,
                            kill: s,
                            raw: a
                        }))(t, e.clientX, e.clientY, o, n, r, e)
                    },
                    Eo = (e, t, o, n, r) => {
                        const s = ((e, t) => o => {
                            e(o) && t(To(o))
                        })(o, n);
                        return e.dom.addEventListener(t, s, r), {
                            unbind: C(Ao, e, t, s, r)
                        }
                    },
                    Ao = (e, t, o, n) => {
                        e.dom.removeEventListener(t, o, n)
                    },
                    Mo = (e, t) => {
                        et(e).each((o => {
                            o.dom.insertBefore(t.dom, e.dom)
                        }))
                    },
                    No = (e, t) => {
                        const o = (e => A.from(e.dom.nextSibling).map(Be))(e);
                        o.fold((() => {
                            et(e).each((e => {
                                Do(e, t)
                            }))
                        }), (e => {
                            Mo(e, t)
                        }))
                    },
                    Ro = (e, t) => {
                        const o = (e => rt(e, 0))(e);
                        o.fold((() => {
                            Do(e, t)
                        }), (o => {
                            e.dom.insertBefore(t.dom, o.dom)
                        }))
                    },
                    Do = (e, t) => {
                        e.dom.appendChild(t.dom)
                    },
                    Bo = (e, t) => {
                        F(t, (t => {
                            Do(e, t)
                        }))
                    },
                    Lo = e => {
                        e.dom.textContent = "", F(nt(e), (e => {
                            Ho(e)
                        }))
                    },
                    Ho = e => {
                        const t = e.dom;
                        null !== t.parentNode && t.parentNode.removeChild(t)
                    },
                    Io = e => {
                        const t = void 0 !== e ? e.dom : document,
                            o = t.body.scrollLeft || t.documentElement.scrollLeft,
                            n = t.body.scrollTop || t.documentElement.scrollTop;
                        return Vt(o, n)
                    },
                    Po = (e, t, o) => {
                        const n = (void 0 !== o ? o.dom : document).defaultView;
                        n && n.scrollTo(e, t)
                    },
                    zo = (e, t, o, n) => ({
                        x: e,
                        y: t,
                        width: o,
                        height: n,
                        right: e + o,
                        bottom: t + n
                    }),
                    Fo = e => {
                        const t = void 0 === e ? window : e,
                            o = t.document,
                            n = Io(Be(o));
                        return (e => {
                            const t = void 0 === e ? window : e;
                            return Oo().browser.isFirefox() ? A.none() : A.from(t.visualViewport)
                        })(t).fold((() => {
                            const e = t.document.documentElement,
                                o = e.clientWidth,
                                r = e.clientHeight;
                            return zo(n.left, n.top, o, r)
                        }), (e => zo(Math.max(e.pageLeft, n.left), Math.max(e.pageTop, n.top), e.width, e.height)))
                    },
                    Vo = () => Be(document),
                    Zo = (e, t) => e.view(t).fold(y([]), (t => {
                        const o = e.owner(t),
                            n = Zo(e, o);
                        return [t].concat(n)
                    }));
                var Uo = Object.freeze({
                    __proto__: null,
                    view: e => {
                        var t;
                        return (e.dom === document ? A.none() : A.from(null === (t = e.dom.defaultView) || void 0 === t ? void 0 : t.frameElement)).map(Be)
                    },
                    owner: e => Ye(e)
                });
                const jo = e => {
                        const t = Vo(),
                            o = Io(t),
                            n = ((e, t) => {
                                const o = t.owner(e),
                                    n = Zo(t, o);
                                return A.some(n)
                            })(e, Uo);
                        return n.fold(C(Ut, e), (t => {
                            const n = jt(e),
                                r = U(t, ((e, t) => {
                                    const o = jt(t);
                                    return {
                                        left: e.left + o.left,
                                        top: e.top + o.top
                                    }
                                }), {
                                    left: 0,
                                    top: 0
                                });
                            return Vt(r.left + n.left + o.left, r.top + n.top + o.top)
                        }))
                    },
                    Wo = (e, t, o, n) => ({
                        x: e,
                        y: t,
                        width: o,
                        height: n,
                        right: e + o,
                        bottom: t + n
                    }),
                    $o = e => {
                        const t = Ut(e),
                            o = qt(e),
                            n = zt(e);
                        return Wo(t.left, t.top, o, n)
                    },
                    qo = e => {
                        const t = jo(e),
                            o = qt(e),
                            n = zt(e);
                        return Wo(t.left, t.top, o, n)
                    },
                    Go = () => Fo(window),
                    Ko = e => {
                        const t = t => t(e),
                            o = y(e),
                            n = () => r,
                            r = {
                                tag: !0,
                                inner: e,
                                fold: (t, o) => o(e),
                                isValue: T,
                                isError: O,
                                map: t => Xo.value(t(e)),
                                mapError: n,
                                bind: t,
                                exists: t,
                                forall: t,
                                getOr: o,
                                or: n,
                                getOrThunk: o,
                                orThunk: n,
                                getOrDie: o,
                                each: t => {
                                    t(e)
                                },
                                toOptional: () => A.some(e)
                            };
                        return r
                    },
                    Yo = e => {
                        const t = () => o,
                            o = {
                                tag: !1,
                                inner: e,
                                fold: (t, o) => t(e),
                                isValue: O,
                                isError: T,
                                map: t,
                                mapError: t => Xo.error(t(e)),
                                bind: t,
                                exists: O,
                                forall: T,
                                getOr: w,
                                or: w,
                                getOrThunk: _,
                                orThunk: _,
                                getOrDie: k(String(e)),
                                each: v,
                                toOptional: A.none
                            };
                        return o
                    },
                    Xo = {
                        value: Ko,
                        error: Yo,
                        fromOption: (e, t) => e.fold((() => Yo(t)), Ko)
                    };
                var Jo;
                ! function(e) {
                    e[e.Error = 0] = "Error", e[e.Value = 1] = "Value"
                }(Jo || (Jo = {}));
                const Qo = (e, t, o) => e.stype === Jo.Error ? t(e.serror) : o(e.svalue),
                    en = e => ({
                        stype: Jo.Value,
                        svalue: e
                    }),
                    tn = e => ({
                        stype: Jo.Error,
                        serror: e
                    }),
                    on = en,
                    nn = tn,
                    rn = Qo,
                    sn = (e, t, o, n) => ({
                        tag: "field",
                        key: e,
                        newKey: t,
                        presence: o,
                        prop: n
                    }),
                    an = (e, t, o) => {
                        switch (e.tag) {
                            case "field":
                                return t(e.key, e.newKey, e.presence, e.prop);
                            case "custom":
                                return o(e.newKey, e.instantiator)
                        }
                    },
                    ln = e => (...t) => {
                        if (0 === t.length) throw new Error("Can't merge zero objects");
                        const o = {};
                        for (let n = 0; n < t.length; n++) {
                            const r = t[n];
                            for (const t in r) be(r, t) && (o[t] = e(o[t], r[t]))
                        }
                        return o
                    },
                    cn = ln(((e, t) => i(e) && i(t) ? cn(e, t) : t)),
                    dn = ln(((e, t) => t)),
                    un = e => ({
                        tag: "defaultedThunk",
                        process: e
                    }),
                    mn = e => un(y(e)),
                    gn = e => ({
                        tag: "mergeWithThunk",
                        process: e
                    }),
                    hn = e => {
                        const t = (e => {
                            const t = [],
                                o = [];
                            return F(e, (e => {
                                Qo(e, (e => o.push(e)), (e => t.push(e)))
                            })), {
                                values: t,
                                errors: o
                            }
                        })(e);
                        return t.errors.length > 0 ? (o = t.errors, b(nn, q)(o)) : on(t.values);
                        var o
                    },
                    pn = e => a(e) && ae(e).length > 100 ? " removed due to size" : JSON.stringify(e, null, 2),
                    fn = (e, t) => nn([{
                        path: e,
                        getErrorInfo: t
                    }]),
                    vn = e => ({
                        extract: (t, o) => {
                            return n = e(o), r = e => ((e, t) => fn(e, y(t)))(t, e), n.stype === Jo.Error ? r(n.serror) : n;
                            var n, r
                        },
                        toString: y("val")
                    }),
                    bn = vn(on),
                    yn = (e, t, o, n) => n(ve(e, t).getOrThunk((() => o(e)))),
                    wn = (e, t, o, n, r) => {
                        const s = e => r.extract(t.concat([n]), e),
                            a = e => e.fold((() => on(A.none())), (e => {
                                const o = r.extract(t.concat([n]), e);
                                return s = o, a = A.some, s.stype === Jo.Value ? {
                                    stype: Jo.Value,
                                    svalue: a(s.svalue)
                                } : s;
                                var s, a
                            }));
                        switch (e.tag) {
                            case "required":
                                return ((e, t, o, n) => ve(t, o).fold((() => ((e, t, o) => fn(e, (() => 'Could not find valid *required* value for "' + t + '" in ' + pn(o))))(e, o, t)), n))(t, o, n, s);
                            case "defaultedThunk":
                                return yn(o, n, e.process, s);
                            case "option":
                                return ((e, t, o) => o(ve(e, t)))(o, n, a);
                            case "defaultedOptionThunk":
                                return ((e, t, o, n) => n(ve(e, t).map((t => !0 === t ? o(e) : t))))(o, n, e.process, a);
                            case "mergeWithThunk":
                                return yn(o, n, y({}), (t => {
                                    const n = cn(e.process(o), t);
                                    return s(n)
                                }))
                        }
                    },
                    xn = e => ({
                        extract: (t, o) => e().extract(t, o),
                        toString: () => e().toString()
                    }),
                    Cn = e => ae(ge(e, g)),
                    Sn = e => {
                        const t = kn(e),
                            o = U(e, ((e, t) => an(t, (t => cn(e, {
                                [t]: !0
                            })), y(e))), {});
                        return {
                            extract: (e, n) => {
                                const r = d(n) ? [] : Cn(n),
                                    s = Z(r, (e => !ye(o, e)));
                                return 0 === s.length ? t.extract(e, n) : ((e, t) => fn(e, (() => "There are unsupported fields: [" + t.join(", ") + "] specified")))(e, s)
                            },
                            toString: t.toString
                        }
                    },
                    kn = e => ({
                        extract: (t, o) => ((e, t, o) => {
                            const n = {},
                                r = [];
                            for (const s of o) an(s, ((o, s, a, i) => {
                                const l = wn(a, e, t, o, i);
                                rn(l, (e => {
                                    r.push(...e)
                                }), (e => {
                                    n[s] = e
                                }))
                            }), ((e, o) => {
                                n[e] = o(t)
                            }));
                            return r.length > 0 ? nn(r) : on(n)
                        })(t, o, e),
                        toString: () => {
                            const t = z(e, (e => an(e, ((e, t, o, n) => e + " -> " + n.toString()), ((e, t) => "state(" + e + ")"))));
                            return "obj{\n" + t.join("\n") + "}"
                        }
                    }),
                    _n = e => ({
                        extract: (t, o) => {
                            const n = z(o, ((o, n) => e.extract(t.concat(["[" + n + "]"]), o)));
                            return hn(n)
                        },
                        toString: () => "array(" + e.toString() + ")"
                    }),
                    On = (e, t) => {
                        const o = void 0 !== t ? t : w;
                        return {
                            extract: (t, n) => {
                                const r = [];
                                for (const s of e) {
                                    const e = s.extract(t, n);
                                    if (e.stype === Jo.Value) return {
                                        stype: Jo.Value,
                                        svalue: o(e.svalue)
                                    };
                                    r.push(e)
                                }
                                return hn(r)
                            },
                            toString: () => "oneOf(" + z(e, (e => e.toString())).join(", ") + ")"
                        }
                    },
                    Tn = (e, t) => ({
                        extract: (o, n) => {
                            const r = ae(n),
                                s = ((t, o) => _n(vn(e)).extract(t, o))(o, r);
                            return i = e => {
                                const r = z(e, (e => sn(e, e, {
                                    tag: "required",
                                    process: {}
                                }, t)));
                                return kn(r).extract(o, n)
                            }, (a = s).stype === Jo.Value ? i(a.svalue) : a;
                            var a, i
                        },
                        toString: () => "setOf(" + t.toString() + ")"
                    }),
                    En = b(_n, kn),
                    An = y(bn),
                    Mn = (e, t) => vn((o => {
                        const n = typeof o;
                        return e(o) ? on(o) : nn(`Expected type: ${t} but got: ${n}`)
                    })),
                    Nn = Mn(p, "number"),
                    Rn = Mn(s, "string"),
                    Dn = Mn(d, "boolean"),
                    Bn = Mn(h, "function"),
                    Ln = e => {
                        if (Object(e) !== e) return !0;
                        switch ({}.toString.call(e).slice(8, -1)) {
                            case "Boolean":
                            case "Number":
                            case "String":
                            case "Date":
                            case "RegExp":
                            case "Blob":
                            case "FileList":
                            case "ImageData":
                            case "ImageBitmap":
                            case "ArrayBuffer":
                                return !0;
                            case "Array":
                            case "Object":
                                return Object.keys(e).every((t => Ln(e[t])));
                            default:
                                return !1
                        }
                    },
                    Hn = vn((e => Ln(e) ? on(e) : nn("Expected value to be acceptable for sending via postMessage"))),
                    In = (e, t) => ({
                        extract: (o, n) => ve(n, e).fold((() => ((e, t) => fn(e, (() => 'Choice schema did not contain choice key: "' + t + '"')))(o, e)), (e => ((e, t, o, n) => ve(o, n).fold((() => ((e, t, o) => fn(e, (() => 'The chosen schema: "' + o + '" did not exist in branches: ' + pn(t))))(e, o, n)), (o => o.extract(e.concat(["branch: " + n]), t))))(o, n, t, e))),
                        toString: () => "chooseOn(" + e + "). Possible values: " + ae(t)
                    }),
                    Pn = e => vn((t => e(t).fold(nn, on))),
                    zn = (e, t) => Tn((t => e(t).fold(tn, en)), t),
                    Fn = (e, t, o) => {
                        return n = ((e, t, o) => ((e, t) => e.stype === Jo.Error ? {
                            stype: Jo.Error,
                            serror: t(e.serror)
                        } : e)(t.extract([e], o), (e => ({
                            input: o,
                            errors: e
                        }))))(e, t, o), Qo(n, Xo.error, Xo.value);
                        var n
                    },
                    Vn = e => e.fold((e => {
                        throw new Error(Un(e))
                    }), w),
                    Zn = (e, t, o) => Vn(Fn(e, t, o)),
                    Un = e => "Errors: \n" + (e => {
                        const t = e.length > 10 ? e.slice(0, 10).concat([{
                            path: [],
                            getErrorInfo: y("... (only showing first ten failures)")
                        }]) : e;
                        return z(t, (e => "Failed path: (" + e.path.join(" > ") + ")\n" + e.getErrorInfo()))
                    })(e.errors).join("\n") + "\n\nInput object: " + pn(e.input),
                    jn = (e, t) => In(e, ce(t, kn)),
                    Wn = sn,
                    $n = (e, t) => ({
                        tag: "custom",
                        newKey: e,
                        instantiator: t
                    }),
                    qn = e => Pn((t => L(e, t) ? Xo.value(t) : Xo.error(`Unsupported value: "${t}", choose one of "${e.join(", ")}".`))),
                    Gn = e => Wn(e, e, {
                        tag: "required",
                        process: {}
                    }, An()),
                    Kn = (e, t) => Wn(e, e, {
                        tag: "required",
                        process: {}
                    }, t),
                    Yn = e => Kn(e, Nn),
                    Xn = e => Kn(e, Rn),
                    Jn = (e, t) => Wn(e, e, {
                        tag: "required",
                        process: {}
                    }, qn(t)),
                    Qn = e => Kn(e, Bn),
                    er = (e, t) => Wn(e, e, {
                        tag: "required",
                        process: {}
                    }, kn(t)),
                    tr = (e, t) => Wn(e, e, {
                        tag: "required",
                        process: {}
                    }, En(t)),
                    or = (e, t) => Wn(e, e, {
                        tag: "required",
                        process: {}
                    }, _n(t)),
                    nr = e => Wn(e, e, {
                        tag: "option",
                        process: {}
                    }, An()),
                    rr = (e, t) => Wn(e, e, {
                        tag: "option",
                        process: {}
                    }, t),
                    sr = e => rr(e, Nn),
                    ar = e => rr(e, Rn),
                    ir = (e, t) => rr(e, qn(t)),
                    lr = e => rr(e, Bn),
                    cr = (e, t) => rr(e, _n(t)),
                    dr = (e, t) => rr(e, kn(t)),
                    ur = (e, t) => Wn(e, e, mn(t), An()),
                    mr = (e, t, o) => Wn(e, e, mn(t), o),
                    gr = (e, t) => mr(e, t, Nn),
                    hr = (e, t) => mr(e, t, Rn),
                    pr = (e, t, o) => mr(e, t, qn(o)),
                    fr = (e, t) => mr(e, t, Dn),
                    vr = (e, t) => mr(e, t, Bn),
                    br = (e, t, o) => mr(e, t, _n(o)),
                    yr = (e, t, o) => mr(e, t, kn(o)),
                    wr = e => {
                        let t = e;
                        return {
                            get: () => t,
                            set: e => {
                                t = e
                            }
                        }
                    },
                    xr = e => {
                        if (!l(e)) throw new Error("cases must be an array");
                        if (0 === e.length) throw new Error("there must be at least one case");
                        const t = [],
                            o = {};
                        return F(e, ((n, r) => {
                            const s = ae(n);
                            if (1 !== s.length) throw new Error("one and only one name per case");
                            const a = s[0],
                                i = n[a];
                            if (void 0 !== o[a]) throw new Error("duplicate key detected:" + a);
                            if ("cata" === a) throw new Error("cannot have a case named cata (sorry)");
                            if (!l(i)) throw new Error("case arguments must be an array");
                            t.push(a), o[a] = (...o) => {
                                const n = o.length;
                                if (n !== i.length) throw new Error("Wrong number of arguments to case " + a + ". Expected " + i.length + " (" + i + "), got " + n);
                                return {
                                    fold: (...t) => {
                                        if (t.length !== e.length) throw new Error("Wrong number of arguments to fold. Expected " + e.length + ", got " + t.length);
                                        return t[r].apply(null, o)
                                    },
                                    match: e => {
                                        const n = ae(e);
                                        if (t.length !== n.length) throw new Error("Wrong number of arguments to match. Expected: " + t.join(",") + "\nActual: " + n.join(","));
                                        if (!K(t, (e => L(n, e)))) throw new Error("Not all branches were specified when using match. Specified: " + n.join(", ") + "\nRequired: " + t.join(", "));
                                        return e[a].apply(null, o)
                                    },
                                    log: e => {
                                        console.log(e, {
                                            constructors: t,
                                            constructor: a,
                                            params: o
                                        })
                                    }
                                }
                            }
                        })), o
                    };
                xr([{
                    bothErrors: ["error1", "error2"]
                }, {
                    firstError: ["error1", "value2"]
                }, {
                    secondError: ["value1", "error2"]
                }, {
                    bothValues: ["value1", "value2"]
                }]);
                const Cr = (e, t) => ((e, t) => ({
                        [e]: t
                    }))(e, t),
                    Sr = e => (e => {
                        const t = {};
                        return F(e, (e => {
                            t[e.key] = e.value
                        })), t
                    })(e),
                    kr = e => h(e) ? e : O,
                    _r = (e, t, o) => {
                        let n = e.dom;
                        const r = kr(o);
                        for (; n.parentNode;) {
                            n = n.parentNode;
                            const e = Be(n),
                                o = t(e);
                            if (o.isSome()) return o;
                            if (r(e)) break
                        }
                        return A.none()
                    },
                    Or = (e, t, o) => {
                        const n = t(e),
                            r = kr(o);
                        return n.orThunk((() => r(e) ? A.none() : _r(e, t, r)))
                    },
                    Tr = (e, t) => Ge(e.element, t.event.target),
                    Er = {
                        can: T,
                        abort: O,
                        run: v
                    },
                    Ar = e => {
                        if (!ye(e, "can") && !ye(e, "abort") && !ye(e, "run")) throw new Error("EventHandler defined by: " + JSON.stringify(e, null, 2) + " does not have can, abort, or run!");
                        return { ...Er,
                            ...e
                        }
                    },
                    Mr = y,
                    Nr = Mr("touchstart"),
                    Rr = Mr("touchmove"),
                    Dr = Mr("touchend"),
                    Br = Mr("touchcancel"),
                    Lr = Mr("mousedown"),
                    Hr = Mr("mousemove"),
                    Ir = Mr("mouseout"),
                    Pr = Mr("mouseup"),
                    zr = Mr("mouseover"),
                    Fr = Mr("focusin"),
                    Vr = Mr("focusout"),
                    Zr = Mr("keydown"),
                    Ur = Mr("keyup"),
                    jr = Mr("input"),
                    Wr = Mr("change"),
                    $r = Mr("click"),
                    qr = Mr("transitioncancel"),
                    Gr = Mr("transitionend"),
                    Kr = Mr("transitionstart"),
                    Yr = Mr("selectstart"),
                    Xr = e => y("alloy." + e),
                    Jr = {
                        tap: Xr("tap")
                    },
                    Qr = Xr("focus"),
                    es = Xr("blur.post"),
                    ts = Xr("paste.post"),
                    os = Xr("receive"),
                    ns = Xr("execute"),
                    rs = Xr("focus.item"),
                    ss = Jr.tap,
                    as = Xr("longpress"),
                    is = Xr("sandbox.close"),
                    ls = Xr("typeahead.cancel"),
                    cs = Xr("system.init"),
                    ds = Xr("system.touchmove"),
                    us = Xr("system.touchend"),
                    ms = Xr("system.scroll"),
                    gs = Xr("system.resize"),
                    hs = Xr("system.attached"),
                    ps = Xr("system.detached"),
                    fs = Xr("system.dismissRequested"),
                    vs = Xr("system.repositionRequested"),
                    bs = Xr("focusmanager.shifted"),
                    ys = Xr("slotcontainer.visibility"),
                    ws = Xr("change.tab"),
                    xs = Xr("dismiss.tab"),
                    Cs = Xr("highlight"),
                    Ss = Xr("dehighlight"),
                    ks = (e, t) => {
                        Es(e, e.element, t, {})
                    },
                    _s = (e, t, o) => {
                        Es(e, e.element, t, o)
                    },
                    Os = e => {
                        ks(e, ns())
                    },
                    Ts = (e, t, o) => {
                        Es(e, t, o, {})
                    },
                    Es = (e, t, o, n) => {
                        const r = {
                            target: t,
                            ...n
                        };
                        e.getSystem().triggerEvent(o, t, r)
                    },
                    As = (e, t, o, n) => {
                        e.getSystem().triggerEvent(o, t, n.event)
                    },
                    Ms = e => Sr(e),
                    Ns = (e, t) => ({
                        key: e,
                        value: Ar({
                            abort: t
                        })
                    }),
                    Rs = e => ({
                        key: e,
                        value: Ar({
                            run: (e, t) => {
                                t.event.prevent()
                            }
                        })
                    }),
                    Ds = (e, t) => ({
                        key: e,
                        value: Ar({
                            run: t
                        })
                    }),
                    Bs = (e, t, o) => ({
                        key: e,
                        value: Ar({
                            run: (e, n) => {
                                t.apply(void 0, [e, n].concat(o))
                            }
                        })
                    }),
                    Ls = e => t => ({
                        key: e,
                        value: Ar({
                            run: (e, o) => {
                                Tr(e, o) && t(e, o)
                            }
                        })
                    }),
                    Hs = (e, t, o) => ((e, t) => Ds(e, ((o, n) => {
                        o.getSystem().getByUid(t).each((t => {
                            As(t, t.element, e, n)
                        }))
                    })))(e, t.partUids[o]),
                    Is = (e, t) => Ds(e, ((e, o) => {
                        const n = o.event,
                            r = e.getSystem().getByDom(n.target).getOrThunk((() => Or(n.target, (t => e.getSystem().getByDom(t).toOptional()), O).getOr(e)));
                        t(e, r, o)
                    })),
                    Ps = e => Ds(e, ((e, t) => {
                        t.cut()
                    })),
                    zs = e => Ds(e, ((e, t) => {
                        t.stop()
                    })),
                    Fs = (e, t) => Ls(e)(t),
                    Vs = Ls(hs()),
                    Zs = Ls(ps()),
                    Us = Ls(cs()),
                    js = (Ys = ns(), e => Ds(Ys, e)),
                    Ws = e => e.dom.innerHTML,
                    $s = (e, t) => {
                        const o = Ye(e).dom,
                            n = Be(o.createDocumentFragment()),
                            r = ((e, t) => {
                                const o = (t || document).createElement("div");
                                return o.innerHTML = e, nt(Be(o))
                            })(t, o);
                        Bo(n, r), Lo(e), Do(e, n)
                    },
                    qs = e => it(e) ? "#shadow-root" : (e => {
                        const t = Re("div"),
                            o = Be(e.dom.cloneNode(!0));
                        return Do(t, o), Ws(t)
                    })((e => ((e, t) => Be(e.dom.cloneNode(!1)))(e))(e)),
                    Gs = e => qs(e),
                    Ks = Ms([((e, t) => ({
                        key: e,
                        value: Ar({
                            can: (e, t) => {
                                const o = t.event,
                                    n = o.originator,
                                    r = o.target;
                                return !((e, t, o) => Ge(t, e.element) && !Ge(t, o))(e, n, r) || (console.warn(Qr() + " did not get interpreted by the desired target. \nOriginator: " + Gs(n) + "\nTarget: " + Gs(r) + "\nCheck the " + Qr() + " event handlers"), !1)
                            }
                        })
                    }))(Qr())]);
                var Ys, Xs = Object.freeze({
                    __proto__: null,
                    events: Ks
                });
                let Js = 0;
                const Qs = e => {
                        const t = (new Date).getTime(),
                            o = Math.floor(1e9 * Math.random());
                        return Js++, e + "_" + o + Js + String(t)
                    },
                    ea = y("alloy-id-"),
                    ta = y("data-alloy-id"),
                    oa = ea(),
                    na = ta(),
                    ra = (e, t) => {
                        Object.defineProperty(e.dom, na, {
                            value: t,
                            writable: !0
                        })
                    },
                    sa = e => {
                        const t = Ve(e) ? e.dom[na] : null;
                        return A.from(t)
                    },
                    aa = e => Qs(e),
                    ia = w,
                    la = e => {
                        const t = t => `The component must be in a context to execute: ${t}` + (e ? "\n" + Gs(e().element) + " is not in context." : ""),
                            o = e => () => {
                                throw new Error(t(e))
                            },
                            n = e => () => {
                                console.warn(t(e))
                            };
                        return {
                            debugInfo: y("fake"),
                            triggerEvent: n("triggerEvent"),
                            triggerFocus: n("triggerFocus"),
                            triggerEscape: n("triggerEscape"),
                            broadcast: n("broadcast"),
                            broadcastOn: n("broadcastOn"),
                            broadcastEvent: n("broadcastEvent"),
                            build: o("build"),
                            buildOrPatch: o("buildOrPatch"),
                            addToWorld: o("addToWorld"),
                            removeFromWorld: o("removeFromWorld"),
                            addToGui: o("addToGui"),
                            removeFromGui: o("removeFromGui"),
                            getByUid: o("getByUid"),
                            getByDom: o("getByDom"),
                            isConnected: O
                        }
                    },
                    ca = la(),
                    da = e => z(e, (e => Oe(e, "/*") ? e.substring(0, e.length - "/*".length) : e)),
                    ua = (e, t) => {
                        const o = e.toString(),
                            n = o.indexOf(")") + 1,
                            r = o.indexOf("("),
                            s = o.substring(r + 1, n - 1).split(/,\s*/);
                        return e.toFunctionAnnotation = () => ({
                            name: t,
                            parameters: da(s)
                        }), e
                    },
                    ma = Qs("alloy-premade"),
                    ga = e => (Object.defineProperty(e.element.dom, ma, {
                        value: e.uid,
                        writable: !0
                    }), Cr(ma, e)),
                    ha = e => ve(e, ma),
                    pa = e => ((e, t) => {
                        const o = t.toString(),
                            n = o.indexOf(")") + 1,
                            r = o.indexOf("("),
                            s = o.substring(r + 1, n - 1).split(/,\s*/);
                        return e.toFunctionAnnotation = () => ({
                            name: "OVERRIDE",
                            parameters: da(s.slice(1))
                        }), e
                    })(((t, ...o) => e(t.getApis(), t, ...o)), e),
                    fa = {
                        init: () => va({
                            readState: y("No State required")
                        })
                    },
                    va = e => e,
                    ba = (e, t) => {
                        const o = {};
                        return le(e, ((e, n) => {
                            le(e, ((e, r) => {
                                const s = ve(o, r).getOr([]);
                                o[r] = s.concat([t(n, e)])
                            }))
                        })), o
                    },
                    ya = e => ({
                        classes: u(e.classes) ? [] : e.classes,
                        attributes: u(e.attributes) ? {} : e.attributes,
                        styles: u(e.styles) ? {} : e.styles
                    }),
                    wa = e => e.cHandler,
                    xa = (e, t) => ({
                        name: e,
                        handler: t
                    }),
                    Ca = (e, t) => {
                        const o = {};
                        return F(e, (e => {
                            o[e.name()] = e.handlers(t)
                        })), o
                    },
                    Sa = (e, t, o) => {
                        const n = t[o];
                        return n ? ((e, t, o, n) => {
                            try {
                                const r = ee(o, ((o, r) => {
                                    const s = o[t],
                                        a = r[t],
                                        i = n.indexOf(s),
                                        l = n.indexOf(a);
                                    if (-1 === i) throw new Error("The ordering for " + e + " does not have an entry for " + s + ".\nOrder specified: " + JSON.stringify(n, null, 2));
                                    if (-1 === l) throw new Error("The ordering for " + e + " does not have an entry for " + a + ".\nOrder specified: " + JSON.stringify(n, null, 2));
                                    return i < l ? -1 : l < i ? 1 : 0
                                }));
                                return Xo.value(r)
                            } catch (e) {
                                return Xo.error([e])
                            }
                        })("Event: " + o, "name", e, n).map((e => (e => {
                            const t = ((e, t) => (...t) => j(e, ((e, o) => e && (e => e.can)(o).apply(void 0, t)), !0))(e),
                                o = ((e, t) => (...t) => j(e, ((e, o) => e || (e => e.abort)(o).apply(void 0, t)), !1))(e);
                            return {
                                can: t,
                                abort: o,
                                run: (...t) => {
                                    F(e, (e => {
                                        e.run.apply(void 0, t)
                                    }))
                                }
                            }
                        })(z(e, (e => e.handler))))) : ((e, t) => Xo.error(["The event (" + e + ') has more than one behaviour that listens to it.\nWhen this occurs, you must specify an event ordering for the behaviours in your spec (e.g. [ "listing", "toggling" ]).\nThe behaviours that can trigger it are: ' + JSON.stringify(z(t, (e => e.name)), null, 2)]))(o, e)
                    },
                    ka = (e, t) => ((e, t) => {
                        const o = (e => {
                            const t = [],
                                o = [];
                            return F(e, (e => {
                                e.fold((e => {
                                    t.push(e)
                                }), (e => {
                                    o.push(e)
                                }))
                            })), {
                                errors: t,
                                values: o
                            }
                        })(e);
                        return o.errors.length > 0 ? (n = o.errors, Xo.error(q(n))) : ((e, t) => 0 === e.length ? Xo.value(t) : Xo.value(cn(t, dn.apply(void 0, e))))(o.values, t);
                        var n
                    })(he(e, ((e, o) => (1 === e.length ? Xo.value(e[0].handler) : Sa(e, t, o)).map((n => {
                        const r = (e => {
                                const t = (e => h(e) ? {
                                    can: T,
                                    abort: O,
                                    run: e
                                } : e)(e);
                                return (e, o, ...n) => {
                                    const r = [e, o].concat(n);
                                    t.abort.apply(void 0, r) ? o.stop() : t.can.apply(void 0, r) && t.run.apply(void 0, r)
                                }
                            })(n),
                            s = e.length > 1 ? Z(t[o], (t => H(e, (e => e.name === t)))).join(" > ") : e[0].name;
                        return Cr(o, ((e, t) => ({
                            handler: e,
                            purpose: t
                        }))(r, s))
                    })))), {}),
                    _a = "alloy.base.behaviour",
                    Oa = kn([Wn("dom", "dom", {
                        tag: "required",
                        process: {}
                    }, kn([Gn("tag"), ur("styles", {}), ur("classes", []), ur("attributes", {}), nr("value"), nr("innerHtml")])), Gn("components"), Gn("uid"), ur("events", {}), ur("apis", {}), Wn("eventOrder", "eventOrder", (Xa = {
                        [ns()]: ["disabling", _a, "toggling", "typeaheadevents"],
                        [Qr()]: [_a, "focusing", "keying"],
                        [cs()]: [_a, "disabling", "toggling", "representing"],
                        [jr()]: [_a, "representing", "streaming", "invalidating"],
                        [ps()]: [_a, "representing", "item-events", "tooltipping"],
                        [Lr()]: ["focusing", _a, "item-type-events"],
                        [Nr()]: ["focusing", _a, "item-type-events"],
                        [zr()]: ["item-type-events", "tooltipping"],
                        [os()]: ["receiving", "reflecting", "tooltipping"]
                    }, gn(y(Xa))), An()), nr("domModification")]),
                    Ta = e => e.events,
                    Ea = (e, t) => {
                        const o = wt(e, t);
                        return void 0 === o || "" === o ? [] : o.split(" ")
                    },
                    Aa = e => void 0 !== e.dom.classList,
                    Ma = e => Ea(e, "class"),
                    Na = (e, t) => {
                        Aa(e) ? e.dom.classList.add(t) : ((e, t) => {
                            ((e, t, o) => {
                                const n = Ea(e, t).concat([o]);
                                bt(e, t, n.join(" "))
                            })(e, "class", t)
                        })(e, t)
                    },
                    Ra = (e, t) => {
                        Aa(e) ? e.dom.classList.remove(t) : ((e, t) => {
                            ((e, t, o) => {
                                const n = Z(Ea(e, t), (e => e !== o));
                                n.length > 0 ? bt(e, t, n.join(" ")) : St(e, t)
                            })(e, "class", t)
                        })(e, t), (e => {
                            0 === (Aa(e) ? e.dom.classList : Ma(e)).length && St(e, "class")
                        })(e)
                    },
                    Da = (e, t) => Aa(e) && e.dom.classList.contains(t),
                    Ba = (e, t) => {
                        F(t, (t => {
                            Na(e, t)
                        }))
                    },
                    La = (e, t) => {
                        F(t, (t => {
                            Ra(e, t)
                        }))
                    },
                    Ha = e => e.dom.value,
                    Ia = (e, t) => {
                        if (void 0 === t) throw new Error("Value.set was undefined");
                        e.dom.value = t
                    },
                    Pa = (e, t, o) => {
                        o.fold((() => Do(e, t)), (e => {
                            Ge(e, t) || (Mo(e, t), Ho(e))
                        }))
                    },
                    za = (e, t, o) => {
                        const n = z(t, o),
                            r = nt(e);
                        return F(r.slice(n.length), Ho), n
                    },
                    Fa = (e, t, o, n) => {
                        const r = rt(e, t),
                            s = n(o, r),
                            a = ((e, t, o) => rt(e, t).map((e => {
                                if (o.exists((t => !Ge(t, e)))) {
                                    const t = o.map(ze).getOr("span"),
                                        n = Re(t);
                                    return Mo(e, n), n
                                }
                                return e
                            })))(e, t, r);
                        return Pa(e, s.element, a), s
                    },
                    Va = (e, t) => {
                        const o = ae(e),
                            n = ae(t);
                        return {
                            toRemove: X(n, o),
                            toSet: ((e, o) => {
                                const n = {},
                                    r = {};
                                return me(e, ((e, o) => !be(t, o) || e !== t[o]), ue(n), ue(r)), {
                                    t: n,
                                    f: r
                                }
                            })(e).t
                        }
                    },
                    Za = (e, t) => {
                        const {
                            class: o,
                            style: n,
                            ...r
                        } = (e => j(e.dom.attributes, ((e, t) => (e[t.name] = t.value, e)), {}))(t), {
                            toSet: s,
                            toRemove: a
                        } = Va(e.attributes, r), i = Rt(t), {
                            toSet: l,
                            toRemove: c
                        } = Va(e.styles, i), d = (e => Aa(e) ? (e => {
                            const t = e.dom.classList,
                                o = new Array(t.length);
                            for (let e = 0; e < t.length; e++) {
                                const n = t.item(e);
                                null !== n && (o[e] = n)
                            }
                            return o
                        })(e) : Ma(e))(t), u = X(d, e.classes), m = X(e.classes, d);
                        return F(a, (e => St(t, e))), yt(t, s), Ba(t, m), La(t, u), F(c, (e => Bt(t, e))), Tt(t, l), e.innerHtml.fold((() => {
                            const o = e.domChildren;
                            ((e, t) => {
                                za(e, t, ((t, o) => {
                                    const n = rt(e, o);
                                    return Pa(e, t, n), t
                                }))
                            })(t, o)
                        }), (e => {
                            $s(t, e)
                        })), (() => {
                            const o = t,
                                n = e.value.getOrUndefined();
                            n !== Ha(o) && Ia(o, null != n ? n : "")
                        })(), t
                    },
                    Ua = e => {
                        const t = (e => {
                            const t = ve(e, "behaviours").getOr({});
                            return G(ae(t), (e => {
                                const o = t[e];
                                return g(o) ? [o.me] : []
                            }))
                        })(e);
                        return ((e, t) => ((e, t) => {
                            const o = z(t, (e => dr(e.name(), [Gn("config"), ur("state", fa)]))),
                                n = Fn("component.behaviours", kn(o), e.behaviours).fold((t => {
                                    throw new Error(Un(t) + "\nComplete spec:\n" + JSON.stringify(e, null, 2))
                                }), w);
                            return {
                                list: t,
                                data: ce(n, (e => {
                                    const t = e.map((e => ({
                                        config: e.config,
                                        state: e.state.init(e.config)
                                    })));
                                    return y(t)
                                }))
                            }
                        })(e, t))(e, t)
                    },
                    ja = (e, t) => {
                        const o = () => m,
                            n = wr(ca),
                            r = Vn((e => Fn("custom.definition", Oa, e))(e)),
                            s = Ua(e),
                            a = (e => e.list)(s),
                            i = (e => e.data)(s),
                            l = ((e, t, o) => {
                                const n = { ...(r = e).dom,
                                    uid: r.uid,
                                    domChildren: z(r.components, (e => e.element))
                                };
                                var r;
                                const s = (e => e.domModification.fold((() => ya({})), ya))(e),
                                    a = {
                                        "alloy.base.modification": s
                                    },
                                    i = t.length > 0 ? ((e, t, o, n) => {
                                        const r = { ...t
                                        };
                                        F(o, (t => {
                                            r[t.name()] = t.exhibit(e, n)
                                        }));
                                        const s = ba(r, ((e, t) => ({
                                                name: e,
                                                modification: t
                                            }))),
                                            a = e => U(e, ((e, t) => ({ ...t.modification,
                                                ...e
                                            })), {}),
                                            i = U(s.classes, ((e, t) => t.modification.concat(e)), []),
                                            l = a(s.attributes),
                                            c = a(s.styles);
                                        return ya({
                                            classes: i,
                                            attributes: l,
                                            styles: c
                                        })
                                    })(o, a, t, n) : s;
                                return l = n, c = i, { ...l,
                                    attributes: { ...l.attributes,
                                        ...c.attributes
                                    },
                                    styles: { ...l.styles,
                                        ...c.styles
                                    },
                                    classes: l.classes.concat(c.classes)
                                };
                                var l, c
                            })(r, a, i),
                            c = ((e, t) => {
                                const o = t.filter((t => ze(t) === e.tag && !(e => e.innerHtml.isSome() && e.domChildren.length > 0)(e) && !(e => be(e.dom, ma))(t))).bind((t => ((e, t) => {
                                    try {
                                        const o = Za(e, t);
                                        return A.some(o)
                                    } catch (e) {
                                        return A.none()
                                    }
                                })(e, t))).getOrThunk((() => (e => {
                                    const t = Re(e.tag);
                                    yt(t, e.attributes), Ba(t, e.classes), Tt(t, e.styles), e.innerHtml.each((e => $s(t, e)));
                                    const o = e.domChildren;
                                    return Bo(t, o), e.value.each((e => {
                                        Ia(t, e)
                                    })), t
                                })(e)));
                                return ra(o, e.uid), o
                            })(l, t),
                            d = ((e, t, o) => {
                                const n = {
                                    "alloy.base.behaviour": Ta(e)
                                };
                                return ((e, t, o, n) => {
                                    const r = ((e, t, o) => {
                                        const n = { ...o,
                                            ...Ca(t, e)
                                        };
                                        return ba(n, xa)
                                    })(e, o, n);
                                    return ka(r, t)
                                })(o, e.eventOrder, t, n).getOrDie()
                            })(r, a, i),
                            u = wr(r.components),
                            m = {
                                uid: e.uid,
                                getSystem: n.get,
                                config: t => {
                                    const o = i;
                                    return (h(o[t.name()]) ? o[t.name()] : () => {
                                        throw new Error("Could not find " + t.name() + " in " + JSON.stringify(e, null, 2))
                                    })()
                                },
                                hasConfigured: e => h(i[e.name()]),
                                spec: e,
                                readState: e => i[e]().map((e => e.state.readState())).getOr("not enabled"),
                                getApis: () => r.apis,
                                connect: e => {
                                    n.set(e)
                                },
                                disconnect: () => {
                                    n.set(la(o))
                                },
                                element: c,
                                syncComponents: () => {
                                    const e = nt(c),
                                        t = G(e, (e => n.get().getByDom(e).fold((() => []), Q)));
                                    u.set(t)
                                },
                                components: u.get,
                                events: d
                            };
                        return m
                    },
                    Wa = e => {
                        const t = De(e);
                        return $a({
                            element: t
                        })
                    },
                    $a = e => {
                        const t = Zn("external.component", Sn([Gn("element"), nr("uid")]), e),
                            o = wr(la()),
                            n = t.uid.getOrThunk((() => aa("external")));
                        ra(t.element, n);
                        const r = {
                            uid: n,
                            getSystem: o.get,
                            config: A.none,
                            hasConfigured: O,
                            connect: e => {
                                o.set(e)
                            },
                            disconnect: () => {
                                o.set(la((() => r)))
                            },
                            getApis: () => ({}),
                            element: t.element,
                            spec: e,
                            readState: y("No state"),
                            syncComponents: v,
                            components: y([]),
                            events: {}
                        };
                        return ga(r)
                    },
                    qa = aa,
                    Ga = (e, t) => ha(e).getOrThunk((() => ((e, t) => {
                        const {
                            events: o,
                            ...n
                        } = ia(e), r = ((e, t) => {
                            const o = ve(e, "components").getOr([]);
                            return t.fold((() => z(o, Ka)), (e => z(o, ((t, o) => Ga(t, rt(e, o))))))
                        })(n, t), s = { ...n,
                            events: { ...Xs,
                                ...o
                            },
                            components: r
                        };
                        return Xo.value(ja(s, t))
                    })((e => be(e, "uid"))(e) ? e : {
                        uid: qa(""),
                        ...e
                    }, t).getOrDie())),
                    Ka = e => Ga(e, A.none()),
                    Ya = ga;
                var Xa, Ja = (e, t, o, n, r) => e(o, n) ? A.some(o) : h(r) && r(o) ? A.none() : t(o, n, r);
                const Qa = (e, t, o) => {
                        let n = e.dom;
                        const r = h(o) ? o : O;
                        for (; n.parentNode;) {
                            n = n.parentNode;
                            const e = Be(n);
                            if (t(e)) return A.some(e);
                            if (r(e)) break
                        }
                        return A.none()
                    },
                    ei = (e, t, o) => Ja(((e, t) => t(e)), Qa, e, t, o),
                    ti = (e, t, o) => ei(e, t, o).isSome(),
                    oi = (e, t, o) => Qa(e, (e => $e(e, t)), o),
                    ni = (e, t) => ((e, o) => W(e.dom.childNodes, (e => {
                        return o = Be(e), $e(o, t);
                        var o
                    })).map(Be))(e),
                    ri = (e, t) => ((e, t) => {
                        const o = void 0 === t ? document : t.dom;
                        return qe(o) ? A.none() : A.from(o.querySelector(e)).map(Be)
                    })(t, e),
                    si = (e, t, o) => Ja(((e, t) => $e(e, t)), oi, e, t, o),
                    ai = "aria-controls",
                    ii = () => {
                        const e = Qs(ai);
                        return {
                            id: e,
                            link: t => {
                                bt(t, ai, e)
                            },
                            unlink: e => {
                                St(e, ai)
                            }
                        }
                    },
                    li = (e, t) => ti(t, (t => Ge(t, e.element)), O) || ((e, t) => (e => ei(e, (e => {
                        if (!Ve(e)) return !1;
                        const t = wt(e, "id");
                        return void 0 !== t && t.indexOf(ai) > -1
                    })).bind((e => {
                        const t = wt(e, "id"),
                            o = dt(e);
                        return ri(o, `[${ai}="${t}"]`)
                    })))(t).exists((t => li(e, t))))(e, t);
                var ci;
                ! function(e) {
                    e[e.STOP = 0] = "STOP", e[e.NORMAL = 1] = "NORMAL", e[e.LOGGING = 2] = "LOGGING"
                }(ci || (ci = {}));
                const di = wr({}),
                    ui = ["alloy/data/Fields", "alloy/debugging/Debugging"],
                    mi = (e, t, o) => ((e, t, o) => {
                        switch (ve(di.get(), e).orThunk((() => {
                            const t = ae(di.get());
                            return se(t, (t => e.indexOf(t) > -1 ? A.some(di.get()[t]) : A.none()))
                        })).getOr(ci.NORMAL)) {
                            case ci.NORMAL:
                                return o(gi());
                            case ci.LOGGING:
                                {
                                    const n = ((e, t) => {
                                            const o = [],
                                                n = (new Date).getTime();
                                            return {
                                                logEventCut: (e, t, n) => {
                                                    o.push({
                                                        outcome: "cut",
                                                        target: t,
                                                        purpose: n
                                                    })
                                                },
                                                logEventStopped: (e, t, n) => {
                                                    o.push({
                                                        outcome: "stopped",
                                                        target: t,
                                                        purpose: n
                                                    })
                                                },
                                                logNoParent: (e, t, n) => {
                                                    o.push({
                                                        outcome: "no-parent",
                                                        target: t,
                                                        purpose: n
                                                    })
                                                },
                                                logEventNoHandlers: (e, t) => {
                                                    o.push({
                                                        outcome: "no-handlers-left",
                                                        target: t
                                                    })
                                                },
                                                logEventResponse: (e, t, n) => {
                                                    o.push({
                                                        outcome: "response",
                                                        purpose: n,
                                                        target: t
                                                    })
                                                },
                                                write: () => {
                                                    const r = (new Date).getTime();
                                                    L(["mousemove", "mouseover", "mouseout", cs()], e) || console.log(e, {
                                                        event: e,
                                                        time: r - n,
                                                        target: t.dom,
                                                        sequence: z(o, (e => L(["cut", "stopped", "response"], e.outcome) ? "{" + e.purpose + "} " + e.outcome + " at (" + Gs(e.target) + ")" : e.outcome))
                                                    })
                                                }
                                            }
                                        })(e, t),
                                        r = o(n);
                                    return n.write(),
                                    r
                                }
                            case ci.STOP:
                                return !0
                        }
                    })(e, t, o),
                    gi = y({
                        logEventCut: v,
                        logEventStopped: v,
                        logNoParent: v,
                        logEventNoHandlers: v,
                        logEventResponse: v,
                        write: v
                    }),
                    hi = y([Gn("menu"), Gn("selectedMenu")]),
                    pi = y([Gn("item"), Gn("selectedItem")]);
                y(kn(pi().concat(hi())));
                const fi = y(kn(pi())),
                    vi = er("initSize", [Gn("numColumns"), Gn("numRows")]),
                    bi = () => er("markers", [Gn("backgroundMenu")].concat(hi()).concat(pi())),
                    yi = e => er("markers", z(e, Gn)),
                    wi = (e, t, o) => ((() => {
                        const e = new Error;
                        if (void 0 !== e.stack) {
                            const t = e.stack.split("\n");
                            W(t, (e => e.indexOf("alloy") > 0 && !H(ui, (t => e.indexOf(t) > -1)))).getOr("unknown")
                        }
                    })(), Wn(t, t, o, Pn((e => Xo.value(((...t) => e.apply(void 0, t))))))),
                    xi = e => wi(0, e, mn(v)),
                    Ci = e => wi(0, e, mn(A.none)),
                    Si = e => wi(0, e, {
                        tag: "required",
                        process: {}
                    }),
                    ki = e => wi(0, e, {
                        tag: "required",
                        process: {}
                    }),
                    _i = (e, t) => $n(e, y(t)),
                    Oi = e => $n(e, w),
                    Ti = y(vi),
                    Ei = (e, t, o, n, r, s, a, i = !1) => ({
                        x: e,
                        y: t,
                        bubble: o,
                        direction: n,
                        placement: r,
                        restriction: s,
                        label: `${a}-${r}`,
                        alwaysFit: i
                    }),
                    Ai = xr([{
                        southeast: []
                    }, {
                        southwest: []
                    }, {
                        northeast: []
                    }, {
                        northwest: []
                    }, {
                        south: []
                    }, {
                        north: []
                    }, {
                        east: []
                    }, {
                        west: []
                    }]),
                    Mi = Ai.southeast,
                    Ni = Ai.southwest,
                    Ri = Ai.northeast,
                    Di = Ai.northwest,
                    Bi = Ai.south,
                    Li = Ai.north,
                    Hi = Ai.east,
                    Ii = Ai.west,
                    Pi = (e, t, o, n) => {
                        const r = e + t;
                        return r > n ? o : r < o ? n : r
                    },
                    zi = (e, t, o) => Math.min(Math.max(e, t), o),
                    Fi = (e, t) => J(["left", "right", "top", "bottom"], (o => ve(t, o).map((t => ((e, t) => {
                        switch (t) {
                            case 1:
                                return e.x;
                            case 0:
                                return e.x + e.width;
                            case 2:
                                return e.y;
                            case 3:
                                return e.y + e.height
                        }
                    })(e, t))))),
                    Vi = "layout",
                    Zi = e => e.x,
                    Ui = (e, t) => e.x + e.width / 2 - t.width / 2,
                    ji = (e, t) => e.x + e.width - t.width,
                    Wi = (e, t) => e.y - t.height,
                    $i = e => e.y + e.height,
                    qi = (e, t) => e.y + e.height / 2 - t.height / 2,
                    Gi = (e, t, o) => Ei(Zi(e), $i(e), o.southeast(), Mi(), "southeast", Fi(e, {
                        left: 1,
                        top: 3
                    }), Vi),
                    Ki = (e, t, o) => Ei(ji(e, t), $i(e), o.southwest(), Ni(), "southwest", Fi(e, {
                        right: 0,
                        top: 3
                    }), Vi),
                    Yi = (e, t, o) => Ei(Zi(e), Wi(e, t), o.northeast(), Ri(), "northeast", Fi(e, {
                        left: 1,
                        bottom: 2
                    }), Vi),
                    Xi = (e, t, o) => Ei(ji(e, t), Wi(e, t), o.northwest(), Di(), "northwest", Fi(e, {
                        right: 0,
                        bottom: 2
                    }), Vi),
                    Ji = (e, t, o) => Ei(Ui(e, t), Wi(e, t), o.north(), Li(), "north", Fi(e, {
                        bottom: 2
                    }), Vi),
                    Qi = (e, t, o) => Ei(Ui(e, t), $i(e), o.south(), Bi(), "south", Fi(e, {
                        top: 3
                    }), Vi),
                    el = (e, t, o) => Ei((e => e.x + e.width)(e), qi(e, t), o.east(), Hi(), "east", Fi(e, {
                        left: 0
                    }), Vi),
                    tl = (e, t, o) => Ei(((e, t) => e.x - t.width)(e, t), qi(e, t), o.west(), Ii(), "west", Fi(e, {
                        right: 1
                    }), Vi),
                    ol = () => [Gi, Ki, Yi, Xi, Qi, Ji, el, tl],
                    nl = () => [Ki, Gi, Xi, Yi, Qi, Ji, el, tl],
                    rl = () => [Yi, Xi, Gi, Ki, Ji, Qi],
                    sl = () => [Xi, Yi, Ki, Gi, Ji, Qi],
                    al = () => [Gi, Ki, Yi, Xi, Qi, Ji],
                    il = () => [Ki, Gi, Xi, Yi, Qi, Ji];
                var ll = Object.freeze({
                        __proto__: null,
                        events: e => Ms([Ds(os(), ((t, o) => {
                            const n = e.channels,
                                r = ae(n),
                                s = o,
                                a = ((e, t) => t.universal ? e : Z(e, (e => L(t.channels, e))))(r, s);
                            F(a, (e => {
                                const o = n[e],
                                    r = o.schema,
                                    a = Zn("channel[" + e + "] data\nReceiver: " + Gs(t.element), r, s.data);
                                o.onReceive(t, a)
                            }))
                        }))])
                    }),
                    cl = [Kn("channels", zn(Xo.value, Sn([Si("onReceive"), ur("schema", An())])))];
                const dl = (e, t, o) => Us(((n, r) => {
                        o(n, e, t)
                    })),
                    ul = e => ({
                        key: e,
                        value: void 0
                    }),
                    ml = (e, t, o, n, r, s, a) => {
                        const i = e => ye(e, o) ? e[o]() : A.none(),
                            l = ce(r, ((e, t) => ((e, t, o) => ((e, t, o) => {
                                const n = o.toString(),
                                    r = n.indexOf(")") + 1,
                                    s = n.indexOf("("),
                                    a = n.substring(s + 1, r - 1).split(/,\s*/);
                                return e.toFunctionAnnotation = () => ({
                                    name: t,
                                    parameters: da(a.slice(0, 1).concat(a.slice(3)))
                                }), e
                            })(((n, ...r) => {
                                const s = [n].concat(r);
                                return n.config({
                                    name: y(e)
                                }).fold((() => {
                                    throw new Error("We could not find any behaviour configuration for: " + e + ". Using API: " + o)
                                }), (e => {
                                    const o = Array.prototype.slice.call(s, 1);
                                    return t.apply(void 0, [n, e.config, e.state].concat(o))
                                }))
                            }), o, t))(o, e, t))),
                            c = { ...ce(s, ((e, t) => ua(e, t))),
                                ...l,
                                revoke: C(ul, o),
                                config: t => {
                                    const n = Zn(o + "-config", e, t);
                                    return {
                                        key: o,
                                        value: {
                                            config: n,
                                            me: c,
                                            configAsRaw: Gt((() => Zn(o + "-config", e, t))),
                                            initialConfig: t,
                                            state: a
                                        }
                                    }
                                },
                                schema: y(t),
                                exhibit: (e, t) => Ce(i(e), ve(n, "exhibit"), ((e, o) => o(t, e.config, e.state))).getOrThunk((() => ya({}))),
                                name: y(o),
                                handlers: e => i(e).map((e => ve(n, "events").getOr((() => ({})))(e.config, e.state))).getOr({})
                            };
                        return c
                    },
                    gl = e => Sr(e),
                    hl = Sn([Gn("fields"), Gn("name"), ur("active", {}), ur("apis", {}), ur("state", fa), ur("extra", {})]),
                    pl = e => {
                        const t = Zn("Creating behaviour: " + e.name, hl, e);
                        return ((e, t, o, n, r, s) => {
                            const a = Sn(e),
                                i = dr(t, [("config", l = e, rr("config", Sn(l)))]);
                            var l;
                            return ml(a, i, t, o, n, r, s)
                        })(t.fields, t.name, t.active, t.apis, t.extra, t.state)
                    },
                    fl = Sn([Gn("branchKey"), Gn("branches"), Gn("name"), ur("active", {}), ur("apis", {}), ur("state", fa), ur("extra", {})]),
                    vl = e => {
                        const t = Zn("Creating behaviour: " + e.name, fl, e);
                        return ((e, t, o, n, r, s) => {
                            const a = e,
                                i = dr(t, [rr("config", e)]);
                            return ml(a, i, t, o, n, r, s)
                        })(jn(t.branchKey, t.branches), t.name, t.active, t.apis, t.extra, t.state)
                    },
                    bl = y(void 0),
                    yl = pl({
                        fields: cl,
                        name: "receiving",
                        active: ll
                    });
                var wl = Object.freeze({
                    __proto__: null,
                    exhibit: (e, t) => ya({
                        classes: [],
                        styles: t.useFixed() ? {} : {
                            position: "relative"
                        }
                    })
                });
                const xl = e => e.dom.focus(),
                    Cl = e => {
                        const t = dt(e).dom;
                        return e.dom === t.activeElement
                    },
                    Sl = (e = Vo()) => A.from(e.dom.activeElement).map(Be),
                    kl = e => Sl(dt(e)).filter((t => e.dom.contains(t.dom))),
                    _l = (e, t) => {
                        const o = dt(t),
                            n = Sl(o).bind((e => {
                                const o = t => Ge(e, t);
                                return o(t) ? A.some(t) : ((e, t) => {
                                    const o = e => {
                                        for (let n = 0; n < e.childNodes.length; n++) {
                                            const r = Be(e.childNodes[n]);
                                            if (t(r)) return A.some(r);
                                            const s = o(e.childNodes[n]);
                                            if (s.isSome()) return s
                                        }
                                        return A.none()
                                    };
                                    return o(e.dom)
                                })(t, o)
                            })),
                            r = e(t);
                        return n.each((e => {
                            Sl(o).filter((t => Ge(t, e))).fold((() => {
                                xl(e)
                            }), v)
                        })), r
                    },
                    Ol = (e, t, o, n, r) => {
                        const s = e => e + "px";
                        return {
                            position: e,
                            left: t.map(s),
                            top: o.map(s),
                            right: n.map(s),
                            bottom: r.map(s)
                        }
                    },
                    Tl = (e, t) => {
                        Et(e, (e => ({ ...e,
                            position: A.some(e.position)
                        }))(t))
                    },
                    El = xr([{
                        none: []
                    }, {
                        relative: ["x", "y", "width", "height"]
                    }, {
                        fixed: ["x", "y", "width", "height"]
                    }]),
                    Al = (e, t, o, n, r, s) => {
                        const a = t.rect,
                            i = a.x - o,
                            l = a.y - n,
                            c = r - (i + a.width),
                            d = s - (l + a.height),
                            u = A.some(i),
                            m = A.some(l),
                            g = A.some(c),
                            h = A.some(d),
                            p = A.none();
                        return t.direction.fold((() => Ol(e, u, m, p, p)), (() => Ol(e, p, m, g, p)), (() => Ol(e, u, p, p, h)), (() => Ol(e, p, p, g, h)), (() => Ol(e, u, m, p, p)), (() => Ol(e, u, p, p, h)), (() => Ol(e, u, m, p, p)), (() => Ol(e, p, m, g, p)))
                    },
                    Ml = (e, t) => e.fold((() => {
                        const e = t.rect;
                        return Ol("absolute", A.some(e.x), A.some(e.y), A.none(), A.none())
                    }), ((e, o, n, r) => Al("absolute", t, e, o, n, r)), ((e, o, n, r) => Al("fixed", t, e, o, n, r))),
                    Nl = (e, t) => {
                        const o = C(jo, t),
                            n = e.fold(o, o, (() => {
                                const e = Io();
                                return jo(t).translate(-e.left, -e.top)
                            })),
                            r = qt(t),
                            s = zt(t);
                        return Wo(n.left, n.top, r, s)
                    },
                    Rl = (e, t) => t.fold((() => e.fold(Go, Go, Wo)), (t => e.fold(t, t, (() => {
                        const o = t(),
                            n = Dl(e, o.x, o.y);
                        return Wo(n.left, n.top, o.width, o.height)
                    })))),
                    Dl = (e, t, o) => {
                        const n = Vt(t, o);
                        return e.fold(y(n), y(n), (() => {
                            const e = Io();
                            return n.translate(-e.left, -e.top)
                        }))
                    };
                El.none;
                const Bl = El.relative,
                    Ll = El.fixed,
                    Hl = "data-alloy-placement",
                    Il = e => xt(e, Hl),
                    Pl = xr([{
                        fit: ["reposition"]
                    }, {
                        nofit: ["reposition", "visibleW", "visibleH", "isVisible"]
                    }]),
                    zl = (e, t, o, n) => {
                        const r = e.bubble,
                            s = r.offset,
                            a = ((e, t, o) => {
                                const n = (n, r) => t[n].map((t => {
                                        const s = "top" === n || "bottom" === n,
                                            a = s ? o.top : o.left,
                                            i = ("left" === n || "top" === n ? Math.max : Math.min)(t, r) + a;
                                        return s ? zi(i, e.y, e.bottom) : zi(i, e.x, e.right)
                                    })).getOr(r),
                                    r = n("left", e.x),
                                    s = n("top", e.y),
                                    a = n("right", e.right),
                                    i = n("bottom", e.bottom);
                                return Wo(r, s, a - r, i - s)
                            })(n, e.restriction, s),
                            i = e.x + s.left,
                            l = e.y + s.top,
                            c = Wo(i, l, t, o),
                            {
                                originInBounds: d,
                                sizeInBounds: u,
                                visibleW: m,
                                visibleH: g
                            } = ((e, t) => {
                                const {
                                    x: o,
                                    y: n,
                                    right: r,
                                    bottom: s
                                } = t, {
                                    x: a,
                                    y: i,
                                    right: l,
                                    bottom: c,
                                    width: d,
                                    height: u
                                } = e;
                                return {
                                    originInBounds: a >= o && a <= r && i >= n && i <= s,
                                    sizeInBounds: l <= r && l >= o && c <= s && c >= n,
                                    visibleW: Math.min(d, a >= o ? r - a : l - o),
                                    visibleH: Math.min(u, i >= n ? s - i : c - n)
                                }
                            })(c, a),
                            h = d && u,
                            p = h ? c : ((e, t) => {
                                const {
                                    x: o,
                                    y: n,
                                    right: r,
                                    bottom: s
                                } = t, {
                                    x: a,
                                    y: i,
                                    width: l,
                                    height: c
                                } = e, d = Math.max(o, r - l), u = Math.max(n, s - c), m = zi(a, o, d), g = zi(i, n, u), h = Math.min(m + l, r) - m, p = Math.min(g + c, s) - g;
                                return Wo(m, g, h, p)
                            })(c, a),
                            f = p.width > 0 && p.height > 0,
                            {
                                maxWidth: v,
                                maxHeight: b
                            } = ((e, t, o) => {
                                const n = y(t.bottom - o.y),
                                    r = y(o.bottom - t.y),
                                    s = ((e, t, o, n) => e.fold(t, t, n, n, t, n, o, o))(e, r, r, n),
                                    a = y(t.right - o.x),
                                    i = y(o.right - t.x),
                                    l = ((e, t, o, n) => e.fold(t, n, t, n, o, o, t, n))(e, i, i, a);
                                return {
                                    maxWidth: l,
                                    maxHeight: s
                                }
                            })(e.direction, p, n),
                            w = {
                                rect: p,
                                maxHeight: b,
                                maxWidth: v,
                                direction: e.direction,
                                placement: e.placement,
                                classes: {
                                    on: r.classesOn,
                                    off: r.classesOff
                                },
                                layout: e.label,
                                testY: l
                            };
                        return h || e.alwaysFit ? Pl.fit(w) : Pl.nofit(w, m, g, f)
                    },
                    Fl = e => {
                        const t = wr(A.none()),
                            o = () => t.get().each(e);
                        return {
                            clear: () => {
                                o(), t.set(A.none())
                            },
                            isSet: () => t.get().isSome(),
                            get: () => t.get(),
                            set: e => {
                                o(), t.set(A.some(e))
                            }
                        }
                    },
                    Vl = () => Fl((e => e.unbind())),
                    Zl = () => {
                        const e = Fl(v);
                        return { ...e,
                            on: t => e.get().each(t)
                        }
                    },
                    Ul = T,
                    jl = (e, t, o) => ((e, t, o, n) => Eo(e, t, o, n, !1))(e, t, Ul, o),
                    Wl = (e, t, o) => ((e, t, o, n) => Eo(e, t, o, n, !0))(e, t, Ul, o),
                    $l = To,
                    ql = ["top", "bottom", "right", "left"],
                    Gl = "data-alloy-transition-timer",
                    Kl = (e, t, o, n, r, a) => {
                        const i = ((e, t, o) => o.exists((o => {
                            const n = e.mode;
                            return "all" === n || o[n] !== t[n]
                        })))(n, r, a);
                        if (i || ((e, t) => ((e, t) => K(t, (t => Da(e, t))))(e, t.classes))(e, n)) {
                            Ot(e, "position", o.position);
                            const a = Nl(t, e),
                                l = Ml(t, { ...r,
                                    rect: a
                                }),
                                c = J(ql, (e => l[e]));
                            ((e, t) => {
                                const o = e => parseFloat(e).toFixed(3);
                                return pe(t, ((t, n) => !((e, t, o = x) => Ce(e, t, o).getOr(e.isNone() && t.isNone()))(e[n].map(o), t.map(o)))).isSome()
                            })(o, c) && (Et(e, c), i && ((e, t) => {
                                Ba(e, t.classes), xt(e, Gl).each((t => {
                                    clearTimeout(parseInt(t, 10)), St(e, Gl)
                                })), ((e, t) => {
                                    const o = Vl(),
                                        n = Vl();
                                    let r;
                                    const a = t => {
                                            var o;
                                            const n = null !== (o = t.raw.pseudoElement) && void 0 !== o ? o : "";
                                            return Ge(t.target, e) && !Ee(n) && L(ql, t.raw.propertyName)
                                        },
                                        i = s => {
                                            if (m(s) || a(s)) {
                                                o.clear(), n.clear();
                                                const a = null == s ? void 0 : s.raw.type;
                                                (m(a) || a === Gr()) && (clearTimeout(r), St(e, Gl), La(e, t.classes))
                                            }
                                        },
                                        l = jl(e, Kr(), (t => {
                                            a(t) && (l.unbind(), o.set(jl(e, Gr(), i)), n.set(jl(e, qr(), i)))
                                        })),
                                        c = (e => {
                                            const t = t => {
                                                    const o = At(e, t).split(/\s*,\s*/);
                                                    return Z(o, Ee)
                                                },
                                                o = e => {
                                                    if (s(e) && /^[\d.]+/.test(e)) {
                                                        const t = parseFloat(e);
                                                        return Oe(e, "ms") ? t : 1e3 * t
                                                    }
                                                    return 0
                                                },
                                                n = t("transition-delay"),
                                                r = t("transition-duration");
                                            return j(r, ((e, t, r) => {
                                                const s = o(n[r]) + o(t);
                                                return Math.max(e, s)
                                            }), 0)
                                        })(e);
                                    requestAnimationFrame((() => {
                                        r = setTimeout(i, c + 17), bt(e, Gl, r)
                                    }))
                                })(e, t)
                            })(e, n), Lt(e))
                        } else La(e, n.classes)
                    },
                    Yl = (e, t) => {
                        ((e, t) => {
                            const o = It.max(e, t, ["margin-top", "border-top-width", "padding-top", "padding-bottom", "border-bottom-width", "margin-bottom"]);
                            Ot(e, "max-height", o + "px")
                        })(e, Math.floor(t))
                    },
                    Xl = y(((e, t) => {
                        Yl(e, t), Tt(e, {
                            "overflow-x": "hidden",
                            "overflow-y": "auto"
                        })
                    })),
                    Jl = y(((e, t) => {
                        Yl(e, t)
                    })),
                    Ql = (e, t, o) => void 0 === e[t] ? o : e[t],
                    ec = (e, t, o, n) => {
                        const r = ((e, t, o, n) => {
                            Bt(t, "max-height"), Bt(t, "max-width");
                            const r = {
                                width: qt(s = t),
                                height: zt(s)
                            };
                            var s;
                            return ((e, t, o, n, r, s) => {
                                const a = n.width,
                                    i = n.height,
                                    l = (t, l, c, d, u) => {
                                        const m = t(o, n, r, e, s),
                                            g = zl(m, a, i, s);
                                        return g.fold(y(g), ((e, t, o, n) => (u === n ? o > d || t > c : !u && n) ? g : Pl.nofit(l, c, d, u)))
                                    };
                                return j(t, ((e, t) => {
                                    const o = C(l, t);
                                    return e.fold(y(e), o)
                                }), Pl.nofit({
                                    rect: o,
                                    maxHeight: n.height,
                                    maxWidth: n.width,
                                    direction: Mi(),
                                    placement: "southeast",
                                    classes: {
                                        on: [],
                                        off: []
                                    },
                                    layout: "none",
                                    testY: o.y
                                }, -1, -1, !1)).fold(w, w)
                            })(t, n.preference, e, r, o, n.bounds)
                        })(e, t, o, n);
                        return ((e, t, o) => {
                            const n = Ml(o.origin, t);
                            o.transition.each((r => {
                                Kl(e, o.origin, n, r, t, o.lastPlacement)
                            })), Tl(e, n)
                        })(t, r, n), ((e, t) => {
                            ((e, t) => {
                                bt(e, Hl, t)
                            })(e, t.placement)
                        })(t, r), ((e, t) => {
                            const o = t.classes;
                            La(e, o.off), Ba(e, o.on)
                        })(t, r), ((e, t, o) => {
                            (0, o.maxHeightFunction)(e, t.maxHeight)
                        })(t, r, n), ((e, t, o) => {
                            (0, o.maxWidthFunction)(e, t.maxWidth)
                        })(t, r, n), {
                            layout: r.layout,
                            placement: r.placement
                        }
                    },
                    tc = ["valignCentre", "alignLeft", "alignRight", "alignCentre", "top", "bottom", "left", "right", "inset"],
                    oc = (e, t, o, n = 1) => {
                        const r = e * n,
                            s = t * n,
                            a = e => ve(o, e).getOr([]),
                            i = (e, t, o) => {
                                const n = X(tc, o);
                                return {
                                    offset: Vt(e, t),
                                    classesOn: G(o, a),
                                    classesOff: G(n, a)
                                }
                            };
                        return {
                            southeast: () => i(-e, t, ["top", "alignLeft"]),
                            southwest: () => i(e, t, ["top", "alignRight"]),
                            south: () => i(-e / 2, t, ["top", "alignCentre"]),
                            northeast: () => i(-e, -t, ["bottom", "alignLeft"]),
                            northwest: () => i(e, -t, ["bottom", "alignRight"]),
                            north: () => i(-e / 2, -t, ["bottom", "alignCentre"]),
                            east: () => i(e, -t / 2, ["valignCentre", "left"]),
                            west: () => i(-e, -t / 2, ["valignCentre", "right"]),
                            insetNortheast: () => i(r, s, ["top", "alignLeft", "inset"]),
                            insetNorthwest: () => i(-r, s, ["top", "alignRight", "inset"]),
                            insetNorth: () => i(-r / 2, s, ["top", "alignCentre", "inset"]),
                            insetSoutheast: () => i(r, -s, ["bottom", "alignLeft", "inset"]),
                            insetSouthwest: () => i(-r, -s, ["bottom", "alignRight", "inset"]),
                            insetSouth: () => i(-r / 2, -s, ["bottom", "alignCentre", "inset"]),
                            insetEast: () => i(-r, -s / 2, ["valignCentre", "right", "inset"]),
                            insetWest: () => i(r, -s / 2, ["valignCentre", "left", "inset"])
                        }
                    },
                    nc = () => oc(0, 0, {}),
                    rc = w,
                    sc = (e, t) => o => "rtl" === ac(o) ? t : e,
                    ac = e => "rtl" === At(e, "direction") ? "rtl" : "ltr";
                var ic;
                ! function(e) {
                    e.TopToBottom = "toptobottom", e.BottomToTop = "bottomtotop"
                }(ic || (ic = {}));
                const lc = "data-alloy-vertical-dir",
                    cc = e => ti(e, (e => Ve(e) && wt(e, "data-alloy-vertical-dir") === ic.BottomToTop)),
                    dc = () => dr("layouts", [Gn("onLtr"), Gn("onRtl"), nr("onBottomLtr"), nr("onBottomRtl")]),
                    uc = (e, t, o, n, r, s, a) => {
                        const i = a.map(cc).getOr(!1),
                            l = t.layouts.map((t => t.onLtr(e))),
                            c = t.layouts.map((t => t.onRtl(e))),
                            d = i ? t.layouts.bind((t => t.onBottomLtr.map((t => t(e))))).or(l).getOr(r) : l.getOr(o),
                            u = i ? t.layouts.bind((t => t.onBottomRtl.map((t => t(e))))).or(c).getOr(s) : c.getOr(n);
                        return sc(d, u)(e)
                    };
                var mc = [Gn("hotspot"), nr("bubble"), ur("overrides", {}), dc(), _i("placement", ((e, t, o) => {
                        const n = t.hotspot,
                            r = Nl(o, n.element),
                            s = uc(e.element, t, al(), il(), rl(), sl(), A.some(t.hotspot.element));
                        return A.some(rc({
                            anchorBox: r,
                            bubble: t.bubble.getOr(nc()),
                            overrides: t.overrides,
                            layouts: s,
                            placer: A.none()
                        }))
                    }))],
                    gc = [Gn("x"), Gn("y"), ur("height", 0), ur("width", 0), ur("bubble", nc()), ur("overrides", {}), dc(), _i("placement", ((e, t, o) => {
                        const n = Dl(o, t.x, t.y),
                            r = Wo(n.left, n.top, t.width, t.height),
                            s = uc(e.element, t, ol(), nl(), ol(), nl(), A.none());
                        return A.some(rc({
                            anchorBox: r,
                            bubble: t.bubble,
                            overrides: t.overrides,
                            layouts: s,
                            placer: A.none()
                        }))
                    }))];
                const hc = xr([{
                        screen: ["point"]
                    }, {
                        absolute: ["point", "scrollLeft", "scrollTop"]
                    }]),
                    pc = e => e.fold(w, ((e, t, o) => e.translate(-t, -o))),
                    fc = e => e.fold(w, w),
                    vc = e => j(e, ((e, t) => e.translate(t.left, t.top)), Vt(0, 0)),
                    bc = e => {
                        const t = z(e, fc);
                        return vc(t)
                    },
                    yc = hc.screen,
                    wc = hc.absolute,
                    xc = (e, t, o) => {
                        const n = Ye(e.element),
                            r = Io(n),
                            s = ((e, t, o) => {
                                const n = Qe(o.root).dom;
                                return A.from(n.frameElement).map(Be).filter((t => {
                                    const o = Ye(t),
                                        n = Ye(e.element);
                                    return Ge(o, n)
                                })).map(Ut)
                            })(e, 0, o).getOr(r);
                        return wc(s, r.left, r.top)
                    },
                    Cc = (e, t, o, n) => {
                        const r = yc(Vt(e, t));
                        return A.some(((e, t, o) => ({
                            point: e,
                            width: t,
                            height: o
                        }))(r, o, n))
                    },
                    Sc = (e, t, o, n, r) => e.map((e => {
                        const s = [t, e.point],
                            a = (i = () => bc(s), l = () => bc(s), c = () => (e => {
                                const t = z(e, pc);
                                return vc(t)
                            })(s), n.fold(i, l, c));
                        var i, l, c;
                        const d = (h = a.left, p = a.top, f = e.width, v = e.height, {
                                x: h,
                                y: p,
                                width: f,
                                height: v
                            }),
                            u = o.showAbove ? rl() : al(),
                            m = o.showAbove ? sl() : il(),
                            g = uc(r, o, u, m, u, m, A.none());
                        var h, p, f, v;
                        return rc({
                            anchorBox: d,
                            bubble: o.bubble.getOr(nc()),
                            overrides: o.overrides,
                            layouts: g,
                            placer: A.none()
                        })
                    }));
                var kc = [Gn("node"), Gn("root"), nr("bubble"), dc(), ur("overrides", {}), ur("showAbove", !1), _i("placement", ((e, t, o) => {
                    const n = xc(e, 0, t);
                    return t.node.filter(ht).bind((r => {
                        const s = r.dom.getBoundingClientRect(),
                            a = Cc(s.left, s.top, s.width, s.height),
                            i = t.node.getOr(e.element);
                        return Sc(a, n, t, o, i)
                    }))
                }))];
                const _c = (e, t, o, n) => ({
                        start: e,
                        soffset: t,
                        finish: o,
                        foffset: n
                    }),
                    Oc = xr([{
                        before: ["element"]
                    }, {
                        on: ["element", "offset"]
                    }, {
                        after: ["element"]
                    }]),
                    Tc = (Oc.before, Oc.on, Oc.after, e => e.fold(w, w, w)),
                    Ec = xr([{
                        domRange: ["rng"]
                    }, {
                        relative: ["startSitu", "finishSitu"]
                    }, {
                        exact: ["start", "soffset", "finish", "foffset"]
                    }]),
                    Ac = {
                        domRange: Ec.domRange,
                        relative: Ec.relative,
                        exact: Ec.exact,
                        exactFromRange: e => Ec.exact(e.start, e.soffset, e.finish, e.foffset),
                        getWin: e => {
                            const t = (e => e.match({
                                domRange: e => Be(e.startContainer),
                                relative: (e, t) => Tc(e),
                                exact: (e, t, o, n) => e
                            }))(e);
                            return Qe(t)
                        },
                        range: _c
                    },
                    Mc = (e, t, o) => {
                        const n = e.document.createRange();
                        var r;
                        return r = n, t.fold((e => {
                            r.setStartBefore(e.dom)
                        }), ((e, t) => {
                            r.setStart(e.dom, t)
                        }), (e => {
                            r.setStartAfter(e.dom)
                        })), ((e, t) => {
                            t.fold((t => {
                                e.setEndBefore(t.dom)
                            }), ((t, o) => {
                                e.setEnd(t.dom, o)
                            }), (t => {
                                e.setEndAfter(t.dom)
                            }))
                        })(n, o), n
                    },
                    Nc = (e, t, o, n, r) => {
                        const s = e.document.createRange();
                        return s.setStart(t.dom, o), s.setEnd(n.dom, r), s
                    },
                    Rc = e => ({
                        left: e.left,
                        top: e.top,
                        right: e.right,
                        bottom: e.bottom,
                        width: e.width,
                        height: e.height
                    }),
                    Dc = xr([{
                        ltr: ["start", "soffset", "finish", "foffset"]
                    }, {
                        rtl: ["start", "soffset", "finish", "foffset"]
                    }]),
                    Bc = (e, t, o) => t(Be(o.startContainer), o.startOffset, Be(o.endContainer), o.endOffset),
                    Lc = (e, t) => ((e, t) => {
                        const o = ((e, t) => t.match({
                            domRange: e => ({
                                ltr: y(e),
                                rtl: A.none
                            }),
                            relative: (t, o) => ({
                                ltr: Gt((() => Mc(e, t, o))),
                                rtl: Gt((() => A.some(Mc(e, o, t))))
                            }),
                            exact: (t, o, n, r) => ({
                                ltr: Gt((() => Nc(e, t, o, n, r))),
                                rtl: Gt((() => A.some(Nc(e, n, r, t, o))))
                            })
                        }))(e, t);
                        return ((e, t) => {
                            const o = t.ltr();
                            return o.collapsed ? t.rtl().filter((e => !1 === e.collapsed)).map((e => Dc.rtl(Be(e.endContainer), e.endOffset, Be(e.startContainer), e.startOffset))).getOrThunk((() => Bc(0, Dc.ltr, o))) : Bc(0, Dc.ltr, o)
                        })(0, o)
                    })(e, t).match({
                        ltr: (t, o, n, r) => {
                            const s = e.document.createRange();
                            return s.setStart(t.dom, o), s.setEnd(n.dom, r), s
                        },
                        rtl: (t, o, n, r) => {
                            const s = e.document.createRange();
                            return s.setStart(n.dom, r), s.setEnd(t.dom, o), s
                        }
                    });
                Dc.ltr, Dc.rtl;
                const Hc = (e, t) => ((e, t) => {
                        const o = void 0 === t ? document : t.dom;
                        return qe(o) ? [] : z(o.querySelectorAll(e), Be)
                    })(t, e),
                    Ic = e => {
                        if (e.rangeCount > 0) {
                            const t = e.getRangeAt(0),
                                o = e.getRangeAt(e.rangeCount - 1);
                            return A.some(_c(Be(t.startContainer), t.startOffset, Be(o.endContainer), o.endOffset))
                        }
                        return A.none()
                    },
                    Pc = e => {
                        if (null === e.anchorNode || null === e.focusNode) return Ic(e); {
                            const t = Be(e.anchorNode),
                                o = Be(e.focusNode);
                            return ((e, t, o, n) => {
                                const r = ((e, t, o, n) => {
                                        const r = Ye(e).dom.createRange();
                                        return r.setStart(e.dom, t), r.setEnd(o.dom, n), r
                                    })(e, t, o, n),
                                    s = Ge(e, o) && t === n;
                                return r.collapsed && !s
                            })(t, e.anchorOffset, o, e.focusOffset) ? A.some(_c(t, e.anchorOffset, o, e.focusOffset)) : Ic(e)
                        }
                    },
                    zc = (e, t) => (e => {
                        const t = e.getClientRects(),
                            o = t.length > 0 ? t[0] : e.getBoundingClientRect();
                        return o.width > 0 || o.height > 0 ? A.some(o).map(Rc) : A.none()
                    })(Lc(e, t)),
                    Fc = ((e, t) => {
                        const o = t => e(t) ? A.from(t.dom.nodeValue) : A.none();
                        return {
                            get: t => {
                                if (!e(t)) throw new Error("Can only get text value of a text node");
                                return o(t).getOr("")
                            },
                            getOption: o,
                            set: (t, o) => {
                                if (!e(t)) throw new Error("Can only set raw text value of a text node");
                                t.dom.nodeValue = o
                            }
                        }
                    })(Ze),
                    Vc = (e, t) => ({
                        element: e,
                        offset: t
                    }),
                    Zc = (e, t) => Ze(e) ? Vc(e, t) : ((e, t) => {
                        const o = nt(e);
                        if (0 === o.length) return Vc(e, t);
                        if (t < o.length) return Vc(o[t], 0); {
                            const e = o[o.length - 1],
                                t = Ze(e) ? (e => Fc.get(e))(e).length : nt(e).length;
                            return Vc(e, t)
                        }
                    })(e, t),
                    Uc = (e, t) => t.getSelection.getOrThunk((() => () => (e => (e => A.from(e.getSelection()))(e).filter((e => e.rangeCount > 0)).bind(Pc))(e)))().map((e => {
                        const t = Zc(e.start, e.soffset),
                            o = Zc(e.finish, e.foffset);
                        return Ac.range(t.element, t.offset, o.element, o.offset)
                    }));
                var jc = [nr("getSelection"), Gn("root"), nr("bubble"), dc(), ur("overrides", {}), ur("showAbove", !1), _i("placement", ((e, t, o) => {
                    const n = Qe(t.root).dom,
                        r = xc(e, 0, t),
                        s = Uc(n, t).bind((e => {
                            const t = ((e, t) => (e => {
                                const t = e.getBoundingClientRect();
                                return t.width > 0 || t.height > 0 ? A.some(t).map(Rc) : A.none()
                            })(Lc(e, t)))(n, Ac.exactFromRange(e)).orThunk((() => {
                                const t = De("\ufeff");
                                Mo(e.start, t);
                                const o = zc(n, Ac.exact(t, 0, t, 1));
                                return Ho(t), o
                            }));
                            return t.bind((e => Cc(e.left, e.top, e.width, e.height)))
                        })),
                        a = Uc(n, t).bind((e => Ve(e.start) ? A.some(e.start) : tt(e.start))).getOr(e.element);
                    return Sc(s, r, t, o, a)
                }))];
                const Wc = "link-layout",
                    $c = e => e.x + e.width,
                    qc = (e, t) => e.x - t.width,
                    Gc = (e, t) => e.y - t.height + e.height,
                    Kc = e => e.y,
                    Yc = (e, t, o) => Ei($c(e), Kc(e), o.southeast(), Mi(), "southeast", Fi(e, {
                        left: 0,
                        top: 2
                    }), Wc),
                    Xc = (e, t, o) => Ei(qc(e, t), Kc(e), o.southwest(), Ni(), "southwest", Fi(e, {
                        right: 1,
                        top: 2
                    }), Wc),
                    Jc = (e, t, o) => Ei($c(e), Gc(e, t), o.northeast(), Ri(), "northeast", Fi(e, {
                        left: 0,
                        bottom: 3
                    }), Wc),
                    Qc = (e, t, o) => Ei(qc(e, t), Gc(e, t), o.northwest(), Di(), "northwest", Fi(e, {
                        right: 1,
                        bottom: 3
                    }), Wc),
                    ed = () => [Yc, Xc, Jc, Qc],
                    td = () => [Xc, Yc, Qc, Jc];
                var od = [Gn("item"), dc(), ur("overrides", {}), _i("placement", ((e, t, o) => {
                        const n = Nl(o, t.item.element),
                            r = uc(e.element, t, ed(), td(), ed(), td(), A.none());
                        return A.some(rc({
                            anchorBox: n,
                            bubble: nc(),
                            overrides: t.overrides,
                            layouts: r,
                            placer: A.none()
                        }))
                    }))],
                    nd = jn("type", {
                        selection: jc,
                        node: kc,
                        hotspot: mc,
                        submenu: od,
                        makeshift: gc
                    });
                const rd = [or("classes", Rn), pr("mode", "all", ["all", "layout", "placement"])],
                    sd = [ur("useFixed", O), nr("getBounds")],
                    ad = [Kn("anchor", nd), dr("transition", rd)],
                    id = (e, t, o, n, r, s, a) => ((e, t, o, n, r, s, a, i) => {
                        const l = Ql(a, "maxHeightFunction", Xl()),
                            c = Ql(a, "maxWidthFunction", v),
                            d = e.anchorBox,
                            u = e.origin,
                            m = {
                                bounds: Rl(u, s),
                                origin: u,
                                preference: n,
                                maxHeightFunction: l,
                                maxWidthFunction: c,
                                lastPlacement: r,
                                transition: i
                            };
                        return ec(d, t, o, m)
                    })(((e, t) => ((e, t) => ({
                        anchorBox: e,
                        origin: t
                    }))(e, t))(o.anchorBox, t), r.element, o.bubble, o.layouts, s, n, o.overrides, a),
                    ld = (e, t, o, n, r, s) => {
                        const a = s.map($o);
                        return cd(e, t, o, n, r, a)
                    },
                    cd = (e, t, o, n, r, s) => {
                        const a = Zn("placement.info", kn(ad), r),
                            i = a.anchor,
                            l = n.element,
                            c = o.get(n.uid);
                        _l((() => {
                            Ot(l, "position", "fixed");
                            const r = Nt(l, "visibility");
                            Ot(l, "visibility", "hidden");
                            const d = t.useFixed() ? (() => {
                                    const e = document.documentElement;
                                    return Ll(0, 0, e.clientWidth, e.clientHeight)
                                })() : (e => {
                                    const t = Ut(e.element),
                                        o = e.element.dom.getBoundingClientRect();
                                    return Bl(t.left, t.top, o.width, o.height)
                                })(e),
                                u = i.placement,
                                m = s.map(y).or(t.getBounds);
                            u(e, i, d).each((t => {
                                const r = t.placer.getOr(id)(e, d, t, m, n, c, a.transition);
                                o.set(n.uid, r)
                            })), r.fold((() => {
                                Bt(l, "visibility")
                            }), (e => {
                                Ot(l, "visibility", e)
                            })), Nt(l, "left").isNone() && Nt(l, "top").isNone() && Nt(l, "right").isNone() && Nt(l, "bottom").isNone() && we(Nt(l, "position"), "fixed") && Bt(l, "position")
                        }), l)
                    };
                var dd = Object.freeze({
                    __proto__: null,
                    position: (e, t, o, n, r) => {
                        ld(e, t, o, n, r, A.none())
                    },
                    positionWithin: ld,
                    positionWithinBounds: cd,
                    getMode: (e, t, o) => t.useFixed() ? "fixed" : "absolute",
                    reset: (e, t, o, n) => {
                        const r = n.element;
                        F(["position", "left", "right", "top", "bottom"], (e => Bt(r, e))), (e => {
                            St(e, Hl)
                        })(r), o.clear(n.uid)
                    }
                });
                const ud = pl({
                        fields: sd,
                        name: "positioning",
                        active: wl,
                        apis: dd,
                        state: Object.freeze({
                            __proto__: null,
                            init: () => {
                                let e = {};
                                return va({
                                    readState: () => e,
                                    clear: t => {
                                        g(t) ? delete e[t] : e = {}
                                    },
                                    set: (t, o) => {
                                        e[t] = o
                                    },
                                    get: t => ve(e, t)
                                })
                            }
                        })
                    }),
                    md = e => e.getSystem().isConnected(),
                    gd = e => {
                        ks(e, ps());
                        const t = e.components();
                        F(t, gd)
                    },
                    hd = e => {
                        const t = e.components();
                        F(t, hd), ks(e, hs())
                    },
                    pd = (e, t) => {
                        e.getSystem().addToWorld(t), ht(e.element) && hd(t)
                    },
                    fd = e => {
                        gd(e), e.getSystem().removeFromWorld(e)
                    },
                    vd = (e, t) => {
                        Do(e.element, t.element)
                    },
                    bd = (e, t) => {
                        yd(e, t, Do)
                    },
                    yd = (e, t, o) => {
                        e.getSystem().addToWorld(t), o(e.element, t.element), ht(e.element) && hd(t), e.syncComponents()
                    },
                    wd = e => {
                        gd(e), Ho(e.element), e.getSystem().removeFromWorld(e)
                    },
                    xd = e => {
                        const t = et(e.element).bind((t => e.getSystem().getByDom(t).toOptional()));
                        wd(e), t.each((e => {
                            e.syncComponents()
                        }))
                    },
                    Cd = e => {
                        const t = e.components();
                        F(t, wd), Lo(e.element), e.syncComponents()
                    },
                    Sd = (e, t) => {
                        kd(e, t, Do)
                    },
                    kd = (e, t, o) => {
                        o(e, t.element);
                        const n = nt(t.element);
                        F(n, (e => {
                            t.getByDom(e).each(hd)
                        }))
                    },
                    _d = e => {
                        const t = nt(e.element);
                        F(t, (t => {
                            e.getByDom(t).each(gd)
                        })), Ho(e.element)
                    },
                    Od = (e, t, o, n) => {
                        o.get().each((t => {
                            Cd(e)
                        }));
                        const r = t.getAttachPoint(e);
                        bd(r, e);
                        const s = e.getSystem().build(n);
                        return bd(e, s), o.set(s), s
                    },
                    Td = (e, t, o, n) => {
                        const r = Od(e, t, o, n);
                        return t.onOpen(e, r), r
                    },
                    Ed = (e, t, o) => {
                        o.get().each((n => {
                            Cd(e), xd(e), t.onClose(e, n), o.clear()
                        }))
                    },
                    Ad = (e, t, o) => o.isOpen(),
                    Md = (e, t, o) => {
                        const n = t.getAttachPoint(e);
                        Ot(e.element, "position", ud.getMode(n)), ((e, t, o, n) => {
                            Nt(e.element, t).fold((() => {
                                St(e.element, o)
                            }), (t => {
                                bt(e.element, o, t)
                            })), Ot(e.element, t, "hidden")
                        })(e, "visibility", t.cloakVisibilityAttr)
                    },
                    Nd = (e, t, o) => {
                        (e => H(["top", "left", "right", "bottom"], (t => Nt(e, t).isSome())))(e.element) || Bt(e.element, "position"), ((e, t, o) => {
                            xt(e.element, o).fold((() => Bt(e.element, t)), (o => Ot(e.element, t, o)))
                        })(e, "visibility", t.cloakVisibilityAttr)
                    };
                var Rd = Object.freeze({
                        __proto__: null,
                        cloak: Md,
                        decloak: Nd,
                        open: Td,
                        openWhileCloaked: (e, t, o, n, r) => {
                            Md(e, t), Td(e, t, o, n), r(), Nd(e, t)
                        },
                        close: Ed,
                        isOpen: Ad,
                        isPartOf: (e, t, o, n) => Ad(0, 0, o) && o.get().exists((o => t.isPartOf(e, o, n))),
                        getState: (e, t, o) => o.get(),
                        setContent: (e, t, o, n) => o.get().map((() => Od(e, t, o, n)))
                    }),
                    Dd = Object.freeze({
                        __proto__: null,
                        events: (e, t) => Ms([Ds(is(), ((o, n) => {
                            Ed(o, e, t)
                        }))])
                    }),
                    Bd = [xi("onOpen"), xi("onClose"), Gn("isPartOf"), Gn("getAttachPoint"), ur("cloakVisibilityAttr", "data-precloak-visibility")],
                    Ld = Object.freeze({
                        __proto__: null,
                        init: () => {
                            const e = Zl(),
                                t = y("not-implemented");
                            return va({
                                readState: t,
                                isOpen: e.isSet,
                                clear: e.clear,
                                set: e.set,
                                get: e.get
                            })
                        }
                    });
                const Hd = pl({
                        fields: Bd,
                        name: "sandboxing",
                        active: Dd,
                        apis: Rd,
                        state: Ld
                    }),
                    Id = y("dismiss.popups"),
                    Pd = y("reposition.popups"),
                    zd = y("mouse.released"),
                    Fd = Sn([ur("isExtraPart", O), dr("fireEventInstead", [ur("event", fs())])]),
                    Vd = e => {
                        const t = Zn("Dismissal", Fd, e);
                        return {
                            [Id()]: {
                                schema: Sn([Gn("target")]),
                                onReceive: (e, o) => {
                                    Hd.isOpen(e) && (Hd.isPartOf(e, o.target) || t.isExtraPart(e, o.target) || t.fireEventInstead.fold((() => Hd.close(e)), (t => ks(e, t.event))))
                                }
                            }
                        }
                    },
                    Zd = Sn([dr("fireEventInstead", [ur("event", vs())]), Qn("doReposition")]),
                    Ud = e => {
                        const t = Zn("Reposition", Zd, e);
                        return {
                            [Pd()]: {
                                onReceive: e => {
                                    Hd.isOpen(e) && t.fireEventInstead.fold((() => t.doReposition(e)), (t => ks(e, t.event)))
                                }
                            }
                        }
                    },
                    jd = (e, t, o) => {
                        t.store.manager.onLoad(e, t, o)
                    },
                    Wd = (e, t, o) => {
                        t.store.manager.onUnload(e, t, o)
                    };
                var $d = Object.freeze({
                        __proto__: null,
                        onLoad: jd,
                        onUnload: Wd,
                        setValue: (e, t, o, n) => {
                            t.store.manager.setValue(e, t, o, n)
                        },
                        getValue: (e, t, o) => t.store.manager.getValue(e, t, o),
                        getState: (e, t, o) => o
                    }),
                    qd = Object.freeze({
                        __proto__: null,
                        events: (e, t) => {
                            const o = e.resetOnDom ? [Vs(((o, n) => {
                                jd(o, e, t)
                            })), Zs(((o, n) => {
                                Wd(o, e, t)
                            }))] : [dl(e, t, jd)];
                            return Ms(o)
                        }
                    });
                const Gd = () => {
                        const e = wr(null);
                        return va({
                            set: e.set,
                            get: e.get,
                            isNotSet: () => null === e.get(),
                            clear: () => {
                                e.set(null)
                            },
                            readState: () => ({
                                mode: "memory",
                                value: e.get()
                            })
                        })
                    },
                    Kd = () => {
                        const e = wr({}),
                            t = wr({});
                        return va({
                            readState: () => ({
                                mode: "dataset",
                                dataByValue: e.get(),
                                dataByText: t.get()
                            }),
                            lookup: o => ve(e.get(), o).orThunk((() => ve(t.get(), o))),
                            update: o => {
                                const n = e.get(),
                                    r = t.get(),
                                    s = {},
                                    a = {};
                                F(o, (e => {
                                    s[e.value] = e, ve(e, "meta").each((t => {
                                        ve(t, "text").each((t => {
                                            a[t] = e
                                        }))
                                    }))
                                })), e.set({ ...n,
                                    ...s
                                }), t.set({ ...r,
                                    ...a
                                })
                            },
                            clear: () => {
                                e.set({}), t.set({})
                            }
                        })
                    };
                var Yd = Object.freeze({
                    __proto__: null,
                    memory: Gd,
                    dataset: Kd,
                    manual: () => va({
                        readState: v
                    }),
                    init: e => e.store.manager.state(e)
                });
                const Xd = (e, t, o, n) => {
                    const r = t.store;
                    o.update([n]), r.setValue(e, n), t.onSetValue(e, n)
                };
                var Jd = [nr("initialValue"), Gn("getFallbackEntry"), Gn("getDataKey"), Gn("setValue"), _i("manager", {
                        setValue: Xd,
                        getValue: (e, t, o) => {
                            const n = t.store,
                                r = n.getDataKey(e);
                            return o.lookup(r).getOrThunk((() => n.getFallbackEntry(r)))
                        },
                        onLoad: (e, t, o) => {
                            t.store.initialValue.each((n => {
                                Xd(e, t, o, n)
                            }))
                        },
                        onUnload: (e, t, o) => {
                            o.clear()
                        },
                        state: Kd
                    })],
                    Qd = [Gn("getValue"), ur("setValue", v), nr("initialValue"), _i("manager", {
                        setValue: (e, t, o, n) => {
                            t.store.setValue(e, n), t.onSetValue(e, n)
                        },
                        getValue: (e, t, o) => t.store.getValue(e),
                        onLoad: (e, t, o) => {
                            t.store.initialValue.each((o => {
                                t.store.setValue(e, o)
                            }))
                        },
                        onUnload: v,
                        state: fa.init
                    })],
                    eu = [nr("initialValue"), _i("manager", {
                        setValue: (e, t, o, n) => {
                            o.set(n), t.onSetValue(e, n)
                        },
                        getValue: (e, t, o) => o.get(),
                        onLoad: (e, t, o) => {
                            t.store.initialValue.each((e => {
                                o.isNotSet() && o.set(e)
                            }))
                        },
                        onUnload: (e, t, o) => {
                            o.clear()
                        },
                        state: Gd
                    })],
                    tu = [mr("store", {
                        mode: "memory"
                    }, jn("mode", {
                        memory: eu,
                        manual: Qd,
                        dataset: Jd
                    })), xi("onSetValue"), ur("resetOnDom", !1)];
                const ou = pl({
                        fields: tu,
                        name: "representing",
                        active: qd,
                        apis: $d,
                        extra: {
                            setValueFrom: (e, t) => {
                                const o = ou.getValue(t);
                                ou.setValue(e, o)
                            }
                        },
                        state: Yd
                    }),
                    nu = (e, t) => yr(e, {}, z(t, (t => {
                        return o = t.name(), n = "Cannot configure " + t.name() + " for " + e, Wn(o, o, {
                            tag: "option",
                            process: {}
                        }, vn((e => nn("The field: " + o + " is forbidden. " + n))));
                        var o, n
                    })).concat([$n("dump", w)])),
                    ru = e => e.dump,
                    su = (e, t) => ({ ...gl(t),
                        ...e.dump
                    }),
                    au = nu,
                    iu = su,
                    lu = "placeholder",
                    cu = xr([{
                        single: ["required", "valueThunk"]
                    }, {
                        multiple: ["required", "valueThunks"]
                    }]),
                    du = e => be(e, "uiType"),
                    uu = (e, t, o, n) => ((e, t, o, n) => du(o) && o.uiType === lu ? ((e, t, o, n) => e.exists((e => e !== o.owner)) ? cu.single(!0, y(o)) : ve(n, o.name).fold((() => {
                        throw new Error("Unknown placeholder component: " + o.name + "\nKnown: [" + ae(n) + "]\nNamespace: " + e.getOr("none") + "\nSpec: " + JSON.stringify(o, null, 2))
                    }), (e => e.replace())))(e, 0, o, n) : cu.single(!1, y(o)))(e, 0, o, n).fold(((r, s) => {
                        const a = du(o) ? s(t, o.config, o.validated) : s(t),
                            i = ve(a, "components").getOr([]),
                            l = G(i, (o => uu(e, t, o, n)));
                        return [{ ...a,
                            components: l
                        }]
                    }), ((e, n) => {
                        if (du(o)) {
                            const e = n(t, o.config, o.validated);
                            return o.validated.preprocess.getOr(w)(e)
                        }
                        return n(t)
                    })),
                    mu = cu.single,
                    gu = cu.multiple,
                    hu = y(lu),
                    pu = xr([{
                        required: ["data"]
                    }, {
                        external: ["data"]
                    }, {
                        optional: ["data"]
                    }, {
                        group: ["data"]
                    }]),
                    fu = ur("factory", {
                        sketch: w
                    }),
                    vu = ur("schema", []),
                    bu = Gn("name"),
                    yu = Wn("pname", "pname", un((e => "<alloy." + Qs(e.name) + ">")), An()),
                    wu = $n("schema", (() => [nr("preprocess")])),
                    xu = ur("defaults", y({})),
                    Cu = ur("overrides", y({})),
                    Su = kn([fu, vu, bu, yu, xu, Cu]),
                    ku = kn([fu, vu, bu, xu, Cu]),
                    _u = kn([fu, vu, bu, yu, xu, Cu]),
                    Ou = kn([fu, wu, bu, Gn("unit"), yu, xu, Cu]),
                    Tu = e => e.fold(A.some, A.none, A.some, A.some),
                    Eu = e => {
                        const t = e => e.name;
                        return e.fold(t, t, t, t)
                    },
                    Au = (e, t) => o => {
                        const n = Zn("Converting part type", t, o);
                        return e(n)
                    },
                    Mu = Au(pu.required, Su),
                    Nu = Au(pu.external, ku),
                    Ru = Au(pu.optional, _u),
                    Du = Au(pu.group, Ou),
                    Bu = y("entirety");
                var Lu = Object.freeze({
                    __proto__: null,
                    required: Mu,
                    external: Nu,
                    optional: Ru,
                    group: Du,
                    asNamedPart: Tu,
                    name: Eu,
                    asCommon: e => e.fold(w, w, w, w),
                    original: Bu
                });
                const Hu = (e, t, o, n) => cn(t.defaults(e, o, n), o, {
                        uid: e.partUids[t.name]
                    }, t.overrides(e, o, n)),
                    Iu = (e, t) => {
                        const o = {};
                        return F(t, (t => {
                            Tu(t).each((t => {
                                const n = Pu(e, t.pname);
                                o[t.name] = o => {
                                    const r = Zn("Part: " + t.name + " in " + e, kn(t.schema), o);
                                    return { ...n,
                                        config: o,
                                        validated: r
                                    }
                                }
                            }))
                        })), o
                    },
                    Pu = (e, t) => ({
                        uiType: hu(),
                        owner: e,
                        name: t
                    }),
                    zu = (e, t, o) => ({
                        uiType: hu(),
                        owner: e,
                        name: t,
                        config: o,
                        validated: {}
                    }),
                    Fu = e => G(e, (e => e.fold(A.none, A.some, A.none, A.none).map((e => er(e.name, e.schema.concat([Oi(Bu())])))).toArray())),
                    Vu = e => z(e, Eu),
                    Zu = (e, t, o) => ((e, t, o) => {
                        const n = {},
                            r = {};
                        return F(o, (e => {
                            e.fold((e => {
                                n[e.pname] = mu(!0, ((t, o, n) => e.factory.sketch(Hu(t, e, o, n))))
                            }), (e => {
                                const o = t.parts[e.name];
                                r[e.name] = y(e.factory.sketch(Hu(t, e, o[Bu()]), o))
                            }), (e => {
                                n[e.pname] = mu(!1, ((t, o, n) => e.factory.sketch(Hu(t, e, o, n))))
                            }), (e => {
                                n[e.pname] = gu(!0, ((t, o, n) => {
                                    const r = t[e.name];
                                    return z(r, (o => e.factory.sketch(cn(e.defaults(t, o, n), o, e.overrides(t, o)))))
                                }))
                            }))
                        })), {
                            internals: y(n),
                            externals: y(r)
                        }
                    })(0, t, o),
                    Uu = (e, t, o) => ((e, t, o, n) => {
                        const r = ce(n, ((e, t) => ((e, t) => {
                                let o = !1;
                                return {
                                    name: y(e),
                                    required: () => t.fold(((e, t) => e), ((e, t) => e)),
                                    used: () => o,
                                    replace: () => {
                                        if (o) throw new Error("Trying to use the same placeholder more than once: " + e);
                                        return o = !0, t
                                    }
                                }
                            })(t, e))),
                            s = ((e, t, o, n) => G(o, (o => uu(e, t, o, n))))(e, t, o, r);
                        return le(r, (o => {
                            if (!1 === o.used() && o.required()) throw new Error("Placeholder: " + o.name() + " was not found in components list\nNamespace: " + e.getOr("none") + "\nComponents: " + JSON.stringify(t.components, null, 2))
                        })), s
                    })(A.some(e), t, t.components, o),
                    ju = (e, t, o) => {
                        const n = t.partUids[o];
                        return e.getSystem().getByUid(n).toOptional()
                    },
                    Wu = (e, t, o) => ju(e, t, o).getOrDie("Could not find part: " + o),
                    $u = (e, t, o) => {
                        const n = {},
                            r = t.partUids,
                            s = e.getSystem();
                        return F(o, (e => {
                            n[e] = y(s.getByUid(r[e]))
                        })), n
                    },
                    qu = (e, t) => {
                        const o = e.getSystem();
                        return ce(t.partUids, ((e, t) => y(o.getByUid(e))))
                    },
                    Gu = e => ae(e.partUids),
                    Ku = (e, t, o) => {
                        const n = {},
                            r = t.partUids,
                            s = e.getSystem();
                        return F(o, (e => {
                            n[e] = y(s.getByUid(r[e]).getOrDie())
                        })), n
                    },
                    Yu = (e, t) => {
                        const o = Vu(t);
                        return Sr(z(o, (t => ({
                            key: t,
                            value: e + "-" + t
                        }))))
                    },
                    Xu = e => Wn("partUids", "partUids", gn((t => Yu(t.uid, e))), An());
                var Ju = Object.freeze({
                    __proto__: null,
                    generate: Iu,
                    generateOne: zu,
                    schemas: Fu,
                    names: Vu,
                    substitutes: Zu,
                    components: Uu,
                    defaultUids: Yu,
                    defaultUidsSchema: Xu,
                    getAllParts: qu,
                    getAllPartNames: Gu,
                    getPart: ju,
                    getPartOrDie: Wu,
                    getParts: $u,
                    getPartsOrDie: Ku
                });
                const Qu = (e, t, o, n, r) => {
                        const s = ((e, t) => (e.length > 0 ? [er("parts", e)] : []).concat([Gn("uid"), ur("dom", {}), ur("components", []), Oi("originalSpec"), ur("debug.sketcher", {})]).concat(t))(n, r);
                        return Zn(e + " [SpecSchema]", Sn(s.concat(t)), o)
                    },
                    em = (e, t, o, n, r) => {
                        const s = tm(r),
                            a = Fu(o),
                            i = Xu(o),
                            l = Qu(e, t, s, a, [i]),
                            c = Zu(0, l, o);
                        return n(l, Uu(e, l, c.internals()), s, c.externals())
                    },
                    tm = e => (e => be(e, "uid"))(e) ? e : { ...e,
                        uid: aa("uid")
                    },
                    om = Sn([Gn("name"), Gn("factory"), Gn("configFields"), ur("apis", {}), ur("extraApis", {})]),
                    nm = Sn([Gn("name"), Gn("factory"), Gn("configFields"), Gn("partFields"), ur("apis", {}), ur("extraApis", {})]),
                    rm = e => {
                        const t = Zn("Sketcher for " + e.name, om, e),
                            o = ce(t.apis, pa),
                            n = ce(t.extraApis, ((e, t) => ua(e, t)));
                        return {
                            name: t.name,
                            configFields: t.configFields,
                            sketch: e => ((e, t, o, n) => {
                                const r = tm(n);
                                return o(Qu(e, t, r, [], []), r)
                            })(t.name, t.configFields, t.factory, e),
                            ...o,
                            ...n
                        }
                    },
                    sm = e => {
                        const t = Zn("Sketcher for " + e.name, nm, e),
                            o = Iu(t.name, t.partFields),
                            n = ce(t.apis, pa),
                            r = ce(t.extraApis, ((e, t) => ua(e, t)));
                        return {
                            name: t.name,
                            partFields: t.partFields,
                            configFields: t.configFields,
                            sketch: e => em(t.name, t.configFields, t.partFields, t.factory, e),
                            parts: o,
                            ...n,
                            ...r
                        }
                    },
                    am = e => We("input")(e) && "radio" !== wt(e, "type") || We("textarea")(e);
                var im = Object.freeze({
                    __proto__: null,
                    getCurrent: (e, t, o) => t.find(e)
                });
                const lm = [Gn("find")],
                    cm = pl({
                        fields: lm,
                        name: "composing",
                        apis: im
                    }),
                    dm = ["input", "button", "textarea", "select"],
                    um = (e, t, o) => {
                        (t.disabled() ? vm : bm)(e, t)
                    },
                    mm = (e, t) => !0 === t.useNative && L(dm, ze(e.element)),
                    gm = e => {
                        bt(e.element, "disabled", "disabled")
                    },
                    hm = e => {
                        St(e.element, "disabled")
                    },
                    pm = e => {
                        bt(e.element, "aria-disabled", "true")
                    },
                    fm = e => {
                        bt(e.element, "aria-disabled", "false")
                    },
                    vm = (e, t, o) => {
                        t.disableClass.each((t => {
                            Na(e.element, t)
                        })), (mm(e, t) ? gm : pm)(e), t.onDisabled(e)
                    },
                    bm = (e, t, o) => {
                        t.disableClass.each((t => {
                            Ra(e.element, t)
                        })), (mm(e, t) ? hm : fm)(e), t.onEnabled(e)
                    },
                    ym = (e, t) => mm(e, t) ? (e => Ct(e.element, "disabled"))(e) : (e => "true" === wt(e.element, "aria-disabled"))(e);
                var wm = Object.freeze({
                        __proto__: null,
                        enable: bm,
                        disable: vm,
                        isDisabled: ym,
                        onLoad: um,
                        set: (e, t, o, n) => {
                            (n ? vm : bm)(e, t)
                        }
                    }),
                    xm = Object.freeze({
                        __proto__: null,
                        exhibit: (e, t) => ya({
                            classes: t.disabled() ? t.disableClass.toArray() : []
                        }),
                        events: (e, t) => Ms([Ns(ns(), ((t, o) => ym(t, e))), dl(e, t, um)])
                    }),
                    Cm = [vr("disabled", O), ur("useNative", !0), nr("disableClass"), xi("onDisabled"), xi("onEnabled")];
                const Sm = pl({
                        fields: Cm,
                        name: "disabling",
                        active: xm,
                        apis: wm
                    }),
                    km = (e, t, o, n) => {
                        const r = Hc(e.element, "." + t.highlightClass);
                        F(r, (o => {
                            H(n, (e => Ge(e.element, o))) || (Ra(o, t.highlightClass), e.getSystem().getByDom(o).each((o => {
                                t.onDehighlight(e, o), ks(o, Ss())
                            })))
                        }))
                    },
                    _m = (e, t, o, n) => {
                        km(e, t, 0, [n]), Om(e, t, o, n) || (Na(n.element, t.highlightClass), t.onHighlight(e, n), ks(n, Cs()))
                    },
                    Om = (e, t, o, n) => Da(n.element, t.highlightClass),
                    Tm = (e, t, o) => ri(e.element, "." + t.itemClass).bind((t => e.getSystem().getByDom(t).toOptional())),
                    Em = (e, t, o) => {
                        const n = Hc(e.element, "." + t.itemClass);
                        return (n.length > 0 ? A.some(n[n.length - 1]) : A.none()).bind((t => e.getSystem().getByDom(t).toOptional()))
                    },
                    Am = (e, t, o, n) => {
                        const r = Hc(e.element, "." + t.itemClass);
                        return $(r, (e => Da(e, t.highlightClass))).bind((t => {
                            const o = Pi(t, n, 0, r.length - 1);
                            return e.getSystem().getByDom(r[o]).toOptional()
                        }))
                    },
                    Mm = (e, t, o) => {
                        const n = Hc(e.element, "." + t.itemClass);
                        return xe(z(n, (t => e.getSystem().getByDom(t).toOptional())))
                    };
                var Nm = Object.freeze({
                        __proto__: null,
                        dehighlightAll: (e, t, o) => km(e, t, 0, []),
                        dehighlight: (e, t, o, n) => {
                            Om(e, t, o, n) && (Ra(n.element, t.highlightClass), t.onDehighlight(e, n), ks(n, Ss()))
                        },
                        highlight: _m,
                        highlightFirst: (e, t, o) => {
                            Tm(e, t).each((n => {
                                _m(e, t, o, n)
                            }))
                        },
                        highlightLast: (e, t, o) => {
                            Em(e, t).each((n => {
                                _m(e, t, o, n)
                            }))
                        },
                        highlightAt: (e, t, o, n) => {
                            ((e, t, o, n) => {
                                const r = Hc(e.element, "." + t.itemClass);
                                return A.from(r[n]).fold((() => Xo.error(new Error("No element found with index " + n))), e.getSystem().getByDom)
                            })(e, t, 0, n).fold((e => {
                                throw e
                            }), (n => {
                                _m(e, t, o, n)
                            }))
                        },
                        highlightBy: (e, t, o, n) => {
                            const r = Mm(e, t);
                            W(r, n).each((n => {
                                _m(e, t, o, n)
                            }))
                        },
                        isHighlighted: Om,
                        getHighlighted: (e, t, o) => ri(e.element, "." + t.highlightClass).bind((t => e.getSystem().getByDom(t).toOptional())),
                        getFirst: Tm,
                        getLast: Em,
                        getPrevious: (e, t, o) => Am(e, t, 0, -1),
                        getNext: (e, t, o) => Am(e, t, 0, 1),
                        getCandidates: Mm
                    }),
                    Rm = [Gn("highlightClass"), Gn("itemClass"), xi("onHighlight"), xi("onDehighlight")];
                const Dm = pl({
                        fields: Rm,
                        name: "highlighting",
                        apis: Nm
                    }),
                    Bm = [8],
                    Lm = [9],
                    Hm = [13],
                    Im = [27],
                    Pm = [32],
                    zm = [37],
                    Fm = [38],
                    Vm = [39],
                    Zm = [40],
                    Um = (e, t, o) => {
                        const n = Y(e.slice(0, t)),
                            r = Y(e.slice(t + 1));
                        return W(n.concat(r), o)
                    },
                    jm = (e, t, o) => {
                        const n = Y(e.slice(0, t));
                        return W(n, o)
                    },
                    Wm = (e, t, o) => {
                        const n = e.slice(0, t),
                            r = e.slice(t + 1);
                        return W(r.concat(n), o)
                    },
                    $m = (e, t, o) => {
                        const n = e.slice(t + 1);
                        return W(n, o)
                    },
                    qm = e => t => {
                        const o = t.raw;
                        return L(e, o.which)
                    },
                    Gm = e => t => K(e, (e => e(t))),
                    Km = e => !0 === e.raw.shiftKey,
                    Ym = e => !0 === e.raw.ctrlKey,
                    Xm = S(Km),
                    Jm = (e, t) => ({
                        matches: e,
                        classification: t
                    }),
                    Qm = (e, t, o) => {
                        t.exists((e => o.exists((t => Ge(t, e))))) || _s(e, bs(), {
                            prevFocus: t,
                            newFocus: o
                        })
                    },
                    eg = () => {
                        const e = e => kl(e.element);
                        return {
                            get: e,
                            set: (t, o) => {
                                const n = e(t);
                                t.getSystem().triggerFocus(o, t.element);
                                const r = e(t);
                                Qm(t, n, r)
                            }
                        }
                    },
                    tg = () => {
                        const e = e => Dm.getHighlighted(e).map((e => e.element));
                        return {
                            get: e,
                            set: (t, o) => {
                                const n = e(t);
                                t.getSystem().getByDom(o).fold(v, (e => {
                                    Dm.highlight(t, e)
                                }));
                                const r = e(t);
                                Qm(t, n, r)
                            }
                        }
                    };
                var og;
                ! function(e) {
                    e.OnFocusMode = "onFocus", e.OnEnterOrSpaceMode = "onEnterOrSpace", e.OnApiMode = "onApi"
                }(og || (og = {}));
                const ng = (e, t, o, n, r) => {
                        const s = (e, t, o, n, r) => {
                                return (s = o(e, t, n, r), a = t.event, W(s, (e => e.matches(a))).map((e => e.classification))).bind((o => o(e, t, n, r)));
                                var s, a
                            },
                            a = {
                                schema: () => e.concat([ur("focusManager", eg()), mr("focusInside", "onFocus", Pn((e => L(["onFocus", "onEnterOrSpace", "onApi"], e) ? Xo.value(e) : Xo.error("Invalid value for focusInside")))), _i("handler", a), _i("state", t), _i("sendFocusIn", r)]),
                                processKey: s,
                                toEvents: (e, t) => {
                                    const a = e.focusInside !== og.OnFocusMode ? A.none() : r(e).map((o => Ds(Qr(), ((n, r) => {
                                            o(n, e, t), r.stop()
                                        })))),
                                        i = [Ds(Zr(), ((n, a) => {
                                            s(n, a, o, e, t).fold((() => {
                                                ((o, n) => {
                                                    const s = qm(Pm.concat(Hm))(n.event);
                                                    e.focusInside === og.OnEnterOrSpaceMode && s && Tr(o, n) && r(e).each((r => {
                                                        r(o, e, t), n.stop()
                                                    }))
                                                })(n, a)
                                            }), (e => {
                                                a.stop()
                                            }))
                                        })), Ds(Ur(), ((o, r) => {
                                            s(o, r, n, e, t).each((e => {
                                                r.stop()
                                            }))
                                        }))];
                                    return Ms(a.toArray().concat(i))
                                }
                            };
                        return a
                    },
                    rg = e => {
                        const t = [nr("onEscape"), nr("onEnter"), ur("selector", '[data-alloy-tabstop="true"]:not(:disabled)'), ur("firstTabstop", 0), ur("useTabstopAt", T), nr("visibilitySelector")].concat([e]),
                            o = (e, t) => {
                                const o = e.visibilitySelector.bind((e => si(t, e))).getOr(t);
                                return Pt(o) > 0
                            },
                            n = (e, t, n) => {
                                ((e, t) => {
                                    const n = Hc(e.element, t.selector),
                                        r = Z(n, (e => o(t, e)));
                                    return A.from(r[t.firstTabstop])
                                })(e, t).each((o => {
                                    t.focusManager.set(e, o)
                                }))
                            },
                            r = (e, t, n, r) => {
                                const s = Hc(e.element, n.selector);
                                return ((e, t) => t.focusManager.get(e).bind((e => si(e, t.selector))))(e, n).bind((t => $(s, C(Ge, t)).bind((t => ((e, t, n, r, s) => s(t, n, (e => ((e, t) => o(e, t) && e.useTabstopAt(t))(r, e))).fold((() => r.cyclic ? A.some(!0) : A.none()), (t => (r.focusManager.set(e, t), A.some(!0)))))(e, s, t, n, r)))))
                            },
                            s = y([Jm(Gm([Km, qm(Lm)]), ((e, t, o) => {
                                const n = o.cyclic ? Um : jm;
                                return r(e, 0, o, n)
                            })), Jm(qm(Lm), ((e, t, o) => {
                                const n = o.cyclic ? Wm : $m;
                                return r(e, 0, o, n)
                            })), Jm(Gm([Xm, qm(Hm)]), ((e, t, o) => o.onEnter.bind((o => o(e, t)))))]),
                            a = y([Jm(qm(Im), ((e, t, o) => o.onEscape.bind((o => o(e, t)))))]);
                        return ng(t, fa.init, s, a, (() => A.some(n)))
                    };
                var sg = rg($n("cyclic", O)),
                    ag = rg($n("cyclic", T));
                const ig = (e, t, o) => am(o) && qm(Pm)(t.event) ? A.none() : ((e, t, o) => (Ts(e, o, ns()), A.some(!0)))(e, 0, o),
                    lg = (e, t) => A.some(!0),
                    cg = [ur("execute", ig), ur("useSpace", !1), ur("useEnter", !0), ur("useControlEnter", !1), ur("useDown", !1)],
                    dg = (e, t, o) => o.execute(e, t, e.element);
                var ug = ng(cg, fa.init, ((e, t, o, n) => {
                    const r = o.useSpace && !am(e.element) ? Pm : [],
                        s = o.useEnter ? Hm : [],
                        a = o.useDown ? Zm : [],
                        i = r.concat(s).concat(a);
                    return [Jm(qm(i), dg)].concat(o.useControlEnter ? [Jm(Gm([Ym, qm(Hm)]), dg)] : [])
                }), ((e, t, o, n) => o.useSpace && !am(e.element) ? [Jm(qm(Pm), lg)] : []), (() => A.none()));
                const mg = () => {
                    const e = Zl();
                    return va({
                        readState: () => e.get().map((e => ({
                            numRows: String(e.numRows),
                            numColumns: String(e.numColumns)
                        }))).getOr({
                            numRows: "?",
                            numColumns: "?"
                        }),
                        setGridSize: (t, o) => {
                            e.set({
                                numRows: t,
                                numColumns: o
                            })
                        },
                        getNumRows: () => e.get().map((e => e.numRows)),
                        getNumColumns: () => e.get().map((e => e.numColumns))
                    })
                };
                var gg = Object.freeze({
                    __proto__: null,
                    flatgrid: mg,
                    init: e => e.state(e)
                });
                const hg = e => (t, o, n, r) => {
                        const s = e(t.element);
                        return bg(s, t, o, n, r)
                    },
                    pg = (e, t) => {
                        const o = sc(e, t);
                        return hg(o)
                    },
                    fg = (e, t) => {
                        const o = sc(t, e);
                        return hg(o)
                    },
                    vg = e => (t, o, n, r) => bg(e, t, o, n, r),
                    bg = (e, t, o, n, r) => n.focusManager.get(t).bind((o => e(t.element, o, n, r))).map((e => (n.focusManager.set(t, e), !0))),
                    yg = vg,
                    wg = vg,
                    xg = vg,
                    Cg = e => !(e => e.offsetWidth <= 0 && e.offsetHeight <= 0)(e.dom),
                    Sg = (e, t, o) => {
                        const n = Hc(e, o);
                        return ((e, o) => $(e, (e => Ge(e, t))).map((t => ({
                            index: t,
                            candidates: e
                        }))))(Z(n, Cg))
                    },
                    kg = (e, t) => $(e, (e => Ge(t, e))),
                    _g = (e, t, o, n) => n(Math.floor(t / o), t % o).bind((t => {
                        const n = t.row * o + t.column;
                        return n >= 0 && n < e.length ? A.some(e[n]) : A.none()
                    })),
                    Og = (e, t, o, n, r) => _g(e, t, n, ((t, s) => {
                        const a = t === o - 1 ? e.length - t * n : n,
                            i = Pi(s, r, 0, a - 1);
                        return A.some({
                            row: t,
                            column: i
                        })
                    })),
                    Tg = (e, t, o, n, r) => _g(e, t, n, ((t, s) => {
                        const a = Pi(t, r, 0, o - 1),
                            i = a === o - 1 ? e.length - a * n : n,
                            l = zi(s, 0, i - 1);
                        return A.some({
                            row: a,
                            column: l
                        })
                    })),
                    Eg = [Gn("selector"), ur("execute", ig), Ci("onEscape"), ur("captureTab", !1), Ti()],
                    Ag = (e, t, o) => {
                        ri(e.element, t.selector).each((o => {
                            t.focusManager.set(e, o)
                        }))
                    },
                    Mg = e => (t, o, n, r) => Sg(t, o, n.selector).bind((t => e(t.candidates, t.index, r.getNumRows().getOr(n.initSize.numRows), r.getNumColumns().getOr(n.initSize.numColumns)))),
                    Ng = (e, t, o) => o.captureTab ? A.some(!0) : A.none(),
                    Rg = Mg(((e, t, o, n) => Og(e, t, o, n, -1))),
                    Dg = Mg(((e, t, o, n) => Og(e, t, o, n, 1))),
                    Bg = Mg(((e, t, o, n) => Tg(e, t, o, n, -1))),
                    Lg = Mg(((e, t, o, n) => Tg(e, t, o, n, 1))),
                    Hg = y([Jm(qm(zm), pg(Rg, Dg)), Jm(qm(Vm), fg(Rg, Dg)), Jm(qm(Fm), yg(Bg)), Jm(qm(Zm), wg(Lg)), Jm(Gm([Km, qm(Lm)]), Ng), Jm(Gm([Xm, qm(Lm)]), Ng), Jm(qm(Pm.concat(Hm)), ((e, t, o, n) => ((e, t) => t.focusManager.get(e).bind((e => si(e, t.selector))))(e, o).bind((n => o.execute(e, t, n)))))]),
                    Ig = y([Jm(qm(Im), ((e, t, o) => o.onEscape(e, t))), Jm(qm(Pm), lg)]);
                var Pg = ng(Eg, mg, Hg, Ig, (() => A.some(Ag)));
                const zg = (e, t, o, n) => {
                        const r = (e, t, o) => {
                            const s = Pi(t, n, 0, o.length - 1);
                            return s === e ? A.none() : (a = o[s], "button" === ze(a) && "disabled" === wt(a, "disabled") ? r(e, s, o) : A.from(o[s]));
                            var a
                        };
                        return Sg(e, o, t).bind((e => {
                            const t = e.index,
                                o = e.candidates;
                            return r(t, t, o)
                        }))
                    },
                    Fg = [Gn("selector"), ur("getInitial", A.none), ur("execute", ig), Ci("onEscape"), ur("executeOnMove", !1), ur("allowVertical", !0)],
                    Vg = (e, t, o) => ((e, t) => t.focusManager.get(e).bind((e => si(e, t.selector))))(e, o).bind((n => o.execute(e, t, n))),
                    Zg = (e, t, o) => {
                        t.getInitial(e).orThunk((() => ri(e.element, t.selector))).each((o => {
                            t.focusManager.set(e, o)
                        }))
                    },
                    Ug = (e, t, o) => zg(e, o.selector, t, -1),
                    jg = (e, t, o) => zg(e, o.selector, t, 1),
                    Wg = e => (t, o, n, r) => e(t, o, n, r).bind((() => n.executeOnMove ? Vg(t, o, n) : A.some(!0))),
                    $g = y([Jm(qm(Pm), lg), Jm(qm(Im), ((e, t, o) => o.onEscape(e, t)))]);
                var qg = ng(Fg, fa.init, ((e, t, o, n) => {
                    const r = zm.concat(o.allowVertical ? Fm : []),
                        s = Vm.concat(o.allowVertical ? Zm : []);
                    return [Jm(qm(r), Wg(pg(Ug, jg))), Jm(qm(s), Wg(fg(Ug, jg))), Jm(qm(Hm), Vg), Jm(qm(Pm), Vg)]
                }), $g, (() => A.some(Zg)));
                const Gg = (e, t, o) => A.from(e[t]).bind((e => A.from(e[o]).map((e => ({
                        rowIndex: t,
                        columnIndex: o,
                        cell: e
                    }))))),
                    Kg = (e, t, o, n) => {
                        const r = e[t].length,
                            s = Pi(o, n, 0, r - 1);
                        return Gg(e, t, s)
                    },
                    Yg = (e, t, o, n) => {
                        const r = Pi(o, n, 0, e.length - 1),
                            s = e[r].length,
                            a = zi(t, 0, s - 1);
                        return Gg(e, r, a)
                    },
                    Xg = (e, t, o, n) => {
                        const r = e[t].length,
                            s = zi(o + n, 0, r - 1);
                        return Gg(e, t, s)
                    },
                    Jg = (e, t, o, n) => {
                        const r = zi(o + n, 0, e.length - 1),
                            s = e[r].length,
                            a = zi(t, 0, s - 1);
                        return Gg(e, r, a)
                    },
                    Qg = [er("selectors", [Gn("row"), Gn("cell")]), ur("cycles", !0), ur("previousSelector", A.none), ur("execute", ig)],
                    eh = (e, t, o) => {
                        t.previousSelector(e).orThunk((() => {
                            const o = t.selectors;
                            return ri(e.element, o.cell)
                        })).each((o => {
                            t.focusManager.set(e, o)
                        }))
                    },
                    th = (e, t) => (o, n, r) => {
                        const s = r.cycles ? e : t;
                        return si(n, r.selectors.row).bind((e => {
                            const t = Hc(e, r.selectors.cell);
                            return kg(t, n).bind((t => {
                                const n = Hc(o, r.selectors.row);
                                return kg(n, e).bind((e => {
                                    const o = ((e, t) => z(e, (e => Hc(e, t.selectors.cell))))(n, r);
                                    return s(o, e, t).map((e => e.cell))
                                }))
                            }))
                        }))
                    },
                    oh = th(((e, t, o) => Kg(e, t, o, -1)), ((e, t, o) => Xg(e, t, o, -1))),
                    nh = th(((e, t, o) => Kg(e, t, o, 1)), ((e, t, o) => Xg(e, t, o, 1))),
                    rh = th(((e, t, o) => Yg(e, o, t, -1)), ((e, t, o) => Jg(e, o, t, -1))),
                    sh = th(((e, t, o) => Yg(e, o, t, 1)), ((e, t, o) => Jg(e, o, t, 1))),
                    ah = y([Jm(qm(zm), pg(oh, nh)), Jm(qm(Vm), fg(oh, nh)), Jm(qm(Fm), yg(rh)), Jm(qm(Zm), wg(sh)), Jm(qm(Pm.concat(Hm)), ((e, t, o) => kl(e.element).bind((n => o.execute(e, t, n)))))]),
                    ih = y([Jm(qm(Pm), lg)]);
                var lh = ng(Qg, fa.init, ah, ih, (() => A.some(eh)));
                const ch = [Gn("selector"), ur("execute", ig), ur("moveOnTab", !1)],
                    dh = (e, t, o) => o.focusManager.get(e).bind((n => o.execute(e, t, n))),
                    uh = (e, t, o) => {
                        ri(e.element, t.selector).each((o => {
                            t.focusManager.set(e, o)
                        }))
                    },
                    mh = (e, t, o) => zg(e, o.selector, t, -1),
                    gh = (e, t, o) => zg(e, o.selector, t, 1),
                    hh = y([Jm(qm(Fm), xg(mh)), Jm(qm(Zm), xg(gh)), Jm(Gm([Km, qm(Lm)]), ((e, t, o, n) => o.moveOnTab ? xg(mh)(e, t, o, n) : A.none())), Jm(Gm([Xm, qm(Lm)]), ((e, t, o, n) => o.moveOnTab ? xg(gh)(e, t, o, n) : A.none())), Jm(qm(Hm), dh), Jm(qm(Pm), dh)]),
                    ph = y([Jm(qm(Pm), lg)]);
                var fh = ng(ch, fa.init, hh, ph, (() => A.some(uh)));
                const vh = [Ci("onSpace"), Ci("onEnter"), Ci("onShiftEnter"), Ci("onLeft"), Ci("onRight"), Ci("onTab"), Ci("onShiftTab"), Ci("onUp"), Ci("onDown"), Ci("onEscape"), ur("stopSpaceKeyup", !1), nr("focusIn")];
                var bh = ng(vh, fa.init, ((e, t, o) => [Jm(qm(Pm), o.onSpace), Jm(Gm([Xm, qm(Hm)]), o.onEnter), Jm(Gm([Km, qm(Hm)]), o.onShiftEnter), Jm(Gm([Km, qm(Lm)]), o.onShiftTab), Jm(Gm([Xm, qm(Lm)]), o.onTab), Jm(qm(Fm), o.onUp), Jm(qm(Zm), o.onDown), Jm(qm(zm), o.onLeft), Jm(qm(Vm), o.onRight), Jm(qm(Pm), o.onSpace)]), ((e, t, o) => [...o.stopSpaceKeyup ? [Jm(qm(Pm), lg)] : [], Jm(qm(Im), o.onEscape)]), (e => e.focusIn));
                const yh = sg.schema(),
                    wh = ag.schema(),
                    xh = qg.schema(),
                    Ch = Pg.schema(),
                    Sh = lh.schema(),
                    kh = ug.schema(),
                    _h = fh.schema(),
                    Oh = bh.schema(),
                    Th = vl({
                        branchKey: "mode",
                        branches: Object.freeze({
                            __proto__: null,
                            acyclic: yh,
                            cyclic: wh,
                            flow: xh,
                            flatgrid: Ch,
                            matrix: Sh,
                            execution: kh,
                            menu: _h,
                            special: Oh
                        }),
                        name: "keying",
                        active: {
                            events: (e, t) => e.handler.toEvents(e, t)
                        },
                        apis: {
                            focusIn: (e, t, o) => {
                                t.sendFocusIn(t).fold((() => {
                                    e.getSystem().triggerFocus(e.element, e.element)
                                }), (n => {
                                    n(e, t, o)
                                }))
                            },
                            setGridSize: (e, t, o, n, r) => {
                                (e => ye(e, "setGridSize"))(o) ? o.setGridSize(n, r): console.error("Layout does not support setGridSize")
                            }
                        },
                        state: gg
                    }),
                    Eh = (e, t) => {
                        _l((() => {
                            ((e, t, o) => {
                                const n = e.components();
                                (e => {
                                    F(e.components(), (e => Ho(e.element))), Lo(e.element), e.syncComponents()
                                })(e);
                                const r = o(t),
                                    s = X(n, r);
                                F(s, (t => {
                                    gd(t), e.getSystem().removeFromWorld(t)
                                })), F(r, (t => {
                                    md(t) ? vd(e, t) : (e.getSystem().addToWorld(t), vd(e, t), ht(e.element) && hd(t))
                                })), e.syncComponents()
                            })(e, t, (() => z(t, e.getSystem().build)))
                        }), e.element)
                    },
                    Ah = (e, t) => {
                        _l((() => {
                            ((o, n, r) => {
                                const s = o.components(),
                                    a = G(n, (e => ha(e).toArray()));
                                F(s, (e => {
                                    L(a, e) || fd(e)
                                }));
                                const i = ((e, t, o) => za(e, t, ((t, n) => Fa(e, n, t, o))))(e.element, t, e.getSystem().buildOrPatch),
                                    l = X(s, i);
                                F(l, (e => {
                                    md(e) && fd(e)
                                })), F(i, (e => {
                                    md(e) || pd(o, e)
                                })), o.syncComponents()
                            })(e, t)
                        }), e.element)
                    },
                    Mh = (e, t, o, n) => {
                        fd(t);
                        const r = Fa(e.element, o, n, e.getSystem().buildOrPatch);
                        pd(e, r), e.syncComponents()
                    },
                    Nh = (e, t, o) => {
                        const n = e.getSystem().build(o);
                        yd(e, n, t)
                    },
                    Rh = (e, t, o, n) => {
                        xd(t), Nh(e, ((e, t) => ((e, t, o) => {
                            rt(e, o).fold((() => {
                                Do(e, t)
                            }), (e => {
                                Mo(e, t)
                            }))
                        })(e, t, o)), n)
                    },
                    Dh = (e, t) => e.components(),
                    Bh = (e, t, o, n, r) => {
                        const s = Dh(e);
                        return A.from(s[n]).map((o => (r.fold((() => xd(o)), (r => {
                            (t.reuseDom ? Mh : Rh)(e, o, n, r)
                        })), o)))
                    };
                var Lh = Object.freeze({
                    __proto__: null,
                    append: (e, t, o, n) => {
                        Nh(e, Do, n)
                    },
                    prepend: (e, t, o, n) => {
                        Nh(e, Ro, n)
                    },
                    remove: (e, t, o, n) => {
                        const r = Dh(e),
                            s = W(r, (e => Ge(n.element, e.element)));
                        s.each(xd)
                    },
                    replaceAt: Bh,
                    replaceBy: (e, t, o, n, r) => {
                        const s = Dh(e);
                        return $(s, n).bind((o => Bh(e, t, 0, o, r)))
                    },
                    set: (e, t, o, n) => (t.reuseDom ? Ah : Eh)(e, n),
                    contents: Dh
                });
                const Hh = pl({
                        fields: [fr("reuseDom", !0)],
                        name: "replacing",
                        apis: Lh
                    }),
                    Ih = (e, t) => {
                        const o = ((e, t) => {
                            const o = Ms(t);
                            return pl({
                                fields: [Gn("enabled")],
                                name: e,
                                active: {
                                    events: y(o)
                                }
                            })
                        })(e, t);
                        return {
                            key: e,
                            value: {
                                config: {},
                                me: o,
                                configAsRaw: y({}),
                                initialConfig: {},
                                state: fa
                            }
                        }
                    },
                    Ph = (e, t) => {
                        t.ignore || (xl(e.element), t.onFocus(e))
                    };
                var zh = Object.freeze({
                        __proto__: null,
                        focus: Ph,
                        blur: (e, t) => {
                            t.ignore || (e => {
                                e.dom.blur()
                            })(e.element)
                        },
                        isFocused: e => Cl(e.element)
                    }),
                    Fh = Object.freeze({
                        __proto__: null,
                        exhibit: (e, t) => {
                            const o = t.ignore ? {} : {
                                attributes: {
                                    tabindex: "-1"
                                }
                            };
                            return ya(o)
                        },
                        events: e => Ms([Ds(Qr(), ((t, o) => {
                            Ph(t, e), o.stop()
                        }))].concat(e.stopMousedown ? [Ds(Lr(), ((e, t) => {
                            t.event.prevent()
                        }))] : []))
                    }),
                    Vh = [xi("onFocus"), ur("stopMousedown", !1), ur("ignore", !1)];
                const Zh = pl({
                        fields: Vh,
                        name: "focusing",
                        active: Fh,
                        apis: zh
                    }),
                    Uh = (e, t, o, n) => {
                        const r = o.get();
                        o.set(n), ((e, t, o) => {
                            t.toggleClass.each((t => {
                                o.get() ? Na(e.element, t) : Ra(e.element, t)
                            }))
                        })(e, t, o), ((e, t, o) => {
                            const n = t.aria;
                            n.update(e, n, o.get())
                        })(e, t, o), r !== n && t.onToggled(e, n)
                    },
                    jh = (e, t, o) => {
                        Uh(e, t, o, !o.get())
                    },
                    Wh = (e, t, o) => {
                        Uh(e, t, o, t.selected)
                    };
                var $h = Object.freeze({
                        __proto__: null,
                        onLoad: Wh,
                        toggle: jh,
                        isOn: (e, t, o) => o.get(),
                        on: (e, t, o) => {
                            Uh(e, t, o, !0)
                        },
                        off: (e, t, o) => {
                            Uh(e, t, o, !1)
                        },
                        set: Uh
                    }),
                    qh = Object.freeze({
                        __proto__: null,
                        exhibit: () => ya({}),
                        events: (e, t) => {
                            const o = (n = e, r = t, s = jh, js((e => {
                                s(e, n, r)
                            })));
                            var n, r, s;
                            const a = dl(e, t, Wh);
                            return Ms(q([e.toggleOnExecute ? [o] : [],
                                [a]
                            ]))
                        }
                    });
                const Gh = (e, t, o) => {
                    bt(e.element, "aria-expanded", o)
                };
                var Kh = [ur("selected", !1), nr("toggleClass"), ur("toggleOnExecute", !0), xi("onToggled"), mr("aria", {
                    mode: "none"
                }, jn("mode", {
                    pressed: [ur("syncWithExpanded", !1), _i("update", ((e, t, o) => {
                        bt(e.element, "aria-pressed", o), t.syncWithExpanded && Gh(e, 0, o)
                    }))],
                    checked: [_i("update", ((e, t, o) => {
                        bt(e.element, "aria-checked", o)
                    }))],
                    expanded: [_i("update", Gh)],
                    selected: [_i("update", ((e, t, o) => {
                        bt(e.element, "aria-selected", o)
                    }))],
                    none: [_i("update", v)]
                }))];
                const Yh = pl({
                    fields: Kh,
                    name: "toggling",
                    active: qh,
                    apis: $h,
                    state: (!1, {
                        init: () => {
                            const e = wr(false);
                            return {
                                get: () => e.get(),
                                set: t => e.set(t),
                                clear: () => e.set(false),
                                readState: () => e.get()
                            }
                        }
                    })
                });
                const Xh = () => {
                        const e = (e, t) => {
                            t.stop(), Os(e)
                        };
                        return [Ds($r(), e), Ds(ss(), e), Ps(Nr()), Ps(Lr())]
                    },
                    Jh = e => Ms(q([e.map((e => js(((t, o) => {
                        e(t), o.stop()
                    })))).toArray(), Xh()])),
                    Qh = "alloy.item-hover",
                    ep = "alloy.item-focus",
                    tp = "alloy.item-toggled",
                    op = e => {
                        (kl(e.element).isNone() || Zh.isFocused(e)) && (Zh.isFocused(e) || Zh.focus(e), _s(e, Qh, {
                            item: e
                        }))
                    },
                    np = e => {
                        _s(e, ep, {
                            item: e
                        })
                    },
                    rp = y(Qh),
                    sp = y(ep),
                    ap = y(tp),
                    ip = e => e.toggling.map((e => e.exclusive ? "menuitemradio" : "menuitemcheckbox")).getOr("menuitem"),
                    lp = [Gn("data"), Gn("components"), Gn("dom"), ur("hasSubmenu", !1), nr("toggling"), au("itemBehaviours", [Yh, Zh, Th, ou]), ur("ignoreFocus", !1), ur("domModification", {}), _i("builder", (e => ({
                        dom: e.dom,
                        domModification: { ...e.domModification,
                            attributes: {
                                role: ip(e),
                                ...e.domModification.attributes,
                                "aria-haspopup": e.hasSubmenu,
                                ...e.hasSubmenu ? {
                                    "aria-expanded": !1
                                } : {}
                            }
                        },
                        behaviours: iu(e.itemBehaviours, [e.toggling.fold(Yh.revoke, (e => Yh.config((e => ({
                            aria: {
                                mode: "checked"
                            },
                            ...ge(e, ((e, t) => "exclusive" !== t)),
                            onToggled: (t, o) => {
                                h(e.onToggled) && e.onToggled(t, o), ((e, t) => {
                                    _s(e, tp, {
                                        item: e,
                                        state: t
                                    })
                                })(t, o)
                            }
                        }))(e)))), Zh.config({
                            ignore: e.ignoreFocus,
                            stopMousedown: e.ignoreFocus,
                            onFocus: e => {
                                np(e)
                            }
                        }), Th.config({
                            mode: "execution"
                        }), ou.config({
                            store: {
                                mode: "memory",
                                initialValue: e.data
                            }
                        }), Ih("item-type-events", [...Xh(), Ds(zr(), op), Ds(rs(), Zh.focus)])]),
                        components: e.components,
                        eventOrder: e.eventOrder
                    }))), ur("eventOrder", {})],
                    cp = [Gn("dom"), Gn("components"), _i("builder", (e => ({
                        dom: e.dom,
                        components: e.components,
                        events: Ms([zs(rs())])
                    })))],
                    dp = y("item-widget"),
                    up = y([Mu({
                        name: "widget",
                        overrides: e => ({
                            behaviours: gl([ou.config({
                                store: {
                                    mode: "manual",
                                    getValue: t => e.data,
                                    setValue: v
                                }
                            })])
                        })
                    })]),
                    mp = [Gn("uid"), Gn("data"), Gn("components"), Gn("dom"), ur("autofocus", !1), ur("ignoreFocus", !1), au("widgetBehaviours", [ou, Zh, Th]), ur("domModification", {}), Xu(up()), _i("builder", (e => {
                        const t = Zu(dp(), e, up()),
                            o = Uu(dp(), e, t.internals()),
                            n = t => ju(t, e, "widget").map((e => (Th.focusIn(e), e))),
                            r = (t, o) => am(o.event.target) ? A.none() : e.autofocus ? (o.setSource(t.element), A.none()) : A.none();
                        return {
                            dom: e.dom,
                            components: o,
                            domModification: e.domModification,
                            events: Ms([js(((e, t) => {
                                n(e).each((e => {
                                    t.stop()
                                }))
                            })), Ds(zr(), op), Ds(rs(), ((t, o) => {
                                e.autofocus ? n(t) : Zh.focus(t)
                            }))]),
                            behaviours: iu(e.widgetBehaviours, [ou.config({
                                store: {
                                    mode: "memory",
                                    initialValue: e.data
                                }
                            }), Zh.config({
                                ignore: e.ignoreFocus,
                                onFocus: e => {
                                    np(e)
                                }
                            }), Th.config({
                                mode: "special",
                                focusIn: e.autofocus ? e => {
                                    n(e)
                                } : bl(),
                                onLeft: r,
                                onRight: r,
                                onEscape: (t, o) => Zh.isFocused(t) || e.autofocus ? e.autofocus ? (o.setSource(t.element), A.none()) : A.none() : (Zh.focus(t), A.some(!0))
                            })])
                        }
                    }))],
                    gp = jn("type", {
                        widget: mp,
                        item: lp,
                        separator: cp
                    }),
                    hp = y([Du({
                        factory: {
                            sketch: e => {
                                const t = Zn("menu.spec item", gp, e);
                                return t.builder(t)
                            }
                        },
                        name: "items",
                        unit: "item",
                        defaults: (e, t) => be(t, "uid") ? t : { ...t,
                            uid: aa("item")
                        },
                        overrides: (e, t) => ({
                            type: t.type,
                            ignoreFocus: e.fakeFocus,
                            domModification: {
                                classes: [e.markers.item]
                            }
                        })
                    })]),
                    pp = y([Gn("value"), Gn("items"), Gn("dom"), Gn("components"), ur("eventOrder", {}), nu("menuBehaviours", [Dm, ou, cm, Th]), mr("movement", {
                        mode: "menu",
                        moveOnTab: !0
                    }, jn("mode", {
                        grid: [Ti(), _i("config", ((e, t) => ({
                            mode: "flatgrid",
                            selector: "." + e.markers.item,
                            initSize: {
                                numColumns: t.initSize.numColumns,
                                numRows: t.initSize.numRows
                            },
                            focusManager: e.focusManager
                        })))],
                        matrix: [_i("config", ((e, t) => ({
                            mode: "matrix",
                            selectors: {
                                row: t.rowSelector,
                                cell: "." + e.markers.item
                            },
                            previousSelector: t.previousSelector,
                            focusManager: e.focusManager
                        }))), Gn("rowSelector"), ur("previousSelector", A.none)],
                        menu: [ur("moveOnTab", !0), _i("config", ((e, t) => ({
                            mode: "menu",
                            selector: "." + e.markers.item,
                            moveOnTab: t.moveOnTab,
                            focusManager: e.focusManager
                        })))]
                    })), Kn("markers", fi()), ur("fakeFocus", !1), ur("focusManager", eg()), xi("onHighlight"), xi("onDehighlight")]),
                    fp = y("alloy.menu-focus"),
                    vp = sm({
                        name: "Menu",
                        configFields: pp(),
                        partFields: hp(),
                        factory: (e, t, o, n) => ({
                            uid: e.uid,
                            dom: e.dom,
                            markers: e.markers,
                            behaviours: su(e.menuBehaviours, [Dm.config({
                                highlightClass: e.markers.selectedItem,
                                itemClass: e.markers.item,
                                onHighlight: e.onHighlight,
                                onDehighlight: e.onDehighlight
                            }), ou.config({
                                store: {
                                    mode: "memory",
                                    initialValue: e.value
                                }
                            }), cm.config({
                                find: A.some
                            }), Th.config(e.movement.config(e, e.movement))]),
                            events: Ms([Ds(sp(), ((e, t) => {
                                const o = t.event;
                                e.getSystem().getByDom(o.target).each((o => {
                                    Dm.highlight(e, o), t.stop(), _s(e, fp(), {
                                        menu: e,
                                        item: o
                                    })
                                }))
                            })), Ds(rp(), ((e, t) => {
                                const o = t.event.item;
                                Dm.highlight(e, o)
                            })), Ds(ap(), ((e, t) => {
                                const {
                                    item: o,
                                    state: n
                                } = t.event;
                                n && "menuitemradio" === wt(o.element, "role") && ((e, t) => {
                                    const o = Hc(e.element, '[role="menuitemradio"][aria-checked="true"]');
                                    F(o, (o => {
                                        Ge(o, t.element) || e.getSystem().getByDom(o).each((e => {
                                            Yh.off(e)
                                        }))
                                    }))
                                })(e, o)
                            }))]),
                            components: t,
                            eventOrder: e.eventOrder,
                            domModification: {
                                attributes: {
                                    role: "menu"
                                }
                            }
                        })
                    }),
                    bp = (e, t, o, n) => ve(o, n).bind((n => ve(e, n).bind((n => {
                        const r = bp(e, t, o, n);
                        return A.some([n].concat(r))
                    })))).getOr([]),
                    yp = e => "prepared" === e.type ? A.some(e.menu) : A.none(),
                    wp = () => {
                        const e = wr({}),
                            t = wr({}),
                            o = wr({}),
                            n = Zl(),
                            r = wr({}),
                            s = e => a(e).bind(yp),
                            a = e => ve(t.get(), e),
                            i = t => ve(e.get(), t);
                        return {
                            setMenuBuilt: (e, o) => {
                                t.set({ ...t.get(),
                                    [e]: {
                                        type: "prepared",
                                        menu: o
                                    }
                                })
                            },
                            setContents: (s, a, i, l) => {
                                n.set(s), e.set(i), t.set(a), r.set(l);
                                const c = ((e, t) => {
                                    const o = {};
                                    le(e, ((e, t) => {
                                        F(e, (e => {
                                            o[e] = t
                                        }))
                                    }));
                                    const n = t,
                                        r = de(t, ((e, t) => ({
                                            k: e,
                                            v: t
                                        }))),
                                        s = ce(r, ((e, t) => [t].concat(bp(o, n, r, t))));
                                    return ce(o, (e => ve(s, e).getOr([e])))
                                })(l, i);
                                o.set(c)
                            },
                            expand: t => ve(e.get(), t).map((e => {
                                const n = ve(o.get(), t).getOr([]);
                                return [e].concat(n)
                            })),
                            refresh: e => ve(o.get(), e),
                            collapse: e => ve(o.get(), e).bind((e => e.length > 1 ? A.some(e.slice(1)) : A.none())),
                            lookupMenu: a,
                            lookupItem: i,
                            otherMenus: e => {
                                const t = r.get();
                                return X(ae(t), e)
                            },
                            getPrimary: () => n.get().bind(s),
                            getMenus: () => t.get(),
                            clear: () => {
                                e.set({}), t.set({}), o.set({}), n.clear()
                            },
                            isClear: () => n.get().isNone(),
                            getTriggeringPath: (t, r) => {
                                const a = Z(i(t).toArray(), (e => s(e).isSome()));
                                return ve(o.get(), t).bind((t => {
                                    const o = Y(a.concat(t));
                                    return (e => {
                                        const t = [];
                                        for (let o = 0; o < e.length; o++) {
                                            const n = e[o];
                                            if (!n.isSome()) return A.none();
                                            t.push(n.getOrDie())
                                        }
                                        return A.some(t)
                                    })(G(o, ((t, a) => ((t, o, n) => s(t).bind((r => (t => pe(e.get(), ((e, o) => e === t)))(t).bind((e => o(e).map((e => ({
                                        triggeredMenu: r,
                                        triggeringItem: e,
                                        triggeringPath: n
                                    }))))))))(t, r, o.slice(0, a + 1)).fold((() => we(n.get(), t) ? [] : [A.none()]), (e => [A.some(e)])))))
                                }))
                            }
                        }
                    },
                    xp = yp,
                    Cp = Qs("tiered-menu-item-highlight"),
                    Sp = Qs("tiered-menu-item-dehighlight");
                var kp;
                ! function(e) {
                    e[e.HighlightMenuAndItem = 0] = "HighlightMenuAndItem", e[e.HighlightJustMenu = 1] = "HighlightJustMenu", e[e.HighlightNone = 2] = "HighlightNone"
                }(kp || (kp = {}));
                const _p = y("collapse-item"),
                    Op = rm({
                        name: "TieredMenu",
                        configFields: [ki("onExecute"), ki("onEscape"), Si("onOpenMenu"), Si("onOpenSubmenu"), xi("onRepositionMenu"), xi("onCollapseMenu"), ur("highlightOnOpen", kp.HighlightMenuAndItem), er("data", [Gn("primary"), Gn("menus"), Gn("expansions")]), ur("fakeFocus", !1), xi("onHighlightItem"), xi("onDehighlightItem"), xi("onHover"), bi(), Gn("dom"), ur("navigateOnHover", !0), ur("stayInDom", !1), nu("tmenuBehaviours", [Th, Dm, cm, Hh]), ur("eventOrder", {})],
                        apis: {
                            collapseMenu: (e, t) => {
                                e.collapseMenu(t)
                            },
                            highlightPrimary: (e, t) => {
                                e.highlightPrimary(t)
                            },
                            repositionMenus: (e, t) => {
                                e.repositionMenus(t)
                            }
                        },
                        factory: (e, t) => {
                            const o = Zl(),
                                n = wp(),
                                r = e => ou.getValue(e).value,
                                s = t => ce(e.data.menus, ((e, t) => G(e.items, (e => "separator" === e.type ? [] : [e.data.value])))),
                                a = Dm.highlight,
                                i = (t, o) => {
                                    a(t, o), Dm.getHighlighted(o).orThunk((() => Dm.getFirst(o))).each((n => {
                                        e.fakeFocus ? Dm.highlight(o, n) : Ts(t, n.element, rs())
                                    }))
                                },
                                l = (e, t) => xe(z(t, (t => e.lookupMenu(t).bind((e => "prepared" === e.type ? A.some(e.menu) : A.none()))))),
                                c = (t, o, n) => {
                                    const r = l(o, o.otherMenus(n));
                                    F(r, (o => {
                                        La(o.element, [e.markers.backgroundMenu]), e.stayInDom || Hh.remove(t, o)
                                    }))
                                },
                                d = (t, n) => {
                                    const s = (t => o.get().getOrThunk((() => {
                                        const n = {},
                                            s = Hc(t.element, `.${e.markers.item}`),
                                            a = Z(s, (e => "true" === wt(e, "aria-haspopup")));
                                        return F(a, (e => {
                                            t.getSystem().getByDom(e).each((e => {
                                                const t = r(e);
                                                n[t] = e
                                            }))
                                        })), o.set(n), n
                                    })))(t);
                                    le(s, ((e, t) => {
                                        const o = L(n, t);
                                        bt(e.element, "aria-expanded", o)
                                    }))
                                },
                                u = (t, o, n) => A.from(n[0]).bind((r => o.lookupMenu(r).bind((r => {
                                    if ("notbuilt" === r.type) return A.none(); {
                                        const s = r.menu,
                                            a = l(o, n.slice(1));
                                        return F(a, (t => {
                                            Na(t.element, e.markers.backgroundMenu)
                                        })), ht(s.element) || Hh.append(t, Ya(s)), La(s.element, [e.markers.backgroundMenu]), i(t, s), c(t, o, n), A.some(s)
                                    }
                                }))));
                            let m;
                            ! function(e) {
                                e[e.HighlightSubmenu = 0] = "HighlightSubmenu", e[e.HighlightParent = 1] = "HighlightParent"
                            }(m || (m = {}));
                            const g = (t, o, s = m.HighlightSubmenu) => {
                                    if (o.hasConfigured(Sm) && Sm.isDisabled(o)) return A.some(o); {
                                        const a = r(o);
                                        return n.expand(a).bind((r => (d(t, r), A.from(r[0]).bind((a => n.lookupMenu(a).bind((i => {
                                            const l = ((e, t, o) => {
                                                if ("notbuilt" === o.type) {
                                                    const r = e.getSystem().build(o.nbMenu());
                                                    return n.setMenuBuilt(t, r), r
                                                }
                                                return o.menu
                                            })(t, a, i);
                                            return ht(l.element) || Hh.append(t, Ya(l)), e.onOpenSubmenu(t, o, l, Y(r)), s === m.HighlightSubmenu ? (Dm.highlightFirst(l), u(t, n, r)) : (Dm.dehighlightAll(l), A.some(o))
                                        })))))))
                                    }
                                },
                                h = (t, o) => {
                                    const s = r(o);
                                    return n.collapse(s).bind((r => (d(t, r), u(t, n, r).map((n => (e.onCollapseMenu(t, o, n), n))))))
                                },
                                p = t => (o, n) => si(n.getSource(), `.${e.markers.item}`).bind((e => o.getSystem().getByDom(e).toOptional().bind((e => t(o, e).map(T))))),
                                f = Ms([Ds(fp(), ((e, t) => {
                                    const o = t.event.item;
                                    n.lookupItem(r(o)).each((() => {
                                        const o = t.event.menu;
                                        Dm.highlight(e, o);
                                        const s = r(t.event.item);
                                        n.refresh(s).each((t => c(e, n, t)))
                                    }))
                                })), js(((t, o) => {
                                    const n = o.event.target;
                                    t.getSystem().getByDom(n).each((o => {
                                        0 === r(o).indexOf("collapse-item") && h(t, o), g(t, o, m.HighlightSubmenu).fold((() => {
                                            e.onExecute(t, o)
                                        }), v)
                                    }))
                                })), Vs(((t, o) => {
                                    (t => {
                                        const o = ((t, o, n) => ce(n, ((n, r) => {
                                                const s = () => vp.sketch({ ...n,
                                                    value: r,
                                                    markers: e.markers,
                                                    fakeFocus: e.fakeFocus,
                                                    onHighlight: (e, t) => {
                                                        _s(e, Cp, {
                                                            menuComp: e,
                                                            itemComp: t
                                                        })
                                                    },
                                                    onDehighlight: (e, t) => {
                                                        _s(e, Sp, {
                                                            menuComp: e,
                                                            itemComp: t
                                                        })
                                                    },
                                                    focusManager: e.fakeFocus ? tg() : eg()
                                                });
                                                return r === o ? {
                                                    type: "prepared",
                                                    menu: t.getSystem().build(s())
                                                } : {
                                                    type: "notbuilt",
                                                    nbMenu: s
                                                }
                                            })))(t, e.data.primary, e.data.menus),
                                            r = s();
                                        return n.setContents(e.data.primary, o, e.data.expansions, r), n.getPrimary()
                                    })(t).each((o => {
                                        Hh.append(t, Ya(o)), e.onOpenMenu(t, o), e.highlightOnOpen === kp.HighlightMenuAndItem ? i(t, o) : e.highlightOnOpen === kp.HighlightJustMenu && a(t, o)
                                    }))
                                })), Ds(Cp, ((t, o) => {
                                    e.onHighlightItem(t, o.event.menuComp, o.event.itemComp)
                                })), Ds(Sp, ((t, o) => {
                                    e.onDehighlightItem(t, o.event.menuComp, o.event.itemComp)
                                })), ...e.navigateOnHover ? [Ds(rp(), ((t, o) => {
                                    const s = o.event.item;
                                    ((e, t) => {
                                        const o = r(t);
                                        n.refresh(o).bind((t => (d(e, t), u(e, n, t))))
                                    })(t, s), g(t, s, m.HighlightParent), e.onHover(t, s)
                                }))] : []]),
                                b = e => Dm.getHighlighted(e).bind(Dm.getHighlighted),
                                y = {
                                    collapseMenu: e => {
                                        b(e).each((t => {
                                            h(e, t)
                                        }))
                                    },
                                    highlightPrimary: e => {
                                        n.getPrimary().each((t => {
                                            i(e, t)
                                        }))
                                    },
                                    repositionMenus: t => {
                                        const o = n.getPrimary().bind((e => b(t).bind((e => {
                                            const t = r(e),
                                                o = fe(n.getMenus()),
                                                s = xe(z(o, xp));
                                            return n.getTriggeringPath(t, (e => ((e, t, o) => se(t, (e => {
                                                if (!e.getSystem().isConnected()) return A.none();
                                                const t = Dm.getCandidates(e);
                                                return W(t, (e => r(e) === o))
                                            })))(0, s, e)))
                                        })).map((t => ({
                                            primary: e,
                                            triggeringPath: t
                                        })))));
                                        o.fold((() => {
                                            (e => A.from(e.components()[0]).filter((e => "menu" === wt(e.element, "role"))))(t).each((o => {
                                                e.onRepositionMenu(t, o, [])
                                            }))
                                        }), (({
                                            primary: o,
                                            triggeringPath: n
                                        }) => {
                                            e.onRepositionMenu(t, o, n)
                                        }))
                                    }
                                };
                            return {
                                uid: e.uid,
                                dom: e.dom,
                                markers: e.markers,
                                behaviours: su(e.tmenuBehaviours, [Th.config({
                                    mode: "special",
                                    onRight: p(((e, t) => am(t.element) ? A.none() : g(e, t, m.HighlightSubmenu))),
                                    onLeft: p(((e, t) => am(t.element) ? A.none() : h(e, t))),
                                    onEscape: p(((t, o) => h(t, o).orThunk((() => e.onEscape(t, o).map((() => t)))))),
                                    focusIn: (e, t) => {
                                        n.getPrimary().each((t => {
                                            Ts(e, t.element, rs())
                                        }))
                                    }
                                }), Dm.config({
                                    highlightClass: e.markers.selectedMenu,
                                    itemClass: e.markers.menu
                                }), cm.config({
                                    find: e => Dm.getHighlighted(e)
                                }), Hh.config({})]),
                                eventOrder: e.eventOrder,
                                apis: y,
                                events: f
                            }
                        },
                        extraApis: {
                            tieredData: (e, t, o) => ({
                                primary: e,
                                menus: t,
                                expansions: o
                            }),
                            singleData: (e, t) => ({
                                primary: e,
                                menus: Cr(e, t),
                                expansions: {}
                            }),
                            collapseItem: e => ({
                                value: Qs(_p()),
                                meta: {
                                    text: e
                                }
                            })
                        }
                    }),
                    Tp = rm({
                        name: "InlineView",
                        configFields: [Gn("lazySink"), xi("onShow"), xi("onHide"), lr("onEscape"), nu("inlineBehaviours", [Hd, ou, yl]), dr("fireDismissalEventInstead", [ur("event", fs())]), dr("fireRepositionEventInstead", [ur("event", vs())]), ur("getRelated", A.none), ur("isExtraPart", O), ur("eventOrder", A.none)],
                        factory: (e, t) => {
                            const o = (e, t, o, r) => {
                                    n(e, t, o, (() => r.map((e => $o(e)))))
                                },
                                n = (t, o, n, r) => {
                                    const s = e.lazySink(t).getOrDie();
                                    Hd.openWhileCloaked(t, o, (() => ud.positionWithinBounds(s, t, n, r()))), ou.setValue(t, A.some({
                                        mode: "position",
                                        config: n,
                                        getBounds: r
                                    }))
                                },
                                r = (t, o, n, r) => {
                                    const s = ((e, t, o, n, r) => {
                                        const s = () => e.lazySink(t),
                                            a = "horizontal" === n.type ? {
                                                layouts: {
                                                    onLtr: () => al(),
                                                    onRtl: () => il()
                                                }
                                            } : {},
                                            i = e => (e => 2 === e.length)(e) ? a : {};
                                        return Op.sketch({
                                            dom: {
                                                tag: "div"
                                            },
                                            data: n.data,
                                            markers: n.menu.markers,
                                            highlightOnOpen: n.menu.highlightOnOpen,
                                            fakeFocus: n.menu.fakeFocus,
                                            onEscape: () => (Hd.close(t), e.onEscape.map((e => e(t))), A.some(!0)),
                                            onExecute: () => A.some(!0),
                                            onOpenMenu: (e, t) => {
                                                ud.positionWithinBounds(s().getOrDie(), t, o, r())
                                            },
                                            onOpenSubmenu: (e, t, o, n) => {
                                                const r = s().getOrDie();
                                                ud.position(r, o, {
                                                    anchor: {
                                                        type: "submenu",
                                                        item: t,
                                                        ...i(n)
                                                    }
                                                })
                                            },
                                            onRepositionMenu: (e, t, n) => {
                                                const a = s().getOrDie();
                                                ud.positionWithinBounds(a, t, o, r()), F(n, (e => {
                                                    const t = i(e.triggeringPath);
                                                    ud.position(a, e.triggeredMenu, {
                                                        anchor: {
                                                            type: "submenu",
                                                            item: e.triggeringItem,
                                                            ...t
                                                        }
                                                    })
                                                }))
                                            }
                                        })
                                    })(e, t, o, n, r);
                                    Hd.open(t, s), ou.setValue(t, A.some({
                                        mode: "menu",
                                        menu: s
                                    }))
                                },
                                s = t => {
                                    Hd.isOpen(t) && ou.getValue(t).each((o => {
                                        switch (o.mode) {
                                            case "menu":
                                                Hd.getState(t).each(Op.repositionMenus);
                                                break;
                                            case "position":
                                                const n = e.lazySink(t).getOrDie();
                                                ud.positionWithinBounds(n, t, o.config, o.getBounds())
                                        }
                                    }))
                                },
                                a = {
                                    setContent: (e, t) => {
                                        Hd.setContent(e, t)
                                    },
                                    showAt: (e, t, n) => {
                                        o(e, t, n, A.none())
                                    },
                                    showWithin: o,
                                    showWithinBounds: n,
                                    showMenuAt: (e, t, o) => {
                                        r(e, t, o, A.none)
                                    },
                                    showMenuWithinBounds: r,
                                    hide: e => {
                                        Hd.isOpen(e) && (ou.setValue(e, A.none()), Hd.close(e))
                                    },
                                    getContent: e => Hd.getState(e),
                                    reposition: s,
                                    isOpen: Hd.isOpen
                                };
                            return {
                                uid: e.uid,
                                dom: e.dom,
                                behaviours: su(e.inlineBehaviours, [Hd.config({
                                    isPartOf: (t, o, n) => li(o, n) || ((t, o) => e.getRelated(t).exists((e => li(e, o))))(t, n),
                                    getAttachPoint: t => e.lazySink(t).getOrDie(),
                                    onOpen: t => {
                                        e.onShow(t)
                                    },
                                    onClose: t => {
                                        e.onHide(t)
                                    }
                                }), ou.config({
                                    store: {
                                        mode: "memory",
                                        initialValue: A.none()
                                    }
                                }), yl.config({
                                    channels: { ...Vd({
                                            isExtraPart: t.isExtraPart,
                                            ...e.fireDismissalEventInstead.map((e => ({
                                                fireEventInstead: {
                                                    event: e.event
                                                }
                                            }))).getOr({})
                                        }),
                                        ...Ud({ ...e.fireRepositionEventInstead.map((e => ({
                                                fireEventInstead: {
                                                    event: e.event
                                                }
                                            }))).getOr({}),
                                            doReposition: s
                                        })
                                    }
                                })]),
                                eventOrder: e.eventOrder,
                                apis: a
                            }
                        },
                        apis: {
                            showAt: (e, t, o, n) => {
                                e.showAt(t, o, n)
                            },
                            showWithin: (e, t, o, n, r) => {
                                e.showWithin(t, o, n, r)
                            },
                            showWithinBounds: (e, t, o, n, r) => {
                                e.showWithinBounds(t, o, n, r)
                            },
                            showMenuAt: (e, t, o, n) => {
                                e.showMenuAt(t, o, n)
                            },
                            showMenuWithinBounds: (e, t, o, n, r) => {
                                e.showMenuWithinBounds(t, o, n, r)
                            },
                            hide: (e, t) => {
                                e.hide(t)
                            },
                            isOpen: (e, t) => e.isOpen(t),
                            getContent: (e, t) => e.getContent(t),
                            setContent: (e, t, o) => {
                                e.setContent(t, o)
                            },
                            reposition: (e, t) => {
                                e.reposition(t)
                            }
                        }
                    });
                var Ep = tinymce.util.Tools.resolve("tinymce.util.Delay");
                const Ap = rm({
                        name: "Button",
                        factory: e => {
                            const t = Jh(e.action),
                                o = e.dom.tag,
                                n = t => ve(e.dom, "attributes").bind((e => ve(e, t)));
                            return {
                                uid: e.uid,
                                dom: e.dom,
                                components: e.components,
                                events: t,
                                behaviours: iu(e.buttonBehaviours, [Zh.config({}), Th.config({
                                    mode: "execution",
                                    useSpace: !0,
                                    useEnter: !0
                                })]),
                                domModification: {
                                    attributes: "button" === o ? {
                                        type: n("type").getOr("button"),
                                        ...n("role").map((e => ({
                                            role: e
                                        }))).getOr({})
                                    } : {
                                        role: n("role").getOr("button")
                                    }
                                },
                                eventOrder: e.eventOrder
                            }
                        },
                        configFields: [ur("uid", void 0), Gn("dom"), ur("components", []), au("buttonBehaviours", [Zh, Th]), nr("action"), nr("role"), ur("eventOrder", {})]
                    }),
                    Mp = e => {
                        const t = (e => void 0 !== e.uid)(e) && ye(e, "uid") ? e.uid : aa("memento");
                        return {
                            get: e => e.getSystem().getByUid(t).getOrDie(),
                            getOpt: e => e.getSystem().getByUid(t).toOptional(),
                            asSpec: () => ({ ...e,
                                uid: t
                            })
                        }
                    };
                var Np = tinymce.util.Tools.resolve("tinymce.util.I18n");
                const Rp = {
                        indent: !0,
                        outdent: !0,
                        "table-insert-column-after": !0,
                        "table-insert-column-before": !0,
                        "paste-column-after": !0,
                        "paste-column-before": !0,
                        "unordered-list": !0,
                        "list-bull-circle": !0,
                        "list-bull-default": !0,
                        "list-bull-square": !0
                    },
                    Dp = "temporary-placeholder",
                    Bp = e => () => ve(e, Dp).getOr("!not found!"),
                    Lp = (e, t) => {
                        const o = e.toLowerCase();
                        if (Np.isRtl()) {
                            const e = ((e, t) => Oe(e, t) ? e : ((e, t) => e + t)(e, t))(o, "-rtl");
                            return be(t, e) ? e : o
                        }
                        return o
                    },
                    Hp = (e, t) => ve(t, Lp(e, t)),
                    Ip = (e, t) => {
                        const o = t();
                        return Hp(e, o).getOrThunk(Bp(o))
                    },
                    Pp = () => Ih("add-focusable", [Vs((e => {
                        ni(e.element, "svg").each((e => bt(e, "focusable", "false")))
                    }))]),
                    zp = (e, t, o, n) => {
                        var r, s;
                        const a = (e => !!Np.isRtl() && be(Rp, e))(t) ? ["tox-icon--flip"] : [],
                            i = ve(o, Lp(t, o)).or(n).getOrThunk(Bp(o));
                        return {
                            dom: {
                                tag: e.tag,
                                attributes: null !== (r = e.attributes) && void 0 !== r ? r : {},
                                classes: e.classes.concat(a),
                                innerHtml: i
                            },
                            behaviours: gl([...null !== (s = e.behaviours) && void 0 !== s ? s : [], Pp()])
                        }
                    },
                    Fp = (e, t, o, n = A.none()) => zp(t, e, o(), n),
                    Vp = {
                        success: "checkmark",
                        error: "warning",
                        err: "error",
                        warning: "warning",
                        warn: "warning",
                        info: "info"
                    },
                    Zp = rm({
                        name: "Notification",
                        factory: e => {
                            const t = Mp({
                                    dom: {
                                        tag: "p",
                                        innerHtml: e.translationProvider(e.text)
                                    },
                                    behaviours: gl([Hh.config({})])
                                }),
                                o = e => ({
                                    dom: {
                                        tag: "div",
                                        classes: ["tox-bar"],
                                        styles: {
                                            width: `${e}%`
                                        }
                                    }
                                }),
                                n = e => ({
                                    dom: {
                                        tag: "div",
                                        classes: ["tox-text"],
                                        innerHtml: `${e}%`
                                    }
                                }),
                                r = Mp({
                                    dom: {
                                        tag: "div",
                                        classes: e.progress ? ["tox-progress-bar", "tox-progress-indicator"] : ["tox-progress-bar"]
                                    },
                                    components: [{
                                        dom: {
                                            tag: "div",
                                            classes: ["tox-bar-container"]
                                        },
                                        components: [o(0)]
                                    }, n(0)],
                                    behaviours: gl([Hh.config({})])
                                }),
                                s = {
                                    updateProgress: (e, t) => {
                                        e.getSystem().isConnected() && r.getOpt(e).each((e => {
                                            Hh.set(e, [{
                                                dom: {
                                                    tag: "div",
                                                    classes: ["tox-bar-container"]
                                                },
                                                components: [o(t)]
                                            }, n(t)])
                                        }))
                                    },
                                    updateText: (e, o) => {
                                        if (e.getSystem().isConnected()) {
                                            const n = t.get(e);
                                            Hh.set(n, [Wa(o)])
                                        }
                                    }
                                },
                                a = q([e.icon.toArray(), e.level.toArray(), e.level.bind((e => A.from(Vp[e]))).toArray()]),
                                i = Mp(Ap.sketch({
                                    dom: {
                                        tag: "button",
                                        classes: ["tox-notification__dismiss", "tox-button", "tox-button--naked", "tox-button--icon"]
                                    },
                                    components: [Fp("close", {
                                        tag: "div",
                                        classes: ["tox-icon"],
                                        attributes: {
                                            "aria-label": e.translationProvider("Close")
                                        }
                                    }, e.iconProvider)],
                                    action: t => {
                                        e.onAction(t)
                                    }
                                })),
                                l = ((e, t, o) => {
                                    const n = o(),
                                        r = W(e, (e => be(n, Lp(e, n))));
                                    return zp({
                                        tag: "div",
                                        classes: ["tox-notification__icon"]
                                    }, r.getOr(Dp), n, A.none())
                                })(a, 0, e.iconProvider),
                                c = [l, {
                                    dom: {
                                        tag: "div",
                                        classes: ["tox-notification__body"]
                                    },
                                    components: [t.asSpec()],
                                    behaviours: gl([Hh.config({})])
                                }];
                            return {
                                uid: e.uid,
                                dom: {
                                    tag: "div",
                                    attributes: {
                                        role: "alert"
                                    },
                                    classes: e.level.map((e => ["tox-notification", "tox-notification--in", `tox-notification--${e}`])).getOr(["tox-notification", "tox-notification--in"])
                                },
                                behaviours: gl([Zh.config({}), Ih("notification-events", [Ds(Fr(), (e => {
                                    i.getOpt(e).each(Zh.focus)
                                }))])]),
                                components: c.concat(e.progress ? [r.asSpec()] : []).concat(e.closeButton ? [i.asSpec()] : []),
                                apis: s
                            }
                        },
                        configFields: [nr("level"), Gn("progress"), nr("icon"), Gn("onAction"), Gn("text"), Gn("iconProvider"), Gn("translationProvider"), fr("closeButton", !0)],
                        apis: {
                            updateProgress: (e, t, o) => {
                                e.updateProgress(t, o)
                            },
                            updateText: (e, t, o) => {
                                e.updateText(t, o)
                            }
                        }
                    });
                var Up, jp, Wp = tinymce.util.Tools.resolve("tinymce.dom.DOMUtils"),
                    $p = tinymce.util.Tools.resolve("tinymce.EditorManager"),
                    qp = tinymce.util.Tools.resolve("tinymce.Env");
                ! function(e) {
                    e.default = "wrap", e.floating = "floating", e.sliding = "sliding", e.scrolling = "scrolling"
                }(Up || (Up = {})),
                function(e) {
                    e.auto = "auto", e.top = "top", e.bottom = "bottom"
                }(jp || (jp = {}));
                const Gp = e => t => t.options.get(e),
                    Kp = e => t => A.from(e(t)),
                    Yp = e => {
                        const t = qp.deviceType.isPhone(),
                            o = qp.deviceType.isTablet() || t,
                            n = e.options.register,
                            r = e => s(e) || !1 === e,
                            a = e => s(e) || p(e);
                        n("skin", {
                            processor: e => s(e) || !1 === e,
                            default: "oxide"
                        }), n("skin_url", {
                            processor: "string"
                        }), n("height", {
                            processor: a,
                            default: Math.max(e.getElement().offsetHeight, 400)
                        }), n("width", {
                            processor: a,
                            default: Wp.DOM.getStyle(e.getElement(), "width")
                        }), n("min_height", {
                            processor: "number",
                            default: 100
                        }), n("min_width", {
                            processor: "number"
                        }), n("max_height", {
                            processor: "number"
                        }), n("max_width", {
                            processor: "number"
                        }), n("style_formats", {
                            processor: "object[]"
                        }), n("style_formats_merge", {
                            processor: "boolean",
                            default: !1
                        }), n("style_formats_autohide", {
                            processor: "boolean",
                            default: !1
                        }), n("line_height_formats", {
                            processor: "string",
                            default: "1 1.1 1.2 1.3 1.4 1.5 2"
                        }), n("font_family_formats", {
                            processor: "string",
                            default: "Andale Mono=andale mono,monospace;Arial=arial,helvetica,sans-serif;Arial Black=arial black,sans-serif;Book Antiqua=book antiqua,palatino,serif;Comic Sans MS=comic sans ms,sans-serif;Courier New=courier new,courier,monospace;Georgia=georgia,palatino,serif;Helvetica=helvetica,arial,sans-serif;Impact=impact,sans-serif;Symbol=symbol;Tahoma=tahoma,arial,helvetica,sans-serif;Terminal=terminal,monaco,monospace;Times New Roman=times new roman,times,serif;Trebuchet MS=trebuchet ms,geneva,sans-serif;Verdana=verdana,geneva,sans-serif;Webdings=webdings;Wingdings=wingdings,zapf dingbats"
                        }), n("font_size_formats", {
                            processor: "string",
                            default: "8pt 10pt 12pt 14pt 18pt 24pt 36pt"
                        }), n("block_formats", {
                            processor: "string",
                            default: "Paragraph=p;Heading 1=h1;Heading 2=h2;Heading 3=h3;Heading 4=h4;Heading 5=h5;Heading 6=h6;Preformatted=pre"
                        }), n("content_langs", {
                            processor: "object[]"
                        }), n("removed_menuitems", {
                            processor: "string",
                            default: ""
                        }), n("menubar", {
                            processor: e => s(e) || d(e),
                            default: !t
                        }), n("menu", {
                            processor: "object",
                            default: {}
                        }), n("toolbar", {
                            processor: e => d(e) || s(e) || l(e) ? {
                                value: e,
                                valid: !0
                            } : {
                                valid: !1,
                                message: "Must be a boolean, string or array."
                            },
                            default: !0
                        }), I(9, (e => {
                            n("toolbar" + (e + 1), {
                                processor: "string"
                            })
                        })), n("toolbar_mode", {
                            processor: "string",
                            default: o ? "scrolling" : "floating"
                        }), n("toolbar_groups", {
                            processor: "object",
                            default: {}
                        }), n("toolbar_location", {
                            processor: "string",
                            default: jp.auto
                        }), n("toolbar_persist", {
                            processor: "boolean",
                            default: !1
                        }), n("toolbar_sticky", {
                            processor: "boolean",
                            default: e.inline
                        }), n("toolbar_sticky_offset", {
                            processor: "number",
                            default: 0
                        }), n("fixed_toolbar_container", {
                            processor: "string",
                            default: ""
                        }), n("fixed_toolbar_container_target", {
                            processor: "object"
                        }), n("file_picker_callback", {
                            processor: "function"
                        }), n("file_picker_validator_handler", {
                            processor: "function"
                        }), n("file_picker_types", {
                            processor: "string"
                        }), n("typeahead_urls", {
                            processor: "boolean",
                            default: !0
                        }), n("anchor_top", {
                            processor: r,
                            default: "#top"
                        }), n("anchor_bottom", {
                            processor: r,
                            default: "#bottom"
                        }), n("draggable_modal", {
                            processor: "boolean",
                            default: !1
                        }), n("statusbar", {
                            processor: "boolean",
                            default: !0
                        }), n("elementpath", {
                            processor: "boolean",
                            default: !0
                        }), n("branding", {
                            processor: "boolean",
                            default: !0
                        }), n("promotion", {
                            processor: "boolean",
                            default: !0
                        }), n("resize", {
                            processor: e => "both" === e || d(e),
                            default: !qp.deviceType.isTouch()
                        }), n("sidebar_show", {
                            processor: "string"
                        })
                    },
                    Xp = Gp("readonly"),
                    Jp = Gp("height"),
                    Qp = Gp("width"),
                    ef = Kp(Gp("min_width")),
                    tf = Kp(Gp("min_height")),
                    of = Kp(Gp("max_width")),
                    nf = Kp(Gp("max_height")),
                    rf = Kp(Gp("style_formats")),
                    sf = Gp("style_formats_merge"),
                    af = Gp("style_formats_autohide"),
                    lf = Gp("content_langs"),
                    cf = Gp("removed_menuitems"),
                    df = Gp("toolbar_mode"),
                    uf = Gp("toolbar_groups"),
                    mf = Gp("toolbar_location"),
                    gf = Gp("fixed_toolbar_container"),
                    hf = Gp("fixed_toolbar_container_target"),
                    pf = Gp("toolbar_persist"),
                    ff = Gp("toolbar_sticky_offset"),
                    vf = Gp("menubar"),
                    bf = Gp("toolbar"),
                    yf = Gp("file_picker_callback"),
                    wf = Gp("file_picker_validator_handler"),
                    xf = Gp("file_picker_types"),
                    Cf = Gp("typeahead_urls"),
                    Sf = Gp("anchor_top"),
                    kf = Gp("anchor_bottom"),
                    _f = Gp("draggable_modal"),
                    Of = Gp("statusbar"),
                    Tf = Gp("elementpath"),
                    Ef = Gp("branding"),
                    Af = Gp("resize"),
                    Mf = Gp("paste_as_text"),
                    Nf = Gp("sidebar_show"),
                    Rf = Gp("promotion"),
                    Df = e => !1 === e.options.get("skin"),
                    Bf = e => !1 !== e.options.get("menubar"),
                    Lf = e => {
                        const t = e.options.get("skin_url");
                        if (Df(e)) return t;
                        if (t) return e.documentBaseURI.toAbsolute(t); {
                            const t = e.options.get("skin");
                            return $p.baseURL + "/skins/ui/" + t
                        }
                    },
                    Hf = e => e.options.get("line_height_formats").split(" "),
                    If = e => {
                        const t = bf(e),
                            o = s(t),
                            n = l(t) && t.length > 0;
                        return !zf(e) && (n || o || !0 === t)
                    },
                    Pf = e => {
                        const t = I(9, (t => e.options.get("toolbar" + (t + 1)))),
                            o = Z(t, s);
                        return Se(o.length > 0, o)
                    },
                    zf = e => Pf(e).fold((() => {
                        const t = bf(e);
                        return f(t, s) && t.length > 0
                    }), T),
                    Ff = e => mf(e) === jp.bottom,
                    Vf = e => {
                        var t;
                        if (!e.inline) return A.none();
                        const o = null !== (t = gf(e)) && void 0 !== t ? t : "";
                        if (o.length > 0) return ri(pt(), o);
                        const n = hf(e);
                        return g(n) ? A.some(Be(n)) : A.none()
                    },
                    Zf = e => e.inline && Vf(e).isSome(),
                    Uf = e => Vf(e).getOrThunk((() => ut(dt(Be(e.getElement()))))),
                    jf = e => e.inline && !Bf(e) && !If(e) && !zf(e),
                    Wf = e => (e.options.get("toolbar_sticky") || e.inline) && !Zf(e) && !jf(e),
                    $f = e => {
                        const t = e.options.get("menu");
                        return ce(t, (e => ({ ...e,
                            items: e.items
                        })))
                    };
                var qf = Object.freeze({
                    __proto__: null,
                    get ToolbarMode() {
                        return Up
                    },
                    get ToolbarLocation() {
                        return jp
                    },
                    register: Yp,
                    getSkinUrl: Lf,
                    isReadOnly: Xp,
                    isSkinDisabled: Df,
                    getHeightOption: Jp,
                    getWidthOption: Qp,
                    getMinWidthOption: ef,
                    getMinHeightOption: tf,
                    getMaxWidthOption: of ,
                    getMaxHeightOption: nf,
                    getUserStyleFormats: rf,
                    shouldMergeStyleFormats: sf,
                    shouldAutoHideStyleFormats: af,
                    getLineHeightFormats: Hf,
                    getContentLanguages: lf,
                    getRemovedMenuItems: cf,
                    isMenubarEnabled: Bf,
                    isMultipleToolbars: zf,
                    isToolbarEnabled: If,
                    isToolbarPersist: pf,
                    getMultipleToolbarsOption: Pf,
                    getUiContainer: Uf,
                    useFixedContainer: Zf,
                    getToolbarMode: df,
                    isDraggableModal: _f,
                    isDistractionFree: jf,
                    isStickyToolbar: Wf,
                    getStickyToolbarOffset: ff,
                    getToolbarLocation: mf,
                    isToolbarLocationBottom: Ff,
                    getToolbarGroups: uf,
                    getMenus: $f,
                    getMenubar: vf,
                    getToolbar: bf,
                    getFilePickerCallback: yf,
                    getFilePickerTypes: xf,
                    useTypeaheadUrls: Cf,
                    getAnchorTop: Sf,
                    getAnchorBottom: kf,
                    getFilePickerValidatorHandler: wf,
                    useStatusBar: Of,
                    useElementPath: Tf,
                    promotionEnabled: Rf,
                    useBranding: Ef,
                    getResize: Af,
                    getPasteAsText: Mf,
                    getSidebarShow: Nf
                });
                const Gf = "[data-mce-autocompleter]",
                    Kf = e => si(e, Gf);
                var Yf;
                ! function(e) {
                    e[e.CLOSE_ON_EXECUTE = 0] = "CLOSE_ON_EXECUTE", e[e.BUBBLE_TO_SANDBOX = 1] = "BUBBLE_TO_SANDBOX"
                }(Yf || (Yf = {}));
                var Xf = Yf;
                const Jf = "tox-menu-nav__js",
                    Qf = "tox-collection__item",
                    ev = "tox-swatch",
                    tv = {
                        normal: Jf,
                        color: ev
                    },
                    ov = "tox-collection__item--enabled",
                    nv = "tox-collection__item-icon",
                    rv = "tox-collection__item-label",
                    sv = "tox-collection__item-caret",
                    av = "tox-collection__item--active",
                    iv = "tox-collection__item-container",
                    lv = "tox-collection__item-container--row",
                    cv = e => ve(tv, e).getOr(Jf),
                    dv = e => "color" === e ? "tox-swatches" : "tox-menu",
                    uv = e => ({
                        backgroundMenu: "tox-background-menu",
                        selectedMenu: "tox-selected-menu",
                        selectedItem: "tox-collection__item--active",
                        hasIcons: "tox-menu--has-icons",
                        menu: dv(e),
                        tieredMenu: "tox-tiered-menu"
                    }),
                    mv = e => {
                        const t = uv(e);
                        return {
                            backgroundMenu: t.backgroundMenu,
                            selectedMenu: t.selectedMenu,
                            menu: t.menu,
                            selectedItem: t.selectedItem,
                            item: cv(e)
                        }
                    },
                    gv = (e, t, o) => {
                        const n = uv(o);
                        return {
                            tag: "div",
                            classes: q([
                                [n.menu, `tox-menu-${t}-column`], e ? [n.hasIcons] : []
                            ])
                        }
                    },
                    hv = [vp.parts.items({})],
                    pv = (e, t, o) => {
                        const n = uv(o);
                        return {
                            dom: {
                                tag: "div",
                                classes: q([
                                    [n.tieredMenu]
                                ])
                            },
                            markers: mv(o)
                        }
                    },
                    fv = y([nr("data"), ur("inputAttributes", {}), ur("inputStyles", {}), ur("tag", "input"), ur("inputClasses", []), xi("onSetValue"), ur("styles", {}), ur("eventOrder", {}), nu("inputBehaviours", [ou, Zh]), ur("selectOnFocus", !0)]),
                    vv = e => gl([Zh.config({
                        onFocus: e.selectOnFocus ? e => {
                            const t = e.element,
                                o = Ha(t);
                            t.dom.setSelectionRange(0, o.length)
                        } : v
                    })]),
                    bv = e => ({ ...vv(e),
                        ...su(e.inputBehaviours, [ou.config({
                            store: {
                                mode: "manual",
                                ...e.data.map((e => ({
                                    initialValue: e
                                }))).getOr({}),
                                getValue: e => Ha(e.element),
                                setValue: (e, t) => {
                                    Ha(e.element) !== t && Ia(e.element, t)
                                }
                            },
                            onSetValue: e.onSetValue
                        })])
                    }),
                    yv = e => ({
                        tag: e.tag,
                        attributes: {
                            type: "text",
                            ...e.inputAttributes
                        },
                        styles: e.inputStyles,
                        classes: e.inputClasses
                    }),
                    wv = rm({
                        name: "Input",
                        configFields: fv(),
                        factory: (e, t) => ({
                            uid: e.uid,
                            dom: yv(e),
                            components: [],
                            behaviours: bv(e),
                            eventOrder: e.eventOrder
                        })
                    }),
                    xv = Qs("refetch-trigger-event"),
                    Cv = Qs("redirect-menu-item-interaction"),
                    Sv = "tox-menu__searcher",
                    kv = e => ri(e.element, `.${Sv}`).bind((t => e.getSystem().getByDom(t).toOptional())),
                    _v = kv,
                    Ov = e => ({
                        fetchPattern: ou.getValue(e),
                        selectionStart: e.element.dom.selectionStart,
                        selectionEnd: e.element.dom.selectionEnd
                    }),
                    Tv = e => {
                        const t = (e, t) => (t.cut(), A.none()),
                            o = (e, t) => {
                                const o = {
                                    interactionEvent: t.event,
                                    eventType: t.event.raw.type
                                };
                                return _s(e, Cv, o), A.some(!0)
                            },
                            n = "searcher-events";
                        return {
                            dom: {
                                tag: "div",
                                classes: [Qf]
                            },
                            components: [wv.sketch({
                                inputClasses: [Sv, "tox-textfield"],
                                inputAttributes: { ...e.placeholder.map((t => ({
                                        placeholder: e.i18n(t)
                                    }))).getOr({}),
                                    type: "search",
                                    "aria-autocomplete": "list"
                                },
                                inputBehaviours: gl([Ih(n, [Ds(jr(), (e => {
                                    ks(e, xv)
                                })), Ds(Zr(), ((e, t) => {
                                    "Escape" === t.event.raw.key && t.stop()
                                }))]), Th.config({
                                    mode: "special",
                                    onLeft: t,
                                    onRight: t,
                                    onSpace: t,
                                    onEnter: o,
                                    onEscape: o,
                                    onUp: o,
                                    onDown: o
                                })]),
                                eventOrder: {
                                    keydown: [n, Th.name()]
                                }
                            })]
                        }
                    },
                    Ev = "tox-collection--results__js",
                    Av = e => {
                        var t;
                        return e.dom ? { ...e,
                            dom: { ...e.dom,
                                attributes: { ...null !== (t = e.dom.attributes) && void 0 !== t ? t : {},
                                    id: Qs("aria-item-search-result-id"),
                                    "aria-selected": "false"
                                }
                            }
                        } : e
                    },
                    Mv = (e, t) => o => {
                        const n = P(o, t);
                        return z(n, (t => ({
                            dom: e,
                            components: t
                        })))
                    },
                    Nv = (e, t) => {
                        const o = [];
                        let n = [];
                        return F(e, ((e, r) => {
                            t(e, r) ? (n.length > 0 && o.push(n), n = [], (be(e.dom, "innerHtml") || e.components && e.components.length > 0) && n.push(e)) : n.push(e)
                        })), n.length > 0 && o.push(n), z(o, (e => ({
                            dom: {
                                tag: "div",
                                classes: ["tox-collection__group"]
                            },
                            components: e
                        })))
                    },
                    Rv = (e, t, o) => vp.parts.items({
                        preprocess: n => {
                            const r = z(n, o);
                            return "auto" !== e && e > 1 ? Mv({
                                tag: "div",
                                classes: ["tox-collection__group"]
                            }, e)(r) : Nv(r, ((e, o) => "separator" === t[o].type))
                        }
                    }),
                    Dv = (e, t, o = !0) => ({
                        dom: {
                            tag: "div",
                            classes: ["tox-menu", "tox-collection"].concat(1 === e ? ["tox-collection--list"] : ["tox-collection--grid"])
                        },
                        components: [Rv(e, t, w)]
                    }),
                    Bv = e => H(e, (e => "icon" in e && void 0 !== e.icon)),
                    Lv = e => (console.error(Un(e)), console.log(e), A.none()),
                    Hv = (e, t, o, n, r) => {
                        const s = (a = o, {
                            dom: {
                                tag: "div",
                                classes: ["tox-collection", "tox-collection--horizontal"]
                            },
                            components: [vp.parts.items({
                                preprocess: e => Nv(e, ((e, t) => "separator" === a[t].type))
                            })]
                        });
                        var a;
                        return {
                            value: e,
                            dom: s.dom,
                            components: s.components,
                            items: o
                        }
                    },
                    Iv = (e, t, o, n, r) => {
                        if ("color" === r.menuType) {
                            const t = (e => ({
                                dom: {
                                    tag: "div",
                                    classes: ["tox-menu", "tox-swatches-menu"]
                                },
                                components: [{
                                    dom: {
                                        tag: "div",
                                        classes: ["tox-swatches"]
                                    },
                                    components: [vp.parts.items({
                                        preprocess: "auto" !== e ? Mv({
                                            tag: "div",
                                            classes: ["tox-swatches__row"]
                                        }, e) : w
                                    })]
                                }]
                            }))(n);
                            return {
                                value: e,
                                dom: t.dom,
                                components: t.components,
                                items: o
                            }
                        }
                        if ("normal" === r.menuType && "auto" === n) {
                            const t = Dv(n, o);
                            return {
                                value: e,
                                dom: t.dom,
                                components: t.components,
                                items: o
                            }
                        }
                        if ("normal" === r.menuType || "searchable" === r.menuType) {
                            const t = "searchable" !== r.menuType ? Dv(n, o) : "search-with-field" === r.searchMode.searchMode ? ((e, t, o) => {
                                const n = Qs("aria-controls-search-results");
                                return {
                                    dom: {
                                        tag: "div",
                                        classes: ["tox-menu", "tox-collection"].concat(1 === e ? ["tox-collection--list"] : ["tox-collection--grid"])
                                    },
                                    components: [Tv({
                                        i18n: Np.translate,
                                        placeholder: o.placeholder
                                    }), {
                                        dom: {
                                            tag: "div",
                                            classes: [...1 === e ? ["tox-collection--list"] : ["tox-collection--grid"], Ev],
                                            attributes: {
                                                id: n
                                            }
                                        },
                                        components: [Rv(e, t, Av)]
                                    }]
                                }
                            })(n, o, r.searchMode) : ((e, t, o = !0) => {
                                const n = Qs("aria-controls-search-results");
                                return {
                                    dom: {
                                        tag: "div",
                                        classes: ["tox-menu", "tox-collection", Ev].concat(1 === e ? ["tox-collection--list"] : ["tox-collection--grid"]),
                                        attributes: {
                                            id: n
                                        }
                                    },
                                    components: [Rv(e, t, Av)]
                                }
                            })(n, o);
                            return {
                                value: e,
                                dom: t.dom,
                                components: t.components,
                                items: o
                            }
                        }
                        if ("listpreview" === r.menuType && "auto" !== n) {
                            const t = (e => ({
                                dom: {
                                    tag: "div",
                                    classes: ["tox-menu", "tox-collection", "tox-collection--toolbar", "tox-collection--toolbar-lg"]
                                },
                                components: [vp.parts.items({
                                    preprocess: Mv({
                                        tag: "div",
                                        classes: ["tox-collection__group"]
                                    }, e)
                                })]
                            }))(n);
                            return {
                                value: e,
                                dom: t.dom,
                                components: t.components,
                                items: o
                            }
                        }
                        return {
                            value: e,
                            dom: gv(t, n, r.menuType),
                            components: hv,
                            items: o
                        }
                    },
                    Pv = Xn("type"),
                    zv = Xn("name"),
                    Fv = Xn("label"),
                    Vv = Xn("text"),
                    Zv = Xn("title"),
                    Uv = Xn("icon"),
                    jv = Xn("value"),
                    Wv = Qn("fetch"),
                    $v = Qn("getSubmenuItems"),
                    qv = Qn("onAction"),
                    Gv = Qn("onItemAction"),
                    Kv = vr("onSetup", (() => v)),
                    Yv = ar("name"),
                    Xv = ar("text"),
                    Jv = ar("icon"),
                    Qv = ar("tooltip"),
                    eb = ar("label"),
                    tb = ar("shortcut"),
                    ob = lr("select"),
                    nb = fr("active", !1),
                    rb = fr("borderless", !1),
                    sb = fr("enabled", !0),
                    ab = fr("primary", !1),
                    ib = e => ur("columns", e),
                    lb = ur("meta", {}),
                    cb = vr("onAction", v),
                    db = e => hr("type", e),
                    ub = e => Wn("name", "name", un((() => Qs(`${e}-name`))), Rn),
                    mb = kn([Pv, Xv]),
                    gb = kn([db("autocompleteitem"), nb, sb, lb, jv, Xv, Jv]),
                    hb = [sb, Qv, Jv, Xv, Kv],
                    pb = kn([Pv, qv].concat(hb)),
                    fb = e => Fn("toolbarbutton", pb, e),
                    vb = [nb].concat(hb),
                    bb = kn(vb.concat([Pv, qv])),
                    yb = e => Fn("ToggleButton", bb, e),
                    wb = [vr("predicate", O), pr("scope", "node", ["node", "editor"]), pr("position", "selection", ["node", "selection", "line"])],
                    xb = hb.concat([db("contextformbutton"), ab, qv, $n("original", w)]),
                    Cb = vb.concat([db("contextformbutton"), ab, qv, $n("original", w)]),
                    Sb = hb.concat([db("contextformbutton")]),
                    kb = vb.concat([db("contextformtogglebutton")]),
                    _b = jn("type", {
                        contextformbutton: xb,
                        contextformtogglebutton: Cb
                    }),
                    Ob = kn([db("contextform"), vr("initValue", y("")), eb, or("commands", _b), rr("launch", jn("type", {
                        contextformbutton: Sb,
                        contextformtogglebutton: kb
                    }))].concat(wb)),
                    Tb = kn([db("contexttoolbar"), Xn("items")].concat(wb)),
                    Eb = [Pv, Xn("src"), ar("alt"), br("classes", [], Rn)],
                    Ab = kn(Eb),
                    Mb = [Pv, Vv, Yv, br("classes", ["tox-collection__item-label"], Rn)],
                    Nb = kn(Mb),
                    Rb = xn((() => In("type", {
                        cardimage: Ab,
                        cardtext: Nb,
                        cardcontainer: Db
                    }))),
                    Db = kn([Pv, hr("direction", "horizontal"), hr("align", "left"), hr("valign", "middle"), or("items", Rb)]),
                    Bb = [sb, Xv, tb, ("menuitem", Wn("value", "value", un((() => Qs("menuitem-value"))), An())), lb];
                const Lb = kn([Pv, eb, or("items", Rb), Kv, cb].concat(Bb)),
                    Hb = kn([Pv, nb, Jv].concat(Bb)),
                    Ib = [Pv, Xn("fancytype"), cb],
                    Pb = [ur("initData", {})].concat(Ib),
                    zb = [yr("initData", {}, [fr("allowCustomColors", !0), hr("storageKey", "default"), cr("colors", An())])].concat(Ib),
                    Fb = jn("fancytype", {
                        inserttable: Pb,
                        colorswatch: zb
                    }),
                    Vb = kn([Pv, Kv, cb, Jv].concat(Bb)),
                    Zb = kn([Pv, $v, Kv, Jv].concat(Bb)),
                    Ub = kn([Pv, Jv, nb, Kv, qv].concat(Bb)),
                    jb = (e, t, o) => {
                        const n = Hc(e.element, "." + o);
                        if (n.length > 0) {
                            const e = $(n, (e => {
                                const o = e.dom.getBoundingClientRect().top,
                                    r = n[0].dom.getBoundingClientRect().top;
                                return Math.abs(o - r) > t
                            })).getOr(n.length);
                            return A.some({
                                numColumns: e,
                                numRows: Math.ceil(n.length / e)
                            })
                        }
                        return A.none()
                    },
                    Wb = e => ((e, t) => gl([Ih(e, t)]))(Qs("unnamed-events"), e),
                    $b = Qs("tooltip.exclusive"),
                    qb = Qs("tooltip.show"),
                    Gb = Qs("tooltip.hide"),
                    Kb = (e, t, o) => {
                        e.getSystem().broadcastOn([$b], {})
                    };
                var Yb = Object.freeze({
                        __proto__: null,
                        hideAllExclusive: Kb,
                        setComponents: (e, t, o, n) => {
                            o.getTooltip().each((e => {
                                e.getSystem().isConnected() && Hh.set(e, n)
                            }))
                        }
                    }),
                    Xb = Object.freeze({
                        __proto__: null,
                        events: (e, t) => {
                            const o = o => {
                                t.getTooltip().each((n => {
                                    xd(n), e.onHide(o, n), t.clearTooltip()
                                })), t.clearTimer()
                            };
                            return Ms(q([
                                [Ds(qb, (o => {
                                    t.resetTimer((() => {
                                        (o => {
                                            if (!t.isShowing()) {
                                                Kb(o);
                                                const n = e.lazySink(o).getOrDie(),
                                                    r = o.getSystem().build({
                                                        dom: e.tooltipDom,
                                                        components: e.tooltipComponents,
                                                        events: Ms("normal" === e.mode ? [Ds(zr(), (e => {
                                                            ks(o, qb)
                                                        })), Ds(Ir(), (e => {
                                                            ks(o, Gb)
                                                        }))] : []),
                                                        behaviours: gl([Hh.config({})])
                                                    });
                                                t.setTooltip(r), bd(n, r), e.onShow(o, r), ud.position(n, r, {
                                                    anchor: e.anchor(o)
                                                })
                                            }
                                        })(o)
                                    }), e.delay)
                                })), Ds(Gb, (n => {
                                    t.resetTimer((() => {
                                        o(n)
                                    }), e.delay)
                                })), Ds(os(), ((e, t) => {
                                    const n = t;
                                    n.universal || L(n.channels, $b) && o(e)
                                })), Zs((e => {
                                    o(e)
                                }))], "normal" === e.mode ? [Ds(Fr(), (e => {
                                    ks(e, qb)
                                })), Ds(es(), (e => {
                                    ks(e, Gb)
                                })), Ds(zr(), (e => {
                                    ks(e, qb)
                                })), Ds(Ir(), (e => {
                                    ks(e, Gb)
                                }))] : [Ds(Cs(), ((e, t) => {
                                    ks(e, qb)
                                })), Ds(Ss(), (e => {
                                    ks(e, Gb)
                                }))]
                            ]))
                        }
                    }),
                    Jb = [Gn("lazySink"), Gn("tooltipDom"), ur("exclusive", !0), ur("tooltipComponents", []), ur("delay", 300), pr("mode", "normal", ["normal", "follow-highlight"]), ur("anchor", (e => ({
                        type: "hotspot",
                        hotspot: e,
                        layouts: {
                            onLtr: y([Qi, Ji, Gi, Yi, Ki, Xi]),
                            onRtl: y([Qi, Ji, Gi, Yi, Ki, Xi])
                        }
                    }))), xi("onHide"), xi("onShow")];
                const Qb = pl({
                        fields: Jb,
                        name: "tooltipping",
                        active: Xb,
                        state: Object.freeze({
                            __proto__: null,
                            init: () => {
                                const e = Zl(),
                                    t = Zl(),
                                    o = () => {
                                        e.on(clearTimeout)
                                    },
                                    n = y("not-implemented");
                                return va({
                                    getTooltip: t.get,
                                    isShowing: t.isSet,
                                    setTooltip: t.set,
                                    clearTooltip: t.clear,
                                    clearTimer: o,
                                    resetTimer: (t, n) => {
                                        o(), e.set(setTimeout(t, n))
                                    },
                                    readState: n
                                })
                            }
                        }),
                        apis: Yb
                    }),
                    ey = "silver.readonly",
                    ty = kn([("readonly", Kn("readonly", Dn))]);
                const oy = (e, t) => {
                        const o = e.mainUi.outerContainer.element,
                            n = [e.mainUi.mothership, ...e.uiMotherships];
                        t && F(n, (e => {
                            e.broadcastOn([Id()], {
                                target: o
                            })
                        })), F(n, (e => {
                            e.broadcastOn([ey], {
                                readonly: t
                            })
                        }))
                    },
                    ny = (e, t) => {
                        e.on("init", (() => {
                            e.mode.isReadOnly() && oy(t, !0)
                        })), e.on("SwitchMode", (() => oy(t, e.mode.isReadOnly()))), Xp(e) && e.mode.set("readonly")
                    },
                    ry = () => yl.config({
                        channels: {
                            [ey]: {
                                schema: ty,
                                onReceive: (e, t) => {
                                    Sm.set(e, t.readonly)
                                }
                            }
                        }
                    }),
                    sy = e => Sm.config({
                        disabled: e
                    }),
                    ay = e => Sm.config({
                        disabled: e,
                        disableClass: "tox-tbtn--disabled"
                    }),
                    iy = e => Sm.config({
                        disabled: e,
                        disableClass: "tox-tbtn--disabled",
                        useNative: !1
                    }),
                    ly = (e, t) => {
                        const o = e.getApi(t);
                        return e => {
                            e(o)
                        }
                    },
                    cy = (e, t) => Vs((o => {
                        ly(e, o)((o => {
                            const n = e.onSetup(o);
                            h(n) && t.set(n)
                        }))
                    })),
                    dy = (e, t) => Zs((o => ly(e, o)(t.get()))),
                    uy = (e, t) => js(((o, n) => {
                        ly(e, o)(e.onAction), e.triggersSubmenu || t !== Xf.CLOSE_ON_EXECUTE || (o.getSystem().isConnected() && ks(o, is()), n.stop())
                    })),
                    my = {
                        [ns()]: ["disabling", "alloy.base.behaviour", "toggling", "item-events"]
                    },
                    gy = xe,
                    hy = (e, t, o, n) => {
                        const r = wr(v);
                        return {
                            type: "item",
                            dom: t.dom,
                            components: gy(t.optComponents),
                            data: e.data,
                            eventOrder: my,
                            hasSubmenu: e.triggersSubmenu,
                            itemBehaviours: gl([Ih("item-events", [uy(e, o), cy(e, r), dy(e, r)]), (s = () => !e.enabled || n.isDisabled(), Sm.config({
                                disabled: s,
                                disableClass: "tox-collection__item--state-disabled"
                            })), ry(), Hh.config({})].concat(e.itemBehaviours))
                        };
                        var s
                    },
                    py = e => ({
                        value: e.value,
                        meta: {
                            text: e.text.getOr(""),
                            ...e.meta
                        }
                    }),
                    fy = e => {
                        const t = qp.os.isMacOS() || qp.os.isiOS(),
                            o = t ? {
                                alt: "",
                                ctrl: "",
                                shift: "",
                                meta: "",
                                access: ""
                            } : {
                                meta: "Ctrl",
                                access: "Shift+Alt"
                            },
                            n = e.split("+"),
                            r = z(n, (e => {
                                const t = e.toLowerCase().trim();
                                return be(o, t) ? o[t] : e
                            }));
                        return t ? r.join("") : r.join("+")
                    },
                    vy = (e, t, o = [nv]) => Fp(e, {
                        tag: "div",
                        classes: o
                    }, t),
                    by = e => ({
                        dom: {
                            tag: "div",
                            classes: [rv]
                        },
                        components: [Wa(Np.translate(e))]
                    }),
                    yy = (e, t) => ({
                        dom: {
                            tag: "div",
                            classes: t,
                            innerHtml: e
                        }
                    }),
                    wy = (e, t) => ({
                        dom: {
                            tag: "div",
                            classes: [rv]
                        },
                        components: [{
                            dom: {
                                tag: e.tag,
                                styles: e.styles
                            },
                            components: [Wa(Np.translate(t))]
                        }]
                    }),
                    xy = e => ({
                        dom: {
                            tag: "div",
                            classes: ["tox-collection__item-accessory"]
                        },
                        components: [Wa(fy(e))]
                    }),
                    Cy = e => vy("checkmark", e, ["tox-collection__item-checkmark"]),
                    Sy = e => {
                        const t = e.map((e => ({
                            attributes: {
                                title: Np.translate(e)
                            }
                        }))).getOr({});
                        return {
                            tag: "div",
                            classes: [Jf, Qf],
                            ...t
                        }
                    },
                    ky = (e, t, o, n = A.none()) => "color" === e.presets ? ((e, t, o) => {
                        const n = e.ariaLabel,
                            r = e.value,
                            s = e.iconContent.map((e => ((e, t, o) => {
                                const n = t();
                                return Hp(e, n).or(o).getOrThunk(Bp(n))
                            })(e, t.icons, o)));
                        return {
                            dom: (() => {
                                const e = ev,
                                    o = s.getOr(""),
                                    a = n.map((e => ({
                                        title: t.translate(e)
                                    }))).getOr({}),
                                    i = {
                                        tag: "div",
                                        attributes: a,
                                        classes: [e]
                                    };
                                return "custom" === r ? { ...i,
                                    tag: "button",
                                    classes: [...i.classes, "tox-swatches__picker-btn"],
                                    innerHtml: o
                                } : "remove" === r ? { ...i,
                                    classes: [...i.classes, "tox-swatch--remove"],
                                    innerHtml: o
                                } : g(r) ? { ...i,
                                    attributes: { ...i.attributes,
                                        "data-mce-color": r
                                    },
                                    styles: {
                                        "background-color": r
                                    },
                                    innerHtml: o
                                } : i
                            })(),
                            optComponents: []
                        }
                    })(e, t, n) : ((e, t, o, n) => {
                        const r = {
                                tag: "div",
                                classes: [nv]
                            },
                            s = o ? e.iconContent.map((e => Fp(e, r, t.icons, n))).orThunk((() => A.some({
                                dom: r
                            }))) : A.none(),
                            a = e.checkMark,
                            i = A.from(e.meta).fold((() => by), (e => be(e, "style") ? C(wy, e.style) : by)),
                            l = e.htmlContent.fold((() => e.textContent.map(i)), (e => A.some(yy(e, [rv]))));
                        return {
                            dom: Sy(e.ariaLabel),
                            optComponents: [s, l, e.shortcutContent.map(xy), a, e.caret]
                        }
                    })(e, t, o, n),
                    _y = (e, t) => ve(e, "tooltipWorker").map((e => [Qb.config({
                        lazySink: t.getSink,
                        tooltipDom: {
                            tag: "div",
                            classes: ["tox-tooltip-worker-container"]
                        },
                        tooltipComponents: [],
                        anchor: e => ({
                            type: "submenu",
                            item: e,
                            overrides: {
                                maxHeightFunction: Jl
                            }
                        }),
                        mode: "follow-highlight",
                        onShow: (t, o) => {
                            e((e => {
                                Qb.setComponents(t, [$a({
                                    element: Be(e)
                                })])
                            }))
                        }
                    })])).getOr([]),
                    Oy = (e, t) => {
                        const o = (e => Wp.DOM.encode(e))(Np.translate(e));
                        if (t.length > 0) {
                            const e = new RegExp((e => e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"))(t), "gi");
                            return o.replace(e, (e => `<span class="tox-autocompleter-highlight">${e}</span>`))
                        }
                        return o
                    },
                    Ty = (e, t) => z(e, (e => {
                        switch (e.type) {
                            case "cardcontainer":
                                return ((e, t) => {
                                    const o = "vertical" === e.direction ? "tox-collection__item-container--column" : lv,
                                        n = "left" === e.align ? "tox-collection__item-container--align-left" : "tox-collection__item-container--align-right";
                                    return {
                                        dom: {
                                            tag: "div",
                                            classes: [iv, o, n, (() => {
                                                switch (e.valign) {
                                                    case "top":
                                                        return "tox-collection__item-container--valign-top";
                                                    case "middle":
                                                        return "tox-collection__item-container--valign-middle";
                                                    case "bottom":
                                                        return "tox-collection__item-container--valign-bottom"
                                                }
                                            })()]
                                        },
                                        components: t
                                    }
                                })(e, Ty(e.items, t));
                            case "cardimage":
                                return ((e, t, o) => ({
                                    dom: {
                                        tag: "img",
                                        classes: t,
                                        attributes: {
                                            src: e,
                                            alt: o.getOr("")
                                        }
                                    }
                                }))(e.src, e.classes, e.alt);
                            case "cardtext":
                                const o = e.name.exists((e => L(t.cardText.highlightOn, e))),
                                    n = o ? A.from(t.cardText.matchText).getOr("") : "";
                                return yy(Oy(e.text, n), e.classes)
                        }
                    })),
                    Ey = Iu(dp(), up()),
                    Ay = e => ({
                        value: e
                    }),
                    My = /^#?([a-f\d])([a-f\d])([a-f\d])$/i,
                    Ny = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i,
                    Ry = e => My.test(e) || Ny.test(e),
                    Dy = e => {
                        return (t = e, ((e, t) => ke(e, t, 0))(t, "#") ? ((e, t) => e.substring(t))(t, "#".length) : t).toUpperCase();
                        var t
                    },
                    By = e => {
                        const t = e.toString(16);
                        return (1 === t.length ? "0" + t : t).toUpperCase()
                    },
                    Ly = e => {
                        const t = By(e.red) + By(e.green) + By(e.blue);
                        return Ay(t)
                    },
                    Hy = Math.min,
                    Iy = Math.max,
                    Py = Math.round,
                    zy = /^\s*rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)\s*$/i,
                    Fy = /^\s*rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d?(?:\.\d+)?)\s*\)\s*$/i,
                    Vy = (e, t, o, n) => ({
                        red: e,
                        green: t,
                        blue: o,
                        alpha: n
                    }),
                    Zy = e => {
                        const t = parseInt(e, 10);
                        return t.toString() === e && t >= 0 && t <= 255
                    },
                    Uy = e => {
                        let t, o, n;
                        const r = (e.hue || 0) % 360;
                        let s = e.saturation / 100,
                            a = e.value / 100;
                        if (s = Iy(0, Hy(s, 1)), a = Iy(0, Hy(a, 1)), 0 === s) return t = o = n = Py(255 * a), Vy(t, o, n, 1);
                        const i = r / 60,
                            l = a * s,
                            c = l * (1 - Math.abs(i % 2 - 1)),
                            d = a - l;
                        switch (Math.floor(i)) {
                            case 0:
                                t = l, o = c, n = 0;
                                break;
                            case 1:
                                t = c, o = l, n = 0;
                                break;
                            case 2:
                                t = 0, o = l, n = c;
                                break;
                            case 3:
                                t = 0, o = c, n = l;
                                break;
                            case 4:
                                t = c, o = 0, n = l;
                                break;
                            case 5:
                                t = l, o = 0, n = c;
                                break;
                            default:
                                t = o = n = 0
                        }
                        return t = Py(255 * (t + d)), o = Py(255 * (o + d)), n = Py(255 * (n + d)), Vy(t, o, n, 1)
                    },
                    jy = e => {
                        const t = (e => {
                                const t = (e => {
                                        const t = e.value.replace(My, ((e, t, o, n) => t + t + o + o + n + n));
                                        return {
                                            value: t
                                        }
                                    })(e),
                                    o = Ny.exec(t.value);
                                return null === o ? ["FFFFFF", "FF", "FF", "FF"] : o
                            })(e),
                            o = parseInt(t[1], 16),
                            n = parseInt(t[2], 16),
                            r = parseInt(t[3], 16);
                        return Vy(o, n, r, 1)
                    },
                    Wy = (e, t, o, n) => {
                        const r = parseInt(e, 10),
                            s = parseInt(t, 10),
                            a = parseInt(o, 10),
                            i = parseFloat(n);
                        return Vy(r, s, a, i)
                    },
                    $y = e => {
                        if ("transparent" === e) return A.some(Vy(0, 0, 0, 0));
                        const t = zy.exec(e);
                        if (null !== t) return A.some(Wy(t[1], t[2], t[3], "1"));
                        const o = Fy.exec(e);
                        return null !== o ? A.some(Wy(o[1], o[2], o[3], o[4])) : A.none()
                    },
                    qy = e => `rgba(${e.red},${e.green},${e.blue},${e.alpha})`,
                    Gy = Vy(255, 0, 0, 1),
                    Ky = (e, t) => {
                        e.dispatch("ResizeContent", t)
                    },
                    Yy = (e, t) => e.dispatch("ResolveName", {
                        name: t.nodeName.toLowerCase(),
                        target: t
                    });
                var Xy = tinymce.util.Tools.resolve("tinymce.util.LocalStorage");
                const Jy = {},
                    Qy = e => ve(Jy, e).getOrThunk((() => {
                        const t = `tinymce-custom-colors-${e}`,
                            o = Xy.getItem(t);
                        if (m(o)) {
                            const e = Xy.getItem("tinymce-custom-colors");
                            Xy.setItem(t, g(e) ? e : "[]")
                        }
                        const n = ((e, t = 10) => {
                            const o = Xy.getItem(e),
                                n = s(o) ? JSON.parse(o) : [],
                                r = t - (a = n).length < 0 ? a.slice(0, t) : a;
                            var a;
                            const i = e => {
                                r.splice(e, 1)
                            };
                            return {
                                add: o => {
                                    B(r, o).each(i), r.unshift(o), r.length > t && r.pop(), Xy.setItem(e, JSON.stringify(r))
                                },
                                state: () => r.slice(0)
                            }
                        })(t, 10);
                        return Jy[e] = n, n
                    })),
                    ew = (e, t) => {
                        Qy(e).add(t)
                    },
                    tw = (e, t, o) => ({
                        hue: e,
                        saturation: t,
                        value: o
                    }),
                    ow = e => {
                        let t = 0,
                            o = 0,
                            n = 0;
                        const r = e.red / 255,
                            s = e.green / 255,
                            a = e.blue / 255,
                            i = Math.min(r, Math.min(s, a)),
                            l = Math.max(r, Math.max(s, a));
                        return i === l ? (n = i, tw(0, 0, 100 * n)) : (t = r === i ? 3 : a === i ? 1 : 5, t = 60 * (t - (r === i ? s - a : a === i ? r - s : a - r) / (l - i)), o = (l - i) / l, n = l, tw(Math.round(t), Math.round(100 * o), Math.round(100 * n)))
                    },
                    nw = e => Ly(Uy(e)),
                    rw = e => {
                        return (t = e, Ry(t) ? A.some({
                            value: Dy(t)
                        }) : A.none()).orThunk((() => $y(e).map(Ly))).getOrThunk((() => {
                            const t = document.createElement("canvas");
                            t.height = 1, t.width = 1;
                            const o = t.getContext("2d");
                            o.clearRect(0, 0, t.width, t.height), o.fillStyle = "#FFFFFF", o.fillStyle = e, o.fillRect(0, 0, 1, 1);
                            const n = o.getImageData(0, 0, 1, 1).data,
                                r = n[0],
                                s = n[1],
                                a = n[2],
                                i = n[3];
                            return Ly(Vy(r, s, a, i))
                        }));
                        var t
                    },
                    sw = "forecolor",
                    aw = "hilitecolor",
                    iw = e => Math.max(5, Math.ceil(Math.sqrt(e))),
                    lw = e => {
                        const t = [];
                        for (let o = 0; o < e.length; o += 2) t.push({
                            text: e[o + 1],
                            value: "#" + rw(e[o]).value,
                            icon: "checkmark",
                            type: "choiceitem"
                        });
                        return t
                    },
                    cw = e => t => t.options.get(e),
                    dw = "#000000",
                    uw = (e, t) => t === sw ? cw("color_cols_foreground")(e) : t === aw ? cw("color_cols_background")(e) : cw("color_cols")(e),
                    mw = cw("custom_colors"),
                    gw = (e, t) => t === sw && e.options.isSet("color_map_foreground") ? cw("color_map_foreground")(e) : t === aw && e.options.isSet("color_map_background") ? cw("color_map_background")(e) : cw("color_map")(e),
                    hw = cw("color_default_foreground"),
                    pw = cw("color_default_background"),
                    fw = (e, t) => {
                        const o = At(Be(e.selection.getStart()), "hilitecolor" === t ? "background-color" : "color");
                        return $y(o).map((e => "#" + Ly(e).value))
                    },
                    vw = e => {
                        const t = "choiceitem",
                            o = {
                                type: t,
                                text: "Remove color",
                                icon: "color-swatch-remove-color",
                                value: "remove"
                            };
                        return e ? [o, {
                            type: t,
                            text: "Custom color",
                            icon: "color-picker",
                            value: "custom"
                        }] : [o]
                    },
                    bw = (e, t, o, n) => {
                        "custom" === o ? kw(e)((o => {
                            o.each((o => {
                                ew(t, o), e.execCommand("mceApplyTextcolor", t, o), n(o)
                            }))
                        }), fw(e, t).getOr(dw)) : "remove" === o ? (n(""), e.execCommand("mceRemoveTextcolor", t)) : (n(o), e.execCommand("mceApplyTextcolor", t, o))
                    },
                    yw = (e, t, o) => e.concat((e => z(Qy(e).state(), (e => ({
                        type: "choiceitem",
                        text: e,
                        icon: "checkmark",
                        value: e
                    }))))(t).concat(vw(o))),
                    ww = (e, t, o) => n => {
                        n(yw(e, t, o))
                    },
                    xw = (e, t, o) => {
                        const n = "forecolor" === t ? "tox-icon-text-color__color" : "tox-icon-highlight-bg-color__color";
                        e.setIconFill(n, o)
                    },
                    Cw = (e, t, o, n, r) => {
                        e.ui.registry.addSplitButton(t, {
                            tooltip: n,
                            presets: "color",
                            icon: "forecolor" === t ? "text-color" : "highlight-bg-color",
                            select: t => {
                                const n = fw(e, o);
                                return we(n, t.toUpperCase())
                            },
                            columns: uw(e, o),
                            fetch: ww(gw(e, o), o, mw(e)),
                            onAction: t => {
                                bw(e, o, r.get(), v)
                            },
                            onItemAction: (n, s) => {
                                bw(e, o, s, (o => {
                                    r.set(o), ((e, t) => {
                                        e.dispatch("TextColorChange", t)
                                    })(e, {
                                        name: t,
                                        color: o
                                    })
                                }))
                            },
                            onSetup: o => {
                                xw(o, t, r.get());
                                const n = e => {
                                    e.name === t && xw(o, e.name, e.color)
                                };
                                return e.on("TextColorChange", n), () => {
                                    e.off("TextColorChange", n)
                                }
                            }
                        })
                    },
                    Sw = (e, t, o, n) => {
                        e.ui.registry.addNestedMenuItem(t, {
                            text: n,
                            icon: "forecolor" === t ? "text-color" : "highlight-bg-color",
                            getSubmenuItems: () => [{
                                type: "fancymenuitem",
                                fancytype: "colorswatch",
                                initData: {
                                    storageKey: o
                                },
                                onAction: t => {
                                    bw(e, o, t.value, v)
                                }
                            }]
                        })
                    },
                    kw = e => (t, o) => {
                        let n = !1;
                        const r = {
                            colorpicker: o
                        };
                        e.windowManager.open({
                            title: "Color Picker",
                            size: "normal",
                            body: {
                                type: "panel",
                                items: [{
                                    type: "colorpicker",
                                    name: "colorpicker",
                                    label: "Color"
                                }]
                            },
                            buttons: [{
                                type: "cancel",
                                name: "cancel",
                                text: "Cancel"
                            }, {
                                type: "submit",
                                name: "save",
                                text: "Save",
                                primary: !0
                            }],
                            initialData: r,
                            onAction: (e, t) => {
                                "hex-valid" === t.name && (n = t.value)
                            },
                            onSubmit: o => {
                                const r = o.getData().colorpicker;
                                n ? (t(A.from(r)), o.close()) : e.windowManager.alert(e.translate(["Invalid hex color code: {0}", r]))
                            },
                            onClose: v,
                            onCancel: () => {
                                t(A.none())
                            }
                        })
                    },
                    _w = (e, t, o, n, r, s, a, i) => {
                        const l = Bv(t),
                            c = Ow(t, o, n, "color" !== r ? "normal" : "color", s, a, i);
                        return Iv(e, l, c, n, {
                            menuType: r
                        })
                    },
                    Ow = (e, t, o, n, r, s, a) => xe(z(e, (i => {
                        return "choiceitem" === i.type ? (l = i, Fn("choicemenuitem", Hb, l)).fold(Lv, (i => A.some(((e, t, o, n, r, s, a, i = !0) => {
                            const l = ky({
                                presets: o,
                                textContent: t ? e.text : A.none(),
                                htmlContent: A.none(),
                                ariaLabel: e.text,
                                iconContent: e.icon,
                                shortcutContent: t ? e.shortcut : A.none(),
                                checkMark: t ? A.some(Cy(a.icons)) : A.none(),
                                caret: A.none(),
                                value: e.value
                            }, a, i);
                            return cn(hy({
                                data: py(e),
                                enabled: e.enabled,
                                getApi: e => ({
                                    setActive: t => {
                                        Yh.set(e, t)
                                    },
                                    isActive: () => Yh.isOn(e),
                                    isEnabled: () => !Sm.isDisabled(e),
                                    setEnabled: t => Sm.set(e, !t)
                                }),
                                onAction: t => n(e.value),
                                onSetup: e => (e.setActive(r), v),
                                triggersSubmenu: !1,
                                itemBehaviours: []
                            }, l, s, a), {
                                toggling: {
                                    toggleClass: ov,
                                    toggleOnExecute: !1,
                                    selected: e.active,
                                    exclusive: !0
                                }
                            })
                        })(i, 1 === o, n, t, s(i.value), r, a, Bv(e))))) : A.none();
                        var l
                    }))),
                    Tw = (e, t) => {
                        const o = mv(t);
                        return 1 === e ? {
                            mode: "menu",
                            moveOnTab: !0
                        } : "auto" === e ? {
                            mode: "grid",
                            selector: "." + o.item,
                            initSize: {
                                numColumns: 1,
                                numRows: 1
                            }
                        } : {
                            mode: "matrix",
                            rowSelector: "." + ("color" === t ? "tox-swatches__row" : "tox-collection__group"),
                            previousSelector: e => "color" === t ? ri(e.element, "[aria-checked=true]") : A.none()
                        }
                    },
                    Ew = Qs("cell-over"),
                    Aw = Qs("cell-execute"),
                    Mw = (e, t, o) => {
                        const n = o => _s(o, Aw, {
                                row: e,
                                col: t
                            }),
                            r = (e, t) => {
                                t.stop(), n(e)
                            };
                        return Ka({
                            dom: {
                                tag: "div",
                                attributes: {
                                    role: "button",
                                    "aria-labelledby": o
                                }
                            },
                            behaviours: gl([Ih("insert-table-picker-cell", [Ds(zr(), Zh.focus), Ds(ns(), n), Ds($r(), r), Ds(ss(), r)]), Yh.config({
                                toggleClass: "tox-insert-table-picker__selected",
                                toggleOnExecute: !1
                            }), Zh.config({
                                onFocus: o => _s(o, Ew, {
                                    row: e,
                                    col: t
                                })
                            })])
                        })
                    },
                    Nw = e => G(e, (e => z(e, Ya))),
                    Rw = (e, t) => Wa(`${t}x${e}`),
                    Dw = {
                        inserttable: e => {
                            const t = Qs("size-label"),
                                o = ((e, t, o) => {
                                    const n = [];
                                    for (let t = 0; t < 10; t++) {
                                        const o = [];
                                        for (let n = 0; n < 10; n++) o.push(Mw(t, n, e));
                                        n.push(o)
                                    }
                                    return n
                                })(t),
                                n = Rw(0, 0),
                                r = Mp({
                                    dom: {
                                        tag: "span",
                                        classes: ["tox-insert-table-picker__label"],
                                        attributes: {
                                            id: t
                                        }
                                    },
                                    components: [n],
                                    behaviours: gl([Hh.config({})])
                                });
                            return {
                                type: "widget",
                                data: {
                                    value: Qs("widget-id")
                                },
                                dom: {
                                    tag: "div",
                                    classes: ["tox-fancymenuitem"]
                                },
                                autofocus: !0,
                                components: [Ey.widget({
                                    dom: {
                                        tag: "div",
                                        classes: ["tox-insert-table-picker"]
                                    },
                                    components: Nw(o).concat(r.asSpec()),
                                    behaviours: gl([Ih("insert-table-picker", [Vs((e => {
                                        Hh.set(r.get(e), [n])
                                    })), Is(Ew, ((e, t, n) => {
                                        const {
                                            row: s,
                                            col: a
                                        } = n.event;
                                        ((e, t, o, n, r) => {
                                            for (let n = 0; n < 10; n++)
                                                for (let r = 0; r < 10; r++) Yh.set(e[n][r], n <= t && r <= o)
                                        })(o, s, a), Hh.set(r.get(e), [Rw(s + 1, a + 1)])
                                    })), Is(Aw, ((t, o, n) => {
                                        const {
                                            row: r,
                                            col: s
                                        } = n.event;
                                        e.onAction({
                                            numRows: r + 1,
                                            numColumns: s + 1
                                        }), ks(t, is())
                                    }))]), Th.config({
                                        initSize: {
                                            numRows: 10,
                                            numColumns: 10
                                        },
                                        mode: "flatgrid",
                                        selector: '[role="button"]'
                                    })])
                                })]
                            }
                        },
                        colorswatch: (e, t) => {
                            const o = ((e, t) => {
                                    const o = e.initData.allowCustomColors && t.colorinput.hasCustomColors();
                                    return e.initData.colors.fold((() => yw(t.colorinput.getColors(e.initData.storageKey), e.initData.storageKey, o)), (e => e.concat(vw(o))))
                                })(e, t),
                                n = t.colorinput.getColorCols(e.initData.storageKey),
                                r = "color",
                                s = { ..._w(Qs("menu-value"), o, (t => {
                                        e.onAction({
                                            value: t
                                        })
                                    }), n, r, Xf.CLOSE_ON_EXECUTE, O, t.shared.providers),
                                    markers: mv(r),
                                    movement: Tw(n, r)
                                };
                            return {
                                type: "widget",
                                data: {
                                    value: Qs("widget-id")
                                },
                                dom: {
                                    tag: "div",
                                    classes: ["tox-fancymenuitem"]
                                },
                                autofocus: !0,
                                components: [Ey.widget(vp.sketch(s))]
                            }
                        }
                    },
                    Bw = e => ({
                        type: "separator",
                        dom: {
                            tag: "div",
                            classes: [Qf, "tox-collection__group-heading"]
                        },
                        components: e.text.map(Wa).toArray()
                    });
                var Lw = Object.freeze({
                        __proto__: null,
                        getCoupled: (e, t, o, n) => o.getOrCreate(e, t, n),
                        getExistingCoupled: (e, t, o, n) => o.getExisting(e, t, n)
                    }),
                    Hw = [Kn("others", zn(Xo.value, An()))],
                    Iw = Object.freeze({
                        __proto__: null,
                        init: () => {
                            const e = {},
                                t = (t, o) => {
                                    if (0 === ae(t.others).length) throw new Error("Cannot find any known coupled components");
                                    return ve(e, o)
                                },
                                o = y({});
                            return va({
                                readState: o,
                                getExisting: (e, o, n) => t(o, n).orThunk((() => (ve(o.others, n).getOrDie("No information found for coupled component: " + n), A.none()))),
                                getOrCreate: (o, n, r) => t(n, r).getOrThunk((() => {
                                    const t = ve(n.others, r).getOrDie("No information found for coupled component: " + r)(o),
                                        s = o.getSystem().build(t);
                                    return e[r] = s, s
                                }))
                            })
                        }
                    });
                const Pw = pl({
                        fields: Hw,
                        name: "coupling",
                        apis: Lw,
                        state: Iw
                    }),
                    zw = e => {
                        let t = A.none(),
                            o = [];
                        const n = e => {
                                r() ? s(e) : o.push(e)
                            },
                            r = () => t.isSome(),
                            s = e => {
                                t.each((t => {
                                    setTimeout((() => {
                                        e(t)
                                    }), 0)
                                }))
                            };
                        return e((e => {
                            r() || (t = A.some(e), F(o, s), o = [])
                        })), {
                            get: n,
                            map: e => zw((t => {
                                n((o => {
                                    t(e(o))
                                }))
                            })),
                            isReady: r
                        }
                    },
                    Fw = {
                        nu: zw,
                        pure: e => zw((t => {
                            t(e)
                        }))
                    },
                    Vw = e => {
                        setTimeout((() => {
                            throw e
                        }), 0)
                    },
                    Zw = e => {
                        const t = t => {
                            e().then(t, Vw)
                        };
                        return {
                            map: t => Zw((() => e().then(t))),
                            bind: t => Zw((() => e().then((e => t(e).toPromise())))),
                            anonBind: t => Zw((() => e().then((() => t.toPromise())))),
                            toLazy: () => Fw.nu(t),
                            toCached: () => {
                                let t = null;
                                return Zw((() => (null === t && (t = e()), t)))
                            },
                            toPromise: e,
                            get: t
                        }
                    },
                    Uw = e => Zw((() => new Promise(e))),
                    jw = e => Zw((() => Promise.resolve(e))),
                    Ww = y("sink"),
                    $w = y(Ru({
                        name: Ww(),
                        overrides: y({
                            dom: {
                                tag: "div"
                            },
                            behaviours: gl([ud.config({
                                useFixed: T
                            })]),
                            events: Ms([Ps(Zr()), Ps(Lr()), Ps($r())])
                        })
                    })),
                    qw = (e, t) => {
                        const o = e.getHotspot(t).getOr(t),
                            n = "hotspot",
                            r = e.getAnchorOverrides();
                        return e.layouts.fold((() => ({
                            type: n,
                            hotspot: o,
                            overrides: r
                        })), (e => ({
                            type: n,
                            hotspot: o,
                            overrides: r,
                            layouts: e
                        })))
                    },
                    Gw = (e, t, o, n, r, s, a) => {
                        const i = ((e, t, o, n, r, s, a) => {
                            const i = ((e, t, o) => (0, e.fetch)(o).map(t))(e, t, n),
                                l = Xw(n, e);
                            return i.map((e => e.bind((e => A.from(Op.sketch({ ...s.menu(),
                                uid: aa(""),
                                data: e,
                                highlightOnOpen: a,
                                onOpenMenu: (e, t) => {
                                    const n = l().getOrDie();
                                    ud.position(n, t, {
                                        anchor: o
                                    }), Hd.decloak(r)
                                },
                                onOpenSubmenu: (e, t, o) => {
                                    const n = l().getOrDie();
                                    ud.position(n, o, {
                                        anchor: {
                                            type: "submenu",
                                            item: t
                                        }
                                    }), Hd.decloak(r)
                                },
                                onRepositionMenu: (e, t, n) => {
                                    const r = l().getOrDie();
                                    ud.position(r, t, {
                                        anchor: o
                                    }), F(n, (e => {
                                        ud.position(r, e.triggeredMenu, {
                                            anchor: {
                                                type: "submenu",
                                                item: e.triggeringItem
                                            }
                                        })
                                    }))
                                },
                                onEscape: () => (Zh.focus(n), Hd.close(r), A.some(!0))
                            }))))))
                        })(e, t, qw(e, o), o, n, r, a);
                        return i.map((e => (e.fold((() => {
                            Hd.isOpen(n) && Hd.close(n)
                        }), (e => {
                            Hd.cloak(n), Hd.open(n, e), s(n)
                        })), n)))
                    },
                    Kw = (e, t, o, n, r, s, a) => (Hd.close(n), jw(n)),
                    Yw = (e, t, o, n, r, s) => {
                        const a = Pw.getCoupled(o, "sandbox");
                        return (Hd.isOpen(a) ? Kw : Gw)(e, t, o, a, n, r, s)
                    },
                    Xw = (e, t) => e.getSystem().getByUid(t.uid + "-" + Ww()).map((e => () => Xo.value(e))).getOrThunk((() => t.lazySink.fold((() => () => Xo.error(new Error("No internal sink is specified, nor could an external sink be found"))), (t => () => t(e))))),
                    Jw = e => {
                        Hd.getState(e).each((e => {
                            Op.repositionMenus(e)
                        }))
                    },
                    Qw = (e, t, o) => {
                        const n = ii(),
                            r = Xw(t, e);
                        return {
                            dom: {
                                tag: "div",
                                classes: e.sandboxClasses,
                                attributes: {
                                    id: n.id,
                                    role: "listbox"
                                }
                            },
                            behaviours: iu(e.sandboxBehaviours, [ou.config({
                                store: {
                                    mode: "memory",
                                    initialValue: t
                                }
                            }), Hd.config({
                                onOpen: (r, s) => {
                                    const a = qw(e, t);
                                    n.link(t.element), e.matchWidth && ((e, t, o) => {
                                        const n = cm.getCurrent(t).getOr(t),
                                            r = $t(e.element);
                                        o ? Ot(n.element, "min-width", r + "px") : ((e, t) => {
                                            Wt.set(e, t)
                                        })(n.element, r)
                                    })(a.hotspot, s, e.useMinWidth), e.onOpen(a, r, s), void 0 !== o && void 0 !== o.onOpen && o.onOpen(r, s)
                                },
                                onClose: (e, r) => {
                                    n.unlink(t.element), void 0 !== o && void 0 !== o.onClose && o.onClose(e, r)
                                },
                                isPartOf: (e, o, n) => li(o, n) || li(t, n),
                                getAttachPoint: () => r().getOrDie()
                            }), cm.config({
                                find: e => Hd.getState(e).bind((e => cm.getCurrent(e)))
                            }), yl.config({
                                channels: { ...Vd({
                                        isExtraPart: O
                                    }),
                                    ...Ud({
                                        doReposition: Jw
                                    })
                                }
                            })])
                        }
                    },
                    ex = e => {
                        const t = Pw.getCoupled(e, "sandbox");
                        Jw(t)
                    },
                    tx = () => [ur("sandboxClasses", []), au("sandboxBehaviours", [cm, yl, Hd, ou])],
                    ox = y([Gn("dom"), Gn("fetch"), xi("onOpen"), Ci("onExecute"), ur("getHotspot", A.some), ur("getAnchorOverrides", y({})), dc(), nu("dropdownBehaviours", [Yh, Pw, Th, Zh]), Gn("toggleClass"), ur("eventOrder", {}), nr("lazySink"), ur("matchWidth", !1), ur("useMinWidth", !1), nr("role")].concat(tx())),
                    nx = y([Nu({
                        schema: [bi(), ur("fakeFocus", !1)],
                        name: "menu",
                        defaults: e => ({
                            onExecute: e.onExecute
                        })
                    }), $w()]),
                    rx = sm({
                        name: "Dropdown",
                        configFields: ox(),
                        partFields: nx(),
                        factory: (e, t, o, n) => {
                            const r = e => {
                                    Hd.getState(e).each((e => {
                                        Op.highlightPrimary(e)
                                    }))
                                },
                                s = (t, o, r) => Yw(e, w, t, n, o, r),
                                a = {
                                    expand: e => {
                                        Yh.isOn(e) || s(e, v, kp.HighlightNone).get(v)
                                    },
                                    open: e => {
                                        Yh.isOn(e) || s(e, v, kp.HighlightMenuAndItem).get(v)
                                    },
                                    refetch: t => Pw.getExistingCoupled(t, "sandbox").fold((() => s(t, v, kp.HighlightMenuAndItem).map(v)), (o => Gw(e, w, t, o, n, v, kp.HighlightMenuAndItem).map(v))),
                                    isOpen: Yh.isOn,
                                    close: e => {
                                        Yh.isOn(e) && s(e, v, kp.HighlightMenuAndItem).get(v)
                                    },
                                    repositionMenus: e => {
                                        Yh.isOn(e) && ex(e)
                                    }
                                },
                                i = (e, t) => (Os(e), A.some(!0));
                            return {
                                uid: e.uid,
                                dom: e.dom,
                                components: t,
                                behaviours: su(e.dropdownBehaviours, [Yh.config({
                                    toggleClass: e.toggleClass,
                                    aria: {
                                        mode: "expanded"
                                    }
                                }), Pw.config({
                                    others: {
                                        sandbox: t => Qw(e, t, {
                                            onOpen: () => Yh.on(t),
                                            onClose: () => Yh.off(t)
                                        })
                                    }
                                }), Th.config({
                                    mode: "special",
                                    onSpace: i,
                                    onEnter: i,
                                    onDown: (e, t) => {
                                        if (rx.isOpen(e)) {
                                            const t = Pw.getCoupled(e, "sandbox");
                                            r(t)
                                        } else rx.open(e);
                                        return A.some(!0)
                                    },
                                    onEscape: (e, t) => rx.isOpen(e) ? (rx.close(e), A.some(!0)) : A.none()
                                }), Zh.config({})]),
                                events: Jh(A.some((e => {
                                    s(e, r, kp.HighlightMenuAndItem).get(v)
                                }))),
                                eventOrder: { ...e.eventOrder,
                                    [ns()]: ["disabling", "toggling", "alloy.base.behaviour"]
                                },
                                apis: a,
                                domModification: {
                                    attributes: {
                                        "aria-haspopup": "true",
                                        ...e.role.fold((() => ({})), (e => ({
                                            role: e
                                        }))),
                                        ..."button" === e.dom.tag ? {
                                            type: ("type", ve(e.dom, "attributes").bind((e => ve(e, "type")))).getOr("button")
                                        } : {}
                                    }
                                }
                            }
                        },
                        apis: {
                            open: (e, t) => e.open(t),
                            refetch: (e, t) => e.refetch(t),
                            expand: (e, t) => e.expand(t),
                            close: (e, t) => e.close(t),
                            isOpen: (e, t) => e.isOpen(t),
                            repositionMenus: (e, t) => e.repositionMenus(t)
                        }
                    }),
                    sx = (e, t, o) => {
                        _v(e).each((e => {
                            var n;
                            ((e, t) => {
                                xt(t.element, "id").each((t => bt(e.element, "aria-activedescendant", t)))
                            })(e, o), (Da((n = t).element, Ev) ? A.some(n.element) : ri(n.element, "." + Ev)).each((t => {
                                xt(t, "id").each((t => bt(e.element, "aria-controls", t)))
                            }))
                        })), bt(o.element, "aria-selected", "true")
                    },
                    ax = (e, t, o) => {
                        bt(o.element, "aria-selected", "false")
                    },
                    ix = e => Pw.getExistingCoupled(e, "sandbox").bind(kv).map(Ov).map((e => e.fetchPattern)).getOr("");
                var lx;
                ! function(e) {
                    e[e.ContentFocus = 0] = "ContentFocus", e[e.UiFocus = 1] = "UiFocus"
                }(lx || (lx = {}));
                const cx = (e, t, o, n, r) => {
                        const s = o.shared.providers,
                            a = e => r ? { ...e,
                                shortcut: A.none(),
                                icon: e.text.isSome() ? A.none() : e.icon
                            } : e;
                        switch (e.type) {
                            case "menuitem":
                                return (i = e, Fn("menuitem", Vb, i)).fold(Lv, (e => A.some(((e, t, o, n = !0) => {
                                    const r = ky({
                                        presets: "normal",
                                        iconContent: e.icon,
                                        textContent: e.text,
                                        htmlContent: A.none(),
                                        ariaLabel: e.text,
                                        caret: A.none(),
                                        checkMark: A.none(),
                                        shortcutContent: e.shortcut
                                    }, o, n);
                                    return hy({
                                        data: py(e),
                                        getApi: e => ({
                                            isEnabled: () => !Sm.isDisabled(e),
                                            setEnabled: t => Sm.set(e, !t)
                                        }),
                                        enabled: e.enabled,
                                        onAction: e.onAction,
                                        onSetup: e.onSetup,
                                        triggersSubmenu: !1,
                                        itemBehaviours: []
                                    }, r, t, o)
                                })(a(e), t, s, n))));
                            case "nestedmenuitem":
                                return (e => Fn("nestedmenuitem", Zb, e))(e).fold(Lv, (e => A.some(((e, t, o, n = !0, r = !1) => {
                                    const s = r ? (a = o.icons, vy("chevron-down", a, [sv])) : (e => vy("chevron-right", e, [sv]))(o.icons);
                                    var a;
                                    const i = ky({
                                        presets: "normal",
                                        iconContent: e.icon,
                                        textContent: e.text,
                                        htmlContent: A.none(),
                                        ariaLabel: e.text,
                                        caret: A.some(s),
                                        checkMark: A.none(),
                                        shortcutContent: e.shortcut
                                    }, o, n);
                                    return hy({
                                        data: py(e),
                                        getApi: e => ({
                                            isEnabled: () => !Sm.isDisabled(e),
                                            setEnabled: t => Sm.set(e, !t)
                                        }),
                                        enabled: e.enabled,
                                        onAction: v,
                                        onSetup: e.onSetup,
                                        triggersSubmenu: !0,
                                        itemBehaviours: []
                                    }, i, t, o)
                                })(a(e), t, s, n, r))));
                            case "togglemenuitem":
                                return (e => Fn("togglemenuitem", Ub, e))(e).fold(Lv, (e => A.some(((e, t, o, n = !0) => {
                                    const r = ky({
                                        iconContent: e.icon,
                                        textContent: e.text,
                                        htmlContent: A.none(),
                                        ariaLabel: e.text,
                                        checkMark: A.some(Cy(o.icons)),
                                        caret: A.none(),
                                        shortcutContent: e.shortcut,
                                        presets: "normal",
                                        meta: e.meta
                                    }, o, n);
                                    return cn(hy({
                                        data: py(e),
                                        enabled: e.enabled,
                                        getApi: e => ({
                                            setActive: t => {
                                                Yh.set(e, t)
                                            },
                                            isActive: () => Yh.isOn(e),
                                            isEnabled: () => !Sm.isDisabled(e),
                                            setEnabled: t => Sm.set(e, !t)
                                        }),
                                        onAction: e.onAction,
                                        onSetup: e.onSetup,
                                        triggersSubmenu: !1,
                                        itemBehaviours: []
                                    }, r, t, o), {
                                        toggling: {
                                            toggleClass: ov,
                                            toggleOnExecute: !1,
                                            selected: e.active
                                        }
                                    })
                                })(a(e), t, s, n))));
                            case "separator":
                                return (e => Fn("separatormenuitem", mb, e))(e).fold(Lv, (e => A.some(Bw(e))));
                            case "fancymenuitem":
                                return (e => Fn("fancymenuitem", Fb, e))(e).fold(Lv, (e => ((e, t) => ve(Dw, e.fancytype).map((o => o(e, t))))(e, o)));
                            default:
                                return console.error("Unknown item in general menu", e), A.none()
                        }
                        var i
                    },
                    dx = (e, t, o, n, r, s, a) => {
                        const i = 1 === n,
                            l = !i || Bv(e);
                        return xe(z(e, (e => {
                            switch (e.type) {
                                case "separator":
                                    return (n = e, Fn("Autocompleter.Separator", mb, n)).fold(Lv, (e => A.some(Bw(e))));
                                case "cardmenuitem":
                                    return (e => Fn("cardmenuitem", Lb, e))(e).fold(Lv, (e => A.some(((e, t, o, n) => {
                                        const r = {
                                            dom: Sy(e.label),
                                            optComponents: [A.some({
                                                dom: {
                                                    tag: "div",
                                                    classes: [iv, lv]
                                                },
                                                components: Ty(e.items, n)
                                            })]
                                        };
                                        return hy({
                                            data: py({
                                                text: A.none(),
                                                ...e
                                            }),
                                            enabled: e.enabled,
                                            getApi: e => ({
                                                isEnabled: () => !Sm.isDisabled(e),
                                                setEnabled: t => {
                                                    Sm.set(e, !t), F(Hc(e.element, "*"), (o => {
                                                        e.getSystem().getByDom(o).each((e => {
                                                            e.hasConfigured(Sm) && Sm.set(e, !t)
                                                        }))
                                                    }))
                                                }
                                            }),
                                            onAction: e.onAction,
                                            onSetup: e.onSetup,
                                            triggersSubmenu: !1,
                                            itemBehaviours: A.from(n.itemBehaviours).getOr([])
                                        }, r, t, o.providers)
                                    })({ ...e,
                                        onAction: t => {
                                            e.onAction(t), o(e.value, e.meta)
                                        }
                                    }, r, s, {
                                        itemBehaviours: _y(e.meta, s),
                                        cardText: {
                                            matchText: t,
                                            highlightOn: a
                                        }
                                    }))));
                                default:
                                    return (e => Fn("Autocompleter.Item", gb, e))(e).fold(Lv, (e => A.some(((e, t, o, n, r, s, a, i = !0) => {
                                        const l = ky({
                                            presets: n,
                                            textContent: A.none(),
                                            htmlContent: o ? e.text.map((e => Oy(e, t))) : A.none(),
                                            ariaLabel: e.text,
                                            iconContent: e.icon,
                                            shortcutContent: A.none(),
                                            checkMark: A.none(),
                                            caret: A.none(),
                                            value: e.value
                                        }, a.providers, i, e.icon);
                                        return hy({
                                            data: py(e),
                                            enabled: e.enabled,
                                            getApi: y({}),
                                            onAction: t => r(e.value, e.meta),
                                            onSetup: y(v),
                                            triggersSubmenu: !1,
                                            itemBehaviours: _y(e.meta, a)
                                        }, l, s, a.providers)
                                    })(e, t, i, "normal", o, r, s, l))))
                            }
                            var n
                        })))
                    },
                    ux = (e, t, o, n, r, s) => {
                        const a = Bv(t),
                            i = xe(z(t, (e => {
                                const t = e => cx(e, o, n, (e => r ? !be(e, "text") : a)(e), r);
                                return "nestedmenuitem" === e.type && e.getSubmenuItems().length <= 0 ? t({ ...e,
                                    enabled: !1
                                }) : t(e)
                            }))),
                            l = (e => "no-search" === e.searchMode ? {
                                menuType: "normal"
                            } : {
                                menuType: "searchable",
                                searchMode: e
                            })(s);
                        return (r ? Hv : Iv)(e, a, i, 1, l)
                    },
                    mx = e => Op.singleData(e.value, e),
                    gx = (e, t) => {
                        const o = wr(!1),
                            n = wr(!1),
                            r = Ka(Tp.sketch({
                                dom: {
                                    tag: "div",
                                    classes: ["tox-autocompleter"]
                                },
                                components: [],
                                fireDismissalEventInstead: {},
                                inlineBehaviours: gl([Ih("dismissAutocompleter", [Ds(fs(), (() => c()))])]),
                                lazySink: t.getSink
                            })),
                            s = () => Tp.isOpen(r),
                            a = n.get,
                            i = () => {
                                s() && Tp.hide(r)
                            },
                            l = () => Tp.getContent(r).bind((e => te(e.components(), 0))),
                            c = () => e.execCommand("mceAutocompleterClose"),
                            d = n => {
                                const s = (n => {
                                    const r = se(n, (e => A.from(e.columns))).getOr(1);
                                    return G(n, (n => {
                                        const s = n.items;
                                        return dx(s, n.matchText, ((t, r) => {
                                            const s = e.selection.getRng();
                                            ((e, t) => Kf(Be(t.startContainer)).map((t => {
                                                const o = e.createRng();
                                                return o.selectNode(t.dom), o
                                            })))(e.dom, s).each((s => {
                                                const a = {
                                                    hide: () => c(),
                                                    reload: t => {
                                                        i(), e.execCommand("mceAutocompleterReload", !1, {
                                                            fetchOptions: t
                                                        })
                                                    }
                                                };
                                                o.set(!0), n.onAction(a, s, t, r), o.set(!1)
                                            }))
                                        }), r, Xf.BUBBLE_TO_SANDBOX, t, n.highlightOn)
                                    }))
                                })(n);
                                s.length > 0 ? ((t, o) => {
                                    var n;
                                    (n = Be(e.getBody()), ri(n, Gf)).each((n => {
                                        const s = se(t, (e => A.from(e.columns))).getOr(1);
                                        Tp.showMenuAt(r, {
                                            anchor: {
                                                type: "node",
                                                root: Be(e.getBody()),
                                                node: A.from(n)
                                            }
                                        }, ((e, t, o, n) => {
                                            const r = Tw(t, n),
                                                s = mv(n);
                                            return {
                                                data: mx({ ...e,
                                                    movement: r,
                                                    menuBehaviours: Wb("auto" !== t ? [] : [Vs(((e, t) => {
                                                        jb(e, 4, s.item).each((({
                                                            numColumns: t,
                                                            numRows: o
                                                        }) => {
                                                            Th.setGridSize(e, o, t)
                                                        }))
                                                    }))])
                                                }),
                                                menu: {
                                                    markers: mv(n),
                                                    fakeFocus: o === lx.ContentFocus
                                                }
                                            }
                                        })(Iv("autocompleter-value", !0, o, s, {
                                            menuType: "normal"
                                        }), s, lx.ContentFocus, "normal"))
                                    })), l().each(Dm.highlightFirst)
                                })(n, s) : i()
                            };
                        e.on("AutocompleterStart", (({
                            lookupData: e
                        }) => {
                            n.set(!0), o.set(!1), d(e)
                        })), e.on("AutocompleterUpdate", (({
                            lookupData: e
                        }) => d(e))), e.on("AutocompleterEnd", (() => {
                            i(), n.set(!1), o.set(!1)
                        }));
                        ((e, t) => {
                            const o = (e, t) => {
                                    _s(e, Zr(), {
                                        raw: t
                                    })
                                },
                                n = () => e.getMenu().bind(Dm.getHighlighted);
                            t.on("keydown", (t => {
                                const r = t.which;
                                e.isActive() && (e.isMenuOpen() ? 13 === r ? (n().each(Os), t.preventDefault()) : 40 === r ? (n().fold((() => {
                                    e.getMenu().each(Dm.highlightFirst)
                                }), (e => {
                                    o(e, t)
                                })), t.preventDefault(), t.stopImmediatePropagation()) : 37 !== r && 38 !== r && 39 !== r || n().each((e => {
                                    o(e, t), t.preventDefault(), t.stopImmediatePropagation()
                                })) : 13 !== r && 38 !== r && 40 !== r || e.cancelIfNecessary())
                            })), t.on("NodeChange", (t => {
                                e.isActive() && !e.isProcessingAction() && Kf(Be(t.element)).isNone() && e.cancelIfNecessary()
                            }))
                        })({
                            cancelIfNecessary: c,
                            isMenuOpen: s,
                            isActive: a,
                            isProcessingAction: o.get,
                            getMenu: l
                        }, e)
                    },
                    hx = (e, t, o) => si(e, t, o).isSome(),
                    px = (e, t) => {
                        let o = null;
                        return {
                            cancel: () => {
                                null !== o && (clearTimeout(o), o = null)
                            },
                            schedule: (...n) => {
                                o = setTimeout((() => {
                                    e.apply(null, n), o = null
                                }), t)
                            }
                        }
                    },
                    fx = e => {
                        const t = e.raw;
                        return void 0 === t.touches || 1 !== t.touches.length ? A.none() : A.some(t.touches[0])
                    },
                    vx = (e, t) => {
                        const o = {
                                stopBackspace: !0,
                                ...t
                            },
                            n = (e => {
                                const t = Zl(),
                                    o = wr(!1),
                                    n = px((t => {
                                        e.triggerEvent(as(), t), o.set(!0)
                                    }), 400),
                                    r = Sr([{
                                        key: Nr(),
                                        value: e => (fx(e).each((r => {
                                            n.cancel();
                                            const s = {
                                                x: r.clientX,
                                                y: r.clientY,
                                                target: e.target
                                            };
                                            n.schedule(e), o.set(!1), t.set(s)
                                        })), A.none())
                                    }, {
                                        key: Rr(),
                                        value: e => (n.cancel(), fx(e).each((e => {
                                            t.on((o => {
                                                ((e, t) => {
                                                    const o = Math.abs(e.clientX - t.x),
                                                        n = Math.abs(e.clientY - t.y);
                                                    return o > 5 || n > 5
                                                })(e, o) && t.clear()
                                            }))
                                        })), A.none())
                                    }, {
                                        key: Dr(),
                                        value: r => (n.cancel(), t.get().filter((e => Ge(e.target, r.target))).map((t => o.get() ? (r.prevent(), !1) : e.triggerEvent(ss(), r))))
                                    }]);
                                return {
                                    fireIfReady: (e, t) => ve(r, t).bind((t => t(e)))
                                }
                            })(o),
                            r = z(["touchstart", "touchmove", "touchend", "touchcancel", "gesturestart", "mousedown", "mouseup", "mouseover", "mousemove", "mouseout", "click"].concat(["selectstart", "input", "contextmenu", "change", "transitionend", "transitioncancel", "drag", "dragstart", "dragend", "dragenter", "dragleave", "dragover", "drop", "keyup"]), (t => jl(e, t, (e => {
                                n.fireIfReady(e, t).each((t => {
                                    t && e.kill()
                                })), o.triggerEvent(t, e) && e.kill()
                            })))),
                            s = Zl(),
                            a = jl(e, "paste", (e => {
                                n.fireIfReady(e, "paste").each((t => {
                                    t && e.kill()
                                })), o.triggerEvent("paste", e) && e.kill(), s.set(setTimeout((() => {
                                    o.triggerEvent(ts(), e)
                                }), 0))
                            })),
                            i = jl(e, "keydown", (e => {
                                o.triggerEvent("keydown", e) ? e.kill() : o.stopBackspace && (e => e.raw.which === Bm[0] && !L(["input", "textarea"], ze(e.target)) && !hx(e.target, '[contenteditable="true"]'))(e) && e.prevent()
                            })),
                            l = jl(e, "focusin", (e => {
                                o.triggerEvent("focusin", e) && e.kill()
                            })),
                            c = Zl(),
                            d = jl(e, "focusout", (e => {
                                o.triggerEvent("focusout", e) && e.kill(), c.set(setTimeout((() => {
                                    o.triggerEvent(es(), e)
                                }), 0))
                            }));
                        return {
                            unbind: () => {
                                F(r, (e => {
                                    e.unbind()
                                })), i.unbind(), l.unbind(), d.unbind(), a.unbind(), s.on(clearTimeout), c.on(clearTimeout)
                            }
                        }
                    },
                    bx = (e, t) => {
                        const o = ve(e, "target").getOr(t);
                        return wr(o)
                    },
                    yx = xr([{
                        stopped: []
                    }, {
                        resume: ["element"]
                    }, {
                        complete: []
                    }]),
                    wx = (e, t, o, n, r, s) => {
                        const a = e(t, n),
                            i = ((e, t) => {
                                const o = wr(!1),
                                    n = wr(!1);
                                return {
                                    stop: () => {
                                        o.set(!0)
                                    },
                                    cut: () => {
                                        n.set(!0)
                                    },
                                    isStopped: o.get,
                                    isCut: n.get,
                                    event: e,
                                    setSource: t.set,
                                    getSource: t.get
                                }
                            })(o, r);
                        return a.fold((() => (s.logEventNoHandlers(t, n), yx.complete())), (e => {
                            const o = e.descHandler;
                            return wa(o)(i), i.isStopped() ? (s.logEventStopped(t, e.element, o.purpose), yx.stopped()) : i.isCut() ? (s.logEventCut(t, e.element, o.purpose), yx.complete()) : et(e.element).fold((() => (s.logNoParent(t, e.element, o.purpose), yx.complete())), (n => (s.logEventResponse(t, e.element, o.purpose), yx.resume(n))))
                        }))
                    },
                    xx = (e, t, o, n, r, s) => wx(e, t, o, n, r, s).fold(T, (n => xx(e, t, o, n, r, s)), O),
                    Cx = (e, t, o, n, r) => {
                        const s = bx(o, n);
                        return xx(e, t, o, n, s, r)
                    },
                    Sx = () => {
                        const e = (() => {
                                const e = {};
                                return {
                                    registerId: (t, o, n) => {
                                        le(n, ((n, r) => {
                                            const s = void 0 !== e[r] ? e[r] : {};
                                            s[o] = ((e, t) => ({
                                                cHandler: C.apply(void 0, [e.handler].concat(t)),
                                                purpose: e.purpose
                                            }))(n, t), e[r] = s
                                        }))
                                    },
                                    unregisterId: t => {
                                        le(e, ((e, o) => {
                                            be(e, t) && delete e[t]
                                        }))
                                    },
                                    filterByType: t => ve(e, t).map((e => he(e, ((e, t) => ((e, t) => ({
                                        id: e,
                                        descHandler: t
                                    }))(t, e))))).getOr([]),
                                    find: (t, o, n) => ve(e, o).bind((e => Or(n, (t => ((e, t) => sa(t).bind((t => ve(e, t))).map((e => ((e, t) => ({
                                        element: e,
                                        descHandler: t
                                    }))(t, e))))(e, t)), t)))
                                }
                            })(),
                            t = {},
                            o = o => {
                                sa(o.element).each((o => {
                                    delete t[o], e.unregisterId(o)
                                }))
                            };
                        return {
                            find: (t, o, n) => e.find(t, o, n),
                            filter: t => e.filterByType(t),
                            register: n => {
                                const r = (e => {
                                    const t = e.element;
                                    return sa(t).getOrThunk((() => ((e, t) => {
                                        const o = Qs(oa + "uid-");
                                        return ra(t, o), o
                                    })(0, e.element)))
                                })(n);
                                ye(t, r) && ((e, n) => {
                                    const r = t[n];
                                    if (r !== e) throw new Error('The tagId "' + n + '" is already used by: ' + Gs(r.element) + "\nCannot use it for: " + Gs(e.element) + "\nThe conflicting element is" + (ht(r.element) ? " " : " not ") + "already in the DOM");
                                    o(e)
                                })(n, r);
                                const s = [n];
                                e.registerId(s, r, n.events), t[r] = n
                            },
                            unregister: o,
                            getById: e => ve(t, e)
                        }
                    },
                    kx = rm({
                        name: "Container",
                        factory: e => {
                            const {
                                attributes: t,
                                ...o
                            } = e.dom;
                            return {
                                uid: e.uid,
                                dom: {
                                    tag: "div",
                                    attributes: {
                                        role: "presentation",
                                        ...t
                                    },
                                    ...o
                                },
                                components: e.components,
                                behaviours: ru(e.containerBehaviours),
                                events: e.events,
                                domModification: e.domModification,
                                eventOrder: e.eventOrder
                            }
                        },
                        configFields: [ur("components", []), nu("containerBehaviours", []), ur("events", {}), ur("domModification", {}), ur("eventOrder", {})]
                    }),
                    _x = e => {
                        const t = t => et(e.element).fold(T, (e => Ge(t, e))),
                            o = Sx(),
                            n = (e, n) => o.find(t, e, n),
                            r = vx(e.element, {
                                triggerEvent: (e, t) => mi(e, t.target, (o => ((e, t, o, n) => Cx(e, t, o, o.target, n))(n, e, t, o)))
                            }),
                            s = {
                                debugInfo: y("real"),
                                triggerEvent: (e, t, o) => {
                                    mi(e, t, (r => Cx(n, e, o, t, r)))
                                },
                                triggerFocus: (e, t) => {
                                    sa(e).fold((() => {
                                        xl(e)
                                    }), (o => {
                                        mi(Qr(), e, (o => (((e, t, o, n, r) => {
                                            const s = bx(o, n);
                                            wx(e, t, o, n, s, r)
                                        })(n, Qr(), {
                                            originator: t,
                                            kill: v,
                                            prevent: v,
                                            target: e
                                        }, e, o), !1)))
                                    }))
                                },
                                triggerEscape: (e, t) => {
                                    s.triggerEvent("keydown", e.element, t.event)
                                },
                                getByUid: e => h(e),
                                getByDom: e => p(e),
                                build: Ka,
                                buildOrPatch: Ga,
                                addToGui: e => {
                                    l(e)
                                },
                                removeFromGui: e => {
                                    c(e)
                                },
                                addToWorld: e => {
                                    a(e)
                                },
                                removeFromWorld: e => {
                                    i(e)
                                },
                                broadcast: e => {
                                    u(e)
                                },
                                broadcastOn: (e, t) => {
                                    m(e, t)
                                },
                                broadcastEvent: (e, t) => {
                                    g(e, t)
                                },
                                isConnected: T
                            },
                            a = e => {
                                e.connect(s), Ze(e.element) || (o.register(e), F(e.components(), a), s.triggerEvent(cs(), e.element, {
                                    target: e.element
                                }))
                            },
                            i = e => {
                                Ze(e.element) || (F(e.components(), i), o.unregister(e)), e.disconnect()
                            },
                            l = t => {
                                bd(e, t)
                            },
                            c = e => {
                                xd(e)
                            },
                            d = e => {
                                const t = o.filter(os());
                                F(t, (t => {
                                    const o = t.descHandler;
                                    wa(o)(e)
                                }))
                            },
                            u = e => {
                                d({
                                    universal: !0,
                                    data: e
                                })
                            },
                            m = (e, t) => {
                                d({
                                    universal: !1,
                                    channels: e,
                                    data: t
                                })
                            },
                            g = (e, t) => ((e, t, o) => {
                                const n = (e => {
                                    const t = wr(!1);
                                    return {
                                        stop: () => {
                                            t.set(!0)
                                        },
                                        cut: v,
                                        isStopped: t.get,
                                        isCut: O,
                                        event: e,
                                        setSource: k("Cannot set source of a broadcasted event"),
                                        getSource: k("Cannot get source of a broadcasted event")
                                    }
                                })(t);
                                return F(e, (e => {
                                    const t = e.descHandler;
                                    wa(t)(n)
                                })), n.isStopped()
                            })(o.filter(e), t),
                            h = e => o.getById(e).fold((() => Xo.error(new Error('Could not find component with uid: "' + e + '" in system.'))), Xo.value),
                            p = e => {
                                const t = sa(e).getOr("not found");
                                return h(t)
                            };
                        return a(e), {
                            root: e,
                            element: e.element,
                            destroy: () => {
                                r.unbind(), Ho(e.element)
                            },
                            add: l,
                            remove: c,
                            getByUid: h,
                            getByDom: p,
                            addToWorld: a,
                            removeFromWorld: i,
                            broadcast: u,
                            broadcastOn: m,
                            broadcastEvent: g
                        }
                    },
                    Ox = y([ur("prefix", "form-field"), nu("fieldBehaviours", [cm, ou])]),
                    Tx = y([Ru({
                        schema: [Gn("dom")],
                        name: "label"
                    }), Ru({
                        factory: {
                            sketch: e => ({
                                uid: e.uid,
                                dom: {
                                    tag: "span",
                                    styles: {
                                        display: "none"
                                    },
                                    attributes: {
                                        "aria-hidden": "true"
                                    },
                                    innerHtml: e.text
                                }
                            })
                        },
                        schema: [Gn("text")],
                        name: "aria-descriptor"
                    }), Mu({
                        factory: {
                            sketch: e => {
                                const t = ((e, t) => {
                                    const o = {};
                                    return le(e, ((e, n) => {
                                        L(t, n) || (o[n] = e)
                                    })), o
                                })(e, ["factory"]);
                                return e.factory.sketch(t)
                            }
                        },
                        schema: [Gn("factory")],
                        name: "field"
                    })]),
                    Ex = sm({
                        name: "FormField",
                        configFields: Ox(),
                        partFields: Tx(),
                        factory: (e, t, o, n) => {
                            const r = su(e.fieldBehaviours, [cm.config({
                                    find: t => ju(t, e, "field")
                                }), ou.config({
                                    store: {
                                        mode: "manual",
                                        getValue: e => cm.getCurrent(e).bind(ou.getValue),
                                        setValue: (e, t) => {
                                            cm.getCurrent(e).each((e => {
                                                ou.setValue(e, t)
                                            }))
                                        }
                                    }
                                })]),
                                s = Ms([Vs(((t, o) => {
                                    const n = $u(t, e, ["label", "field", "aria-descriptor"]);
                                    n.field().each((t => {
                                        const o = Qs(e.prefix);
                                        n.label().each((e => {
                                            bt(e.element, "for", o), bt(t.element, "id", o)
                                        })), n["aria-descriptor"]().each((o => {
                                            const n = Qs(e.prefix);
                                            bt(o.element, "id", n), bt(t.element, "aria-describedby", n)
                                        }))
                                    }))
                                }))]),
                                a = {
                                    getField: t => ju(t, e, "field"),
                                    getLabel: t => ju(t, e, "label")
                                };
                            return {
                                uid: e.uid,
                                dom: e.dom,
                                components: t,
                                behaviours: r,
                                events: s,
                                apis: a
                            }
                        },
                        apis: {
                            getField: (e, t) => e.getField(t),
                            getLabel: (e, t) => e.getLabel(t)
                        }
                    });
                var Ax = Object.freeze({
                        __proto__: null,
                        exhibit: (e, t) => ya({
                            attributes: Sr([{
                                key: t.tabAttr,
                                value: "true"
                            }])
                        })
                    }),
                    Mx = [ur("tabAttr", "data-alloy-tabstop")];
                const Nx = pl({
                    fields: Mx,
                    name: "tabstopping",
                    active: Ax
                });
                var Rx = tinymce.util.Tools.resolve("tinymce.html.Entities");
                const Dx = (e, t, o, n) => {
                        const r = Bx(e, t, o, n);
                        return Ex.sketch(r)
                    },
                    Bx = (e, t, o, n) => ({
                        dom: Lx(o),
                        components: e.toArray().concat([t]),
                        fieldBehaviours: gl(n)
                    }),
                    Lx = e => ({
                        tag: "div",
                        classes: ["tox-form__group"].concat(e)
                    }),
                    Hx = (e, t) => Ex.parts.label({
                        dom: {
                            tag: "label",
                            classes: ["tox-label"]
                        },
                        components: [Wa(t.translate(e))]
                    }),
                    Ix = Qs("form-component-change"),
                    Px = Qs("form-close"),
                    zx = Qs("form-cancel"),
                    Fx = Qs("form-action"),
                    Vx = Qs("form-submit"),
                    Zx = Qs("form-block"),
                    Ux = Qs("form-unblock"),
                    jx = Qs("form-tabchange"),
                    Wx = Qs("form-resize"),
                    $x = ["input", "textarea"],
                    qx = e => {
                        const t = ze(e);
                        return L($x, t)
                    },
                    Gx = (e, t) => {
                        const o = t.getRoot(e).getOr(e.element);
                        Ra(o, t.invalidClass), t.notify.each((t => {
                            qx(e.element) && bt(e.element, "aria-invalid", !1), t.getContainer(e).each((e => {
                                $s(e, t.validHtml)
                            })), t.onValid(e)
                        }))
                    },
                    Kx = (e, t, o, n) => {
                        const r = t.getRoot(e).getOr(e.element);
                        Na(r, t.invalidClass), t.notify.each((t => {
                            qx(e.element) && bt(e.element, "aria-invalid", !0), t.getContainer(e).each((e => {
                                $s(e, n)
                            })), t.onInvalid(e, n)
                        }))
                    },
                    Yx = (e, t, o) => t.validator.fold((() => jw(Xo.value(!0))), (t => t.validate(e))),
                    Xx = (e, t, o) => (t.notify.each((t => {
                        t.onValidate(e)
                    })), Yx(e, t).map((o => e.getSystem().isConnected() ? o.fold((o => (Kx(e, t, 0, o), Xo.error(o))), (o => (Gx(e, t), Xo.value(o)))) : Xo.error("No longer in system"))));
                var Jx = Object.freeze({
                        __proto__: null,
                        markValid: Gx,
                        markInvalid: Kx,
                        query: Yx,
                        run: Xx,
                        isInvalid: (e, t) => {
                            const o = t.getRoot(e).getOr(e.element);
                            return Da(o, t.invalidClass)
                        }
                    }),
                    Qx = Object.freeze({
                        __proto__: null,
                        events: (e, t) => e.validator.map((t => Ms([Ds(t.onEvent, (t => {
                            Xx(t, e).get(w)
                        }))].concat(t.validateOnLoad ? [Vs((t => {
                            Xx(t, e).get(v)
                        }))] : [])))).getOr({})
                    }),
                    eC = [Gn("invalidClass"), ur("getRoot", A.none), dr("notify", [ur("aria", "alert"), ur("getContainer", A.none), ur("validHtml", ""), xi("onValid"), xi("onInvalid"), xi("onValidate")]), dr("validator", [Gn("validate"), ur("onEvent", "input"), ur("validateOnLoad", !0)])];
                const tC = pl({
                        fields: eC,
                        name: "invalidating",
                        active: Qx,
                        apis: Jx,
                        extra: {
                            validation: e => t => {
                                const o = ou.getValue(t);
                                return jw(e(o))
                            }
                        }
                    }),
                    oC = pl({
                        fields: [],
                        name: "unselecting",
                        active: Object.freeze({
                            __proto__: null,
                            events: () => Ms([Ns(Yr(), T)]),
                            exhibit: () => ya({
                                styles: {
                                    "-webkit-user-select": "none",
                                    "user-select": "none",
                                    "-ms-user-select": "none",
                                    "-moz-user-select": "-moz-none"
                                },
                                attributes: {
                                    unselectable: "on"
                                }
                            })
                        })
                    }),
                    nC = Qs("color-input-change"),
                    rC = Qs("color-swatch-change"),
                    sC = Qs("color-picker-cancel"),
                    aC = Ru({
                        schema: [Gn("dom")],
                        name: "label"
                    }),
                    iC = e => Ru({
                        name: e + "-edge",
                        overrides: t => t.model.manager.edgeActions[e].fold((() => ({})), (e => ({
                            events: Ms([Bs(Nr(), ((t, o, n) => e(t, n)), [t]), Bs(Lr(), ((t, o, n) => e(t, n)), [t]), Bs(Hr(), ((t, o, n) => {
                                n.mouseIsDown.get() && e(t, n)
                            }), [t])])
                        })))
                    }),
                    lC = iC("top-left"),
                    cC = iC("top"),
                    dC = iC("top-right"),
                    uC = iC("right"),
                    mC = iC("bottom-right"),
                    gC = iC("bottom"),
                    hC = iC("bottom-left");
                var pC = [aC, iC("left"), uC, cC, gC, lC, dC, hC, mC, Mu({
                    name: "thumb",
                    defaults: y({
                        dom: {
                            styles: {
                                position: "absolute"
                            }
                        }
                    }),
                    overrides: e => ({
                        events: Ms([Hs(Nr(), e, "spectrum"), Hs(Rr(), e, "spectrum"), Hs(Dr(), e, "spectrum"), Hs(Lr(), e, "spectrum"), Hs(Hr(), e, "spectrum"), Hs(Pr(), e, "spectrum")])
                    })
                }), Mu({
                    schema: [$n("mouseIsDown", (() => wr(!1)))],
                    name: "spectrum",
                    overrides: e => {
                        const t = e.model.manager,
                            o = (o, n) => t.getValueFromEvent(n).map((n => t.setValueFrom(o, e, n)));
                        return {
                            behaviours: gl([Th.config({
                                mode: "special",
                                onLeft: o => t.onLeft(o, e),
                                onRight: o => t.onRight(o, e),
                                onUp: o => t.onUp(o, e),
                                onDown: o => t.onDown(o, e)
                            }), Zh.config({})]),
                            events: Ms([Ds(Nr(), o), Ds(Rr(), o), Ds(Lr(), o), Ds(Hr(), ((t, n) => {
                                e.mouseIsDown.get() && o(t, n)
                            }))])
                        }
                    }
                })];
                const fC = y("slider.change.value"),
                    vC = e => {
                        const t = e.event.raw;
                        if ((e => -1 !== e.type.indexOf("touch"))(t)) {
                            const e = t;
                            return void 0 !== e.touches && 1 === e.touches.length ? A.some(e.touches[0]).map((e => Vt(e.clientX, e.clientY))) : A.none()
                        } {
                            const e = t;
                            return void 0 !== e.clientX ? A.some(e).map((e => Vt(e.clientX, e.clientY))) : A.none()
                        }
                    },
                    bC = e => e.model.minX,
                    yC = e => e.model.minY,
                    wC = e => e.model.minX - 1,
                    xC = e => e.model.minY - 1,
                    CC = e => e.model.maxX,
                    SC = e => e.model.maxY,
                    kC = e => e.model.maxX + 1,
                    _C = e => e.model.maxY + 1,
                    OC = (e, t, o) => t(e) - o(e),
                    TC = e => OC(e, CC, bC),
                    EC = e => OC(e, SC, yC),
                    AC = e => TC(e) / 2,
                    MC = e => EC(e) / 2,
                    NC = e => e.stepSize,
                    RC = e => e.snapToGrid,
                    DC = e => e.snapStart,
                    BC = e => e.rounded,
                    LC = (e, t) => void 0 !== e[t + "-edge"],
                    HC = e => LC(e, "left"),
                    IC = e => LC(e, "right"),
                    PC = e => LC(e, "top"),
                    zC = e => LC(e, "bottom"),
                    FC = e => e.model.value.get(),
                    VC = (e, t) => ({
                        x: e,
                        y: t
                    }),
                    ZC = (e, t) => {
                        _s(e, fC(), {
                            value: t
                        })
                    },
                    UC = (e, t, o, n) => e < t ? e : e > o ? o : e === t ? t - 1 : Math.max(t, e - n),
                    jC = (e, t, o, n) => e > o ? e : e < t ? t : e === o ? o + 1 : Math.min(o, e + n),
                    WC = (e, t, o) => Math.max(t, Math.min(o, e)),
                    $C = e => {
                        const {
                            min: t,
                            max: o,
                            range: n,
                            value: r,
                            step: s,
                            snap: a,
                            snapStart: i,
                            rounded: l,
                            hasMinEdge: c,
                            hasMaxEdge: d,
                            minBound: u,
                            maxBound: m,
                            screenRange: g
                        } = e, h = c ? t - 1 : t, p = d ? o + 1 : o;
                        if (r < u) return h;
                        if (r > m) return p; {
                            const e = ((e, t, o) => Math.min(o, Math.max(e, t)) - t)(r, u, m),
                                c = WC(e / g * n + t, h, p);
                            return a && c >= t && c <= o ? ((e, t, o, n, r) => r.fold((() => {
                                const r = e - t,
                                    s = Math.round(r / n) * n;
                                return WC(t + s, t - 1, o + 1)
                            }), (t => {
                                const r = (e - t) % n,
                                    s = Math.round(r / n),
                                    a = Math.floor((e - t) / n),
                                    i = Math.floor((o - t) / n),
                                    l = t + Math.min(i, a + s) * n;
                                return Math.max(t, l)
                            })))(c, t, o, s, i) : l ? Math.round(c) : c
                        }
                    },
                    qC = e => {
                        const {
                            min: t,
                            max: o,
                            range: n,
                            value: r,
                            hasMinEdge: s,
                            hasMaxEdge: a,
                            maxBound: i,
                            maxOffset: l,
                            centerMinEdge: c,
                            centerMaxEdge: d
                        } = e;
                        return r < t ? s ? 0 : c : r > o ? a ? i : d : (r - t) / n * l
                    },
                    GC = "top",
                    KC = "right",
                    YC = "bottom",
                    XC = "left",
                    JC = e => e.element.dom.getBoundingClientRect(),
                    QC = (e, t) => e[t],
                    eS = e => {
                        const t = JC(e);
                        return QC(t, XC)
                    },
                    tS = e => {
                        const t = JC(e);
                        return QC(t, KC)
                    },
                    oS = e => {
                        const t = JC(e);
                        return QC(t, GC)
                    },
                    nS = e => {
                        const t = JC(e);
                        return QC(t, YC)
                    },
                    rS = e => {
                        const t = JC(e);
                        return QC(t, "width")
                    },
                    sS = e => {
                        const t = JC(e);
                        return QC(t, "height")
                    },
                    aS = (e, t, o) => (e + t) / 2 - o,
                    iS = (e, t) => {
                        const o = JC(e),
                            n = JC(t),
                            r = QC(o, XC),
                            s = QC(o, KC),
                            a = QC(n, XC);
                        return aS(r, s, a)
                    },
                    lS = (e, t) => {
                        const o = JC(e),
                            n = JC(t),
                            r = QC(o, GC),
                            s = QC(o, YC),
                            a = QC(n, GC);
                        return aS(r, s, a)
                    },
                    cS = (e, t) => {
                        _s(e, fC(), {
                            value: t
                        })
                    },
                    dS = (e, t, o) => {
                        const n = {
                            min: bC(t),
                            max: CC(t),
                            range: TC(t),
                            value: o,
                            step: NC(t),
                            snap: RC(t),
                            snapStart: DC(t),
                            rounded: BC(t),
                            hasMinEdge: HC(t),
                            hasMaxEdge: IC(t),
                            minBound: eS(e),
                            maxBound: tS(e),
                            screenRange: rS(e)
                        };
                        return $C(n)
                    },
                    uS = e => (t, o) => ((e, t, o) => {
                        const n = (e > 0 ? jC : UC)(FC(o), bC(o), CC(o), NC(o));
                        return cS(t, n), A.some(n)
                    })(e, t, o).map(T),
                    mS = (e, t, o, n, r, s) => {
                        const a = ((e, t, o, n, r) => {
                            const s = rS(e),
                                a = n.bind((t => A.some(iS(t, e)))).getOr(0),
                                i = r.bind((t => A.some(iS(t, e)))).getOr(s),
                                l = {
                                    min: bC(t),
                                    max: CC(t),
                                    range: TC(t),
                                    value: o,
                                    hasMinEdge: HC(t),
                                    hasMaxEdge: IC(t),
                                    minBound: eS(e),
                                    minOffset: 0,
                                    maxBound: tS(e),
                                    maxOffset: s,
                                    centerMinEdge: a,
                                    centerMaxEdge: i
                                };
                            return qC(l)
                        })(t, s, o, n, r);
                        return eS(t) - eS(e) + a
                    },
                    gS = uS(-1),
                    hS = uS(1),
                    pS = A.none,
                    fS = A.none,
                    vS = {
                        "top-left": A.none(),
                        top: A.none(),
                        "top-right": A.none(),
                        right: A.some(((e, t) => {
                            ZC(e, kC(t))
                        })),
                        "bottom-right": A.none(),
                        bottom: A.none(),
                        "bottom-left": A.none(),
                        left: A.some(((e, t) => {
                            ZC(e, wC(t))
                        }))
                    };
                var bS = Object.freeze({
                    __proto__: null,
                    setValueFrom: (e, t, o) => {
                        const n = dS(e, t, o);
                        return cS(e, n), n
                    },
                    setToMin: (e, t) => {
                        const o = bC(t);
                        cS(e, o)
                    },
                    setToMax: (e, t) => {
                        const o = CC(t);
                        cS(e, o)
                    },
                    findValueOfOffset: dS,
                    getValueFromEvent: e => vC(e).map((e => e.left)),
                    findPositionOfValue: mS,
                    setPositionFromValue: (e, t, o, n) => {
                        const r = FC(o),
                            s = mS(e, n.getSpectrum(e), r, n.getLeftEdge(e), n.getRightEdge(e), o),
                            a = $t(t.element) / 2;
                        Ot(t.element, "left", s - a + "px")
                    },
                    onLeft: gS,
                    onRight: hS,
                    onUp: pS,
                    onDown: fS,
                    edgeActions: vS
                });
                const yS = (e, t) => {
                        _s(e, fC(), {
                            value: t
                        })
                    },
                    wS = (e, t, o) => {
                        const n = {
                            min: yC(t),
                            max: SC(t),
                            range: EC(t),
                            value: o,
                            step: NC(t),
                            snap: RC(t),
                            snapStart: DC(t),
                            rounded: BC(t),
                            hasMinEdge: PC(t),
                            hasMaxEdge: zC(t),
                            minBound: oS(e),
                            maxBound: nS(e),
                            screenRange: sS(e)
                        };
                        return $C(n)
                    },
                    xS = e => (t, o) => ((e, t, o) => {
                        const n = (e > 0 ? jC : UC)(FC(o), yC(o), SC(o), NC(o));
                        return yS(t, n), A.some(n)
                    })(e, t, o).map(T),
                    CS = (e, t, o, n, r, s) => {
                        const a = ((e, t, o, n, r) => {
                            const s = sS(e),
                                a = n.bind((t => A.some(lS(t, e)))).getOr(0),
                                i = r.bind((t => A.some(lS(t, e)))).getOr(s),
                                l = {
                                    min: yC(t),
                                    max: SC(t),
                                    range: EC(t),
                                    value: o,
                                    hasMinEdge: PC(t),
                                    hasMaxEdge: zC(t),
                                    minBound: oS(e),
                                    minOffset: 0,
                                    maxBound: nS(e),
                                    maxOffset: s,
                                    centerMinEdge: a,
                                    centerMaxEdge: i
                                };
                            return qC(l)
                        })(t, s, o, n, r);
                        return oS(t) - oS(e) + a
                    },
                    SS = A.none,
                    kS = A.none,
                    _S = xS(-1),
                    OS = xS(1),
                    TS = {
                        "top-left": A.none(),
                        top: A.some(((e, t) => {
                            ZC(e, xC(t))
                        })),
                        "top-right": A.none(),
                        right: A.none(),
                        "bottom-right": A.none(),
                        bottom: A.some(((e, t) => {
                            ZC(e, _C(t))
                        })),
                        "bottom-left": A.none(),
                        left: A.none()
                    };
                var ES = Object.freeze({
                    __proto__: null,
                    setValueFrom: (e, t, o) => {
                        const n = wS(e, t, o);
                        return yS(e, n), n
                    },
                    setToMin: (e, t) => {
                        const o = yC(t);
                        yS(e, o)
                    },
                    setToMax: (e, t) => {
                        const o = SC(t);
                        yS(e, o)
                    },
                    findValueOfOffset: wS,
                    getValueFromEvent: e => vC(e).map((e => e.top)),
                    findPositionOfValue: CS,
                    setPositionFromValue: (e, t, o, n) => {
                        const r = FC(o),
                            s = CS(e, n.getSpectrum(e), r, n.getTopEdge(e), n.getBottomEdge(e), o),
                            a = Pt(t.element) / 2;
                        Ot(t.element, "top", s - a + "px")
                    },
                    onLeft: SS,
                    onRight: kS,
                    onUp: _S,
                    onDown: OS,
                    edgeActions: TS
                });
                const AS = (e, t) => {
                        _s(e, fC(), {
                            value: t
                        })
                    },
                    MS = (e, t) => ({
                        x: e,
                        y: t
                    }),
                    NS = (e, t) => (o, n) => ((e, t, o, n) => {
                        const r = e > 0 ? jC : UC,
                            s = t ? FC(n).x : r(FC(n).x, bC(n), CC(n), NC(n)),
                            a = t ? r(FC(n).y, yC(n), SC(n), NC(n)) : FC(n).y;
                        return AS(o, MS(s, a)), A.some(s)
                    })(e, t, o, n).map(T),
                    RS = NS(-1, !1),
                    DS = NS(1, !1),
                    BS = NS(-1, !0),
                    LS = NS(1, !0),
                    HS = {
                        "top-left": A.some(((e, t) => {
                            ZC(e, VC(wC(t), xC(t)))
                        })),
                        top: A.some(((e, t) => {
                            ZC(e, VC(AC(t), xC(t)))
                        })),
                        "top-right": A.some(((e, t) => {
                            ZC(e, VC(kC(t), xC(t)))
                        })),
                        right: A.some(((e, t) => {
                            ZC(e, VC(kC(t), MC(t)))
                        })),
                        "bottom-right": A.some(((e, t) => {
                            ZC(e, VC(kC(t), _C(t)))
                        })),
                        bottom: A.some(((e, t) => {
                            ZC(e, VC(AC(t), _C(t)))
                        })),
                        "bottom-left": A.some(((e, t) => {
                            ZC(e, VC(wC(t), _C(t)))
                        })),
                        left: A.some(((e, t) => {
                            ZC(e, VC(wC(t), MC(t)))
                        }))
                    };
                var IS = Object.freeze({
                    __proto__: null,
                    setValueFrom: (e, t, o) => {
                        const n = dS(e, t, o.left),
                            r = wS(e, t, o.top),
                            s = MS(n, r);
                        return AS(e, s), s
                    },
                    setToMin: (e, t) => {
                        const o = bC(t),
                            n = yC(t);
                        AS(e, MS(o, n))
                    },
                    setToMax: (e, t) => {
                        const o = CC(t),
                            n = SC(t);
                        AS(e, MS(o, n))
                    },
                    getValueFromEvent: e => vC(e),
                    setPositionFromValue: (e, t, o, n) => {
                        const r = FC(o),
                            s = mS(e, n.getSpectrum(e), r.x, n.getLeftEdge(e), n.getRightEdge(e), o),
                            a = CS(e, n.getSpectrum(e), r.y, n.getTopEdge(e), n.getBottomEdge(e), o),
                            i = $t(t.element) / 2,
                            l = Pt(t.element) / 2;
                        Ot(t.element, "left", s - i + "px"), Ot(t.element, "top", a - l + "px")
                    },
                    onLeft: RS,
                    onRight: DS,
                    onUp: BS,
                    onDown: LS,
                    edgeActions: HS
                });
                const PS = sm({
                        name: "Slider",
                        configFields: [ur("stepSize", 1), ur("onChange", v), ur("onChoose", v), ur("onInit", v), ur("onDragStart", v), ur("onDragEnd", v), ur("snapToGrid", !1), ur("rounded", !0), nr("snapStart"), Kn("model", jn("mode", {
                            x: [ur("minX", 0), ur("maxX", 100), $n("value", (e => wr(e.mode.minX))), Gn("getInitialValue"), _i("manager", bS)],
                            y: [ur("minY", 0), ur("maxY", 100), $n("value", (e => wr(e.mode.minY))), Gn("getInitialValue"), _i("manager", ES)],
                            xy: [ur("minX", 0), ur("maxX", 100), ur("minY", 0), ur("maxY", 100), $n("value", (e => wr({
                                x: e.mode.minX,
                                y: e.mode.minY
                            }))), Gn("getInitialValue"), _i("manager", IS)]
                        })), nu("sliderBehaviours", [Th, ou]), $n("mouseIsDown", (() => wr(!1)))],
                        partFields: pC,
                        factory: (e, t, o, n) => {
                            const r = t => Wu(t, e, "thumb"),
                                s = t => Wu(t, e, "spectrum"),
                                a = t => ju(t, e, "left-edge"),
                                i = t => ju(t, e, "right-edge"),
                                l = t => ju(t, e, "top-edge"),
                                c = t => ju(t, e, "bottom-edge"),
                                d = e.model,
                                u = d.manager,
                                m = (t, o) => {
                                    u.setPositionFromValue(t, o, e, {
                                        getLeftEdge: a,
                                        getRightEdge: i,
                                        getTopEdge: l,
                                        getBottomEdge: c,
                                        getSpectrum: s
                                    })
                                },
                                g = (e, t) => {
                                    d.value.set(t);
                                    const o = r(e);
                                    m(e, o)
                                },
                                h = t => {
                                    const o = e.mouseIsDown.get();
                                    e.mouseIsDown.set(!1), o && ju(t, e, "thumb").each((o => {
                                        const n = d.value.get();
                                        e.onChoose(t, o, n)
                                    }))
                                },
                                p = (t, o) => {
                                    o.stop(), e.mouseIsDown.set(!0), e.onDragStart(t, r(t))
                                },
                                f = (t, o) => {
                                    o.stop(), e.onDragEnd(t, r(t)), h(t)
                                };
                            return {
                                uid: e.uid,
                                dom: e.dom,
                                components: t,
                                behaviours: su(e.sliderBehaviours, [Th.config({
                                    mode: "special",
                                    focusIn: t => ju(t, e, "spectrum").map(Th.focusIn).map(T)
                                }), ou.config({
                                    store: {
                                        mode: "manual",
                                        getValue: e => d.value.get(),
                                        setValue: g
                                    }
                                }), yl.config({
                                    channels: {
                                        [zd()]: {
                                            onReceive: h
                                        }
                                    }
                                })]),
                                events: Ms([Ds(fC(), ((t, o) => {
                                    ((t, o) => {
                                        g(t, o);
                                        const n = r(t);
                                        e.onChange(t, n, o), A.some(!0)
                                    })(t, o.event.value)
                                })), Vs(((t, o) => {
                                    const n = d.getInitialValue();
                                    d.value.set(n);
                                    const a = r(t);
                                    m(t, a);
                                    const i = s(t);
                                    e.onInit(t, a, i, d.value.get())
                                })), Ds(Nr(), p), Ds(Dr(), f), Ds(Lr(), p), Ds(Pr(), f)]),
                                apis: {
                                    resetToMin: t => {
                                        u.setToMin(t, e)
                                    },
                                    resetToMax: t => {
                                        u.setToMax(t, e)
                                    },
                                    setValue: g,
                                    refresh: m
                                },
                                domModification: {
                                    styles: {
                                        position: "relative"
                                    }
                                }
                            }
                        },
                        apis: {
                            setValue: (e, t, o) => {
                                e.setValue(t, o)
                            },
                            resetToMin: (e, t) => {
                                e.resetToMin(t)
                            },
                            resetToMax: (e, t) => {
                                e.resetToMax(t)
                            },
                            refresh: (e, t) => {
                                e.refresh(t)
                            }
                        }
                    }),
                    zS = Qs("rgb-hex-update"),
                    FS = Qs("slider-update"),
                    VS = Qs("palette-update"),
                    ZS = "form",
                    US = [nu("formBehaviours", [ou])],
                    jS = e => "<alloy.field." + e + ">",
                    WS = (e, t) => ({
                        uid: e.uid,
                        dom: e.dom,
                        components: t,
                        behaviours: su(e.formBehaviours, [ou.config({
                            store: {
                                mode: "manual",
                                getValue: t => {
                                    const o = qu(t, e);
                                    return ce(o, ((e, t) => e().bind((e => {
                                        return o = cm.getCurrent(e), n = new Error(`Cannot find a current component to extract the value from for form part '${t}': ` + Gs(e.element)), o.fold((() => Xo.error(n)), Xo.value);
                                        var o, n
                                    })).map(ou.getValue)))
                                },
                                setValue: (t, o) => {
                                    le(o, ((o, n) => {
                                        ju(t, e, n).each((e => {
                                            cm.getCurrent(e).each((e => {
                                                ou.setValue(e, o)
                                            }))
                                        }))
                                    }))
                                }
                            }
                        })]),
                        apis: {
                            getField: (t, o) => ju(t, e, o).bind(cm.getCurrent)
                        }
                    }),
                    $S = {
                        getField: pa(((e, t, o) => e.getField(t, o))),
                        sketch: e => {
                            const t = (() => {
                                    const e = [];
                                    return {
                                        field: (t, o) => (e.push(t), zu(ZS, jS(t), o)),
                                        record: y(e)
                                    }
                                })(),
                                o = e(t),
                                n = t.record(),
                                r = z(n, (e => Mu({
                                    name: e,
                                    pname: jS(e)
                                })));
                            return em(ZS, US, r, WS, o)
                        }
                    },
                    qS = Qs("valid-input"),
                    GS = Qs("invalid-input"),
                    KS = Qs("validating-input"),
                    YS = "colorcustom.rgb.",
                    XS = (e, t, o, n) => {
                        const r = (o, n) => tC.config({
                                invalidClass: t("invalid"),
                                notify: {
                                    onValidate: e => {
                                        _s(e, KS, {
                                            type: o
                                        })
                                    },
                                    onValid: e => {
                                        _s(e, qS, {
                                            type: o,
                                            value: ou.getValue(e)
                                        })
                                    },
                                    onInvalid: e => {
                                        _s(e, GS, {
                                            type: o,
                                            value: ou.getValue(e)
                                        })
                                    }
                                },
                                validator: {
                                    validate: t => {
                                        const o = ou.getValue(t),
                                            r = n(o) ? Xo.value(!0) : Xo.error(e("aria.input.invalid"));
                                        return jw(r)
                                    },
                                    validateOnLoad: !1
                                }
                            }),
                            s = (o, n, s, a, i) => {
                                const l = e(YS + "range"),
                                    c = Ex.parts.label({
                                        dom: {
                                            tag: "label",
                                            attributes: {
                                                "aria-label": a
                                            }
                                        },
                                        components: [Wa(s)]
                                    }),
                                    d = Ex.parts.field({
                                        data: i,
                                        factory: wv,
                                        inputAttributes: {
                                            type: "text",
                                            ..."hex" === n ? {
                                                "aria-live": "polite"
                                            } : {}
                                        },
                                        inputClasses: [t("textfield")],
                                        inputBehaviours: gl([r(n, o), Nx.config({})]),
                                        onSetValue: e => {
                                            tC.isInvalid(e) && tC.run(e).get(v)
                                        }
                                    }),
                                    u = [c, d],
                                    m = "hex" !== n ? [Ex.parts["aria-descriptor"]({
                                        text: l
                                    })] : [];
                                return {
                                    dom: {
                                        tag: "div",
                                        attributes: {
                                            role: "presentation"
                                        }
                                    },
                                    components: u.concat(m)
                                }
                            },
                            a = (e, t) => {
                                const o = t.red,
                                    n = t.green,
                                    r = t.blue;
                                ou.setValue(e, {
                                    red: o,
                                    green: n,
                                    blue: r
                                })
                            },
                            i = Mp({
                                dom: {
                                    tag: "div",
                                    classes: [t("rgba-preview")],
                                    styles: {
                                        "background-color": "white"
                                    },
                                    attributes: {
                                        role: "presentation"
                                    }
                                }
                            }),
                            l = (e, t) => {
                                i.getOpt(e).each((e => {
                                    Ot(e.element, "background-color", "#" + t.value)
                                }))
                            },
                            c = rm({
                                factory: () => {
                                    const r = {
                                            red: wr(A.some(255)),
                                            green: wr(A.some(255)),
                                            blue: wr(A.some(255)),
                                            hex: wr(A.some("ffffff"))
                                        },
                                        c = e => r[e].get(),
                                        d = (e, t) => {
                                            r[e].set(t)
                                        },
                                        u = e => {
                                            const t = e.red,
                                                o = e.green,
                                                n = e.blue;
                                            d("red", A.some(t)), d("green", A.some(o)), d("blue", A.some(n))
                                        },
                                        m = (e, t) => {
                                            const o = t.event;
                                            "hex" !== o.type ? d(o.type, A.none()) : n(e)
                                        },
                                        g = (e, t) => {
                                            const n = t.event;
                                            (e => "hex" === e.type)(n) ? ((e, t) => {
                                                o(e);
                                                const n = Ay(t);
                                                d("hex", A.some(t));
                                                const r = jy(n);
                                                a(e, r), u(r), _s(e, zS, {
                                                    hex: n
                                                }), l(e, n)
                                            })(e, n.value) : ((e, t, o) => {
                                                const n = parseInt(o, 10);
                                                d(t, A.some(n)), c("red").bind((e => c("green").bind((t => c("blue").map((o => Vy(e, t, o, 1))))))).each((t => {
                                                    const o = ((e, t) => {
                                                        const o = Ly(t);
                                                        return $S.getField(e, "hex").each((t => {
                                                            Zh.isFocused(t) || ou.setValue(e, {
                                                                hex: o.value
                                                            })
                                                        })), o
                                                    })(e, t);
                                                    _s(e, zS, {
                                                        hex: o
                                                    }), l(e, o)
                                                }))
                                            })(e, n.type, n.value)
                                        },
                                        h = t => ({
                                            label: e(YS + t + ".label"),
                                            description: e(YS + t + ".description")
                                        }),
                                        p = h("red"),
                                        f = h("green"),
                                        v = h("blue"),
                                        b = h("hex");
                                    return cn($S.sketch((o => ({
                                        dom: {
                                            tag: "form",
                                            classes: [t("rgb-form")],
                                            attributes: {
                                                "aria-label": e("aria.color.picker")
                                            }
                                        },
                                        components: [o.field("red", Ex.sketch(s(Zy, "red", p.label, p.description, 255))), o.field("green", Ex.sketch(s(Zy, "green", f.label, f.description, 255))), o.field("blue", Ex.sketch(s(Zy, "blue", v.label, v.description, 255))), o.field("hex", Ex.sketch(s(Ry, "hex", b.label, b.description, "ffffff"))), i.asSpec()],
                                        formBehaviours: gl([tC.config({
                                            invalidClass: t("form-invalid")
                                        }), Ih("rgb-form-events", [Ds(qS, g), Ds(GS, m), Ds(KS, m)])])
                                    }))), {
                                        apis: {
                                            updateHex: (e, t) => {
                                                ou.setValue(e, {
                                                    hex: t.value
                                                }), ((e, t) => {
                                                    const o = jy(t);
                                                    a(e, o), u(o)
                                                })(e, t), l(e, t)
                                            }
                                        }
                                    })
                                },
                                name: "RgbForm",
                                configFields: [],
                                apis: {
                                    updateHex: (e, t, o) => {
                                        e.updateHex(t, o)
                                    }
                                },
                                extraApis: {}
                            });
                        return c
                    },
                    JS = (e, t) => {
                        const o = rm({
                            name: "ColourPicker",
                            configFields: [Gn("dom"), ur("onValidHex", v), ur("onInvalidHex", v)],
                            factory: o => {
                                const n = XS(e, t, o.onValidHex, o.onInvalidHex),
                                    r = ((e, t) => {
                                        const o = PS.parts.spectrum({
                                                dom: {
                                                    tag: "canvas",
                                                    attributes: {
                                                        role: "presentation"
                                                    },
                                                    classes: [t("sv-palette-spectrum")]
                                                }
                                            }),
                                            n = PS.parts.thumb({
                                                dom: {
                                                    tag: "div",
                                                    attributes: {
                                                        role: "presentation"
                                                    },
                                                    classes: [t("sv-palette-thumb")],
                                                    innerHtml: `<div class=${t("sv-palette-inner-thumb")} role="presentation"></div>`
                                                }
                                            }),
                                            r = (e, t) => {
                                                const {
                                                    width: o,
                                                    height: n
                                                } = e, r = e.getContext("2d");
                                                if (null === r) return;
                                                r.fillStyle = t, r.fillRect(0, 0, o, n);
                                                const s = r.createLinearGradient(0, 0, o, 0);
                                                s.addColorStop(0, "rgba(255,255,255,1)"), s.addColorStop(1, "rgba(255,255,255,0)"), r.fillStyle = s, r.fillRect(0, 0, o, n);
                                                const a = r.createLinearGradient(0, 0, 0, n);
                                                a.addColorStop(0, "rgba(0,0,0,0)"), a.addColorStop(1, "rgba(0,0,0,1)"), r.fillStyle = a, r.fillRect(0, 0, o, n)
                                            };
                                        return rm({
                                            factory: e => {
                                                const s = y({
                                                        x: 0,
                                                        y: 0
                                                    }),
                                                    a = gl([cm.config({
                                                        find: A.some
                                                    }), Zh.config({})]);
                                                return PS.sketch({
                                                    dom: {
                                                        tag: "div",
                                                        attributes: {
                                                            role: "presentation"
                                                        },
                                                        classes: [t("sv-palette")]
                                                    },
                                                    model: {
                                                        mode: "xy",
                                                        getInitialValue: s
                                                    },
                                                    rounded: !1,
                                                    components: [o, n],
                                                    onChange: (e, t, o) => {
                                                        _s(e, VS, {
                                                            value: o
                                                        })
                                                    },
                                                    onInit: (e, t, o, n) => {
                                                        r(o.element.dom, qy(Gy))
                                                    },
                                                    sliderBehaviours: a
                                                })
                                            },
                                            name: "SaturationBrightnessPalette",
                                            configFields: [],
                                            apis: {
                                                setHue: (e, t, o) => {
                                                    ((e, t) => {
                                                        const o = e.components()[0].element.dom,
                                                            n = tw(t, 100, 100),
                                                            s = Uy(n);
                                                        r(o, qy(s))
                                                    })(t, o)
                                                },
                                                setThumb: (e, t, o) => {
                                                    ((e, t) => {
                                                        const o = ow(jy(t));
                                                        PS.setValue(e, {
                                                            x: o.saturation,
                                                            y: 100 - o.value
                                                        })
                                                    })(t, o)
                                                }
                                            },
                                            extraApis: {}
                                        })
                                    })(0, t),
                                    s = {
                                        paletteRgba: wr(Gy),
                                        paletteHue: wr(0)
                                    },
                                    a = Mp(((e, t) => {
                                        const o = PS.parts.spectrum({
                                                dom: {
                                                    tag: "div",
                                                    classes: [t("hue-slider-spectrum")],
                                                    attributes: {
                                                        role: "presentation"
                                                    }
                                                }
                                            }),
                                            n = PS.parts.thumb({
                                                dom: {
                                                    tag: "div",
                                                    classes: [t("hue-slider-thumb")],
                                                    attributes: {
                                                        role: "presentation"
                                                    }
                                                }
                                            });
                                        return PS.sketch({
                                            dom: {
                                                tag: "div",
                                                classes: [t("hue-slider")],
                                                attributes: {
                                                    role: "presentation"
                                                }
                                            },
                                            rounded: !1,
                                            model: {
                                                mode: "y",
                                                getInitialValue: y(0)
                                            },
                                            components: [o, n],
                                            sliderBehaviours: gl([Zh.config({})]),
                                            onChange: (e, t, o) => {
                                                _s(e, FS, {
                                                    value: o
                                                })
                                            }
                                        })
                                    })(0, t)),
                                    i = Mp(r.sketch({})),
                                    l = Mp(n.sketch({})),
                                    c = (e, t, o) => {
                                        i.getOpt(e).each((e => {
                                            r.setHue(e, o)
                                        }))
                                    },
                                    d = (e, t) => {
                                        l.getOpt(e).each((e => {
                                            n.updateHex(e, t)
                                        }))
                                    },
                                    u = (e, t, o) => {
                                        a.getOpt(e).each((e => {
                                            PS.setValue(e, (e => 100 - e / 360 * 100)(o))
                                        }))
                                    },
                                    m = (e, t) => {
                                        i.getOpt(e).each((e => {
                                            r.setThumb(e, t)
                                        }))
                                    },
                                    g = (e, t, o, n) => {
                                        ((e, t) => {
                                            const o = jy(e);
                                            s.paletteRgba.set(o), s.paletteHue.set(t)
                                        })(t, o), F(n, (n => {
                                            n(e, t, o)
                                        }))
                                    };
                                return {
                                    uid: o.uid,
                                    dom: o.dom,
                                    components: [i.asSpec(), a.asSpec(), l.asSpec()],
                                    behaviours: gl([Ih("colour-picker-events", [Ds(zS, (() => {
                                        const e = [c, u, m];
                                        return (t, o) => {
                                            const n = o.event.hex,
                                                r = (e => ow(jy(e)))(n);
                                            g(t, n, r.hue, e)
                                        }
                                    })()), Ds(VS, (() => {
                                        const e = [d];
                                        return (t, o) => {
                                            const n = o.event.value,
                                                r = s.paletteHue.get(),
                                                a = tw(r, n.x, 100 - n.y),
                                                i = nw(a);
                                            g(t, i, r, e)
                                        }
                                    })()), Ds(FS, (() => {
                                        const e = [c, d];
                                        return (t, o) => {
                                            const n = (e => (100 - e) / 100 * 360)(o.event.value),
                                                r = s.paletteRgba.get(),
                                                a = ow(r),
                                                i = tw(n, a.saturation, a.value),
                                                l = nw(i);
                                            g(t, l, n, e)
                                        }
                                    })())]), cm.config({
                                        find: e => l.getOpt(e)
                                    }), Th.config({
                                        mode: "acyclic"
                                    })])
                                }
                            }
                        });
                        return o
                    },
                    QS = () => cm.config({
                        find: A.some
                    }),
                    ek = e => cm.config({
                        find: t => rt(t.element, e).bind((e => t.getSystem().getByDom(e).toOptional()))
                    }),
                    tk = kn([ur("preprocess", w), ur("postprocess", w)]),
                    ok = (e, t, o) => ou.config({
                        store: {
                            mode: "manual",
                            ...e.map((e => ({
                                initialValue: e
                            }))).getOr({}),
                            getValue: t,
                            setValue: o
                        }
                    }),
                    nk = (e, t, o) => ok(e, (e => t(e.element)), ((e, t) => o(e.element, t))),
                    rk = (e, t) => {
                        const o = Zn("RepresentingConfigs.memento processors", tk, t);
                        return ou.config({
                            store: {
                                mode: "manual",
                                getValue: t => {
                                    const n = e.get(t),
                                        r = ou.getValue(n);
                                    return o.postprocess(r)
                                },
                                setValue: (t, n) => {
                                    const r = o.preprocess(n),
                                        s = e.get(t);
                                    ou.setValue(s, r)
                                }
                            }
                        })
                    },
                    sk = nk,
                    ak = ok,
                    ik = e => ou.config({
                        store: {
                            mode: "memory",
                            initialValue: e
                        }
                    }),
                    lk = {
                        "colorcustom.rgb.red.label": "R",
                        "colorcustom.rgb.red.description": "Red component",
                        "colorcustom.rgb.green.label": "G",
                        "colorcustom.rgb.green.description": "Green component",
                        "colorcustom.rgb.blue.label": "B",
                        "colorcustom.rgb.blue.description": "Blue component",
                        "colorcustom.rgb.hex.label": "#",
                        "colorcustom.rgb.hex.description": "Hex color code",
                        "colorcustom.rgb.range": "Range 0 to 255",
                        "aria.color.picker": "Color Picker",
                        "aria.input.invalid": "Invalid input"
                    };
                var ck = tinymce.util.Tools.resolve("tinymce.Resource"),
                    dk = tinymce.util.Tools.resolve("tinymce.util.Tools");
                const uk = Qs("alloy-fake-before-tabstop"),
                    mk = Qs("alloy-fake-after-tabstop"),
                    gk = e => ({
                        dom: {
                            tag: "div",
                            styles: {
                                width: "1px",
                                height: "1px",
                                outline: "none"
                            },
                            attributes: {
                                tabindex: "0"
                            },
                            classes: e
                        },
                        behaviours: gl([Zh.config({
                            ignore: !0
                        }), Nx.config({})])
                    }),
                    hk = e => ({
                        dom: {
                            tag: "div",
                            classes: ["tox-navobj"]
                        },
                        components: [gk([uk]), e, gk([mk])],
                        behaviours: gl([ek(1)])
                    }),
                    pk = (e, t) => {
                        _s(e, Zr(), {
                            raw: {
                                which: 9,
                                shiftKey: t
                            }
                        })
                    },
                    fk = (e, t) => {
                        const o = t.element;
                        Da(o, uk) ? pk(e, !0) : Da(o, mk) && pk(e, !1)
                    },
                    vk = e => hx(e, ["." + uk, "." + mk].join(","), O),
                    bk = Qs("toolbar.button.execute"),
                    yk = {
                        [ns()]: ["disabling", "alloy.base.behaviour", "toggling", "toolbar-button-events"]
                    },
                    wk = (e, t, o) => Fp(e, {
                        tag: "span",
                        classes: ["tox-icon", "tox-tbtn__icon-wrap"],
                        behaviours: o
                    }, t),
                    xk = (e, t) => wk(e, t, []),
                    Ck = (e, t) => wk(e, t, [Hh.config({})]),
                    Sk = (e, t, o) => ({
                        dom: {
                            tag: "span",
                            classes: [`${t}__select-label`]
                        },
                        components: [Wa(o.translate(e))],
                        behaviours: gl([Hh.config({})])
                    }),
                    kk = Qs("update-menu-text"),
                    _k = Qs("update-menu-icon"),
                    Ok = (e, t, o) => {
                        const n = wr(v),
                            r = e.text.map((e => Mp(Sk(e, t, o.providers)))),
                            s = e.icon.map((e => Mp(Ck(e, o.providers.icons)))),
                            a = (e, t) => {
                                const o = ou.getValue(e);
                                return Zh.focus(o), _s(o, "keydown", {
                                    raw: t.event.raw
                                }), rx.close(o), A.some(!0)
                            },
                            i = e.role.fold((() => ({})), (e => ({
                                role: e
                            }))),
                            l = e.tooltip.fold((() => ({})), (e => {
                                const t = o.providers.translate(e);
                                return {
                                    title: t,
                                    "aria-label": t
                                }
                            })),
                            c = Fp("chevron-down", {
                                tag: "div",
                                classes: [`${t}__select-chevron`]
                            }, o.providers.icons),
                            d = Mp(rx.sketch({ ...e.uid ? {
                                    uid: e.uid
                                } : {},
                                ...i,
                                dom: {
                                    tag: "button",
                                    classes: [t, `${t}--select`].concat(z(e.classes, (e => `${t}--${e}`))),
                                    attributes: { ...l
                                    }
                                },
                                components: gy([s.map((e => e.asSpec())), r.map((e => e.asSpec())), A.some(c)]),
                                matchWidth: !0,
                                useMinWidth: !0,
                                onOpen: (t, o, n) => {
                                    e.searchable && (e => {
                                        _v(e).each((e => Zh.focus(e)))
                                    })(n)
                                },
                                dropdownBehaviours: gl([...e.dropdownBehaviours, sy((() => e.disabled || o.providers.isDisabled())), ry(), oC.config({}), Hh.config({}), Ih("dropdown-events", [cy(e, n), dy(e, n)]), Ih("menubutton-update-display-text", [Ds(kk, ((e, t) => {
                                    r.bind((t => t.getOpt(e))).each((e => {
                                        Hh.set(e, [Wa(o.providers.translate(t.event.text))])
                                    }))
                                })), Ds(_k, ((e, t) => {
                                    s.bind((t => t.getOpt(e))).each((e => {
                                        Hh.set(e, [Ck(t.event.icon, o.providers.icons)])
                                    }))
                                }))])]),
                                eventOrder: cn(yk, {
                                    mousedown: ["focusing", "alloy.base.behaviour", "item-type-events", "normal-dropdown-events"]
                                }),
                                sandboxBehaviours: gl([Th.config({
                                    mode: "special",
                                    onLeft: a,
                                    onRight: a
                                }), Ih("dropdown-sandbox-events", [Ds(xv, ((e, t) => {
                                    (e => {
                                        const t = ou.getValue(e),
                                            o = kv(e).map(Ov);
                                        rx.refetch(t).get((() => {
                                            const e = Pw.getCoupled(t, "sandbox");
                                            o.each((t => kv(e).each((e => ((e, t) => {
                                                ou.setValue(e, t.fetchPattern), e.element.dom.selectionStart = t.selectionStart, e.element.dom.selectionEnd = t.selectionEnd
                                            })(e, t)))))
                                        }))
                                    })(e), t.stop()
                                })), Ds(Cv, ((e, t) => {
                                    ((e, t) => {
                                        (e => Hd.getState(e).bind(Dm.getHighlighted).bind(Dm.getHighlighted))(e).each((o => {
                                            ((e, t, o, n) => {
                                                const r = { ...n,
                                                    target: t
                                                };
                                                e.getSystem().triggerEvent(o, t, r)
                                            })(e, o.element, t.event.eventType, t.event.interactionEvent)
                                        }))
                                    })(e, t), t.stop()
                                }))])]),
                                lazySink: o.getSink,
                                toggleClass: `${t}--active`,
                                parts: {
                                    menu: { ...pv(0, e.columns, e.presets),
                                        fakeFocus: e.searchable,
                                        onHighlightItem: sx,
                                        onCollapseMenu: (e, t, o) => {
                                            Dm.getHighlighted(o).each((t => {
                                                sx(e, o, t)
                                            }))
                                        },
                                        onDehighlightItem: ax
                                    }
                                },
                                fetch: t => Uw(C(e.fetch, t))
                            }));
                        return d.asSpec()
                    },
                    Tk = e => "separator" === e.type,
                    Ek = {
                        type: "separator"
                    },
                    Ak = (e, t) => {
                        const o = ((e, t) => {
                            const o = j(e, ((e, o) => (e => s(e))(o) ? "" === o ? e : "|" === o ? e.length > 0 && !Tk(e[e.length - 1]) ? e.concat([Ek]) : e : be(t, o.toLowerCase()) ? e.concat([t[o.toLowerCase()]]) : e : e.concat([o])), []);
                            return o.length > 0 && Tk(o[o.length - 1]) && o.pop(), o
                        })(s(e) ? e.split(" ") : e, t);
                        return U(o, ((e, o) => {
                            if ((e => be(e, "getSubmenuItems"))(o)) {
                                const n = (e => {
                                        const t = ve(e, "value").getOrThunk((() => Qs("generated-menu-item")));
                                        return cn({
                                            value: t
                                        }, e)
                                    })(o),
                                    r = ((e, t) => {
                                        const o = e.getSubmenuItems(),
                                            n = Ak(o, t);
                                        return {
                                            item: e,
                                            menus: cn(n.menus, {
                                                [e.value]: n.items
                                            }),
                                            expansions: cn(n.expansions, {
                                                [e.value]: e.value
                                            })
                                        }
                                    })(n, t);
                                return {
                                    menus: cn(e.menus, r.menus),
                                    items: [r.item, ...e.items],
                                    expansions: cn(e.expansions, r.expansions)
                                }
                            }
                            return { ...e,
                                items: [o, ...e.items]
                            }
                        }), {
                            menus: {},
                            expansions: {},
                            items: []
                        })
                    },
                    Mk = (e, t, o, n) => {
                        const r = Qs("primary-menu"),
                            s = Ak(e, o.shared.providers.menuItems());
                        if (0 === s.items.length) return A.none();
                        const a = (e => e.search.fold((() => ({
                                searchMode: "no-search"
                            })), (e => ({
                                searchMode: "search-with-field",
                                placeholder: e.placeholder
                            }))))(n),
                            i = ux(r, s.items, t, o, n.isHorizontalMenu, a),
                            l = (e => e.search.fold((() => ({
                                searchMode: "no-search"
                            })), (e => ({
                                searchMode: "search-with-results"
                            }))))(n),
                            c = ce(s.menus, ((e, n) => ux(n, e, t, o, !1, l))),
                            d = cn(c, Cr(r, i));
                        return A.from(Op.tieredData(r, d, s.expansions))
                    },
                    Nk = e => !be(e, "items"),
                    Rk = "data-value",
                    Dk = (e, t, o, n) => z(o, (o => Nk(o) ? {
                        type: "togglemenuitem",
                        text: o.text,
                        value: o.value,
                        active: o.value === n,
                        onAction: () => {
                            ou.setValue(e, o.value), _s(e, Ix, {
                                name: t
                            }), Zh.focus(e)
                        }
                    } : {
                        type: "nestedmenuitem",
                        text: o.text,
                        getSubmenuItems: () => Dk(e, t, o.items, n)
                    })),
                    Bk = (e, t) => se(e, (e => Nk(e) ? Se(e.value === t, e) : Bk(e.items, t))),
                    Lk = rm({
                        name: "HtmlSelect",
                        configFields: [Gn("options"), nu("selectBehaviours", [Zh, ou]), ur("selectClasses", []), ur("selectAttributes", {}), nr("data")],
                        factory: (e, t) => {
                            const o = z(e.options, (e => ({
                                    dom: {
                                        tag: "option",
                                        value: e.value,
                                        innerHtml: e.text
                                    }
                                }))),
                                n = e.data.map((e => Cr("initialValue", e))).getOr({});
                            return {
                                uid: e.uid,
                                dom: {
                                    tag: "select",
                                    classes: e.selectClasses,
                                    attributes: e.selectAttributes
                                },
                                components: o,
                                behaviours: su(e.selectBehaviours, [Zh.config({}), ou.config({
                                    store: {
                                        mode: "manual",
                                        getValue: e => Ha(e.element),
                                        setValue: (t, o) => {
                                            W(e.options, (e => e.value === o)).isSome() && Ia(t.element, o)
                                        },
                                        ...n
                                    }
                                })])
                            }
                        }
                    }),
                    Hk = y([ur("field1Name", "field1"), ur("field2Name", "field2"), Si("onLockedChange"), yi(["lockClass"]), ur("locked", !1), au("coupledFieldBehaviours", [cm, ou])]),
                    Ik = (e, t) => Mu({
                        factory: Ex,
                        name: e,
                        overrides: e => ({
                            fieldBehaviours: gl([Ih("coupled-input-behaviour", [Ds(jr(), (o => {
                                ((e, t, o) => ju(e, t, o).bind(cm.getCurrent))(o, e, t).each((t => {
                                    ju(o, e, "lock").each((n => {
                                        Yh.isOn(n) && e.onLockedChange(o, t, n)
                                    }))
                                }))
                            }))])])
                        })
                    }),
                    Pk = y([Ik("field1", "field2"), Ik("field2", "field1"), Mu({
                        factory: Ap,
                        schema: [Gn("dom")],
                        name: "lock",
                        overrides: e => ({
                            buttonBehaviours: gl([Yh.config({
                                selected: e.locked,
                                toggleClass: e.markers.lockClass,
                                aria: {
                                    mode: "pressed"
                                }
                            })])
                        })
                    })]),
                    zk = sm({
                        name: "FormCoupledInputs",
                        configFields: Hk(),
                        partFields: Pk(),
                        factory: (e, t, o, n) => ({
                            uid: e.uid,
                            dom: e.dom,
                            components: t,
                            behaviours: iu(e.coupledFieldBehaviours, [cm.config({
                                find: A.some
                            }), ou.config({
                                store: {
                                    mode: "manual",
                                    getValue: t => {
                                        const o = Ku(t, e, ["field1", "field2"]);
                                        return {
                                            [e.field1Name]: ou.getValue(o.field1()),
                                            [e.field2Name]: ou.getValue(o.field2())
                                        }
                                    },
                                    setValue: (t, o) => {
                                        const n = Ku(t, e, ["field1", "field2"]);
                                        ye(o, e.field1Name) && ou.setValue(n.field1(), o[e.field1Name]), ye(o, e.field2Name) && ou.setValue(n.field2(), o[e.field2Name])
                                    }
                                }
                            })]),
                            apis: {
                                getField1: t => ju(t, e, "field1"),
                                getField2: t => ju(t, e, "field2"),
                                getLock: t => ju(t, e, "lock")
                            }
                        }),
                        apis: {
                            getField1: (e, t) => e.getField1(t),
                            getField2: (e, t) => e.getField2(t),
                            getLock: (e, t) => e.getLock(t)
                        }
                    }),
                    Fk = e => {
                        const t = /^\s*(\d+(?:\.\d+)?)\s*(|cm|mm|in|px|pt|pc|em|ex|ch|rem|vw|vh|vmin|vmax|%)\s*$/.exec(e);
                        if (null !== t) {
                            const e = parseFloat(t[1]),
                                o = t[2];
                            return Xo.value({
                                value: e,
                                unit: o
                            })
                        }
                        return Xo.error(e)
                    },
                    Vk = (e, t) => {
                        const o = {
                                "": 96,
                                px: 96,
                                pt: 72,
                                cm: 2.54,
                                pc: 12,
                                mm: 25.4,
                                in: 1
                            },
                            n = e => be(o, e);
                        return e.unit === t ? A.some(e.value) : n(e.unit) && n(t) ? o[e.unit] === o[t] ? A.some(e.value) : A.some(e.value / o[e.unit] * o[t]) : A.none()
                    },
                    Zk = e => A.none(),
                    Uk = (e, t) => {
                        const o = e.label.map((e => Hx(e, t))),
                            n = [Sm.config({
                                disabled: () => e.disabled || t.isDisabled()
                            }), ry(), Th.config({
                                mode: "execution",
                                useEnter: !0 !== e.multiline,
                                useControlEnter: !0 === e.multiline,
                                execute: e => (ks(e, Vx), A.some(!0))
                            }), Ih("textfield-change", [Ds(jr(), ((t, o) => {
                                _s(t, Ix, {
                                    name: e.name
                                })
                            })), Ds(ts(), ((t, o) => {
                                _s(t, Ix, {
                                    name: e.name
                                })
                            }))]), Nx.config({})],
                            r = e.validation.map((e => tC.config({
                                getRoot: e => tt(e.element),
                                invalidClass: "tox-invalid",
                                validator: {
                                    validate: t => {
                                        const o = ou.getValue(t),
                                            n = e.validator(o);
                                        return jw(!0 === n ? Xo.value(o) : Xo.error(n))
                                    },
                                    validateOnLoad: e.validateOnLoad
                                }
                            }))).toArray(),
                            s = { ...e.placeholder.fold(y({}), (e => ({
                                    placeholder: t.translate(e)
                                }))),
                                ...e.inputMode.fold(y({}), (e => ({
                                    inputmode: e
                                })))
                            },
                            a = Ex.parts.field({
                                tag: !0 === e.multiline ? "textarea" : "input",
                                ...e.data.map((e => ({
                                    data: e
                                }))).getOr({}),
                                inputAttributes: s,
                                inputClasses: [e.classname],
                                inputBehaviours: gl(q([n, r])),
                                selectOnFocus: !1,
                                factory: wv
                            }),
                            i = (e.flex ? ["tox-form__group--stretched"] : []).concat(e.maximized ? ["tox-form-group--maximize"] : []),
                            l = [Sm.config({
                                disabled: () => e.disabled || t.isDisabled(),
                                onDisabled: e => {
                                    Ex.getField(e).each(Sm.disable)
                                },
                                onEnabled: e => {
                                    Ex.getField(e).each(Sm.enable)
                                }
                            }), ry()];
                        return Dx(o, a, i, l)
                    };
                var jk = Object.freeze({
                    __proto__: null,
                    events: (e, t) => {
                        const o = e.stream.streams.setup(e, t);
                        return Ms([Ds(e.event, o), Zs((() => t.cancel()))].concat(e.cancelEvent.map((e => [Ds(e, (() => t.cancel()))])).getOr([])))
                    }
                });
                const Wk = (e, t) => {
                        let o = null;
                        const n = () => {
                            c(o) || (clearTimeout(o), o = null)
                        };
                        return {
                            cancel: n,
                            throttle: (...r) => {
                                n(), o = setTimeout((() => {
                                    o = null, e.apply(null, r)
                                }), t)
                            }
                        }
                    },
                    $k = e => {
                        const t = wr(null);
                        return va({
                            readState: () => ({
                                timer: null !== t.get() ? "set" : "unset"
                            }),
                            setTimer: e => {
                                t.set(e)
                            },
                            cancel: () => {
                                const e = t.get();
                                null !== e && e.cancel()
                            }
                        })
                    };
                var qk = Object.freeze({
                        __proto__: null,
                        throttle: $k,
                        init: e => e.stream.streams.state(e)
                    }),
                    Gk = [Kn("stream", jn("mode", {
                        throttle: [Gn("delay"), ur("stopEvent", !0), _i("streams", {
                            setup: (e, t) => {
                                const o = e.stream,
                                    n = Wk(e.onStream, o.delay);
                                return t.setTimer(n), (e, t) => {
                                    n.throttle(e, t), o.stopEvent && t.stop()
                                }
                            },
                            state: $k
                        })]
                    })), ur("event", "input"), nr("cancelEvent"), Si("onStream")];
                const Kk = pl({
                        fields: Gk,
                        name: "streaming",
                        active: jk,
                        state: qk
                    }),
                    Yk = (e, t, o) => {
                        const n = ou.getValue(o);
                        ou.setValue(t, n), Jk(t)
                    },
                    Xk = (e, t) => {
                        const o = e.element,
                            n = Ha(o),
                            r = o.dom;
                        "number" !== wt(o, "type") && t(r, n)
                    },
                    Jk = e => {
                        Xk(e, ((e, t) => e.setSelectionRange(t.length, t.length)))
                    },
                    Qk = y("alloy.typeahead.itemexecute"),
                    e_ = y([nr("lazySink"), Gn("fetch"), ur("minChars", 5), ur("responseTime", 1e3), xi("onOpen"), ur("getHotspot", A.some), ur("getAnchorOverrides", y({})), ur("layouts", A.none()), ur("eventOrder", {}), yr("model", {}, [ur("getDisplayText", (e => void 0 !== e.meta && void 0 !== e.meta.text ? e.meta.text : e.value)), ur("selectsOver", !0), ur("populateFromBrowse", !0)]), xi("onSetValue"), Ci("onExecute"), xi("onItemExecute"), ur("inputClasses", []), ur("inputAttributes", {}), ur("inputStyles", {}), ur("matchWidth", !0), ur("useMinWidth", !1), ur("dismissOnBlur", !0), yi(["openClass"]), nr("initialData"), nu("typeaheadBehaviours", [Zh, ou, Kk, Th, Yh, Pw]), $n("lazyTypeaheadComp", (() => wr(A.none))), $n("previewing", (() => wr(!0)))].concat(fv()).concat(tx())),
                    t_ = y([Nu({
                        schema: [bi()],
                        name: "menu",
                        overrides: e => ({
                            fakeFocus: !0,
                            onHighlightItem: (t, o, n) => {
                                e.previewing.get() ? e.lazyTypeaheadComp.get().each((t => {
                                    ((e, t, o) => {
                                        if (e.selectsOver) {
                                            const n = ou.getValue(t),
                                                r = e.getDisplayText(n),
                                                s = ou.getValue(o);
                                            return 0 === e.getDisplayText(s).indexOf(r) ? A.some((() => {
                                                Yk(0, t, o), ((e, t) => {
                                                    Xk(e, ((e, o) => e.setSelectionRange(t, o.length)))
                                                })(t, r.length)
                                            })) : A.none()
                                        }
                                        return A.none()
                                    })(e.model, t, n).fold((() => {
                                        e.model.selectsOver ? (Dm.dehighlight(o, n), e.previewing.set(!0)) : e.previewing.set(!1)
                                    }), (t => {
                                        t(), e.previewing.set(!1)
                                    }))
                                })) : e.lazyTypeaheadComp.get().each((t => {
                                    e.model.populateFromBrowse && Yk(e.model, t, n)
                                }))
                            },
                            onExecute: (t, o) => e.lazyTypeaheadComp.get().map((e => (_s(e, Qk(), {
                                item: o
                            }), !0))),
                            onHover: (t, o) => {
                                e.previewing.set(!1), e.lazyTypeaheadComp.get().each((t => {
                                    e.model.populateFromBrowse && Yk(e.model, t, o)
                                }))
                            }
                        })
                    })]),
                    o_ = sm({
                        name: "Typeahead",
                        configFields: e_(),
                        partFields: t_(),
                        factory: (e, t, o, n) => {
                            const r = (t, o, r) => {
                                    e.previewing.set(!1);
                                    const s = Pw.getCoupled(t, "sandbox");
                                    if (Hd.isOpen(s)) cm.getCurrent(s).each((e => {
                                        Dm.getHighlighted(e).fold((() => {
                                            r(e)
                                        }), (() => {
                                            As(s, e.element, "keydown", o)
                                        }))
                                    }));
                                    else {
                                        const o = e => {
                                            cm.getCurrent(e).each(r)
                                        };
                                        Gw(e, a(t), t, s, n, o, kp.HighlightMenuAndItem).get(v)
                                    }
                                },
                                s = vv(e),
                                a = e => t => t.map((t => {
                                    const o = fe(t.menus),
                                        n = G(o, (e => Z(e.items, (e => "item" === e.type))));
                                    return ou.getState(e).update(z(n, (e => e.data))), t
                                })),
                                i = e => cm.getCurrent(e),
                                l = "typeaheadevents",
                                c = [Zh.config({}), ou.config({
                                    onSetValue: e.onSetValue,
                                    store: {
                                        mode: "dataset",
                                        getDataKey: e => Ha(e.element),
                                        getFallbackEntry: e => ({
                                            value: e,
                                            meta: {}
                                        }),
                                        setValue: (t, o) => {
                                            Ia(t.element, e.model.getDisplayText(o))
                                        },
                                        ...e.initialData.map((e => Cr("initialValue", e))).getOr({})
                                    }
                                }), Kk.config({
                                    stream: {
                                        mode: "throttle",
                                        delay: e.responseTime,
                                        stopEvent: !1
                                    },
                                    onStream: (t, o) => {
                                        const r = Pw.getCoupled(t, "sandbox");
                                        if (Zh.isFocused(t) && Ha(t.element).length >= e.minChars) {
                                            const o = i(r).bind((e => Dm.getHighlighted(e).map(ou.getValue)));
                                            e.previewing.set(!0);
                                            const s = t => {
                                                i(r).each((t => {
                                                    o.fold((() => {
                                                        e.model.selectsOver && Dm.highlightFirst(t)
                                                    }), (e => {
                                                        Dm.highlightBy(t, (t => ou.getValue(t).value === e.value)), Dm.getHighlighted(t).orThunk((() => (Dm.highlightFirst(t), A.none())))
                                                    }))
                                                }))
                                            };
                                            Gw(e, a(t), t, r, n, s, kp.HighlightJustMenu).get(v)
                                        }
                                    },
                                    cancelEvent: ls()
                                }), Th.config({
                                    mode: "special",
                                    onDown: (e, t) => (r(e, t, Dm.highlightFirst), A.some(!0)),
                                    onEscape: e => {
                                        const t = Pw.getCoupled(e, "sandbox");
                                        return Hd.isOpen(t) ? (Hd.close(t), A.some(!0)) : A.none()
                                    },
                                    onUp: (e, t) => (r(e, t, Dm.highlightLast), A.some(!0)),
                                    onEnter: t => {
                                        const o = Pw.getCoupled(t, "sandbox"),
                                            n = Hd.isOpen(o);
                                        if (n && !e.previewing.get()) return i(o).bind((e => Dm.getHighlighted(e))).map((e => (_s(t, Qk(), {
                                            item: e
                                        }), !0))); {
                                            const r = ou.getValue(t);
                                            return ks(t, ls()), e.onExecute(o, t, r), n && Hd.close(o), A.some(!0)
                                        }
                                    }
                                }), Yh.config({
                                    toggleClass: e.markers.openClass,
                                    aria: {
                                        mode: "expanded"
                                    }
                                }), Pw.config({
                                    others: {
                                        sandbox: t => Qw(e, t, {
                                            onOpen: () => Yh.on(t),
                                            onClose: () => Yh.off(t)
                                        })
                                    }
                                }), Ih(l, [Vs((t => {
                                    e.lazyTypeaheadComp.set(A.some(t))
                                })), Zs((t => {
                                    e.lazyTypeaheadComp.set(A.none())
                                })), js((t => {
                                    const o = v;
                                    Yw(e, a(t), t, n, o, kp.HighlightMenuAndItem).get(v)
                                })), Ds(Qk(), ((t, o) => {
                                    const n = Pw.getCoupled(t, "sandbox");
                                    Yk(e.model, t, o.event.item), ks(t, ls()), e.onItemExecute(t, n, o.event.item, ou.getValue(t)), Hd.close(n), Jk(t)
                                }))].concat(e.dismissOnBlur ? [Ds(es(), (e => {
                                    const t = Pw.getCoupled(e, "sandbox");
                                    kl(t.element).isNone() && Hd.close(t)
                                }))] : []))],
                                d = {
                                    [ps()]: [ou.name(), Kk.name(), l],
                                    ...e.eventOrder
                                };
                            return {
                                uid: e.uid,
                                dom: yv(cn(e, {
                                    inputAttributes: {
                                        role: "combobox",
                                        "aria-autocomplete": "list",
                                        "aria-haspopup": "true"
                                    }
                                })),
                                behaviours: { ...s,
                                    ...su(e.typeaheadBehaviours, c)
                                },
                                eventOrder: d
                            }
                        }
                    }),
                    n_ = e => ({ ...e,
                        toCached: () => n_(e.toCached()),
                        bindFuture: t => n_(e.bind((e => e.fold((e => jw(Xo.error(e))), (e => t(e)))))),
                        bindResult: t => n_(e.map((e => e.bind(t)))),
                        mapResult: t => n_(e.map((e => e.map(t)))),
                        mapError: t => n_(e.map((e => e.mapError(t)))),
                        foldResult: (t, o) => e.map((e => e.fold(t, o))),
                        withTimeout: (t, o) => n_(Uw((n => {
                            let r = !1;
                            const s = setTimeout((() => {
                                r = !0, n(Xo.error(o()))
                            }), t);
                            e.get((e => {
                                r || (clearTimeout(s), n(e))
                            }))
                        })))
                    }),
                    r_ = e => n_(Uw(e)),
                    s_ = e => ({
                        isEnabled: () => !Sm.isDisabled(e),
                        setEnabled: t => Sm.set(e, !t),
                        setActive: t => {
                            const o = e.element;
                            t ? (Na(o, "tox-tbtn--enabled"), bt(o, "aria-pressed", !0)) : (Ra(o, "tox-tbtn--enabled"), St(o, "aria-pressed"))
                        },
                        isActive: () => Da(e.element, "tox-tbtn--enabled")
                    }),
                    a_ = (e, t, o, n) => Ok({
                        text: e.text,
                        icon: e.icon,
                        tooltip: e.tooltip,
                        searchable: e.search.isSome(),
                        role: n,
                        fetch: (t, n) => {
                            const r = {
                                pattern: e.search.isSome() ? ix(t) : ""
                            };
                            e.fetch((t => {
                                n(Mk(t, Xf.CLOSE_ON_EXECUTE, o, {
                                    isHorizontalMenu: !1,
                                    search: e.search
                                }))
                            }), r)
                        },
                        onSetup: e.onSetup,
                        getApi: s_,
                        columns: 1,
                        presets: "normal",
                        classes: [],
                        dropdownBehaviours: [Nx.config({})]
                    }, t, o.shared),
                    i_ = (e, t, o) => {
                        const n = e => n => {
                                const r = !n.isActive();
                                n.setActive(r), e.storage.set(r), o.shared.getSink().each((o => {
                                    t().getOpt(o).each((t => {
                                        xl(t.element), _s(t, Fx, {
                                            name: e.name,
                                            value: e.storage.get()
                                        })
                                    }))
                                }))
                            },
                            r = e => t => {
                                t.setActive(e.storage.get())
                            };
                        return t => {
                            t(z(e, (e => {
                                const t = e.text.fold((() => ({})), (e => ({
                                    text: e
                                })));
                                return {
                                    type: e.type,
                                    active: !1,
                                    ...t,
                                    onAction: n(e),
                                    onSetup: r(e)
                                }
                            })))
                        }
                    },
                    l_ = (e, t, o = [], n, r, s) => {
                        const a = t.fold((() => ({})), (e => ({
                                action: e
                            }))),
                            i = {
                                buttonBehaviours: gl([sy((() => !e.enabled || s.isDisabled())), ry(), Nx.config({}), Ih("button press", [Rs("click"), Rs("mousedown")])].concat(o)),
                                eventOrder: {
                                    click: ["button press", "alloy.base.behaviour"],
                                    mousedown: ["button press", "alloy.base.behaviour"]
                                },
                                ...a
                            },
                            l = cn(i, {
                                dom: n
                            });
                        return cn(l, {
                            components: r
                        })
                    },
                    c_ = (e, t, o, n = []) => {
                        const r = {
                                tag: "button",
                                classes: ["tox-tbtn"],
                                attributes: e.tooltip.map((e => ({
                                    "aria-label": o.translate(e),
                                    title: o.translate(e)
                                }))).getOr({})
                            },
                            s = e.icon.map((e => xk(e, o.icons))),
                            a = gy([s]);
                        return l_(e, t, n, r, a, o)
                    },
                    d_ = (e, t, o, n = [], r = []) => {
                        const s = o.translate(e.text),
                            a = e.icon.map((e => xk(e, o.icons))),
                            i = [a.getOrThunk((() => Wa(s)))],
                            l = [...(e => {
                                switch (e) {
                                    case "primary":
                                        return ["tox-button"];
                                    case "toolbar":
                                        return ["tox-tbtn"];
                                    default:
                                        return ["tox-button", "tox-button--secondary"]
                                }
                            })(e.buttonType.getOr(e.primary || e.borderless ? "primary" : "secondary")), ...a.isSome() ? ["tox-button--icon"] : [], ...e.borderless ? ["tox-button--naked"] : [], ...r];
                        return l_(e, t, n, {
                            tag: "button",
                            classes: l,
                            attributes: {
                                title: s
                            }
                        }, i, o)
                    },
                    u_ = (e, t, o, n = [], r = []) => {
                        const s = d_(e, A.some(t), o, n, r);
                        return Ap.sketch(s)
                    },
                    m_ = (e, t) => o => {
                        "custom" === t ? _s(o, Fx, {
                            name: e,
                            value: {}
                        }) : "submit" === t ? ks(o, Vx) : "cancel" === t ? ks(o, zx) : console.error("Unknown button type: ", t)
                    },
                    g_ = (e, t, o) => {
                        if (((e, t) => "menu" === t)(0, t)) {
                            const t = () => s,
                                n = e,
                                r = { ...e,
                                    type: "menubutton",
                                    search: A.none(),
                                    onSetup: t => (t.setEnabled(e.enabled), v),
                                    fetch: i_(n.items, t, o)
                                },
                                s = Mp(a_(r, "tox-tbtn", o, A.none()));
                            return s.asSpec()
                        }
                        if (((e, t) => "custom" === t || "cancel" === t || "submit" === t)(0, t)) {
                            const n = m_(e.name, t),
                                r = { ...e,
                                    borderless: !1
                                };
                            return u_(r, n, o.shared.providers, [])
                        }
                        throw console.error("Unknown footer button type: ", t), new Error("Unknown footer button type")
                    },
                    h_ = {
                        type: "separator"
                    },
                    p_ = e => ({
                        type: "menuitem",
                        value: e.url,
                        text: e.title,
                        meta: {
                            attach: e.attach
                        },
                        onAction: v
                    }),
                    f_ = (e, t) => ({
                        type: "menuitem",
                        value: t,
                        text: e,
                        meta: {
                            attach: void 0
                        },
                        onAction: v
                    }),
                    v_ = (e, t) => (e => z(e, p_))(((e, t) => Z(t, (t => t.type === e)))(e, t)),
                    b_ = e => v_("header", e.targets),
                    y_ = e => v_("anchor", e.targets),
                    w_ = e => A.from(e.anchorTop).map((e => f_("<top>", e))).toArray(),
                    x_ = e => A.from(e.anchorBottom).map((e => f_("<bottom>", e))).toArray(),
                    C_ = (e, t) => {
                        const o = e.toLowerCase();
                        return Z(t, (e => {
                            var t;
                            const n = void 0 !== e.meta && void 0 !== e.meta.text ? e.meta.text : e.text,
                                r = null !== (t = e.value) && void 0 !== t ? t : "";
                            return _e(n.toLowerCase(), o) || _e(r.toLowerCase(), o)
                        }))
                    },
                    S_ = Qs("aria-invalid"),
                    k_ = (e, t) => {
                        e.dom.checked = t
                    },
                    __ = e => e.dom.checked,
                    O_ = e => (t, o, n, r) => ve(o, "name").fold((() => e(o, r, A.none())), (s => t.field(s, e(o, r, ve(n, s))))),
                    T_ = {
                        bar: O_(((e, t) => ((e, t) => ({
                            dom: {
                                tag: "div",
                                classes: ["tox-bar", "tox-form__controls-h-stack"]
                            },
                            components: z(e.items, t.interpreter)
                        }))(e, t.shared))),
                        collection: O_(((e, t, o) => ((e, t, o) => {
                            const n = e.label.map((e => Hx(e, t))),
                                r = e => (t, o) => {
                                    si(o.event.target, "[data-collection-item-value]").each((n => {
                                        e(t, o, n, wt(n, "data-collection-item-value"))
                                    }))
                                },
                                s = r(((o, n, r, s) => {
                                    n.stop(), t.isDisabled() || _s(o, Fx, {
                                        name: e.name,
                                        value: s
                                    })
                                })),
                                a = [Ds(zr(), r(((e, t, o) => {
                                    xl(o)
                                }))), Ds($r(), s), Ds(ss(), s), Ds(Fr(), r(((e, t, o) => {
                                    ri(e.element, "." + av).each((e => {
                                        Ra(e, av)
                                    })), Na(o, av)
                                }))), Ds(Vr(), r((e => {
                                    ri(e.element, "." + av).each((e => {
                                        Ra(e, av)
                                    }))
                                }))), js(r(((t, o, n, r) => {
                                    _s(t, Fx, {
                                        name: e.name,
                                        value: r
                                    })
                                })))],
                                i = (e, t) => z(Hc(e.element, ".tox-collection__item"), t),
                                l = Ex.parts.field({
                                    dom: {
                                        tag: "div",
                                        classes: ["tox-collection"].concat(1 !== e.columns ? ["tox-collection--grid"] : ["tox-collection--list"])
                                    },
                                    components: [],
                                    factory: {
                                        sketch: w
                                    },
                                    behaviours: gl([Sm.config({
                                        disabled: t.isDisabled,
                                        onDisabled: e => {
                                            i(e, (e => {
                                                Na(e, "tox-collection__item--state-disabled"), bt(e, "aria-disabled", !0)
                                            }))
                                        },
                                        onEnabled: e => {
                                            i(e, (e => {
                                                Ra(e, "tox-collection__item--state-disabled"), St(e, "aria-disabled")
                                            }))
                                        }
                                    }), ry(), Hh.config({}), ou.config({
                                        store: {
                                            mode: "memory",
                                            initialValue: o.getOr([])
                                        },
                                        onSetValue: (o, n) => {
                                            ((o, n) => {
                                                const r = z(n, (o => {
                                                        const n = Np.translate(o.text),
                                                            r = 1 === e.columns ? `<div class="tox-collection__item-label">${n}</div>` : "",
                                                            s = `<div class="tox-collection__item-icon">${o.icon}</div>`,
                                                            a = {
                                                                _: " ",
                                                                " - ": " ",
                                                                "-": " "
                                                            },
                                                            i = n.replace(/\_| \- |\-/g, (e => a[e]));
                                                        return `<div class="tox-collection__item${t.isDisabled()?" tox-collection__item--state-disabled":""}" tabindex="-1" data-collection-item-value="${Rx.encodeAllRaw(o.value)}" title="${i}" aria-label="${i}">${s}${r}</div>`
                                                    })),
                                                    s = "auto" !== e.columns && e.columns > 1 ? P(r, e.columns) : [r],
                                                    a = z(s, (e => `<div class="tox-collection__group">${e.join("")}</div>`));
                                                $s(o.element, a.join(""))
                                            })(o, n), "auto" === e.columns && jb(o, 5, "tox-collection__item").each((({
                                                numRows: e,
                                                numColumns: t
                                            }) => {
                                                Th.setGridSize(o, e, t)
                                            })), ks(o, Wx)
                                        }
                                    }), Nx.config({}), Th.config((c = e.columns, 1 === c ? {
                                        mode: "menu",
                                        moveOnTab: !1,
                                        selector: ".tox-collection__item"
                                    } : "auto" === c ? {
                                        mode: "flatgrid",
                                        selector: ".tox-collection__item",
                                        initSize: {
                                            numColumns: 1,
                                            numRows: 1
                                        }
                                    } : {
                                        mode: "matrix",
                                        selectors: {
                                            row: ".tox-collection__group",
                                            cell: `.${Qf}`
                                        }
                                    })), Ih("collection-events", a)]),
                                    eventOrder: {
                                        [ns()]: ["disabling", "alloy.base.behaviour", "collection-events"]
                                    }
                                });
                            var c;
                            return Dx(n, l, ["tox-form__group--collection"], [])
                        })(e, t.shared.providers, o))),
                        alertbanner: O_(((e, t) => ((e, t) => kx.sketch({
                            dom: {
                                tag: "div",
                                attributes: {
                                    role: "alert"
                                },
                                classes: ["tox-notification", "tox-notification--in", `tox-notification--${e.level}`]
                            },
                            components: [{
                                dom: {
                                    tag: "div",
                                    classes: ["tox-notification__icon"]
                                },
                                components: [Ap.sketch({
                                    dom: {
                                        tag: "button",
                                        classes: ["tox-button", "tox-button--naked", "tox-button--icon"],
                                        innerHtml: Ip(e.icon, t.icons),
                                        attributes: {
                                            title: t.translate(e.iconTooltip)
                                        }
                                    },
                                    action: t => {
                                        _s(t, Fx, {
                                            name: "alert-banner",
                                            value: e.url
                                        })
                                    },
                                    buttonBehaviours: gl([Pp()])
                                })]
                            }, {
                                dom: {
                                    tag: "div",
                                    classes: ["tox-notification__body"],
                                    innerHtml: t.translate(e.text)
                                }
                            }]
                        }))(e, t.shared.providers))),
                        input: O_(((e, t, o) => ((e, t, o) => Uk({
                            name: e.name,
                            multiline: !1,
                            label: e.label,
                            inputMode: e.inputMode,
                            placeholder: e.placeholder,
                            flex: !1,
                            disabled: !e.enabled,
                            classname: "tox-textfield",
                            validation: A.none(),
                            maximized: e.maximized,
                            data: o
                        }, t))(e, t.shared.providers, o))),
                        textarea: O_(((e, t, o) => ((e, t, o) => Uk({
                            name: e.name,
                            multiline: !0,
                            label: e.label,
                            inputMode: A.none(),
                            placeholder: e.placeholder,
                            flex: !0,
                            disabled: !e.enabled,
                            classname: "tox-textarea",
                            validation: A.none(),
                            maximized: e.maximized,
                            data: o
                        }, t))(e, t.shared.providers, o))),
                        label: O_(((e, t) => ((e, t) => {
                            return {
                                dom: {
                                    tag: "div",
                                    classes: ["tox-form__group"]
                                },
                                components: [{
                                    dom: {
                                        tag: "label",
                                        classes: ["tox-label"]
                                    },
                                    components: [Wa(t.providers.translate(e.label))]
                                }, ...z(e.items, t.interpreter)],
                                behaviours: gl([QS(), Hh.config({}), (o = A.none(), nk(o, Ws, $s)), Th.config({
                                    mode: "acyclic"
                                })])
                            };
                            var o
                        })(e, t.shared))),
                        iframe: (JO = (e, t, o) => ((e, t, o) => {
                            const n = e.sandboxed,
                                r = e.transparent,
                                s = "tox-dialog__iframe",
                                a = { ...e.label.map((e => ({
                                        title: e
                                    }))).getOr({}),
                                    ...o.map((e => ({
                                        srcdoc: e
                                    }))).getOr({}),
                                    ...n ? {
                                        sandbox: "allow-scripts allow-same-origin"
                                    } : {}
                                },
                                i = (e => {
                                    const t = wr(e.getOr(""));
                                    return {
                                        getValue: e => t.get(),
                                        setValue: (e, o) => {
                                            t.get() !== o && bt(e.element, "srcdoc", o), t.set(o)
                                        }
                                    }
                                })(o),
                                l = e.label.map((e => Hx(e, t))),
                                c = Ex.parts.field({
                                    factory: {
                                        sketch: e => hk({
                                            uid: e.uid,
                                            dom: {
                                                tag: "iframe",
                                                attributes: a,
                                                classes: r ? [s] : [s, `${s}--opaque`]
                                            },
                                            behaviours: gl([Nx.config({}), Zh.config({}), ak(o, i.getValue, i.setValue)])
                                        })
                                    }
                                });
                            return Dx(l, c, ["tox-form__group--stretched"], [])
                        })(e, t.shared.providers, o), (e, t, o, n) => {
                            const r = cn(t, {
                                source: "dynamic"
                            });
                            return O_(JO)(e, r, o, n)
                        }),
                        button: O_(((e, t) => ((e, t) => {
                            const o = m_(e.name, "custom");
                            return n = A.none(), r = Ex.parts.field({
                                factory: Ap,
                                ...d_(e, A.some(o), t, [ik(""), QS()])
                            }), Dx(n, r, [], []);
                            var n, r
                        })(e, t.shared.providers))),
                        checkbox: O_(((e, t, o) => ((e, t, o) => {
                            const n = e => (e.element.dom.click(), A.some(!0)),
                                r = Ex.parts.field({
                                    factory: {
                                        sketch: w
                                    },
                                    dom: {
                                        tag: "input",
                                        classes: ["tox-checkbox__input"],
                                        attributes: {
                                            type: "checkbox"
                                        }
                                    },
                                    behaviours: gl([QS(), Sm.config({
                                        disabled: () => !e.enabled || t.isDisabled()
                                    }), Nx.config({}), Zh.config({}), sk(o, __, k_), Th.config({
                                        mode: "special",
                                        onEnter: n,
                                        onSpace: n,
                                        stopSpaceKeyup: !0
                                    }), Ih("checkbox-events", [Ds(Wr(), ((t, o) => {
                                        _s(t, Ix, {
                                            name: e.name
                                        })
                                    }))])])
                                }),
                                s = Ex.parts.label({
                                    dom: {
                                        tag: "span",
                                        classes: ["tox-checkbox__label"]
                                    },
                                    components: [Wa(t.translate(e.label))],
                                    behaviours: gl([oC.config({})])
                                }),
                                a = e => Fp("checked" === e ? "selected" : "unselected", {
                                    tag: "span",
                                    classes: ["tox-icon", "tox-checkbox-icon__" + e]
                                }, t.icons),
                                i = Mp({
                                    dom: {
                                        tag: "div",
                                        classes: ["tox-checkbox__icons"]
                                    },
                                    components: [a("checked"), a("unchecked")]
                                });
                            return Ex.sketch({
                                dom: {
                                    tag: "label",
                                    classes: ["tox-checkbox"]
                                },
                                components: [r, i.asSpec(), s],
                                fieldBehaviours: gl([Sm.config({
                                    disabled: () => !e.enabled || t.isDisabled(),
                                    disableClass: "tox-checkbox--disabled",
                                    onDisabled: e => {
                                        Ex.getField(e).each(Sm.disable)
                                    },
                                    onEnabled: e => {
                                        Ex.getField(e).each(Sm.enable)
                                    }
                                }), ry()])
                            })
                        })(e, t.shared.providers, o))),
                        colorinput: O_(((e, t, o) => ((e, t, o, n) => {
                            const r = Ex.parts.field({
                                    factory: wv,
                                    inputClasses: ["tox-textfield"],
                                    data: n,
                                    onSetValue: e => tC.run(e).get(v),
                                    inputBehaviours: gl([Sm.config({
                                        disabled: t.providers.isDisabled
                                    }), ry(), Nx.config({}), tC.config({
                                        invalidClass: "tox-textbox-field-invalid",
                                        getRoot: e => tt(e.element),
                                        notify: {
                                            onValid: e => {
                                                const t = ou.getValue(e);
                                                _s(e, nC, {
                                                    color: t
                                                })
                                            }
                                        },
                                        validator: {
                                            validateOnLoad: !1,
                                            validate: e => {
                                                const t = ou.getValue(e);
                                                if (0 === t.length) return jw(Xo.value(!0)); {
                                                    const e = Re("span");
                                                    Ot(e, "background-color", t);
                                                    const o = Nt(e, "background-color").fold((() => Xo.error("blah")), (e => Xo.value(t)));
                                                    return jw(o)
                                                }
                                            }
                                        }
                                    })]),
                                    selectOnFocus: !1
                                }),
                                s = e.label.map((e => Hx(e, t.providers))),
                                a = (e, t) => {
                                    _s(e, rC, {
                                        value: t
                                    })
                                },
                                i = Mp(((e, t) => rx.sketch({
                                    dom: e.dom,
                                    components: e.components,
                                    toggleClass: "mce-active",
                                    dropdownBehaviours: gl([sy(t.providers.isDisabled), ry(), oC.config({}), Nx.config({})]),
                                    layouts: e.layouts,
                                    sandboxClasses: ["tox-dialog__popups"],
                                    lazySink: t.getSink,
                                    fetch: o => Uw((t => e.fetch(t))).map((n => A.from(mx(cn(_w(Qs("menu-value"), n, (t => {
                                        e.onItemAction(o, t)
                                    }), e.columns, e.presets, Xf.CLOSE_ON_EXECUTE, O, t.providers), {
                                        movement: Tw(e.columns, e.presets)
                                    }))))),
                                    parts: {
                                        menu: pv(0, 0, e.presets)
                                    }
                                }))({
                                    dom: {
                                        tag: "span",
                                        attributes: {
                                            "aria-label": t.providers.translate("Color swatch")
                                        }
                                    },
                                    layouts: {
                                        onRtl: () => [Ki, Gi, Qi],
                                        onLtr: () => [Gi, Ki, Qi]
                                    },
                                    components: [],
                                    fetch: ww(o.getColors(e.storageKey), e.storageKey, o.hasCustomColors()),
                                    columns: o.getColorCols(e.storageKey),
                                    presets: "color",
                                    onItemAction: (t, n) => {
                                        i.getOpt(t).each((t => {
                                            "custom" === n ? o.colorPicker((o => {
                                                o.fold((() => ks(t, sC)), (o => {
                                                    a(t, o), ew(e.storageKey, o)
                                                }))
                                            }), "#ffffff") : a(t, "remove" === n ? "" : n)
                                        }))
                                    }
                                }, t));
                            return Ex.sketch({
                                dom: {
                                    tag: "div",
                                    classes: ["tox-form__group"]
                                },
                                components: s.toArray().concat([{
                                    dom: {
                                        tag: "div",
                                        classes: ["tox-color-input"]
                                    },
                                    components: [r, i.asSpec()]
                                }]),
                                fieldBehaviours: gl([Ih("form-field-events", [Ds(nC, ((t, o) => {
                                    i.getOpt(t).each((e => {
                                        Ot(e.element, "background-color", o.event.color)
                                    })), _s(t, Ix, {
                                        name: e.name
                                    })
                                })), Ds(rC, ((e, t) => {
                                    Ex.getField(e).each((o => {
                                        ou.setValue(o, t.event.value), cm.getCurrent(e).each(Zh.focus)
                                    }))
                                })), Ds(sC, ((e, t) => {
                                    Ex.getField(e).each((t => {
                                        cm.getCurrent(e).each(Zh.focus)
                                    }))
                                }))])])
                            })
                        })(e, t.shared, t.colorinput, o))),
                        colorpicker: O_(((e, t, o) => ((e, t, o) => {
                            const n = e => "tox-" + e,
                                r = JS((e => t => e.translate(lk[t]))(t), n),
                                s = Mp(r.sketch({
                                    dom: {
                                        tag: "div",
                                        classes: [n("color-picker-container")],
                                        attributes: {
                                            role: "presentation"
                                        }
                                    },
                                    onValidHex: e => {
                                        _s(e, Fx, {
                                            name: "hex-valid",
                                            value: !0
                                        })
                                    },
                                    onInvalidHex: e => {
                                        _s(e, Fx, {
                                            name: "hex-valid",
                                            value: !1
                                        })
                                    }
                                }));
                            return {
                                dom: {
                                    tag: "div"
                                },
                                components: [s.asSpec()],
                                behaviours: gl([ak(o, (e => {
                                    const t = s.get(e);
                                    return cm.getCurrent(t).bind((e => ou.getValue(e).hex)).map((e => "#" + e)).getOr("")
                                }), ((e, t) => {
                                    const o = A.from(/^#([a-fA-F0-9]{3}(?:[a-fA-F0-9]{3})?)/.exec(t)).bind((e => te(e, 1))),
                                        n = s.get(e);
                                    cm.getCurrent(n).fold((() => {
                                        console.log("Can not find form")
                                    }), (e => {
                                        ou.setValue(e, {
                                            hex: o.getOr("")
                                        }), $S.getField(e, "hex").each((e => {
                                            ks(e, jr())
                                        }))
                                    }))
                                })), QS()])
                            }
                        })(0, t.shared.providers, o))),
                        dropzone: O_(((e, t, o) => ((e, t, o) => {
                            const n = (e, t) => {
                                    t.stop()
                                },
                                r = e => (t, o) => {
                                    F(e, (e => {
                                        e(t, o)
                                    }))
                                },
                                s = (e, t) => {
                                    var o;
                                    if (!Sm.isDisabled(e)) {
                                        const n = t.event.raw;
                                        i(e, null === (o = n.dataTransfer) || void 0 === o ? void 0 : o.files)
                                    }
                                },
                                a = (e, t) => {
                                    const o = t.event.raw.target;
                                    i(e, o.files)
                                },
                                i = (o, n) => {
                                    n && (ou.setValue(o, ((e, t) => {
                                        const o = dk.explode(t.getOption("images_file_types"));
                                        return Z(re(e), (e => H(o, (t => Oe(e.name.toLowerCase(), `.${t.toLowerCase()}`)))))
                                    })(n, t)), _s(o, Ix, {
                                        name: e.name
                                    }))
                                },
                                l = Mp({
                                    dom: {
                                        tag: "input",
                                        attributes: {
                                            type: "file",
                                            accept: "image/*"
                                        },
                                        styles: {
                                            display: "none"
                                        }
                                    },
                                    behaviours: gl([Ih("input-file-events", [Ps($r()), Ps(ss())])])
                                }),
                                c = e.label.map((e => Hx(e, t))),
                                d = Ex.parts.field({
                                    factory: {
                                        sketch: e => ({
                                            uid: e.uid,
                                            dom: {
                                                tag: "div",
                                                classes: ["tox-dropzone-container"]
                                            },
                                            behaviours: gl([ik(o.getOr([])), QS(), Sm.config({}), Yh.config({
                                                toggleClass: "dragenter",
                                                toggleOnExecute: !1
                                            }), Ih("dropzone-events", [Ds("dragenter", r([n, Yh.toggle])), Ds("dragleave", r([n, Yh.toggle])), Ds("dragover", n), Ds("drop", r([n, s])), Ds(Wr(), a)])]),
                                            components: [{
                                                dom: {
                                                    tag: "div",
                                                    classes: ["tox-dropzone"],
                                                    styles: {}
                                                },
                                                components: [{
                                                    dom: {
                                                        tag: "p"
                                                    },
                                                    components: [Wa(t.translate("Drop an image here"))]
                                                }, Ap.sketch({
                                                    dom: {
                                                        tag: "button",
                                                        styles: {
                                                            position: "relative"
                                                        },
                                                        classes: ["tox-button", "tox-button--secondary"]
                                                    },
                                                    components: [Wa(t.translate("Browse for an image")), l.asSpec()],
                                                    action: e => {
                                                        l.get(e).element.dom.click()
                                                    },
                                                    buttonBehaviours: gl([Nx.config({}), sy(t.isDisabled), ry()])
                                                })]
                                            }]
                                        })
                                    }
                                });
                            return Dx(c, d, ["tox-form__group--stretched"], [])
                        })(e, t.shared.providers, o))),
                        grid: O_(((e, t) => ((e, t) => ({
                            dom: {
                                tag: "div",
                                classes: ["tox-form__grid", `tox-form__grid--${e.columns}col`]
                            },
                            components: z(e.items, t.interpreter)
                        }))(e, t.shared))),
                        listbox: O_(((e, t, o) => ((e, t, o) => {
                            const n = t.shared.providers,
                                r = o.bind((t => Bk(e.items, t))).orThunk((() => oe(e.items).filter(Nk))),
                                s = e.label.map((e => Hx(e, n))),
                                a = Ex.parts.field({
                                    dom: {},
                                    factory: {
                                        sketch: o => Ok({
                                            uid: o.uid,
                                            text: r.map((e => e.text)),
                                            icon: A.none(),
                                            tooltip: e.label,
                                            role: A.none(),
                                            fetch: (o, n) => {
                                                const r = Dk(o, e.name, e.items, ou.getValue(o));
                                                n(Mk(r, Xf.CLOSE_ON_EXECUTE, t, {
                                                    isHorizontalMenu: !1,
                                                    search: A.none()
                                                }))
                                            },
                                            onSetup: y(v),
                                            getApi: y({}),
                                            columns: 1,
                                            presets: "normal",
                                            classes: [],
                                            dropdownBehaviours: [Nx.config({}), ak(r.map((e => e.value)), (e => wt(e.element, Rk)), ((t, o) => {
                                                Bk(e.items, o).each((e => {
                                                    bt(t.element, Rk, e.value), _s(t, kk, {
                                                        text: e.text
                                                    })
                                                }))
                                            }))]
                                        }, "tox-listbox", t.shared)
                                    }
                                }),
                                i = {
                                    dom: {
                                        tag: "div",
                                        classes: ["tox-listboxfield"]
                                    },
                                    components: [a]
                                };
                            return Ex.sketch({
                                dom: {
                                    tag: "div",
                                    classes: ["tox-form__group"]
                                },
                                components: q([s.toArray(), [i]]),
                                fieldBehaviours: gl([Sm.config({
                                    disabled: y(!e.enabled),
                                    onDisabled: e => {
                                        Ex.getField(e).each(Sm.disable)
                                    },
                                    onEnabled: e => {
                                        Ex.getField(e).each(Sm.enable)
                                    }
                                })])
                            })
                        })(e, t, o))),
                        selectbox: O_(((e, t, o) => ((e, t, o) => {
                            const n = z(e.items, (e => ({
                                    text: t.translate(e.text),
                                    value: e.value
                                }))),
                                r = e.label.map((e => Hx(e, t))),
                                s = Ex.parts.field({
                                    dom: {},
                                    ...o.map((e => ({
                                        data: e
                                    }))).getOr({}),
                                    selectAttributes: {
                                        size: e.size
                                    },
                                    options: n,
                                    factory: Lk,
                                    selectBehaviours: gl([Sm.config({
                                        disabled: () => !e.enabled || t.isDisabled()
                                    }), Nx.config({}), Ih("selectbox-change", [Ds(Wr(), ((t, o) => {
                                        _s(t, Ix, {
                                            name: e.name
                                        })
                                    }))])])
                                }),
                                a = e.size > 1 ? A.none() : A.some(Fp("chevron-down", {
                                    tag: "div",
                                    classes: ["tox-selectfield__icon-js"]
                                }, t.icons)),
                                i = {
                                    dom: {
                                        tag: "div",
                                        classes: ["tox-selectfield"]
                                    },
                                    components: q([
                                        [s], a.toArray()
                                    ])
                                };
                            return Ex.sketch({
                                dom: {
                                    tag: "div",
                                    classes: ["tox-form__group"]
                                },
                                components: q([r.toArray(), [i]]),
                                fieldBehaviours: gl([Sm.config({
                                    disabled: () => !e.enabled || t.isDisabled(),
                                    onDisabled: e => {
                                        Ex.getField(e).each(Sm.disable)
                                    },
                                    onEnabled: e => {
                                        Ex.getField(e).each(Sm.enable)
                                    }
                                }), ry()])
                            })
                        })(e, t.shared.providers, o))),
                        sizeinput: O_(((e, t) => ((e, t) => {
                            let o = Zk;
                            const n = Qs("ratio-event"),
                                r = e => Fp(e, {
                                    tag: "span",
                                    classes: ["tox-icon", "tox-lock-icon__" + e]
                                }, t.icons),
                                s = zk.parts.lock({
                                    dom: {
                                        tag: "button",
                                        classes: ["tox-lock", "tox-button", "tox-button--naked", "tox-button--icon"],
                                        attributes: {
                                            title: t.translate(e.label.getOr("Constrain proportions"))
                                        }
                                    },
                                    components: [r("lock"), r("unlock")],
                                    buttonBehaviours: gl([Sm.config({
                                        disabled: () => !e.enabled || t.isDisabled()
                                    }), ry(), Nx.config({})])
                                }),
                                a = e => ({
                                    dom: {
                                        tag: "div",
                                        classes: ["tox-form__group"]
                                    },
                                    components: e
                                }),
                                i = o => Ex.parts.field({
                                    factory: wv,
                                    inputClasses: ["tox-textfield"],
                                    inputBehaviours: gl([Sm.config({
                                        disabled: () => !e.enabled || t.isDisabled()
                                    }), ry(), Nx.config({}), Ih("size-input-events", [Ds(Fr(), ((e, t) => {
                                        _s(e, n, {
                                            isField1: o
                                        })
                                    })), Ds(Wr(), ((t, o) => {
                                        _s(t, Ix, {
                                            name: e.name
                                        })
                                    }))])]),
                                    selectOnFocus: !1
                                }),
                                l = e => ({
                                    dom: {
                                        tag: "label",
                                        classes: ["tox-label"]
                                    },
                                    components: [Wa(t.translate(e))]
                                }),
                                c = zk.parts.field1(a([Ex.parts.label(l("Width")), i(!0)])),
                                d = zk.parts.field2(a([Ex.parts.label(l("Height")), i(!1)]));
                            return zk.sketch({
                                dom: {
                                    tag: "div",
                                    classes: ["tox-form__group"]
                                },
                                components: [{
                                    dom: {
                                        tag: "div",
                                        classes: ["tox-form__controls-h-stack"]
                                    },
                                    components: [c, d, a([l(""), s])]
                                }],
                                field1Name: "width",
                                field2Name: "height",
                                locked: !0,
                                markers: {
                                    lockClass: "tox-locked"
                                },
                                onLockedChange: (e, t, n) => {
                                    Fk(ou.getValue(e)).each((e => {
                                        o(e).each((e => {
                                            ou.setValue(t, (e => {
                                                const t = {
                                                    "": 0,
                                                    px: 0,
                                                    pt: 1,
                                                    mm: 1,
                                                    pc: 2,
                                                    ex: 2,
                                                    em: 2,
                                                    ch: 2,
                                                    rem: 2,
                                                    cm: 3,
                                                    in: 4,
                                                    "%": 4
                                                };
                                                let o = e.value.toFixed((n = e.unit) in t ? t[n] : 1);
                                                var n;
                                                return -1 !== o.indexOf(".") && (o = o.replace(/\.?0*$/, "")), o + e.unit
                                            })(e))
                                        }))
                                    }))
                                },
                                coupledFieldBehaviours: gl([Sm.config({
                                    disabled: () => !e.enabled || t.isDisabled(),
                                    onDisabled: e => {
                                        zk.getField1(e).bind(Ex.getField).each(Sm.disable), zk.getField2(e).bind(Ex.getField).each(Sm.disable), zk.getLock(e).each(Sm.disable)
                                    },
                                    onEnabled: e => {
                                        zk.getField1(e).bind(Ex.getField).each(Sm.enable), zk.getField2(e).bind(Ex.getField).each(Sm.enable), zk.getLock(e).each(Sm.enable)
                                    }
                                }), ry(), Ih("size-input-events2", [Ds(n, ((e, t) => {
                                    const n = t.event.isField1,
                                        r = n ? zk.getField1(e) : zk.getField2(e),
                                        s = n ? zk.getField2(e) : zk.getField1(e),
                                        a = r.map(ou.getValue).getOr(""),
                                        i = s.map(ou.getValue).getOr("");
                                    o = ((e, t) => {
                                        const o = Fk(e).toOptional(),
                                            n = Fk(t).toOptional();
                                        return Ce(o, n, ((e, t) => Vk(e, t.unit).map((e => t.value / e)).map((e => {
                                            return o = e, n = t.unit, e => Vk(e, n).map((e => ({
                                                value: e * o,
                                                unit: n
                                            })));
                                            var o, n
                                        })).getOr(Zk))).getOr(Zk)
                                    })(a, i)
                                }))])])
                            })
                        })(e, t.shared.providers))),
                        slider: O_(((e, t, o) => ((e, t, o) => {
                            const n = PS.parts.label({
                                    dom: {
                                        tag: "label",
                                        classes: ["tox-label"]
                                    },
                                    components: [Wa(t.translate(e.label))]
                                }),
                                r = PS.parts.spectrum({
                                    dom: {
                                        tag: "div",
                                        classes: ["tox-slider__rail"],
                                        attributes: {
                                            role: "presentation"
                                        }
                                    }
                                }),
                                s = PS.parts.thumb({
                                    dom: {
                                        tag: "div",
                                        classes: ["tox-slider__handle"],
                                        attributes: {
                                            role: "presentation"
                                        }
                                    }
                                });
                            return PS.sketch({
                                dom: {
                                    tag: "div",
                                    classes: ["tox-slider"],
                                    attributes: {
                                        role: "presentation"
                                    }
                                },
                                model: {
                                    mode: "x",
                                    minX: e.min,
                                    maxX: e.max,
                                    getInitialValue: y(o.getOrThunk((() => (Math.abs(e.max) - Math.abs(e.min)) / 2)))
                                },
                                components: [n, r, s],
                                sliderBehaviours: gl([QS(), Zh.config({})]),
                                onChoose: (t, o, n) => {
                                    _s(t, Ix, {
                                        name: e.name,
                                        value: n
                                    })
                                }
                            })
                        })(e, t.shared.providers, o))),
                        urlinput: O_(((e, t, o) => ((e, t, o, n) => {
                            const r = t.shared.providers,
                                s = t => {
                                    const n = ou.getValue(t);
                                    o.addToHistory(n.value, e.filetype)
                                },
                                a = { ...n.map((e => ({
                                        initialData: e
                                    }))).getOr({}),
                                    dismissOnBlur: !0,
                                    inputClasses: ["tox-textfield"],
                                    sandboxClasses: ["tox-dialog__popups"],
                                    inputAttributes: {
                                        "aria-errormessage": S_,
                                        type: "url"
                                    },
                                    minChars: 0,
                                    responseTime: 0,
                                    fetch: n => {
                                        const r = ((e, t, o) => {
                                                const n = ou.getValue(t),
                                                    r = void 0 !== n.meta.text ? n.meta.text : n.value;
                                                return o.getLinkInformation().fold((() => []), (t => {
                                                    const n = C_(r, (e => z(e, (e => f_(e, e))))(o.getHistory(e)));
                                                    return "file" === e ? (s = [n, C_(r, b_(t)), C_(r, q([w_(t), y_(t), x_(t)]))], j(s, ((e, t) => 0 === e.length || 0 === t.length ? e.concat(t) : e.concat(h_, t)), [])) : n;
                                                    var s
                                                }))
                                            })(e.filetype, n, o),
                                            s = Mk(r, Xf.BUBBLE_TO_SANDBOX, t, {
                                                isHorizontalMenu: !1,
                                                search: A.none()
                                            });
                                        return jw(s)
                                    },
                                    getHotspot: e => g.getOpt(e),
                                    onSetValue: (e, t) => {
                                        e.hasConfigured(tC) && tC.run(e).get(v)
                                    },
                                    typeaheadBehaviours: gl([...o.getValidationHandler().map((t => tC.config({
                                        getRoot: e => tt(e.element),
                                        invalidClass: "tox-control-wrap--status-invalid",
                                        notify: {
                                            onInvalid: (e, t) => {
                                                c.getOpt(e).each((e => {
                                                    bt(e.element, "title", r.translate(t))
                                                }))
                                            }
                                        },
                                        validator: {
                                            validate: o => {
                                                const n = ou.getValue(o);
                                                return r_((o => {
                                                    t({
                                                        type: e.filetype,
                                                        url: n.value
                                                    }, (e => {
                                                        if ("invalid" === e.status) {
                                                            const t = Xo.error(e.message);
                                                            o(t)
                                                        } else {
                                                            const t = Xo.value(e.message);
                                                            o(t)
                                                        }
                                                    }))
                                                }))
                                            },
                                            validateOnLoad: !1
                                        }
                                    }))).toArray(), Sm.config({
                                        disabled: () => !e.enabled || r.isDisabled()
                                    }), Nx.config({}), Ih("urlinput-events", [Ds(jr(), (t => {
                                        const o = Ha(t.element),
                                            n = o.trim();
                                        n !== o && Ia(t.element, n), "file" === e.filetype && _s(t, Ix, {
                                            name: e.name
                                        })
                                    })), Ds(Wr(), (t => {
                                        _s(t, Ix, {
                                            name: e.name
                                        }), s(t)
                                    })), Ds(ts(), (t => {
                                        _s(t, Ix, {
                                            name: e.name
                                        }), s(t)
                                    }))])]),
                                    eventOrder: {
                                        [jr()]: ["streaming", "urlinput-events", "invalidating"]
                                    },
                                    model: {
                                        getDisplayText: e => e.value,
                                        selectsOver: !1,
                                        populateFromBrowse: !1
                                    },
                                    markers: {
                                        openClass: "tox-textfield--popup-open"
                                    },
                                    lazySink: t.shared.getSink,
                                    parts: {
                                        menu: pv(0, 0, "normal")
                                    },
                                    onExecute: (e, t, o) => {
                                        _s(t, Vx, {})
                                    },
                                    onItemExecute: (t, o, n, r) => {
                                        s(t), _s(t, Ix, {
                                            name: e.name
                                        })
                                    }
                                },
                                i = Ex.parts.field({ ...a,
                                    factory: o_
                                }),
                                l = e.label.map((e => Hx(e, r))),
                                c = Mp(((e, t, o = e, n = e) => Fp(o, {
                                    tag: "div",
                                    classes: ["tox-icon", "tox-control-wrap__status-icon-" + e],
                                    attributes: {
                                        title: r.translate(n),
                                        "aria-live": "polite",
                                        ...t.fold((() => ({})), (e => ({
                                            id: e
                                        })))
                                    }
                                }, r.icons))("invalid", A.some(S_), "warning")),
                                d = Mp({
                                    dom: {
                                        tag: "div",
                                        classes: ["tox-control-wrap__status-icon-wrap"]
                                    },
                                    components: [c.asSpec()]
                                }),
                                u = o.getUrlPicker(e.filetype),
                                m = Qs("browser.url.event"),
                                g = Mp({
                                    dom: {
                                        tag: "div",
                                        classes: ["tox-control-wrap"]
                                    },
                                    components: [i, d.asSpec()],
                                    behaviours: gl([Sm.config({
                                        disabled: () => !e.enabled || r.isDisabled()
                                    })])
                                }),
                                h = Mp(u_({
                                    name: e.name,
                                    icon: A.some("browse"),
                                    text: e.label.getOr(""),
                                    enabled: e.enabled,
                                    primary: !1,
                                    buttonType: A.none(),
                                    borderless: !0
                                }, (e => ks(e, m)), r, [], ["tox-browse-url"]));
                            return Ex.sketch({
                                dom: Lx([]),
                                components: l.toArray().concat([{
                                    dom: {
                                        tag: "div",
                                        classes: ["tox-form__controls-h-stack"]
                                    },
                                    components: q([
                                        [g.asSpec()], u.map((() => h.asSpec())).toArray()
                                    ])
                                }]),
                                fieldBehaviours: gl([Sm.config({
                                    disabled: () => !e.enabled || r.isDisabled(),
                                    onDisabled: e => {
                                        Ex.getField(e).each(Sm.disable), h.getOpt(e).each(Sm.disable)
                                    },
                                    onEnabled: e => {
                                        Ex.getField(e).each(Sm.enable), h.getOpt(e).each(Sm.enable)
                                    }
                                }), ry(), Ih("url-input-events", [Ds(m, (t => {
                                    cm.getCurrent(t).each((o => {
                                        const n = ou.getValue(o),
                                            r = {
                                                fieldname: e.name,
                                                ...n
                                            };
                                        u.each((n => {
                                            n(r).get((n => {
                                                ou.setValue(o, n), _s(t, Ix, {
                                                    name: e.name
                                                })
                                            }))
                                        }))
                                    }))
                                }))])])
                            })
                        })(e, t, t.urlinput, o))),
                        customeditor: O_((e => {
                            const t = Zl(),
                                o = Mp({
                                    dom: {
                                        tag: e.tag
                                    }
                                }),
                                n = Zl();
                            return {
                                dom: {
                                    tag: "div",
                                    classes: ["tox-custom-editor"]
                                },
                                behaviours: gl([Ih("custom-editor-events", [Vs((r => {
                                    o.getOpt(r).each((o => {
                                        ((e => be(e, "init"))(e) ? e.init(o.element.dom) : ck.load(e.scriptId, e.scriptUrl).then((t => t(o.element.dom, e.settings)))).then((e => {
                                            n.on((t => {
                                                e.setValue(t)
                                            })), n.clear(), t.set(e)
                                        }))
                                    }))
                                }))]), ak(A.none(), (() => t.get().fold((() => n.get().getOr("")), (e => e.getValue()))), ((e, o) => {
                                    t.get().fold((() => n.set(o)), (e => e.setValue(o)))
                                })), QS()]),
                                components: [o.asSpec()]
                            }
                        })),
                        htmlpanel: O_((e => "presentation" === e.presets ? kx.sketch({
                            dom: {
                                tag: "div",
                                classes: ["tox-form__group"],
                                innerHtml: e.html
                            }
                        }) : kx.sketch({
                            dom: {
                                tag: "div",
                                classes: ["tox-form__group"],
                                innerHtml: e.html,
                                attributes: {
                                    role: "document"
                                }
                            },
                            containerBehaviours: gl([Nx.config({}), Zh.config({})])
                        }))),
                        imagepreview: O_(((e, t, o) => ((e, t) => {
                            const o = wr(t.getOr({
                                    url: ""
                                })),
                                n = Mp({
                                    dom: {
                                        tag: "img",
                                        classes: ["tox-imagepreview__image"],
                                        attributes: t.map((e => ({
                                            src: e.url
                                        }))).getOr({})
                                    }
                                }),
                                r = Mp({
                                    dom: {
                                        tag: "div",
                                        classes: ["tox-imagepreview__container"],
                                        attributes: {
                                            role: "presentation"
                                        }
                                    },
                                    components: [n.asSpec()]
                                }),
                                s = {};
                            e.height.each((e => s.height = e));
                            const a = t.map((e => ({
                                url: e.url,
                                zoom: A.from(e.zoom),
                                cachedWidth: A.from(e.cachedWidth),
                                cachedHeight: A.from(e.cachedHeight)
                            })));
                            return {
                                dom: {
                                    tag: "div",
                                    classes: ["tox-imagepreview"],
                                    styles: s,
                                    attributes: {
                                        role: "presentation"
                                    }
                                },
                                components: [r.asSpec()],
                                behaviours: gl([QS(), ak(a, (() => o.get()), ((e, t) => {
                                    const s = {
                                        url: t.url
                                    };
                                    t.zoom.each((e => s.zoom = e)), t.cachedWidth.each((e => s.cachedWidth = e)), t.cachedHeight.each((e => s.cachedHeight = e)), o.set(s);
                                    const a = () => {
                                        const {
                                            cachedWidth: t,
                                            cachedHeight: o,
                                            zoom: n
                                        } = s;
                                        if (!u(t) && !u(o)) {
                                            if (u(n)) {
                                                const n = ((e, t, o) => {
                                                    const n = $t(e),
                                                        r = Pt(e);
                                                    return Math.min(n / t, r / o, 1)
                                                })(e.element, t, o);
                                                s.zoom = n
                                            }
                                            const a = ((e, t, o, n, r) => {
                                                const s = o * r,
                                                    a = n * r,
                                                    i = Math.max(0, e / 2 - s / 2),
                                                    l = Math.max(0, t / 2 - a / 2);
                                                return {
                                                    left: i.toString() + "px",
                                                    top: l.toString() + "px",
                                                    width: s.toString() + "px",
                                                    height: a.toString() + "px"
                                                }
                                            })($t(e.element), Pt(e.element), t, o, s.zoom);
                                            r.getOpt(e).each((e => {
                                                Tt(e.element, a)
                                            }))
                                        }
                                    };
                                    n.getOpt(e).each((o => {
                                        const n = o.element;
                                        var r;
                                        t.url !== wt(n, "src") && (bt(n, "src", t.url), Ra(e.element, "tox-imagepreview__loaded")), a(), (r = n, new Promise(((e, t) => {
                                            const o = () => {
                                                    s(), e(r)
                                                },
                                                n = [jl(r, "load", o), jl(r, "error", (() => {
                                                    s(), t("Unable to load data from image: " + r.dom.src)
                                                }))],
                                                s = () => F(n, (e => e.unbind()));
                                            r.dom.complete && o()
                                        }))).then((t => {
                                            e.getSystem().isConnected() && (Na(e.element, "tox-imagepreview__loaded"), s.cachedWidth = t.dom.naturalWidth, s.cachedHeight = t.dom.naturalHeight, a())
                                        }))
                                    }))
                                }))])
                            }
                        })(e, o))),
                        table: O_(((e, t) => ((e, t) => {
                            const o = e => ({
                                dom: {
                                    tag: "td",
                                    innerHtml: t.translate(e)
                                }
                            });
                            return {
                                dom: {
                                    tag: "table",
                                    classes: ["tox-dialog__table"]
                                },
                                components: [(r = e.header, {
                                    dom: {
                                        tag: "thead"
                                    },
                                    components: [{
                                        dom: {
                                            tag: "tr"
                                        },
                                        components: z(r, (e => ({
                                            dom: {
                                                tag: "th",
                                                innerHtml: t.translate(e)
                                            }
                                        })))
                                    }]
                                }), (n = e.cells, {
                                    dom: {
                                        tag: "tbody"
                                    },
                                    components: z(n, (e => ({
                                        dom: {
                                            tag: "tr"
                                        },
                                        components: z(e, o)
                                    })))
                                })],
                                behaviours: gl([Nx.config({}), Zh.config({})])
                            };
                            var n, r
                        })(e, t.shared.providers))),
                        panel: O_(((e, t) => ((e, t) => ({
                            dom: {
                                tag: "div",
                                classes: e.classes
                            },
                            components: z(e.items, t.shared.interpreter)
                        }))(e, t)))
                    },
                    E_ = {
                        field: (e, t) => t,
                        record: y([])
                    },
                    A_ = (e, t, o, n) => {
                        const r = cn(n, {
                            shared: {
                                interpreter: t => M_(e, t, o, r)
                            }
                        });
                        return M_(e, t, o, r)
                    },
                    M_ = (e, t, o, n) => ve(T_, t.type).fold((() => (console.error(`Unknown factory type "${t.type}", defaulting to container: `, t), t)), (r => r(e, t, o, n))),
                    N_ = (e, t, o) => M_(E_, e, t, o),
                    R_ = "layout-inset",
                    D_ = e => e.x,
                    B_ = (e, t) => e.x + e.width / 2 - t.width / 2,
                    L_ = (e, t) => e.x + e.width - t.width,
                    H_ = e => e.y,
                    I_ = (e, t) => e.y + e.height - t.height,
                    P_ = (e, t) => e.y + e.height / 2 - t.height / 2,
                    z_ = (e, t, o) => Ei(L_(e, t), I_(e, t), o.insetSouthwest(), Di(), "southwest", Fi(e, {
                        right: 0,
                        bottom: 3
                    }), R_),
                    F_ = (e, t, o) => Ei(D_(e), I_(e, t), o.insetSoutheast(), Ri(), "southeast", Fi(e, {
                        left: 1,
                        bottom: 3
                    }), R_),
                    V_ = (e, t, o) => Ei(L_(e, t), H_(e), o.insetNorthwest(), Ni(), "northwest", Fi(e, {
                        right: 0,
                        top: 2
                    }), R_),
                    Z_ = (e, t, o) => Ei(D_(e), H_(e), o.insetNortheast(), Mi(), "northeast", Fi(e, {
                        left: 1,
                        top: 2
                    }), R_),
                    U_ = (e, t, o) => Ei(B_(e, t), H_(e), o.insetNorth(), Bi(), "north", Fi(e, {
                        top: 2
                    }), R_),
                    j_ = (e, t, o) => Ei(B_(e, t), I_(e, t), o.insetSouth(), Li(), "south", Fi(e, {
                        bottom: 3
                    }), R_),
                    W_ = (e, t, o) => Ei(L_(e, t), P_(e, t), o.insetEast(), Ii(), "east", Fi(e, {
                        right: 0
                    }), R_),
                    $_ = (e, t, o) => Ei(D_(e), P_(e, t), o.insetWest(), Hi(), "west", Fi(e, {
                        left: 1
                    }), R_),
                    q_ = e => {
                        switch (e) {
                            case "north":
                                return U_;
                            case "northeast":
                                return Z_;
                            case "northwest":
                                return V_;
                            case "south":
                                return j_;
                            case "southeast":
                                return F_;
                            case "southwest":
                                return z_;
                            case "east":
                                return W_;
                            case "west":
                                return $_
                        }
                    },
                    G_ = (e, t, o, n, r) => Il(n).map(q_).getOr(U_)(e, t, o, n, r),
                    K_ = e => {
                        switch (e) {
                            case "north":
                                return j_;
                            case "northeast":
                                return F_;
                            case "northwest":
                                return z_;
                            case "south":
                                return U_;
                            case "southeast":
                                return Z_;
                            case "southwest":
                                return V_;
                            case "east":
                                return $_;
                            case "west":
                                return W_
                        }
                    },
                    Y_ = (e, t, o, n, r) => Il(n).map(K_).getOr(U_)(e, t, o, n, r),
                    X_ = {
                        valignCentre: [],
                        alignCentre: [],
                        alignLeft: [],
                        alignRight: [],
                        right: [],
                        left: [],
                        bottom: [],
                        top: []
                    },
                    J_ = (e, t, o) => {
                        const n = {
                            maxHeightFunction: Jl()
                        };
                        return () => o() ? {
                            type: "node",
                            root: ut(dt(e())),
                            node: A.from(e()),
                            bubble: oc(12, 12, X_),
                            layouts: {
                                onRtl: () => [Z_],
                                onLtr: () => [V_]
                            },
                            overrides: n
                        } : {
                            type: "hotspot",
                            hotspot: t(),
                            bubble: oc(-12, 12, X_),
                            layouts: {
                                onRtl: () => [Gi],
                                onLtr: () => [Ki]
                            },
                            overrides: n
                        }
                    },
                    Q_ = (e, t, o) => () => o() ? {
                        type: "node",
                        root: ut(dt(e())),
                        node: A.from(e()),
                        layouts: {
                            onRtl: () => [U_],
                            onLtr: () => [U_]
                        }
                    } : {
                        type: "hotspot",
                        hotspot: t(),
                        layouts: {
                            onRtl: () => [Qi],
                            onLtr: () => [Qi]
                        }
                    },
                    eO = (e, t) => () => ({
                        type: "selection",
                        root: t(),
                        getSelection: () => {
                            const t = e.selection.getRng();
                            return A.some(Ac.range(Be(t.startContainer), t.startOffset, Be(t.endContainer), t.endOffset))
                        }
                    }),
                    tO = e => t => ({
                        type: "node",
                        root: e(),
                        node: t
                    }),
                    oO = (e, t, o) => {
                        const n = Zf(e),
                            r = () => Be(e.getBody()),
                            s = () => Be(e.getContentAreaContainer()),
                            a = () => n || !o();
                        return {
                            inlineDialog: J_(s, t, a),
                            banner: Q_(s, t, a),
                            cursor: eO(e, r),
                            node: tO(r)
                        }
                    },
                    nO = e => (t, o) => {
                        kw(e)(t, o)
                    },
                    rO = e => () => mw(e),
                    sO = e => t => gw(e, t),
                    aO = e => t => uw(e, t),
                    iO = e => () => _f(e),
                    lO = e => ye(e, "items"),
                    cO = e => ye(e, "format"),
                    dO = [{
                        title: "Headings",
                        items: [{
                            title: "Heading 1",
                            format: "h1"
                        }, {
                            title: "Heading 2",
                            format: "h2"
                        }, {
                            title: "Heading 3",
                            format: "h3"
                        }, {
                            title: "Heading 4",
                            format: "h4"
                        }, {
                            title: "Heading 5",
                            format: "h5"
                        }, {
                            title: "Heading 6",
                            format: "h6"
                        }]
                    }, {
                        title: "Inline",
                        items: [{
                            title: "Bold",
                            format: "bold"
                        }, {
                            title: "Italic",
                            format: "italic"
                        }, {
                            title: "Underline",
                            format: "underline"
                        }, {
                            title: "Strikethrough",
                            format: "strikethrough"
                        }, {
                            title: "Superscript",
                            format: "superscript"
                        }, {
                            title: "Subscript",
                            format: "subscript"
                        }, {
                            title: "Code",
                            format: "code"
                        }]
                    }, {
                        title: "Blocks",
                        items: [{
                            title: "Paragraph",
                            format: "p"
                        }, {
                            title: "Blockquote",
                            format: "blockquote"
                        }, {
                            title: "Div",
                            format: "div"
                        }, {
                            title: "Pre",
                            format: "pre"
                        }]
                    }, {
                        title: "Align",
                        items: [{
                            title: "Left",
                            format: "alignleft"
                        }, {
                            title: "Center",
                            format: "aligncenter"
                        }, {
                            title: "Right",
                            format: "alignright"
                        }, {
                            title: "Justify",
                            format: "alignjustify"
                        }]
                    }],
                    uO = e => j(e, ((e, t) => {
                        if (be(t, "items")) {
                            const o = uO(t.items);
                            return {
                                customFormats: e.customFormats.concat(o.customFormats),
                                formats: e.formats.concat([{
                                    title: t.title,
                                    items: o.formats
                                }])
                            }
                        }
                        if (be(t, "inline") || (e => be(e, "block"))(t) || (e => be(e, "selector"))(t)) {
                            const o = `custom-${s(t.name)?t.name:t.title.toLowerCase()}`;
                            return {
                                customFormats: e.customFormats.concat([{
                                    name: o,
                                    format: t
                                }]),
                                formats: e.formats.concat([{
                                    title: t.title,
                                    format: o,
                                    icon: t.icon
                                }])
                            }
                        }
                        return { ...e,
                            formats: e.formats.concat(t)
                        }
                    }), {
                        customFormats: [],
                        formats: []
                    }),
                    mO = e => rf(e).map((t => {
                        const o = ((e, t) => {
                            const o = uO(t),
                                n = t => {
                                    F(t, (t => {
                                        e.formatter.has(t.name) || e.formatter.register(t.name, t.format)
                                    }))
                                };
                            return e.formatter ? n(o.customFormats) : e.on("init", (() => {
                                n(o.customFormats)
                            })), o.formats
                        })(e, t);
                        return sf(e) ? dO.concat(o) : o
                    })).getOr(dO),
                    gO = (e, t, o) => ({ ...e,
                        type: "formatter",
                        isSelected: t(e.format),
                        getStylePreview: o(e.format)
                    }),
                    hO = (e, t, o, n) => {
                        const r = t => z(t, (t => lO(t) ? (e => {
                            const t = r(e.items);
                            return { ...e,
                                type: "submenu",
                                getStyleItems: y(t)
                            }
                        })(t) : cO(t) ? (e => gO(e, o, n))(t) : (e => {
                            const t = ae(e);
                            return 1 === t.length && L(t, "title")
                        })(t) ? { ...t,
                            type: "separator"
                        } : (t => {
                            const r = s(t.name) ? t.name : Qs(t.title),
                                a = `custom-${r}`,
                                i = { ...t,
                                    type: "formatter",
                                    format: a,
                                    isSelected: o(a),
                                    getStylePreview: n(a)
                                };
                            return e.formatter.register(r, i), i
                        })(t)));
                        return r(t)
                    },
                    pO = dk.trim,
                    fO = e => t => {
                        if ((e => g(e) && 1 === e.nodeType)(t)) {
                            if (t.contentEditable === e) return !0;
                            if (t.getAttribute("data-mce-contenteditable") === e) return !0
                        }
                        return !1
                    },
                    vO = fO("true"),
                    bO = fO("false"),
                    yO = (e, t, o, n, r) => ({
                        type: e,
                        title: t,
                        url: o,
                        level: n,
                        attach: r
                    }),
                    wO = e => e.innerText || e.textContent,
                    xO = e => (e => e && "A" === e.nodeName && void 0 !== (e.id || e.name))(e) && SO(e),
                    CO = e => e && /^(H[1-6])$/.test(e.nodeName),
                    SO = e => (e => {
                        let t = e;
                        for (; t = t.parentNode;) {
                            const e = t.contentEditable;
                            if (e && "inherit" !== e) return vO(t)
                        }
                        return !1
                    })(e) && !bO(e),
                    kO = e => CO(e) && SO(e),
                    _O = e => {
                        var t;
                        const o = (e => e.id ? e.id : Qs("h"))(e);
                        return yO("header", null !== (t = wO(e)) && void 0 !== t ? t : "", "#" + o, (e => CO(e) ? parseInt(e.nodeName.substr(1), 10) : 0)(e), (() => {
                            e.id = o
                        }))
                    },
                    OO = e => {
                        const t = e.id || e.name,
                            o = wO(e);
                        return yO("anchor", o || "#" + t, "#" + t, 0, v)
                    },
                    TO = e => pO(e.title).length > 0,
                    EO = e => {
                        const t = (e => {
                            const t = z(Hc(Be(e), "h1,h2,h3,h4,h5,h6,a:not([href])"), (e => e.dom));
                            return t
                        })(e);
                        return Z((e => z(Z(e, kO), _O))(t).concat((e => z(Z(e, xO), OO))(t)), TO)
                    },
                    AO = "tinymce-url-history",
                    MO = e => s(e) && /^https?/.test(e),
                    NO = e => a(e) && pe(e, (e => {
                        return !(l(t = e) && t.length <= 5 && K(t, MO));
                        var t
                    })).isNone(),
                    RO = () => {
                        const e = Xy.getItem(AO);
                        if (null === e) return {};
                        let t;
                        try {
                            t = JSON.parse(e)
                        } catch (e) {
                            if (e instanceof SyntaxError) return console.log("Local storage " + AO + " was not valid JSON", e), {};
                            throw e
                        }
                        return NO(t) ? t : (console.log("Local storage " + AO + " was not valid format", t), {})
                    },
                    DO = e => {
                        const t = RO();
                        return ve(t, e).getOr([])
                    },
                    BO = (e, t) => {
                        if (!MO(e)) return;
                        const o = RO(),
                            n = ve(o, t).getOr([]),
                            r = Z(n, (t => t !== e));
                        o[t] = [e].concat(r).slice(0, 5), (e => {
                            if (!NO(e)) throw new Error("Bad format for history:\n" + JSON.stringify(e));
                            Xy.setItem(AO, JSON.stringify(e))
                        })(o)
                    },
                    LO = e => !!e,
                    HO = e => ce(dk.makeMap(e, /[, ]/), LO),
                    IO = e => A.from(yf(e)),
                    PO = e => A.from(e).filter(s).getOrUndefined(),
                    zO = e => ({
                        getHistory: DO,
                        addToHistory: BO,
                        getLinkInformation: () => (e => Cf(e) ? A.some({
                            targets: EO(e.getBody()),
                            anchorTop: PO(Sf(e)),
                            anchorBottom: PO(kf(e))
                        }) : A.none())(e),
                        getValidationHandler: () => (e => A.from(wf(e)))(e),
                        getUrlPicker: t => ((e, t) => ((e, t) => {
                            const o = (e => {
                                const t = A.from(xf(e)).filter(LO).map(HO);
                                return IO(e).fold(O, (e => t.fold(T, (e => ae(e).length > 0 && e))))
                            })(e);
                            return d(o) ? o ? IO(e) : A.none() : o[t] ? IO(e) : A.none()
                        })(e, t).map((o => n => Uw((r => {
                            const i = {
                                filetype: t,
                                fieldname: n.fieldname,
                                ...A.from(n.meta).getOr({})
                            };
                            o.call(e, ((e, t) => {
                                if (!s(e)) throw new Error("Expected value to be string");
                                if (void 0 !== t && !a(t)) throw new Error("Expected meta to be a object");
                                r({
                                    value: e,
                                    meta: t
                                })
                            }), n.value, i)
                        })))))(e, t)
                    }),
                    FO = Ju,
                    VO = Lu,
                    ZO = y([ur("shell", !1), Gn("makeItem"), ur("setupItem", v), au("listBehaviours", [Hh])]),
                    UO = Ru({
                        name: "items",
                        overrides: () => ({
                            behaviours: gl([Hh.config({})])
                        })
                    }),
                    jO = y([UO]),
                    WO = sm({
                        name: y("CustomList")(),
                        configFields: ZO(),
                        partFields: jO(),
                        factory: (e, t, o, n) => {
                            const r = e.shell ? {
                                behaviours: [Hh.config({})],
                                components: []
                            } : {
                                behaviours: [],
                                components: t
                            };
                            return {
                                uid: e.uid,
                                dom: e.dom,
                                components: r.components,
                                behaviours: su(e.listBehaviours, r.behaviours),
                                apis: {
                                    setItems: (t, o) => {
                                        var n;
                                        (n = t, e.shell ? A.some(n) : ju(n, e, "items")).fold((() => {
                                            throw console.error("Custom List was defined to not be a shell, but no item container was specified in components"), new Error("Custom List was defined to not be a shell, but no item container was specified in components")
                                        }), (n => {
                                            const r = Hh.contents(n),
                                                s = o.length,
                                                a = s - r.length,
                                                i = a > 0 ? I(a, (() => e.makeItem())) : [],
                                                l = r.slice(s);
                                            F(l, (e => Hh.remove(n, e))), F(i, (e => Hh.append(n, e)));
                                            const c = Hh.contents(n);
                                            F(c, ((n, r) => {
                                                e.setupItem(t, n, o[r], r)
                                            }))
                                        }))
                                    }
                                }
                            }
                        },
                        apis: {
                            setItems: (e, t, o) => {
                                e.setItems(t, o)
                            }
                        }
                    }),
                    $O = y([Gn("dom"), ur("shell", !0), nu("toolbarBehaviours", [Hh])]),
                    qO = y([Ru({
                        name: "groups",
                        overrides: () => ({
                            behaviours: gl([Hh.config({})])
                        })
                    })]),
                    GO = sm({
                        name: "Toolbar",
                        configFields: $O(),
                        partFields: qO(),
                        factory: (e, t, o, n) => {
                            const r = e.shell ? {
                                behaviours: [Hh.config({})],
                                components: []
                            } : {
                                behaviours: [],
                                components: t
                            };
                            return {
                                uid: e.uid,
                                dom: e.dom,
                                components: r.components,
                                behaviours: su(e.toolbarBehaviours, r.behaviours),
                                apis: {
                                    setGroups: (t, o) => {
                                        var n;
                                        (n = t, e.shell ? A.some(n) : ju(n, e, "groups")).fold((() => {
                                            throw console.error("Toolbar was defined to not be a shell, but no groups container was specified in components"), new Error("Toolbar was defined to not be a shell, but no groups container was specified in components")
                                        }), (e => {
                                            Hh.set(e, o)
                                        }))
                                    }
                                },
                                domModification: {
                                    attributes: {
                                        role: "group"
                                    }
                                }
                            }
                        },
                        apis: {
                            setGroups: (e, t, o) => {
                                e.setGroups(t, o)
                            }
                        }
                    }),
                    KO = v,
                    YO = O,
                    XO = y([]);
                var JO, QO = Object.freeze({
                    __proto__: null,
                    setup: KO,
                    isDocked: YO,
                    getBehaviours: XO
                });
                const eT = e => (we(Nt(e, "position"), "fixed") ? A.none() : ot(e)).orThunk((() => {
                        const t = Re("span");
                        return et(e).bind((e => {
                            Do(e, t);
                            const o = ot(t);
                            return Ho(t), o
                        }))
                    })),
                    tT = e => eT(e).map(Ut).getOrThunk((() => Vt(0, 0))),
                    oT = xr([{
                        static: []
                    }, {
                        absolute: ["positionCss"]
                    }, {
                        fixed: ["positionCss"]
                    }]),
                    nT = (e, t) => {
                        const o = e.element;
                        Na(o, t.transitionClass), Ra(o, t.fadeOutClass), Na(o, t.fadeInClass), t.onShow(e)
                    },
                    rT = (e, t) => {
                        const o = e.element;
                        Na(o, t.transitionClass), Ra(o, t.fadeInClass), Na(o, t.fadeOutClass), t.onHide(e)
                    },
                    sT = (e, t, o) => K(e, (e => {
                        switch (e) {
                            case "bottom":
                                return ((e, t) => e.bottom <= t.bottom)(t, o);
                            case "top":
                                return ((e, t) => e.y >= t.y)(t, o)
                        }
                    })),
                    aT = (e, t) => t.getInitialPos().map((t => Wo(t.bounds.x, t.bounds.y, $t(e), Pt(e)))),
                    iT = (e, t, o) => o.getInitialPos().bind((n => {
                        switch (o.clearInitialPos(), n.position) {
                            case "static":
                                return A.some(oT.static());
                            case "absolute":
                                const o = eT(e).map($o).getOrThunk((() => $o(pt())));
                                return A.some(oT.absolute(Ol("absolute", ve(n.style, "left").map((e => t.x - o.x)), ve(n.style, "top").map((e => t.y - o.y)), ve(n.style, "right").map((e => o.right - t.right)), ve(n.style, "bottom").map((e => o.bottom - t.bottom)))));
                            default:
                                return A.none()
                        }
                    })),
                    lT = (e, t, o) => {
                        const n = e.element;
                        return we(Nt(n, "position"), "fixed") ? ((e, t, o) => aT(e, o).filter((e => sT(o.getModes(), e, t))).bind((t => iT(e, t, o))))(n, t, o) : ((e, t, o) => {
                            const n = $o(e);
                            if (sT(o.getModes(), n, t)) return A.none(); {
                                ((e, t, o) => {
                                    o.setInitialPos({
                                        style: Rt(e),
                                        position: At(e, "position") || "static",
                                        bounds: t
                                    })
                                })(e, n, o);
                                const r = Go(),
                                    s = n.x - r.x,
                                    a = t.y - r.y,
                                    i = r.bottom - t.bottom,
                                    l = n.y <= t.y;
                                return A.some(oT.fixed(Ol("fixed", A.some(s), l ? A.some(a) : A.none(), A.none(), l ? A.none() : A.some(i))))
                            }
                        })(n, t, o)
                    },
                    cT = (e, t, o) => {
                        o.setDocked(!1), F(["left", "right", "top", "bottom", "position"], (t => Bt(e.element, t))), t.onUndocked(e)
                    },
                    dT = (e, t, o, n) => {
                        const r = "fixed" === n.position;
                        o.setDocked(r), Tl(e.element, n), (r ? t.onDocked : t.onUndocked)(e)
                    },
                    uT = (e, t, o, n, r = !1) => {
                        t.contextual.each((t => {
                            t.lazyContext(e).each((s => {
                                const a = ((e, t) => e.y < t.bottom && e.bottom > t.y)(s, n);
                                a !== o.isVisible() && (o.setVisible(a), r && !a ? (Ba(e.element, [t.fadeOutClass]), t.onHide(e)) : (a ? nT : rT)(e, t))
                            }))
                        }))
                    },
                    mT = (e, t, o) => {
                        e.getSystem().isConnected() && ((e, t, o) => {
                            const n = t.lazyViewport(e);
                            o.isDocked() && uT(e, t, o, n), lT(e, n, o).each((r => {
                                r.fold((() => cT(e, t, o)), (n => dT(e, t, o, n)), (r => {
                                    uT(e, t, o, n, !0), dT(e, t, o, r)
                                }))
                            }))
                        })(e, t, o)
                    },
                    gT = (e, t, o) => {
                        o.isDocked() && ((e, t, o) => {
                            const n = e.element;
                            o.setDocked(!1), ((e, t) => {
                                const o = e.element;
                                return aT(o, t).bind((e => iT(o, e, t)))
                            })(e, o).each((n => {
                                n.fold((() => cT(e, t, o)), (n => dT(e, t, o, n)), v)
                            })), o.setVisible(!0), t.contextual.each((t => {
                                La(n, [t.fadeInClass, t.fadeOutClass, t.transitionClass]), t.onShow(e)
                            })), mT(e, t, o)
                        })(e, t, o)
                    };
                var hT = Object.freeze({
                        __proto__: null,
                        refresh: mT,
                        reset: gT,
                        isDocked: (e, t, o) => o.isDocked(),
                        getModes: (e, t, o) => o.getModes(),
                        setModes: (e, t, o, n) => o.setModes(n)
                    }),
                    pT = Object.freeze({
                        __proto__: null,
                        events: (e, t) => Ms([Fs(Gr(), ((o, n) => {
                            e.contextual.each((e => {
                                Da(o.element, e.transitionClass) && (La(o.element, [e.transitionClass, e.fadeInClass]), (t.isVisible() ? e.onShown : e.onHidden)(o)), n.stop()
                            }))
                        })), Ds(ms(), ((o, n) => {
                            mT(o, e, t)
                        })), Ds(gs(), ((o, n) => {
                            gT(o, e, t)
                        }))])
                    }),
                    fT = [dr("contextual", [Xn("fadeInClass"), Xn("fadeOutClass"), Xn("transitionClass"), Qn("lazyContext"), xi("onShow"), xi("onShown"), xi("onHide"), xi("onHidden")]), vr("lazyViewport", Go), br("modes", ["top", "bottom"], Rn), xi("onDocked"), xi("onUndocked")];
                const vT = pl({
                        fields: fT,
                        name: "docking",
                        active: pT,
                        apis: hT,
                        state: Object.freeze({
                            __proto__: null,
                            init: e => {
                                const t = wr(!1),
                                    o = wr(!0),
                                    n = Zl(),
                                    r = wr(e.modes);
                                return va({
                                    isDocked: t.get,
                                    setDocked: t.set,
                                    getInitialPos: n.get,
                                    setInitialPos: n.set,
                                    clearInitialPos: n.clear,
                                    isVisible: o.get,
                                    setVisible: o.set,
                                    getModes: r.get,
                                    setModes: r.set,
                                    readState: () => `docked:  ${t.get()}, visible: ${o.get()}, modes: ${r.get().join(",")}`
                                })
                            }
                        })
                    }),
                    bT = y(Qs("toolbar-height-change")),
                    yT = {
                        fadeInClass: "tox-editor-dock-fadein",
                        fadeOutClass: "tox-editor-dock-fadeout",
                        transitionClass: "tox-editor-dock-transition"
                    },
                    wT = "tox-tinymce--toolbar-sticky-on",
                    xT = "tox-tinymce--toolbar-sticky-off",
                    CT = (e, t) => L(vT.getModes(e), t),
                    ST = e => {
                        const t = e.element;
                        tt(t).each((o => {
                            const n = "padding-" + vT.getModes(e)[0];
                            if (vT.isDocked(e)) {
                                const e = $t(o);
                                Ot(t, "width", e + "px"), Ot(o, n, (e => zt(e) + (parseInt(At(e, "margin-top"), 10) || 0) + (parseInt(At(e, "margin-bottom"), 10) || 0))(t) + "px")
                            } else Bt(t, "width"), Bt(o, n)
                        }))
                    },
                    kT = (e, t) => {
                        t ? (Ra(e, yT.fadeOutClass), Ba(e, [yT.transitionClass, yT.fadeInClass])) : (Ra(e, yT.fadeInClass), Ba(e, [yT.fadeOutClass, yT.transitionClass]))
                    },
                    _T = (e, t) => {
                        const o = Be(e.getContainer());
                        t ? (Na(o, wT), Ra(o, xT)) : (Na(o, xT), Ra(o, wT))
                    },
                    OT = (e, t) => {
                        const o = Zl(),
                            n = t.getSink,
                            r = e => {
                                n().each((t => e(t.element)))
                            },
                            s = t => {
                                e.inline || ST(t), _T(e, vT.isDocked(t)), t.getSystem().broadcastOn([Pd()], {}), n().each((e => e.getSystem().broadcastOn([Pd()], {})))
                            },
                            a = e.inline ? [] : [yl.config({
                                channels: {
                                    [bT()]: {
                                        onReceive: ST
                                    }
                                }
                            })];
                        return [Zh.config({}), vT.config({
                            contextual: {
                                lazyContext: t => {
                                    const o = zt(t.element),
                                        n = e.inline ? e.getContentAreaContainer() : e.getContainer(),
                                        r = $o(Be(n)),
                                        s = r.height - o,
                                        a = r.y + (CT(t, "top") ? 0 : o);
                                    return A.some(Wo(r.x, a, r.width, s))
                                },
                                onShow: () => {
                                    r((e => kT(e, !0)))
                                },
                                onShown: e => {
                                    r((e => La(e, [yT.transitionClass, yT.fadeInClass]))), o.get().each((t => {
                                        ((e, t) => {
                                            const o = Ye(t);
                                            Sl(o).filter((e => !Ge(t, e))).filter((t => Ge(t, Be(o.dom.body)) || Ke(e, t))).each((() => xl(t)))
                                        })(e.element, t), o.clear()
                                    }))
                                },
                                onHide: e => {
                                    ((e, t) => kl(e).orThunk((() => t().toOptional().bind((e => kl(e.element))))))(e.element, n).fold(o.clear, o.set), r((e => kT(e, !1)))
                                },
                                onHidden: () => {
                                    r((e => La(e, [yT.transitionClass])))
                                },
                                ...yT
                            },
                            lazyViewport: t => {
                                const o = Go(),
                                    n = ff(e),
                                    r = o.y + (CT(t, "top") ? n : 0),
                                    s = o.height - (CT(t, "bottom") ? n : 0);
                                return Wo(o.x, r, o.width, s)
                            },
                            modes: [t.header.getDockingMode()],
                            onDocked: s,
                            onUndocked: s
                        }), ...a]
                    };
                var TT = Object.freeze({
                    __proto__: null,
                    setup: (e, t, o) => {
                        e.inline || (t.header.isPositionedAtTop() || e.on("ResizeEditor", (() => {
                            o().each(vT.reset)
                        })), e.on("ResizeWindow ResizeEditor", (() => {
                            o().each(ST)
                        })), e.on("SkinLoaded", (() => {
                            o().each((e => {
                                vT.isDocked(e) ? vT.reset(e) : vT.refresh(e)
                            }))
                        })), e.on("FullscreenStateChanged", (() => {
                            o().each(vT.reset)
                        }))), e.on("AfterScrollIntoView", (e => {
                            o().each((t => {
                                vT.refresh(t);
                                const o = t.element;
                                Cg(o) && ((e, t) => {
                                    const o = Ye(t),
                                        n = Qe(t).dom.innerHeight,
                                        r = Io(o),
                                        s = Be(e.elm),
                                        a = qo(s),
                                        i = Pt(s),
                                        l = a.y,
                                        c = l + i,
                                        d = Ut(t),
                                        u = Pt(t),
                                        m = d.top,
                                        g = m + u,
                                        h = Math.abs(m - r.top) < 2,
                                        p = Math.abs(g - (r.top + n)) < 2;
                                    if (h && l < g) Po(r.left, l - u, o);
                                    else if (p && c > m) {
                                        const e = l - n + i + u;
                                        Po(r.left, e, o)
                                    }
                                })(e, o)
                            }))
                        })), e.on("PostRender", (() => {
                            _T(e, !1)
                        }))
                    },
                    isDocked: e => e().map(vT.isDocked).getOr(!1),
                    getBehaviours: OT
                });
                const ET = kn([Pv, Kn("items", On([En([zv, or("items", Rn)]), Rn]))].concat(hb)),
                    AT = [ar("text"), ar("tooltip"), ar("icon"), mr("search", !1, On([Dn, kn([ar("placeholder")])], (e => d(e) ? e ? A.some({
                        placeholder: A.none()
                    }) : A.none() : A.some(e)))), Qn("fetch"), vr("onSetup", (() => v))],
                    MT = kn([Pv, ...AT]),
                    NT = e => Fn("menubutton", MT, e),
                    RT = kn([Pv, Qv, Jv, Xv, ob, Wv, Kv, pr("presets", "normal", ["normal", "color", "listpreview"]), ib(1), qv, Gv]);
                var DT = rm({
                    factory: (e, t) => {
                        const o = {
                            focus: Th.focusIn,
                            setMenus: (e, o) => {
                                const n = z(o, (e => {
                                    const o = {
                                            type: "menubutton",
                                            text: e.text,
                                            fetch: t => {
                                                t(e.getItems())
                                            }
                                        },
                                        n = NT(o).mapError((e => Un(e))).getOrDie();
                                    return a_(n, "tox-mbtn", t.backstage, A.some("menuitem"))
                                }));
                                Hh.set(e, n)
                            }
                        };
                        return {
                            uid: e.uid,
                            dom: e.dom,
                            components: [],
                            behaviours: gl([Hh.config({}), Ih("menubar-events", [Vs((t => {
                                e.onSetup(t)
                            })), Ds(zr(), ((e, t) => {
                                ri(e.element, ".tox-mbtn--active").each((o => {
                                    si(t.event.target, ".tox-mbtn").each((t => {
                                        Ge(o, t) || e.getSystem().getByDom(o).each((o => {
                                            e.getSystem().getByDom(t).each((e => {
                                                rx.expand(e), rx.close(o), Zh.focus(e)
                                            }))
                                        }))
                                    }))
                                }))
                            })), Ds(bs(), ((e, t) => {
                                t.event.prevFocus.bind((t => e.getSystem().getByDom(t).toOptional())).each((o => {
                                    t.event.newFocus.bind((t => e.getSystem().getByDom(t).toOptional())).each((e => {
                                        rx.isOpen(o) && (rx.expand(e), rx.close(o))
                                    }))
                                }))
                            }))]), Th.config({
                                mode: "flow",
                                selector: ".tox-mbtn",
                                onEscape: t => (e.onEscape(t), A.some(!0))
                            }), Nx.config({})]),
                            apis: o,
                            domModification: {
                                attributes: {
                                    role: "menubar"
                                }
                            }
                        }
                    },
                    name: "silver.Menubar",
                    configFields: [Gn("dom"), Gn("uid"), Gn("onEscape"), Gn("backstage"), ur("onSetup", v)],
                    apis: {
                        focus: (e, t) => {
                            e.focus(t)
                        },
                        setMenus: (e, t, o) => {
                            e.setMenus(t, o)
                        }
                    }
                });
                const BT = (e, t) => t.getAnimationRoot.fold((() => e.element), (t => t(e))),
                    LT = e => e.dimension.property,
                    HT = (e, t) => e.dimension.getDimension(t),
                    IT = (e, t) => {
                        const o = BT(e, t);
                        La(o, [t.shrinkingClass, t.growingClass])
                    },
                    PT = (e, t) => {
                        Ra(e.element, t.openClass), Na(e.element, t.closedClass), Ot(e.element, LT(t), "0px"), Lt(e.element)
                    },
                    zT = (e, t) => {
                        Ra(e.element, t.closedClass), Na(e.element, t.openClass), Bt(e.element, LT(t))
                    },
                    FT = (e, t, o, n) => {
                        o.setCollapsed(), Ot(e.element, LT(t), HT(t, e.element)), IT(e, t), PT(e, t), t.onStartShrink(e), t.onShrunk(e)
                    },
                    VT = (e, t, o, n) => {
                        const r = n.getOrThunk((() => HT(t, e.element)));
                        o.setCollapsed(), Ot(e.element, LT(t), r), Lt(e.element);
                        const s = BT(e, t);
                        Ra(s, t.growingClass), Na(s, t.shrinkingClass), PT(e, t), t.onStartShrink(e)
                    },
                    ZT = (e, t, o) => {
                        const n = HT(t, e.element);
                        ("0px" === n ? FT : VT)(e, t, o, A.some(n))
                    },
                    UT = (e, t, o) => {
                        const n = BT(e, t),
                            r = Da(n, t.shrinkingClass),
                            s = HT(t, e.element);
                        zT(e, t);
                        const a = HT(t, e.element);
                        (r ? () => {
                            Ot(e.element, LT(t), s), Lt(e.element)
                        } : () => {
                            PT(e, t)
                        })(), Ra(n, t.shrinkingClass), Na(n, t.growingClass), zT(e, t), Ot(e.element, LT(t), a), o.setExpanded(), t.onStartGrow(e)
                    },
                    jT = (e, t, o) => {
                        const n = BT(e, t);
                        return !0 === Da(n, t.growingClass)
                    },
                    WT = (e, t, o) => {
                        const n = BT(e, t);
                        return !0 === Da(n, t.shrinkingClass)
                    };
                var $T = Object.freeze({
                        __proto__: null,
                        refresh: (e, t, o) => {
                            if (o.isExpanded()) {
                                Bt(e.element, LT(t));
                                const o = HT(t, e.element);
                                Ot(e.element, LT(t), o)
                            }
                        },
                        grow: (e, t, o) => {
                            o.isExpanded() || UT(e, t, o)
                        },
                        shrink: (e, t, o) => {
                            o.isExpanded() && ZT(e, t, o)
                        },
                        immediateShrink: (e, t, o) => {
                            o.isExpanded() && FT(e, t, o)
                        },
                        hasGrown: (e, t, o) => o.isExpanded(),
                        hasShrunk: (e, t, o) => o.isCollapsed(),
                        isGrowing: jT,
                        isShrinking: WT,
                        isTransitioning: (e, t, o) => jT(e, t) || WT(e, t),
                        toggleGrow: (e, t, o) => {
                            (o.isExpanded() ? ZT : UT)(e, t, o)
                        },
                        disableTransitions: IT,
                        immediateGrow: (e, t, o) => {
                            o.isExpanded() || (zT(e, t), Ot(e.element, LT(t), HT(t, e.element)), IT(e, t), o.setExpanded(), t.onStartGrow(e), t.onGrown(e))
                        }
                    }),
                    qT = Object.freeze({
                        __proto__: null,
                        exhibit: (e, t, o) => {
                            const n = t.expanded;
                            return ya(n ? {
                                classes: [t.openClass],
                                styles: {}
                            } : {
                                classes: [t.closedClass],
                                styles: Cr(t.dimension.property, "0px")
                            })
                        },
                        events: (e, t) => Ms([Fs(Gr(), ((o, n) => {
                            n.event.raw.propertyName === e.dimension.property && (IT(o, e), t.isExpanded() && Bt(o.element, e.dimension.property), (t.isExpanded() ? e.onGrown : e.onShrunk)(o))
                        }))])
                    }),
                    GT = [Gn("closedClass"), Gn("openClass"), Gn("shrinkingClass"), Gn("growingClass"), nr("getAnimationRoot"), xi("onShrunk"), xi("onStartShrink"), xi("onGrown"), xi("onStartGrow"), ur("expanded", !1), Kn("dimension", jn("property", {
                        width: [_i("property", "width"), _i("getDimension", (e => $t(e) + "px"))],
                        height: [_i("property", "height"), _i("getDimension", (e => Pt(e) + "px"))]
                    }))];
                const KT = pl({
                        fields: GT,
                        name: "sliding",
                        active: qT,
                        apis: $T,
                        state: Object.freeze({
                            __proto__: null,
                            init: e => {
                                const t = wr(e.expanded);
                                return va({
                                    isExpanded: () => !0 === t.get(),
                                    isCollapsed: () => !1 === t.get(),
                                    setCollapsed: C(t.set, !1),
                                    setExpanded: C(t.set, !0),
                                    readState: () => "expanded: " + t.get()
                                })
                            }
                        })
                    }),
                    YT = "container",
                    XT = [nu("slotBehaviours", [])],
                    JT = e => "<alloy.field." + e + ">",
                    QT = (e, t) => {
                        const o = t => Gu(e),
                            n = (t, o) => (n, r) => ju(n, e, r).map((e => t(e, r))).getOr(o),
                            r = (e, t) => "true" !== wt(e.element, "aria-hidden"),
                            s = n(r, !1),
                            a = n(((e, t) => {
                                if (r(e)) {
                                    const o = e.element;
                                    Ot(o, "display", "none"), bt(o, "aria-hidden", "true"), _s(e, ys(), {
                                        name: t,
                                        visible: !1
                                    })
                                }
                            })),
                            i = (l = a, (e, t) => {
                                F(t, (t => l(e, t)))
                            });
                        var l;
                        const c = n(((e, t) => {
                                if (!r(e)) {
                                    const o = e.element;
                                    Bt(o, "display"), St(o, "aria-hidden"), _s(e, ys(), {
                                        name: t,
                                        visible: !0
                                    })
                                }
                            })),
                            d = {
                                getSlotNames: o,
                                getSlot: (t, o) => ju(t, e, o),
                                isShowing: s,
                                hideSlot: a,
                                hideAllSlots: e => i(e, o()),
                                showSlot: c
                            };
                        return {
                            uid: e.uid,
                            dom: e.dom,
                            components: t,
                            behaviours: ru(e.slotBehaviours),
                            apis: d
                        }
                    },
                    eE = ce({
                        getSlotNames: (e, t) => e.getSlotNames(t),
                        getSlot: (e, t, o) => e.getSlot(t, o),
                        isShowing: (e, t, o) => e.isShowing(t, o),
                        hideSlot: (e, t, o) => e.hideSlot(t, o),
                        hideAllSlots: (e, t) => e.hideAllSlots(t),
                        showSlot: (e, t, o) => e.showSlot(t, o)
                    }, (e => pa(e))),
                    tE = { ...eE,
                        sketch: e => {
                            const t = (() => {
                                    const e = [];
                                    return {
                                        slot: (t, o) => (e.push(t), zu(YT, JT(t), o)),
                                        record: y(e)
                                    }
                                })(),
                                o = e(t),
                                n = t.record(),
                                r = z(n, (e => Mu({
                                    name: e,
                                    pname: JT(e)
                                })));
                            return em(YT, XT, r, QT, o)
                        }
                    },
                    oE = kn([Jv, Qv, vr("onShow", v), vr("onHide", v), Kv]),
                    nE = e => ({
                        element: () => e.element.dom
                    }),
                    rE = (e, t) => {
                        const o = z(ae(t), (e => {
                            const o = t[e],
                                n = Vn((e => Fn("sidebar", oE, e))(o));
                            return {
                                name: e,
                                getApi: nE,
                                onSetup: n.onSetup,
                                onShow: n.onShow,
                                onHide: n.onHide
                            }
                        }));
                        return z(o, (t => {
                            const n = wr(v);
                            return e.slot(t.name, {
                                dom: {
                                    tag: "div",
                                    classes: ["tox-sidebar__pane"]
                                },
                                behaviours: Wb([cy(t, n), dy(t, n), Ds(ys(), ((e, t) => {
                                    const n = t.event,
                                        r = W(o, (e => e.name === n.name));
                                    r.each((t => {
                                        (n.visible ? t.onShow : t.onHide)(t.getApi(e))
                                    }))
                                }))])
                            })
                        }))
                    },
                    sE = e => tE.sketch((t => ({
                        dom: {
                            tag: "div",
                            classes: ["tox-sidebar__pane-container"]
                        },
                        components: rE(t, e),
                        slotBehaviours: Wb([Vs((e => tE.hideAllSlots(e)))])
                    }))),
                    aE = e => cm.getCurrent(e).bind((e => KT.isGrowing(e) || KT.hasGrown(e) ? cm.getCurrent(e).bind((e => W(tE.getSlotNames(e), (t => tE.isShowing(e, t))))) : A.none())),
                    iE = Qs("FixSizeEvent"),
                    lE = Qs("AutoSizeEvent");
                var cE = Object.freeze({
                        __proto__: null,
                        block: (e, t, o, n) => {
                            bt(e.element, "aria-busy", !0);
                            const r = t.getRoot(e).getOr(e),
                                s = gl([Th.config({
                                    mode: "special",
                                    onTab: () => A.some(!0),
                                    onShiftTab: () => A.some(!0)
                                }), Zh.config({})]),
                                a = n(r, s),
                                i = r.getSystem().build(a);
                            Hh.append(r, Ya(i)), i.hasConfigured(Th) && t.focus && Th.focusIn(i), o.isBlocked() || t.onBlock(e), o.blockWith((() => Hh.remove(r, i)))
                        },
                        unblock: (e, t, o) => {
                            St(e.element, "aria-busy"), o.isBlocked() && t.onUnblock(e), o.clear()
                        }
                    }),
                    dE = [vr("getRoot", A.none), fr("focus", !0), xi("onBlock"), xi("onUnblock")];
                const uE = pl({
                        fields: dE,
                        name: "blocking",
                        apis: cE,
                        state: Object.freeze({
                            __proto__: null,
                            init: () => {
                                const e = Fl((e => e.destroy()));
                                return va({
                                    readState: e.isSet,
                                    blockWith: t => {
                                        e.set({
                                            destroy: t
                                        })
                                    },
                                    clear: e.clear,
                                    isBlocked: e.isSet
                                })
                            }
                        })
                    }),
                    mE = e => {
                        const t = Ne(e),
                            o = nt(t),
                            n = (e => {
                                const t = void 0 !== e.dom.attributes ? e.dom.attributes : [];
                                return j(t, ((e, t) => "class" === t.name ? e : { ...e,
                                    [t.name]: t.value
                                }), {})
                            })(t),
                            r = (e => Array.prototype.slice.call(e.dom.classList, 0))(t),
                            s = 0 === o.length ? {} : {
                                innerHtml: Ws(t)
                            };
                        return {
                            tag: ze(t),
                            classes: r,
                            attributes: n,
                            ...s
                        }
                    },
                    gE = e => cm.getCurrent(e).each((e => xl(e.element))),
                    hE = (e, t, o) => {
                        const n = wr(!1),
                            r = Zl(),
                            s = o => {
                                var r;
                                n.get() && (!(e => "focusin" === e.type)(r = o) || !(r.composed ? oe(r.composedPath()) : A.from(r.target)).map(Be).filter(Ve).exists((e => Da(e, "mce-pastebin")))) && (o.preventDefault(), gE(t()), e.editorManager.setActive(e))
                            };
                        e.inline || e.on("PreInit", (() => {
                            e.dom.bind(e.getWin(), "focusin", s), e.on("BeforeExecCommand", (e => {
                                "mcefocus" === e.command.toLowerCase() && !0 !== e.value && s(e)
                            }))
                        }));
                        const a = r => {
                            r !== n.get() && (n.set(r), ((e, t, o, n) => {
                                const r = t.element;
                                if (((e, t) => {
                                        const o = "tabindex",
                                            n = `data-mce-${o}`;
                                        A.from(e.iframeElement).map(Be).each((e => {
                                            t ? (xt(e, o).each((t => bt(e, n, t))), bt(e, o, -1)) : (St(e, o), xt(e, n).each((t => {
                                                bt(e, o, t), St(e, n)
                                            })))
                                        }))
                                    })(e, o), o) uE.block(t, (e => (t, o) => ({
                                    dom: {
                                        tag: "div",
                                        attributes: {
                                            "aria-label": e.translate("Loading..."),
                                            tabindex: "0"
                                        },
                                        classes: ["tox-throbber__busy-spinner"]
                                    },
                                    components: [{
                                        dom: mE('<div class="tox-spinner"><div></div><div></div><div></div></div>')
                                    }]
                                }))(n)), Bt(r, "display"), St(r, "aria-hidden"), e.hasFocus() && gE(t);
                                else {
                                    const o = cm.getCurrent(t).exists((e => Cl(e.element)));
                                    uE.unblock(t), Ot(r, "display", "none"), bt(r, "aria-hidden", "true"), o && e.focus()
                                }
                            })(e, t(), r, o.providers), ((e, t) => {
                                e.dispatch("AfterProgressState", {
                                    state: t
                                })
                            })(e, r))
                        };
                        e.on("ProgressState", (t => {
                            if (r.on(clearTimeout), p(t.time)) {
                                const o = Ep.setEditorTimeout(e, (() => a(t.state)), t.time);
                                r.set(o)
                            } else a(t.state), r.clear()
                        }))
                    },
                    pE = (e, t, o) => ({
                        within: e,
                        extra: t,
                        withinWidth: o
                    }),
                    fE = (e, t, o) => {
                        const n = j(e, ((e, t) => ((e, t) => {
                                const n = o(e);
                                return A.some({
                                    element: e,
                                    start: t,
                                    finish: t + n,
                                    width: n
                                })
                            })(t, e.len).fold(y(e), (t => ({
                                len: t.finish,
                                list: e.list.concat([t])
                            })))), {
                                len: 0,
                                list: []
                            }).list,
                            r = Z(n, (e => e.finish <= t)),
                            s = U(r, ((e, t) => e + t.width), 0);
                        return {
                            within: r,
                            extra: n.slice(r.length),
                            withinWidth: s
                        }
                    },
                    vE = e => z(e, (e => e.element)),
                    bE = (e, t) => {
                        const o = z(t, (e => Ya(e)));
                        GO.setGroups(e, o)
                    },
                    yE = (e, t, o) => {
                        const n = t.builtGroups.get();
                        if (0 === n.length) return;
                        const r = Wu(e, t, "primary"),
                            s = Pw.getCoupled(e, "overflowGroup");
                        Ot(r.element, "visibility", "hidden");
                        const a = n.concat([s]),
                            i = se(a, (e => kl(e.element).bind((t => e.getSystem().getByDom(t).toOptional()))));
                        o([]), bE(r, a);
                        const l = ((e, t, o, n) => {
                            const r = ((e, t, o) => {
                                    const n = fE(t, e, o);
                                    return 0 === n.extra.length ? A.some(n) : A.none()
                                })(e, t, o).getOrThunk((() => fE(t, e - o(n), o))),
                                s = r.within,
                                a = r.extra,
                                i = r.withinWidth;
                            return 1 === a.length && a[0].width <= o(n) ? ((e, t, o) => {
                                const n = vE(e.concat(t));
                                return pE(n, [], o)
                            })(s, a, i) : a.length >= 1 ? ((e, t, o, n) => {
                                const r = vE(e).concat([o]);
                                return pE(r, vE(t), n)
                            })(s, a, n, i) : ((e, t, o) => pE(vE(e), [], o))(s, 0, i)
                        })($t(r.element), t.builtGroups.get(), (e => $t(e.element)), s);
                        0 === l.extra.length ? (Hh.remove(r, s), o([])) : (bE(r, l.within), o(l.extra)), Bt(r.element, "visibility"), Lt(r.element), i.each(Zh.focus)
                    },
                    wE = y([nu("splitToolbarBehaviours", [Pw]), $n("builtGroups", (() => wr([])))]),
                    xE = y([yi(["overflowToggledClass"]), lr("getOverflowBounds"), Gn("lazySink"), $n("overflowGroups", (() => wr([]))), xi("onOpened"), xi("onClosed")].concat(wE())),
                    CE = y([Mu({
                        factory: GO,
                        schema: $O(),
                        name: "primary"
                    }), Nu({
                        schema: $O(),
                        name: "overflow"
                    }), Nu({
                        name: "overflow-button"
                    }), Nu({
                        name: "overflow-group"
                    })]),
                    SE = y(((e, t) => {
                        ((e, t) => {
                            const o = Wt.max(e, t, ["margin-left", "border-left-width", "padding-left", "padding-right", "border-right-width", "margin-right"]);
                            Ot(e, "max-width", o + "px")
                        })(e, Math.floor(t))
                    })),
                    kE = y([yi(["toggledClass"]), Gn("lazySink"), Qn("fetch"), lr("getBounds"), dr("fireDismissalEventInstead", [ur("event", fs())]), dc(), xi("onToggled")]),
                    _E = y([Nu({
                        name: "button",
                        overrides: e => ({
                            dom: {
                                attributes: {
                                    "aria-haspopup": "true"
                                }
                            },
                            buttonBehaviours: gl([Yh.config({
                                toggleClass: e.markers.toggledClass,
                                aria: {
                                    mode: "expanded"
                                },
                                toggleOnExecute: !1,
                                onToggled: e.onToggled
                            })])
                        })
                    }), Nu({
                        factory: GO,
                        schema: $O(),
                        name: "toolbar",
                        overrides: e => ({
                            toolbarBehaviours: gl([Th.config({
                                mode: "cyclic",
                                onEscape: t => (ju(t, e, "button").each(Zh.focus), A.none())
                            })])
                        })
                    })]),
                    OE = (e, t) => {
                        const o = Pw.getCoupled(e, "toolbarSandbox");
                        Hd.isOpen(o) ? Hd.close(o) : Hd.open(o, t.toolbar())
                    },
                    TE = (e, t, o, n) => {
                        const r = o.getBounds.map((e => e())),
                            s = o.lazySink(e).getOrDie();
                        ud.positionWithinBounds(s, t, {
                            anchor: {
                                type: "hotspot",
                                hotspot: e,
                                layouts: n,
                                overrides: {
                                    maxWidthFunction: SE()
                                }
                            }
                        }, r)
                    },
                    EE = (e, t, o, n, r) => {
                        GO.setGroups(t, r), TE(e, t, o, n), Yh.on(e)
                    },
                    AE = sm({
                        name: "FloatingToolbarButton",
                        factory: (e, t, o, n) => ({ ...Ap.sketch({ ...n.button(),
                                action: e => {
                                    OE(e, n)
                                },
                                buttonBehaviours: iu({
                                    dump: n.button().buttonBehaviours
                                }, [Pw.config({
                                    others: {
                                        toolbarSandbox: t => ((e, t, o) => {
                                            const n = ii();
                                            return {
                                                dom: {
                                                    tag: "div",
                                                    attributes: {
                                                        id: n.id
                                                    }
                                                },
                                                behaviours: gl([Th.config({
                                                    mode: "special",
                                                    onEscape: e => (Hd.close(e), A.some(!0))
                                                }), Hd.config({
                                                    onOpen: (r, s) => {
                                                        o.fetch().get((r => {
                                                            EE(e, s, o, t.layouts, r), n.link(e.element), Th.focusIn(s)
                                                        }))
                                                    },
                                                    onClose: () => {
                                                        Yh.off(e), Zh.focus(e), n.unlink(e.element)
                                                    },
                                                    isPartOf: (t, o, n) => li(o, n) || li(e, n),
                                                    getAttachPoint: () => o.lazySink(e).getOrDie()
                                                }), yl.config({
                                                    channels: { ...Vd({
                                                            isExtraPart: O,
                                                            ...o.fireDismissalEventInstead.map((e => ({
                                                                fireEventInstead: {
                                                                    event: e.event
                                                                }
                                                            }))).getOr({})
                                                        }),
                                                        ...Ud({
                                                            doReposition: () => {
                                                                Hd.getState(Pw.getCoupled(e, "toolbarSandbox")).each((n => {
                                                                    TE(e, n, o, t.layouts)
                                                                }))
                                                            }
                                                        })
                                                    }
                                                })])
                                            }
                                        })(t, o, e)
                                    }
                                })])
                            }),
                            apis: {
                                setGroups: (t, n) => {
                                    Hd.getState(Pw.getCoupled(t, "toolbarSandbox")).each((r => {
                                        EE(t, r, e, o.layouts, n)
                                    }))
                                },
                                reposition: t => {
                                    Hd.getState(Pw.getCoupled(t, "toolbarSandbox")).each((n => {
                                        TE(t, n, e, o.layouts)
                                    }))
                                },
                                toggle: e => {
                                    OE(e, n)
                                },
                                getToolbar: e => Hd.getState(Pw.getCoupled(e, "toolbarSandbox")),
                                isOpen: e => Hd.isOpen(Pw.getCoupled(e, "toolbarSandbox"))
                            }
                        }),
                        configFields: kE(),
                        partFields: _E(),
                        apis: {
                            setGroups: (e, t, o) => {
                                e.setGroups(t, o)
                            },
                            reposition: (e, t) => {
                                e.reposition(t)
                            },
                            toggle: (e, t) => {
                                e.toggle(t)
                            },
                            getToolbar: (e, t) => e.getToolbar(t),
                            isOpen: (e, t) => e.isOpen(t)
                        }
                    }),
                    ME = y([Gn("items"), yi(["itemSelector"]), nu("tgroupBehaviours", [Th])]),
                    NE = y([Du({
                        name: "items",
                        unit: "item"
                    })]),
                    RE = sm({
                        name: "ToolbarGroup",
                        configFields: ME(),
                        partFields: NE(),
                        factory: (e, t, o, n) => ({
                            uid: e.uid,
                            dom: e.dom,
                            components: t,
                            behaviours: su(e.tgroupBehaviours, [Th.config({
                                mode: "flow",
                                selector: e.markers.itemSelector
                            })]),
                            domModification: {
                                attributes: {
                                    role: "toolbar"
                                }
                            }
                        })
                    }),
                    DE = e => z(e, (e => Ya(e))),
                    BE = (e, t, o) => {
                        yE(e, o, (n => {
                            o.overflowGroups.set(n), t.getOpt(e).each((e => {
                                AE.setGroups(e, DE(n))
                            }))
                        }))
                    },
                    LE = sm({
                        name: "SplitFloatingToolbar",
                        configFields: xE(),
                        partFields: CE(),
                        factory: (e, t, o, n) => {
                            const r = Mp(AE.sketch({
                                fetch: () => Uw((t => {
                                    t(DE(e.overflowGroups.get()))
                                })),
                                layouts: {
                                    onLtr: () => [Ki, Gi],
                                    onRtl: () => [Gi, Ki],
                                    onBottomLtr: () => [Xi, Yi],
                                    onBottomRtl: () => [Yi, Xi]
                                },
                                getBounds: o.getOverflowBounds,
                                lazySink: e.lazySink,
                                fireDismissalEventInstead: {},
                                markers: {
                                    toggledClass: e.markers.overflowToggledClass
                                },
                                parts: {
                                    button: n["overflow-button"](),
                                    toolbar: n.overflow()
                                },
                                onToggled: (t, o) => e[o ? "onOpened" : "onClosed"](t)
                            }));
                            return {
                                uid: e.uid,
                                dom: e.dom,
                                components: t,
                                behaviours: su(e.splitToolbarBehaviours, [Pw.config({
                                    others: {
                                        overflowGroup: () => RE.sketch({ ...n["overflow-group"](),
                                            items: [r.asSpec()]
                                        })
                                    }
                                })]),
                                apis: {
                                    setGroups: (t, o) => {
                                        e.builtGroups.set(z(o, t.getSystem().build)), BE(t, r, e)
                                    },
                                    refresh: t => BE(t, r, e),
                                    toggle: e => {
                                        r.getOpt(e).each((e => {
                                            AE.toggle(e)
                                        }))
                                    },
                                    isOpen: e => r.getOpt(e).map(AE.isOpen).getOr(!1),
                                    reposition: e => {
                                        r.getOpt(e).each((e => {
                                            AE.reposition(e)
                                        }))
                                    },
                                    getOverflow: e => r.getOpt(e).bind(AE.getToolbar)
                                },
                                domModification: {
                                    attributes: {
                                        role: "group"
                                    }
                                }
                            }
                        },
                        apis: {
                            setGroups: (e, t, o) => {
                                e.setGroups(t, o)
                            },
                            refresh: (e, t) => {
                                e.refresh(t)
                            },
                            reposition: (e, t) => {
                                e.reposition(t)
                            },
                            toggle: (e, t) => {
                                e.toggle(t)
                            },
                            isOpen: (e, t) => e.isOpen(t),
                            getOverflow: (e, t) => e.getOverflow(t)
                        }
                    }),
                    HE = y([yi(["closedClass", "openClass", "shrinkingClass", "growingClass", "overflowToggledClass"]), xi("onOpened"), xi("onClosed")].concat(wE())),
                    IE = y([Mu({
                        factory: GO,
                        schema: $O(),
                        name: "primary"
                    }), Mu({
                        factory: GO,
                        schema: $O(),
                        name: "overflow",
                        overrides: e => ({
                            toolbarBehaviours: gl([KT.config({
                                dimension: {
                                    property: "height"
                                },
                                closedClass: e.markers.closedClass,
                                openClass: e.markers.openClass,
                                shrinkingClass: e.markers.shrinkingClass,
                                growingClass: e.markers.growingClass,
                                onShrunk: t => {
                                    ju(t, e, "overflow-button").each((e => {
                                        Yh.off(e), Zh.focus(e)
                                    })), e.onClosed(t)
                                },
                                onGrown: t => {
                                    Th.focusIn(t), e.onOpened(t)
                                },
                                onStartGrow: t => {
                                    ju(t, e, "overflow-button").each(Yh.on)
                                }
                            }), Th.config({
                                mode: "acyclic",
                                onEscape: t => (ju(t, e, "overflow-button").each(Zh.focus), A.some(!0))
                            })])
                        })
                    }), Nu({
                        name: "overflow-button",
                        overrides: e => ({
                            buttonBehaviours: gl([Yh.config({
                                toggleClass: e.markers.overflowToggledClass,
                                aria: {
                                    mode: "pressed"
                                },
                                toggleOnExecute: !1
                            })])
                        })
                    }), Nu({
                        name: "overflow-group"
                    })]),
                    PE = (e, t) => {
                        ju(e, t, "overflow-button").bind((() => ju(e, t, "overflow"))).each((o => {
                            zE(e, t), KT.toggleGrow(o)
                        }))
                    },
                    zE = (e, t) => {
                        ju(e, t, "overflow").each((o => {
                            yE(e, t, (e => {
                                const t = z(e, (e => Ya(e)));
                                GO.setGroups(o, t)
                            })), ju(e, t, "overflow-button").each((e => {
                                KT.hasGrown(o) && Yh.on(e)
                            })), KT.refresh(o)
                        }))
                    },
                    FE = sm({
                        name: "SplitSlidingToolbar",
                        configFields: HE(),
                        partFields: IE(),
                        factory: (e, t, o, n) => {
                            const r = "alloy.toolbar.toggle";
                            return {
                                uid: e.uid,
                                dom: e.dom,
                                components: t,
                                behaviours: su(e.splitToolbarBehaviours, [Pw.config({
                                    others: {
                                        overflowGroup: e => RE.sketch({ ...n["overflow-group"](),
                                            items: [Ap.sketch({ ...n["overflow-button"](),
                                                action: t => {
                                                    ks(e, r)
                                                }
                                            })]
                                        })
                                    }
                                }), Ih("toolbar-toggle-events", [Ds(r, (t => {
                                    PE(t, e)
                                }))])]),
                                apis: {
                                    setGroups: (t, o) => {
                                        ((t, o) => {
                                            const n = z(o, t.getSystem().build);
                                            e.builtGroups.set(n)
                                        })(t, o), zE(t, e)
                                    },
                                    refresh: t => zE(t, e),
                                    toggle: t => PE(t, e),
                                    isOpen: t => ((e, t) => ju(e, t, "overflow").map(KT.hasGrown).getOr(!1))(t, e)
                                },
                                domModification: {
                                    attributes: {
                                        role: "group"
                                    }
                                }
                            }
                        },
                        apis: {
                            setGroups: (e, t, o) => {
                                e.setGroups(t, o)
                            },
                            refresh: (e, t) => {
                                e.refresh(t)
                            },
                            toggle: (e, t) => {
                                e.toggle(t)
                            },
                            isOpen: (e, t) => e.isOpen(t)
                        }
                    }),
                    VE = e => {
                        const t = e.title.fold((() => ({})), (e => ({
                            attributes: {
                                title: e
                            }
                        })));
                        return {
                            dom: {
                                tag: "div",
                                classes: ["tox-toolbar__group"],
                                ...t
                            },
                            components: [RE.parts.items({})],
                            items: e.items,
                            markers: {
                                itemSelector: "*:not(.tox-split-button) > .tox-tbtn:not([disabled]), .tox-split-button:not([disabled]), .tox-toolbar-nav-js:not([disabled])"
                            },
                            tgroupBehaviours: gl([Nx.config({}), Zh.config({})])
                        }
                    },
                    ZE = e => RE.sketch(VE(e)),
                    UE = (e, t) => {
                        const o = Vs((t => {
                            const o = z(e.initGroups, ZE);
                            GO.setGroups(t, o)
                        }));
                        return gl([iy(e.providers.isDisabled), ry(), Th.config({
                            mode: t,
                            onEscape: e.onEscape,
                            selector: ".tox-toolbar__group"
                        }), Ih("toolbar-events", [o])])
                    },
                    jE = e => {
                        const t = e.cyclicKeying ? "cyclic" : "acyclic";
                        return {
                            uid: e.uid,
                            dom: {
                                tag: "div",
                                classes: ["tox-toolbar-overlord"]
                            },
                            parts: {
                                "overflow-group": VE({
                                    title: A.none(),
                                    items: []
                                }),
                                "overflow-button": c_({
                                    name: "more",
                                    icon: A.some("more-drawer"),
                                    enabled: !0,
                                    tooltip: A.some("More..."),
                                    primary: !1,
                                    buttonType: A.none(),
                                    borderless: !1
                                }, A.none(), e.providers)
                            },
                            splitToolbarBehaviours: UE(e, t)
                        }
                    },
                    WE = e => {
                        const t = jE(e),
                            o = LE.parts.primary({
                                dom: {
                                    tag: "div",
                                    classes: ["tox-toolbar__primary"]
                                }
                            });
                        return LE.sketch({ ...t,
                            lazySink: e.getSink,
                            getOverflowBounds: () => {
                                const t = e.moreDrawerData.lazyHeader().element,
                                    o = qo(t),
                                    n = Je(t),
                                    r = qo(n),
                                    s = Math.max(n.dom.scrollHeight, r.height);
                                return Wo(o.x + 4, r.y, o.width - 8, s)
                            },
                            parts: { ...t.parts,
                                overflow: {
                                    dom: {
                                        tag: "div",
                                        classes: ["tox-toolbar__overflow"],
                                        attributes: e.attributes
                                    }
                                }
                            },
                            components: [o],
                            markers: {
                                overflowToggledClass: "tox-tbtn--enabled"
                            },
                            onOpened: t => e.onToggled(t, !0),
                            onClosed: t => e.onToggled(t, !1)
                        })
                    },
                    $E = e => {
                        const t = FE.parts.primary({
                                dom: {
                                    tag: "div",
                                    classes: ["tox-toolbar__primary"]
                                }
                            }),
                            o = FE.parts.overflow({
                                dom: {
                                    tag: "div",
                                    classes: ["tox-toolbar__overflow"]
                                }
                            }),
                            n = jE(e);
                        return FE.sketch({ ...n,
                            components: [t, o],
                            markers: {
                                openClass: "tox-toolbar__overflow--open",
                                closedClass: "tox-toolbar__overflow--closed",
                                growingClass: "tox-toolbar__overflow--growing",
                                shrinkingClass: "tox-toolbar__overflow--shrinking",
                                overflowToggledClass: "tox-tbtn--enabled"
                            },
                            onOpened: t => {
                                t.getSystem().broadcastOn([bT()], {
                                    type: "opened"
                                }), e.onToggled(t, !0)
                            },
                            onClosed: t => {
                                t.getSystem().broadcastOn([bT()], {
                                    type: "closed"
                                }), e.onToggled(t, !1)
                            }
                        })
                    },
                    qE = e => {
                        const t = e.cyclicKeying ? "cyclic" : "acyclic";
                        return GO.sketch({
                            uid: e.uid,
                            dom: {
                                tag: "div",
                                classes: ["tox-toolbar"].concat(e.type === Up.scrolling ? ["tox-toolbar--scrolling"] : [])
                            },
                            components: [GO.parts.groups({})],
                            toolbarBehaviours: UE(e, t)
                        })
                    },
                    GE = [Jn("type", ["button"]), Vv, pr("buttonType", "secondary", ["primary", "secondary"]), Qn("onAction")],
                    KE = jn("type", {
                        button: GE
                    }),
                    YE = kn([br("buttons", [], KE), Qn("onShow"), Qn("onHide")]);
                var XE = sm({
                    name: "silver.View",
                    configFields: [Gn("viewConfig")],
                    partFields: [Ru({
                        factory: {
                            sketch: e => {
                                const t = z(e.buttons, (t => ((e, t) => u_({
                                    text: e.text,
                                    enabled: !0,
                                    primary: !1,
                                    name: "name",
                                    icon: A.none(),
                                    borderless: !1,
                                    buttonType: A.some(e.buttonType)
                                }, (t => {
                                    e.onAction()
                                }), t))(t, e.providers)));
                                return {
                                    uid: e.uid,
                                    dom: {
                                        tag: "div",
                                        classes: ["tox-view__header"]
                                    },
                                    components: [kx.sketch({
                                        dom: {
                                            tag: "div",
                                            classes: ["tox-view__header-start"]
                                        },
                                        components: []
                                    }), kx.sketch({
                                        dom: {
                                            tag: "div",
                                            classes: ["tox-view__header-end"]
                                        },
                                        components: t
                                    })]
                                }
                            }
                        },
                        schema: [Gn("buttons"), Gn("providers")],
                        name: "header"
                    }), Ru({
                        factory: {
                            sketch: e => ({
                                uid: e.uid,
                                dom: {
                                    tag: "div",
                                    classes: ["tox-view__pane"]
                                }
                            })
                        },
                        schema: [],
                        name: "pane"
                    })],
                    factory: (e, t, o, n) => {
                        const r = {
                            getPane: t => FO.getPart(t, e, "pane"),
                            getOnShow: t => e.viewConfig.onShow,
                            getOnHide: t => e.viewConfig.onHide
                        };
                        return {
                            uid: e.uid,
                            dom: e.dom,
                            components: t,
                            apis: r
                        }
                    },
                    apis: {
                        getPane: (e, t) => e.getPane(t),
                        getOnShow: (e, t) => e.getOnShow(t),
                        getOnHide: (e, t) => e.getOnHide(t)
                    }
                });
                const JE = (e, t, o) => he(t, ((t, n) => {
                        const r = Vn(Fn("view", YE, t));
                        return e.slot(n, XE.sketch({
                            dom: {
                                tag: "div",
                                classes: ["tox-view"]
                            },
                            viewConfig: r,
                            components: [...r.buttons.length > 0 ? [XE.parts.header({
                                buttons: r.buttons,
                                providers: o
                            })] : [], XE.parts.pane({})]
                        }))
                    })),
                    QE = (e, t) => tE.sketch((o => ({
                        dom: {
                            tag: "div",
                            classes: ["tox-view-wrap__slot-container"]
                        },
                        components: JE(o, e, t),
                        slotBehaviours: Wb([Vs((e => tE.hideAllSlots(e)))])
                    }))),
                    eA = e => W(tE.getSlotNames(e), (t => tE.isShowing(e, t))),
                    tA = (e, t, o) => {
                        tE.getSlot(e, t).each((e => {
                            XE.getPane(e).each((t => {
                                var n;
                                o(e)((n = t.element.dom, {
                                    getContainer: y(n)
                                }))
                            }))
                        }))
                    };
                var oA = rm({
                    factory: (e, t) => {
                        const o = {
                            setViews: (e, o) => {
                                Hh.set(e, [QE(o, t.backstage.shared.providers)])
                            },
                            whichView: e => cm.getCurrent(e).bind(eA),
                            toggleView: (e, t, o, n) => cm.getCurrent(e).exists((r => {
                                const s = eA(r),
                                    a = s.exists((e => n === e)),
                                    i = tE.getSlot(r, n).isSome();
                                return i && (tE.hideAllSlots(r), a ? ((e => {
                                    const t = e.element;
                                    Ot(t, "display", "none"), bt(t, "aria-hidden", "true")
                                })(e), t()) : (o(), (e => {
                                    const t = e.element;
                                    Bt(t, "display"), St(t, "aria-hidden")
                                })(e), tE.showSlot(r, n), ((e, t) => {
                                    tA(e, t, XE.getOnShow)
                                })(r, n)), s.each((e => ((e, t) => tA(e, t, XE.getOnHide))(r, e)))), i
                            }))
                        };
                        return {
                            uid: e.uid,
                            dom: {
                                tag: "div",
                                classes: ["tox-view-wrap"],
                                attributes: {
                                    "aria-hidden": "true"
                                },
                                styles: {
                                    display: "none"
                                }
                            },
                            components: [],
                            behaviours: gl([Hh.config({}), cm.config({
                                find: e => {
                                    const t = Hh.contents(e);
                                    return oe(t)
                                }
                            })]),
                            apis: o
                        }
                    },
                    name: "silver.ViewWrapper",
                    configFields: [Gn("backstage")],
                    apis: {
                        setViews: (e, t, o) => e.setViews(t, o),
                        toggleView: (e, t, o, n, r) => e.toggleView(t, o, n, r),
                        whichView: (e, t) => e.whichView(t)
                    }
                });
                const nA = VO.optional({
                        factory: DT,
                        name: "menubar",
                        schema: [Gn("backstage")]
                    }),
                    rA = VO.optional({
                        factory: {
                            sketch: e => WO.sketch({
                                uid: e.uid,
                                dom: e.dom,
                                listBehaviours: gl([Th.config({
                                    mode: "acyclic",
                                    selector: ".tox-toolbar"
                                })]),
                                makeItem: () => qE({
                                    type: e.type,
                                    uid: Qs("multiple-toolbar-item"),
                                    cyclicKeying: !1,
                                    initGroups: [],
                                    providers: e.providers,
                                    onEscape: () => (e.onEscape(), A.some(!0))
                                }),
                                setupItem: (e, t, o, n) => {
                                    GO.setGroups(t, o)
                                },
                                shell: !0
                            })
                        },
                        name: "multiple-toolbar",
                        schema: [Gn("dom"), Gn("onEscape")]
                    }),
                    sA = VO.optional({
                        factory: {
                            sketch: e => {
                                const t = (e => e.type === Up.sliding ? $E : e.type === Up.floating ? WE : qE)(e);
                                return t({
                                    type: e.type,
                                    uid: e.uid,
                                    onEscape: () => (e.onEscape(), A.some(!0)),
                                    onToggled: (t, o) => e.onToolbarToggled(o),
                                    cyclicKeying: !1,
                                    initGroups: [],
                                    getSink: e.getSink,
                                    providers: e.providers,
                                    moreDrawerData: {
                                        lazyToolbar: e.lazyToolbar,
                                        lazyMoreButton: e.lazyMoreButton,
                                        lazyHeader: e.lazyHeader
                                    },
                                    attributes: e.attributes
                                })
                            }
                        },
                        name: "toolbar",
                        schema: [Gn("dom"), Gn("onEscape"), Gn("getSink")]
                    }),
                    aA = VO.optional({
                        factory: {
                            sketch: e => {
                                const t = e.editor,
                                    o = e.sticky ? OT : XO;
                                return {
                                    uid: e.uid,
                                    dom: e.dom,
                                    components: e.components,
                                    behaviours: gl(o(t, e.sharedBackstage))
                                }
                            }
                        },
                        name: "header",
                        schema: [Gn("dom")]
                    }),
                    iA = VO.optional({
                        factory: {
                            sketch: e => ({
                                uid: e.uid,
                                dom: e.dom,
                                components: [{
                                    dom: {
                                        tag: "a",
                                        attributes: {
                                            href: "https://www.tiny.cloud/tinymce-self-hosted-premium-features/?utm_source=TinyMCE&utm_medium=SPAP&utm_campaign=SPAP&utm_id=editorreferral",
                                            rel: "noopener",
                                            target: "_blank",
                                            "aria-hidden": "true"
                                        },
                                        classes: ["tox-promotion-link"],
                                        innerHtml: "Upgrade"
                                    }
                                }]
                            })
                        },
                        name: "promotion",
                        schema: [Gn("dom")]
                    }),
                    lA = VO.optional({
                        name: "socket",
                        schema: [Gn("dom")]
                    }),
                    cA = VO.optional({
                        factory: {
                            sketch: e => ({
                                uid: e.uid,
                                dom: {
                                    tag: "div",
                                    classes: ["tox-sidebar"],
                                    attributes: {
                                        role: "complementary"
                                    }
                                },
                                components: [{
                                    dom: {
                                        tag: "div",
                                        classes: ["tox-sidebar__slider"]
                                    },
                                    components: [],
                                    behaviours: gl([Nx.config({}), Zh.config({}), KT.config({
                                        dimension: {
                                            property: "width"
                                        },
                                        closedClass: "tox-sidebar--sliding-closed",
                                        openClass: "tox-sidebar--sliding-open",
                                        shrinkingClass: "tox-sidebar--sliding-shrinking",
                                        growingClass: "tox-sidebar--sliding-growing",
                                        onShrunk: e => {
                                            cm.getCurrent(e).each(tE.hideAllSlots), ks(e, lE)
                                        },
                                        onGrown: e => {
                                            ks(e, lE)
                                        },
                                        onStartGrow: e => {
                                            _s(e, iE, {
                                                width: Nt(e.element, "width").getOr("")
                                            })
                                        },
                                        onStartShrink: e => {
                                            _s(e, iE, {
                                                width: $t(e.element) + "px"
                                            })
                                        }
                                    }), Hh.config({}), cm.config({
                                        find: e => {
                                            const t = Hh.contents(e);
                                            return oe(t)
                                        }
                                    })])
                                }],
                                behaviours: gl([ek(0), Ih("sidebar-sliding-events", [Ds(iE, ((e, t) => {
                                    Ot(e.element, "width", t.event.width)
                                })), Ds(lE, ((e, t) => {
                                    Bt(e.element, "width")
                                }))])])
                            })
                        },
                        name: "sidebar",
                        schema: [Gn("dom")]
                    }),
                    dA = VO.optional({
                        factory: {
                            sketch: e => ({
                                uid: e.uid,
                                dom: {
                                    tag: "div",
                                    attributes: {
                                        "aria-hidden": "true"
                                    },
                                    classes: ["tox-throbber"],
                                    styles: {
                                        display: "none"
                                    }
                                },
                                behaviours: gl([Hh.config({}), uE.config({
                                    focus: !1
                                }), cm.config({
                                    find: e => oe(e.components())
                                })]),
                                components: []
                            })
                        },
                        name: "throbber",
                        schema: [Gn("dom")]
                    }),
                    uA = VO.optional({
                        factory: oA,
                        name: "viewWrapper",
                        schema: [Gn("backstage")]
                    }),
                    mA = VO.optional({
                        factory: {
                            sketch: e => ({
                                uid: e.uid,
                                dom: {
                                    tag: "div",
                                    classes: ["tox-editor-container"]
                                },
                                components: e.components
                            })
                        },
                        name: "editorContainer",
                        schema: []
                    });
                var gA = sm({
                    name: "OuterContainer",
                    factory: (e, t, o) => {
                        let n = !1;
                        const r = {
                            getSocket: t => FO.getPart(t, e, "socket"),
                            setSidebar: (t, o, n) => {
                                FO.getPart(t, e, "sidebar").each((e => ((e, t, o) => {
                                    cm.getCurrent(e).each((e => {
                                        Hh.set(e, [sE(t)]);
                                        const n = null == o ? void 0 : o.toLowerCase();
                                        s(n) && be(t, n) && cm.getCurrent(e).each((t => {
                                            tE.showSlot(t, n), KT.immediateGrow(e), Bt(e.element, "width")
                                        }))
                                    }))
                                })(e, o, n)))
                            },
                            toggleSidebar: (t, o) => {
                                FO.getPart(t, e, "sidebar").each((e => ((e, t) => {
                                    cm.getCurrent(e).each((e => {
                                        cm.getCurrent(e).each((o => {
                                            KT.hasGrown(e) ? tE.isShowing(o, t) ? KT.shrink(e) : (tE.hideAllSlots(o), tE.showSlot(o, t)) : (tE.hideAllSlots(o), tE.showSlot(o, t), KT.grow(e))
                                        }))
                                    }))
                                })(e, o)))
                            },
                            whichSidebar: t => FO.getPart(t, e, "sidebar").bind(aE).getOrNull(),
                            getHeader: t => FO.getPart(t, e, "header"),
                            getToolbar: t => FO.getPart(t, e, "toolbar"),
                            setToolbar: (t, o) => {
                                FO.getPart(t, e, "toolbar").each((e => {
                                    const t = z(o, ZE);
                                    e.getApis().setGroups(e, t)
                                }))
                            },
                            setToolbars: (t, o) => {
                                FO.getPart(t, e, "multiple-toolbar").each((e => {
                                    const t = z(o, (e => z(e, ZE)));
                                    WO.setItems(e, t)
                                }))
                            },
                            refreshToolbar: t => {
                                FO.getPart(t, e, "toolbar").each((e => e.getApis().refresh(e)))
                            },
                            toggleToolbarDrawer: t => {
                                FO.getPart(t, e, "toolbar").each((e => {
                                    var t, o;
                                    o = t => t(e), null != (t = e.getApis().toggle) ? A.some(o(t)) : A.none()
                                }))
                            },
                            isToolbarDrawerToggled: t => FO.getPart(t, e, "toolbar").bind((e => A.from(e.getApis().isOpen).map((t => t(e))))).getOr(!1),
                            getThrobber: t => FO.getPart(t, e, "throbber"),
                            focusToolbar: t => {
                                FO.getPart(t, e, "toolbar").orThunk((() => FO.getPart(t, e, "multiple-toolbar"))).each((e => {
                                    Th.focusIn(e)
                                }))
                            },
                            setMenubar: (t, o) => {
                                FO.getPart(t, e, "menubar").each((e => {
                                    DT.setMenus(e, o)
                                }))
                            },
                            focusMenubar: t => {
                                FO.getPart(t, e, "menubar").each((e => {
                                    DT.focus(e)
                                }))
                            },
                            setViews: (t, o) => {
                                FO.getPart(t, e, "viewWrapper").each((e => {
                                    oA.setViews(e, o)
                                }))
                            },
                            toggleView: (t, o) => FO.getPart(t, e, "viewWrapper").exists((e => oA.toggleView(e, (() => r.showMainView(t)), (() => r.hideMainView(t)), o))),
                            whichView: t => FO.getPart(t, e, "viewWrapper").bind(oA.whichView).getOrNull(),
                            hideMainView: t => {
                                n = r.isToolbarDrawerToggled(t), n && r.toggleToolbarDrawer(t), FO.getPart(t, e, "editorContainer").each((e => {
                                    const t = e.element;
                                    Ot(t, "display", "none"), bt(t, "aria-hidden", "true")
                                }))
                            },
                            showMainView: t => {
                                n && r.toggleToolbarDrawer(t), FO.getPart(t, e, "editorContainer").each((e => {
                                    const t = e.element;
                                    Bt(t, "display"), St(t, "aria-hidden")
                                }))
                            }
                        };
                        return {
                            uid: e.uid,
                            dom: e.dom,
                            components: t,
                            apis: r,
                            behaviours: e.behaviours
                        }
                    },
                    configFields: [Gn("dom"), Gn("behaviours")],
                    partFields: [aA, nA, sA, rA, lA, cA, iA, dA, uA, mA],
                    apis: {
                        getSocket: (e, t) => e.getSocket(t),
                        setSidebar: (e, t, o, n) => {
                            e.setSidebar(t, o, n)
                        },
                        toggleSidebar: (e, t, o) => {
                            e.toggleSidebar(t, o)
                        },
                        whichSidebar: (e, t) => e.whichSidebar(t),
                        getHeader: (e, t) => e.getHeader(t),
                        getToolbar: (e, t) => e.getToolbar(t),
                        setToolbar: (e, t, o) => {
                            e.setToolbar(t, o)
                        },
                        setToolbars: (e, t, o) => {
                            e.setToolbars(t, o)
                        },
                        refreshToolbar: (e, t) => e.refreshToolbar(t),
                        toggleToolbarDrawer: (e, t) => {
                            e.toggleToolbarDrawer(t)
                        },
                        isToolbarDrawerToggled: (e, t) => e.isToolbarDrawerToggled(t),
                        getThrobber: (e, t) => e.getThrobber(t),
                        setMenubar: (e, t, o) => {
                            e.setMenubar(t, o)
                        },
                        focusMenubar: (e, t) => {
                            e.focusMenubar(t)
                        },
                        focusToolbar: (e, t) => {
                            e.focusToolbar(t)
                        },
                        setViews: (e, t, o) => {
                            e.setViews(t, o)
                        },
                        toggleView: (e, t, o) => e.toggleView(t, o),
                        whichView: (e, t) => e.whichView(t)
                    }
                });
                const hA = {
                        file: {
                            title: "File",
                            items: "newdocument restoredraft | preview | export print | deleteallconversations"
                        },
                        edit: {
                            title: "Edit",
                            items: "undo redo | cut copy paste pastetext | selectall | searchreplace"
                        },
                        view: {
                            title: "View",
                            items: "code | visualaid visualchars visualblocks | spellchecker | preview fullscreen | showcomments"
                        },
                        insert: {
                            title: "Insert",
                            items: "image link media addcomment pageembed template codesample inserttable | charmap emoticons hr | pagebreak nonbreaking anchor tableofcontents footnotes | mergetags | insertdatetime"
                        },
                        format: {
                            title: "Format",
                            items: "bold italic underline strikethrough superscript subscript codeformat | styles blocks fontfamily fontsize align lineheight | forecolor backcolor | language | removeformat"
                        },
                        tools: {
                            title: "Tools",
                            items: "spellchecker spellcheckerlanguage | autocorrect capitalization | a11ycheck code wordcount"
                        },
                        table: {
                            title: "Table",
                            items: "inserttable | cell row column | advtablesort | tableprops deletetable"
                        },
                        help: {
                            title: "Help",
                            items: "help"
                        }
                    },
                    pA = e => e.split(" "),
                    fA = (e, t) => {
                        const o = { ...hA,
                                ...t.menus
                            },
                            n = ae(t.menus).length > 0,
                            r = void 0 === t.menubar || !0 === t.menubar ? pA("file edit view insert format tools table help") : pA(!1 === t.menubar ? "" : t.menubar),
                            a = Z(r, (e => {
                                const o = be(hA, e);
                                return n ? o || ve(t.menus, e).exists((e => be(e, "items"))) : o
                            })),
                            i = z(a, (n => {
                                const r = o[n];
                                return ((e, t, o) => {
                                    const n = cf(o).split(/[ ,]/);
                                    return {
                                        text: e.title,
                                        getItems: () => G(e.items, (e => {
                                            const o = e.toLowerCase();
                                            return 0 === o.trim().length || H(n, (e => e === o)) ? [] : "separator" === o || "|" === o ? [{
                                                type: "separator"
                                            }] : t.menuItems[o] ? [t.menuItems[o]] : []
                                        }))
                                    }
                                })({
                                    title: r.title,
                                    items: pA(r.items)
                                }, t, e)
                            }));
                        return Z(i, (e => e.getItems().length > 0 && H(e.getItems(), (e => s(e) || "separator" !== e.type))))
                    },
                    vA = e => {
                        const t = () => {
                            e._skinLoaded = !0, (e => {
                                e.dispatch("SkinLoaded")
                            })(e)
                        };
                        return () => {
                            e.initialized ? t() : e.on("init", t)
                        }
                    },
                    bA = (e, t, o) => (e.on("remove", (() => o.unload(t))), o.load(t)),
                    yA = (e, t) => bA(e, t + "/skin.min.css", e.ui.styleSheetLoader),
                    wA = (e, t) => {
                        var o;
                        return o = Be(e.getElement()), mt(o).isSome() ? bA(e, t + "/skin.shadowdom.min.css", Wp.DOM.styleSheetLoader) : Promise.resolve()
                    },
                    xA = (e, t) => {
                        const o = Lf(t);
                        o && t.contentCSS.push(o + (e ? "/content.inline" : "/content") + ".min.css"), !Df(t) && s(o) ? Promise.all([yA(t, o), wA(t, o)]).then(vA(t), ((e, t) => () => ((e, t) => {
                            e.dispatch("SkinLoadError", t)
                        })(e, {
                            message: "Skin could not be loaded"
                        }))(t)) : vA(t)()
                    },
                    CA = C(xA, !1),
                    SA = C(xA, !0),
                    kA = (e, t) => o => {
                        const n = Vl(),
                            r = () => {
                                o.setActive(e.formatter.match(t));
                                const r = e.formatter.formatChanged(t, o.setActive);
                                n.set(r)
                            };
                        return e.initialized ? r() : e.once("init", r), () => {
                            e.off("init", r), n.clear()
                        }
                    },
                    _A = (e, t, o) => n => {
                        const r = () => o(n),
                            s = () => {
                                o(n), e.on(t, r)
                            };
                        return e.initialized ? s() : e.once("init", s), () => {
                            e.off("init", s), e.off(t, r)
                        }
                    },
                    OA = e => t => () => {
                        e.undoManager.transact((() => {
                            e.focus(), e.execCommand("mceToggleFormat", !1, t.format)
                        }))
                    },
                    TA = (e, t) => () => e.execCommand(t),
                    EA = (e, t, o) => {
                        const n = (e, n, s, a) => {
                                const i = t.shared.providers.translate(e.title);
                                if ("separator" === e.type) return A.some({
                                    type: "separator",
                                    text: i
                                });
                                if ("submenu" === e.type) {
                                    const t = G(e.getStyleItems(), (e => r(e, n, a)));
                                    return 0 === n && t.length <= 0 ? A.none() : A.some({
                                        type: "nestedmenuitem",
                                        text: i,
                                        enabled: t.length > 0,
                                        getSubmenuItems: () => G(e.getStyleItems(), (e => r(e, n, a)))
                                    })
                                }
                                return A.some({
                                    type: "togglemenuitem",
                                    text: i,
                                    icon: e.icon,
                                    active: e.isSelected(a),
                                    enabled: !s,
                                    onAction: o.onAction(e),
                                    ...e.getStylePreview().fold((() => ({})), (e => ({
                                        meta: {
                                            style: e
                                        }
                                    })))
                                })
                            },
                            r = (e, t, r) => {
                                const s = "formatter" === e.type && o.isInvalid(e);
                                return 0 === t ? s ? [] : n(e, t, !1, r).toArray() : n(e, t, s, r).toArray()
                            },
                            s = e => {
                                const t = o.getCurrentValue(),
                                    n = o.shouldHide ? 0 : 1;
                                return G(e, (e => r(e, n, t)))
                            };
                        return {
                            validateItems: s,
                            getFetch: (e, t) => (o, n) => {
                                const r = t(),
                                    a = s(r);
                                n(Mk(a, Xf.CLOSE_ON_EXECUTE, e, {
                                    isHorizontalMenu: !1,
                                    search: A.none()
                                }))
                            }
                        }
                    },
                    AA = (e, t, o) => {
                        const n = o.dataset,
                            r = "basic" === n.type ? () => z(n.data, (e => gO(e, o.isSelectedFor, o.getPreviewFor))) : n.getData;
                        return {
                            items: EA(0, t, o),
                            getStyleItems: r
                        }
                    },
                    MA = (e, t, o) => {
                        const {
                            items: n,
                            getStyleItems: r
                        } = AA(0, t, o), s = _A(e, "NodeChange", (e => {
                            const t = e.getComponent();
                            o.updateText(t)
                        }));
                        return Ok({
                            text: o.icon.isSome() ? A.none() : o.text,
                            icon: o.icon,
                            tooltip: A.from(o.tooltip),
                            role: A.none(),
                            fetch: n.getFetch(t, r),
                            onSetup: s,
                            getApi: e => ({
                                getComponent: y(e)
                            }),
                            columns: 1,
                            presets: "normal",
                            classes: o.icon.isSome() ? [] : ["bespoke"],
                            dropdownBehaviours: []
                        }, "tox-tbtn", t.shared)
                    };
                var NA;
                ! function(e) {
                    e[e.SemiColon = 0] = "SemiColon", e[e.Space = 1] = "Space"
                }(NA || (NA = {}));
                const RA = (e, t, o) => {
                        const n = (r = ((e, t) => t === NA.SemiColon ? e.replace(/;$/, "").split(";") : e.split(" "))(e.options.get(t), o), z(r, (e => {
                            let t = e,
                                o = e;
                            const n = e.split("=");
                            return n.length > 1 && (t = n[0], o = n[1]), {
                                title: t,
                                format: o
                            }
                        })));
                        var r;
                        return {
                            type: "basic",
                            data: n
                        }
                    },
                    DA = [{
                        title: "Left",
                        icon: "align-left",
                        format: "alignleft",
                        command: "JustifyLeft"
                    }, {
                        title: "Center",
                        icon: "align-center",
                        format: "aligncenter",
                        command: "JustifyCenter"
                    }, {
                        title: "Right",
                        icon: "align-right",
                        format: "alignright",
                        command: "JustifyRight"
                    }, {
                        title: "Justify",
                        icon: "align-justify",
                        format: "alignjustify",
                        command: "JustifyFull"
                    }],
                    BA = e => {
                        const t = {
                            type: "basic",
                            data: DA
                        };
                        return {
                            tooltip: "Align",
                            text: A.none(),
                            icon: A.some("align-left"),
                            isSelectedFor: t => () => e.formatter.match(t),
                            getCurrentValue: A.none,
                            getPreviewFor: e => A.none,
                            onAction: t => () => W(DA, (e => e.format === t.format)).each((t => e.execCommand(t.command))),
                            updateText: t => {
                                const o = W(DA, (t => e.formatter.match(t.format))).fold(y("left"), (e => e.title.toLowerCase()));
                                _s(t, _k, {
                                    icon: `align-${o}`
                                })
                            },
                            dataset: t,
                            shouldHide: !1,
                            isInvalid: t => !e.formatter.canApply(t.format)
                        }
                    },
                    LA = (e, t) => {
                        const o = t(),
                            n = z(o, (e => e.format));
                        return A.from(e.formatter.closest(n)).bind((e => W(o, (t => t.format === e)))).orThunk((() => Se(e.formatter.match("p"), {
                            title: "Paragraph",
                            format: "p"
                        })))
                    },
                    HA = e => {
                        const t = "Paragraph",
                            o = RA(e, "block_formats", NA.SemiColon);
                        return {
                            tooltip: "Blocks",
                            text: A.some(t),
                            icon: A.none(),
                            isSelectedFor: t => () => e.formatter.match(t),
                            getCurrentValue: A.none,
                            getPreviewFor: t => () => {
                                const o = e.formatter.get(t);
                                return o ? A.some({
                                    tag: o.length > 0 && (o[0].inline || o[0].block) || "div",
                                    styles: e.dom.parseStyle(e.formatter.getCssText(t))
                                }) : A.none()
                            },
                            onAction: OA(e),
                            updateText: n => {
                                const r = LA(e, (() => o.data)).fold(y(t), (e => e.title));
                                _s(n, kk, {
                                    text: r
                                })
                            },
                            dataset: o,
                            shouldHide: !1,
                            isInvalid: t => !e.formatter.canApply(t.format)
                        }
                    },
                    IA = ["-apple-system", "Segoe UI", "Roboto", "Helvetica Neue", "sans-serif"],
                    PA = e => {
                        const t = e.split(/\s*,\s*/);
                        return z(t, (e => e.replace(/^['"]+|['"]+$/g, "")))
                    },
                    zA = e => {
                        const t = "System Font",
                            o = () => {
                                const o = e => e ? PA(e)[0] : "",
                                    r = e.queryCommandValue("FontName"),
                                    s = n.data,
                                    a = r ? r.toLowerCase() : "",
                                    i = W(s, (e => {
                                        const t = e.format;
                                        return t.toLowerCase() === a || o(t).toLowerCase() === o(a).toLowerCase()
                                    })).orThunk((() => Se((e => 0 === e.indexOf("-apple-system") && (() => {
                                        const t = PA(e.toLowerCase());
                                        return K(IA, (e => t.indexOf(e.toLowerCase()) > -1))
                                    })())(a), {
                                        title: t,
                                        format: a
                                    })));
                                return {
                                    matchOpt: i,
                                    font: r
                                }
                            },
                            n = RA(e, "font_family_formats", NA.SemiColon);
                        return {
                            tooltip: "Fonts",
                            text: A.some(t),
                            icon: A.none(),
                            isSelectedFor: e => t => t.exists((t => t.format === e)),
                            getCurrentValue: () => {
                                const {
                                    matchOpt: e
                                } = o();
                                return e
                            },
                            getPreviewFor: e => () => A.some({
                                tag: "div",
                                styles: -1 === e.indexOf("dings") ? {
                                    "font-family": e
                                } : {}
                            }),
                            onAction: t => () => {
                                e.undoManager.transact((() => {
                                    e.focus(), e.execCommand("FontName", !1, t.format)
                                }))
                            },
                            updateText: e => {
                                const {
                                    matchOpt: t,
                                    font: n
                                } = o(), r = t.fold(y(n), (e => e.title));
                                _s(e, kk, {
                                    text: r
                                })
                            },
                            dataset: n,
                            shouldHide: !1,
                            isInvalid: O
                        }
                    },
                    FA = {
                        "8pt": "1",
                        "10pt": "2",
                        "12pt": "3",
                        "14pt": "4",
                        "18pt": "5",
                        "24pt": "6",
                        "36pt": "7"
                    },
                    VA = {
                        "xx-small": "7pt",
                        "x-small": "8pt",
                        small: "10pt",
                        medium: "12pt",
                        large: "14pt",
                        "x-large": "18pt",
                        "xx-large": "24pt"
                    },
                    ZA = (e, t) => /[0-9.]+px$/.test(e) ? ((e, t) => {
                        const o = Math.pow(10, t);
                        return Math.round(e * o) / o
                    })(72 * parseInt(e, 10) / 96, t || 0) + "pt" : ve(VA, e).getOr(e),
                    UA = e => ve(FA, e).getOr(""),
                    jA = e => {
                        const t = () => {
                                let t = A.none();
                                const o = n.data,
                                    r = e.queryCommandValue("FontSize");
                                if (r)
                                    for (let e = 3; t.isNone() && e >= 0; e--) {
                                        const n = ZA(r, e),
                                            s = UA(n);
                                        t = W(o, (e => e.format === r || e.format === n || e.format === s))
                                    }
                                return {
                                    matchOpt: t,
                                    size: r
                                }
                            },
                            o = y(A.none),
                            n = RA(e, "font_size_formats", NA.Space);
                        return {
                            tooltip: "Font sizes",
                            text: A.some("12pt"),
                            icon: A.none(),
                            isSelectedFor: e => t => t.exists((t => t.format === e)),
                            getPreviewFor: o,
                            getCurrentValue: () => {
                                const {
                                    matchOpt: e
                                } = t();
                                return e
                            },
                            onAction: t => () => {
                                e.undoManager.transact((() => {
                                    e.focus(), e.execCommand("FontSize", !1, t.format)
                                }))
                            },
                            updateText: e => {
                                const {
                                    matchOpt: o,
                                    size: n
                                } = t(), r = o.fold(y(n), (e => e.title));
                                _s(e, kk, {
                                    text: r
                                })
                            },
                            dataset: n,
                            shouldHide: !1,
                            isInvalid: O
                        }
                    },
                    WA = (e, t) => {
                        const o = "Paragraph";
                        return {
                            tooltip: "Formats",
                            text: A.some(o),
                            icon: A.none(),
                            isSelectedFor: t => () => e.formatter.match(t),
                            getCurrentValue: A.none,
                            getPreviewFor: t => () => {
                                const o = e.formatter.get(t);
                                return void 0 !== o ? A.some({
                                    tag: o.length > 0 && (o[0].inline || o[0].block) || "div",
                                    styles: e.dom.parseStyle(e.formatter.getCssText(t))
                                }) : A.none()
                            },
                            onAction: OA(e),
                            updateText: t => {
                                const n = e => lO(e) ? G(e.items, n) : cO(e) ? [{
                                        title: e.title,
                                        format: e.format
                                    }] : [],
                                    r = G(mO(e), n),
                                    s = LA(e, y(r)).fold(y(o), (e => e.title));
                                _s(t, kk, {
                                    text: s
                                })
                            },
                            shouldHide: af(e),
                            isInvalid: t => !e.formatter.canApply(t.format),
                            dataset: t
                        }
                    };
                var $A = Object.freeze({
                        __proto__: null,
                        events: (e, t) => {
                            const o = (o, n) => {
                                e.updateState.each((e => {
                                    const r = e(o, n);
                                    t.set(r)
                                })), e.renderComponents.each((r => {
                                    const s = r(n, t.get());
                                    (e.reuseDom ? Ah : Eh)(o, s)
                                }))
                            };
                            return Ms([Ds(os(), ((t, n) => {
                                const r = n;
                                if (!r.universal) {
                                    const n = e.channel;
                                    L(r.channels, n) && o(t, r.data)
                                }
                            })), Vs(((t, n) => {
                                e.initialData.each((e => {
                                    o(t, e)
                                }))
                            }))])
                        }
                    }),
                    qA = Object.freeze({
                        __proto__: null,
                        getState: (e, t, o) => o
                    }),
                    GA = [Gn("channel"), nr("renderComponents"), nr("updateState"), nr("initialData"), fr("reuseDom", !0)];
                const KA = pl({
                        fields: GA,
                        name: "reflecting",
                        active: $A,
                        apis: qA,
                        state: Object.freeze({
                            __proto__: null,
                            init: () => {
                                const e = wr(A.none());
                                return {
                                    readState: () => e.get().getOr("none"),
                                    get: e.get,
                                    set: e.set,
                                    clear: () => e.set(A.none())
                                }
                            }
                        })
                    }),
                    YA = y([Gn("toggleClass"), Gn("fetch"), Si("onExecute"), ur("getHotspot", A.some), ur("getAnchorOverrides", y({})), dc(), Si("onItemExecute"), nr("lazySink"), Gn("dom"), xi("onOpen"), nu("splitDropdownBehaviours", [Pw, Th, Zh]), ur("matchWidth", !1), ur("useMinWidth", !1), ur("eventOrder", {}), nr("role")].concat(tx())),
                    XA = Mu({
                        factory: Ap,
                        schema: [Gn("dom")],
                        name: "arrow",
                        defaults: () => ({
                            buttonBehaviours: gl([Zh.revoke()])
                        }),
                        overrides: e => ({
                            dom: {
                                tag: "span",
                                attributes: {
                                    role: "presentation"
                                }
                            },
                            action: t => {
                                t.getSystem().getByUid(e.uid).each(Os)
                            },
                            buttonBehaviours: gl([Yh.config({
                                toggleOnExecute: !1,
                                toggleClass: e.toggleClass
                            })])
                        })
                    }),
                    JA = Mu({
                        factory: Ap,
                        schema: [Gn("dom")],
                        name: "button",
                        defaults: () => ({
                            buttonBehaviours: gl([Zh.revoke()])
                        }),
                        overrides: e => ({
                            dom: {
                                tag: "span",
                                attributes: {
                                    role: "presentation"
                                }
                            },
                            action: t => {
                                t.getSystem().getByUid(e.uid).each((o => {
                                    e.onExecute(o, t)
                                }))
                            }
                        })
                    }),
                    QA = y([XA, JA, Ru({
                        factory: {
                            sketch: e => ({
                                uid: e.uid,
                                dom: {
                                    tag: "span",
                                    styles: {
                                        display: "none"
                                    },
                                    attributes: {
                                        "aria-hidden": "true"
                                    },
                                    innerHtml: e.text
                                }
                            })
                        },
                        schema: [Gn("text")],
                        name: "aria-descriptor"
                    }), Nu({
                        schema: [bi()],
                        name: "menu",
                        defaults: e => ({
                            onExecute: (t, o) => {
                                t.getSystem().getByUid(e.uid).each((n => {
                                    e.onItemExecute(n, t, o)
                                }))
                            }
                        })
                    }), $w()]),
                    eM = sm({
                        name: "SplitDropdown",
                        configFields: YA(),
                        partFields: QA(),
                        factory: (e, t, o, n) => {
                            const r = e => {
                                    cm.getCurrent(e).each((e => {
                                        Dm.highlightFirst(e), Th.focusIn(e)
                                    }))
                                },
                                s = t => {
                                    Yw(e, w, t, n, r, kp.HighlightMenuAndItem).get(v)
                                },
                                a = t => {
                                    const o = Wu(t, e, "button");
                                    return Os(o), A.some(!0)
                                },
                                i = { ...Ms([Vs(((t, o) => {
                                        ju(t, e, "aria-descriptor").each((e => {
                                            const o = Qs("aria");
                                            bt(e.element, "id", o), bt(t.element, "aria-describedby", o)
                                        }))
                                    }))]),
                                    ...Jh(A.some(s))
                                },
                                l = {
                                    repositionMenus: e => {
                                        Yh.isOn(e) && ex(e)
                                    }
                                };
                            return {
                                uid: e.uid,
                                dom: e.dom,
                                components: t,
                                apis: l,
                                eventOrder: { ...e.eventOrder,
                                    [ns()]: ["disabling", "toggling", "alloy.base.behaviour"]
                                },
                                events: i,
                                behaviours: su(e.splitDropdownBehaviours, [Pw.config({
                                    others: {
                                        sandbox: t => {
                                            const o = Wu(t, e, "arrow");
                                            return Qw(e, t, {
                                                onOpen: () => {
                                                    Yh.on(o), Yh.on(t)
                                                },
                                                onClose: () => {
                                                    Yh.off(o), Yh.off(t)
                                                }
                                            })
                                        }
                                    }
                                }), Th.config({
                                    mode: "special",
                                    onSpace: a,
                                    onEnter: a,
                                    onDown: e => (s(e), A.some(!0))
                                }), Zh.config({}), Yh.config({
                                    toggleOnExecute: !1,
                                    aria: {
                                        mode: "expanded"
                                    }
                                })]),
                                domModification: {
                                    attributes: {
                                        role: e.role.getOr("button"),
                                        "aria-haspopup": !0
                                    }
                                }
                            }
                        },
                        apis: {
                            repositionMenus: (e, t) => e.repositionMenus(t)
                        }
                    }),
                    tM = e => ({
                        isEnabled: () => !Sm.isDisabled(e),
                        setEnabled: t => Sm.set(e, !t)
                    }),
                    oM = e => ({
                        setActive: t => {
                            Yh.set(e, t)
                        },
                        isActive: () => Yh.isOn(e),
                        isEnabled: () => !Sm.isDisabled(e),
                        setEnabled: t => Sm.set(e, !t)
                    }),
                    nM = (e, t) => e.map((e => ({
                        "aria-label": t.translate(e),
                        title: t.translate(e)
                    }))).getOr({}),
                    rM = Qs("focus-button"),
                    sM = (e, t, o, n, r, s) => ({
                        dom: {
                            tag: "button",
                            classes: ["tox-tbtn"].concat(t.isSome() ? ["tox-tbtn--select"] : []),
                            attributes: nM(o, s)
                        },
                        components: gy([e.map((e => xk(e, s.icons))), t.map((e => Sk(e, "tox-tbtn", s)))]),
                        eventOrder: {
                            [Lr()]: ["focusing", "alloy.base.behaviour", "common-button-display-events"]
                        },
                        buttonBehaviours: gl([iy(s.isDisabled), ry(), Ih("common-button-display-events", [Ds(Lr(), ((e, t) => {
                            t.event.prevent(), ks(e, rM)
                        }))])].concat(n.map((o => KA.config({
                            channel: o,
                            initialData: {
                                icon: e,
                                text: t
                            },
                            renderComponents: (e, t) => gy([e.icon.map((e => xk(e, s.icons))), e.text.map((e => Sk(e, "tox-tbtn", s)))])
                        }))).toArray()).concat(r.getOr([])))
                    }),
                    aM = (e, t, o) => {
                        const n = wr(v),
                            r = sM(e.icon, e.text, e.tooltip, A.none(), A.none(), o);
                        return Ap.sketch({
                            dom: r.dom,
                            components: r.components,
                            eventOrder: yk,
                            buttonBehaviours: gl([Ih("toolbar-button-events", [(s = {
                                onAction: e.onAction,
                                getApi: t.getApi
                            }, js(((e, t) => {
                                ly(s, e)((t => {
                                    _s(e, bk, {
                                        buttonApi: t
                                    }), s.onAction(t)
                                }))
                            }))), cy(t, n), dy(t, n)]), iy((() => !e.enabled || o.isDisabled())), ry()].concat(t.toolbarButtonBehaviours))
                        });
                        var s
                    },
                    iM = (e, t, o) => aM(e, {
                        toolbarButtonBehaviours: o.length > 0 ? [Ih("toolbarButtonWith", o)] : [],
                        getApi: tM,
                        onSetup: e.onSetup
                    }, t),
                    lM = (e, t, o) => aM(e, {
                        toolbarButtonBehaviours: [Hh.config({}), Yh.config({
                            toggleClass: "tox-tbtn--enabled",
                            aria: {
                                mode: "pressed"
                            },
                            toggleOnExecute: !1
                        })].concat(o.length > 0 ? [Ih("toolbarToggleButtonWith", o)] : []),
                        getApi: oM,
                        onSetup: e.onSetup
                    }, t),
                    cM = (e, t, o) => n => Uw((e => t.fetch(e))).map((r => A.from(mx(cn(_w(Qs("menu-value"), r, (o => {
                        t.onItemAction(e(n), o)
                    }), t.columns, t.presets, Xf.CLOSE_ON_EXECUTE, t.select.getOr(O), o), {
                        movement: Tw(t.columns, t.presets),
                        menuBehaviours: Wb("auto" !== t.columns ? [] : [Vs(((e, o) => {
                            jb(e, 4, cv(t.presets)).each((({
                                numRows: t,
                                numColumns: o
                            }) => {
                                Th.setGridSize(e, t, o)
                            }))
                        }))])
                    }))))),
                    dM = [{
                        name: "history",
                        items: ["undo", "redo"]
                    }, {
                        name: "styles",
                        items: ["styles"]
                    }, {
                        name: "formatting",
                        items: ["bold", "italic"]
                    }, {
                        name: "alignment",
                        items: ["alignleft", "aligncenter", "alignright", "alignjustify"]
                    }, {
                        name: "indentation",
                        items: ["outdent", "indent"]
                    }, {
                        name: "permanent pen",
                        items: ["permanentpen"]
                    }, {
                        name: "comments",
                        items: ["addcomment"]
                    }],
                    uM = (e, t) => (o, n, r) => {
                        const s = e(o).mapError((e => Un(e))).getOrDie();
                        return t(s, n, r)
                    },
                    mM = {
                        button: uM(fb, ((e, t) => {
                            return o = e, n = t.shared.providers, iM(o, n, []);
                            var o, n
                        })),
                        togglebutton: uM(yb, ((e, t) => {
                            return o = e, n = t.shared.providers, lM(o, n, []);
                            var o, n
                        })),
                        menubutton: uM(NT, ((e, t) => a_(e, "tox-tbtn", t, A.none()))),
                        splitbutton: uM((e => Fn("SplitButton", RT, e)), ((e, t) => ((e, t) => {
                            const o = Qs("channel-update-split-dropdown-display"),
                                n = e => ({
                                    isEnabled: () => !Sm.isDisabled(e),
                                    setEnabled: t => Sm.set(e, !t),
                                    setIconFill: (t, o) => {
                                        ri(e.element, 'svg path[id="' + t + '"], rect[id="' + t + '"]').each((e => {
                                            bt(e, "fill", o)
                                        }))
                                    },
                                    setActive: t => {
                                        bt(e.element, "aria-pressed", t), ri(e.element, "span").each((o => {
                                            e.getSystem().getByDom(o).each((e => Yh.set(e, t)))
                                        }))
                                    },
                                    isActive: () => ri(e.element, "span").exists((t => e.getSystem().getByDom(t).exists(Yh.isOn)))
                                }),
                                r = wr(v),
                                s = {
                                    getApi: n,
                                    onSetup: e.onSetup
                                };
                            return eM.sketch({
                                dom: {
                                    tag: "div",
                                    classes: ["tox-split-button"],
                                    attributes: {
                                        "aria-pressed": !1,
                                        ...nM(e.tooltip, t.providers)
                                    }
                                },
                                onExecute: t => {
                                    e.onAction(n(t))
                                },
                                onItemExecute: (e, t, o) => {},
                                splitDropdownBehaviours: gl([ay(t.providers.isDisabled), ry(), Ih("split-dropdown-events", [Ds(rM, Zh.focus), cy(s, r), dy(s, r)]), oC.config({})]),
                                eventOrder: {
                                    [hs()]: ["alloy.base.behaviour", "split-dropdown-events"]
                                },
                                toggleClass: "tox-tbtn--enabled",
                                lazySink: t.getSink,
                                fetch: cM(n, e, t.providers),
                                parts: {
                                    menu: pv(0, e.columns, e.presets)
                                },
                                components: [eM.parts.button(sM(e.icon, e.text, A.none(), A.some(o), A.some([Yh.config({
                                    toggleClass: "tox-tbtn--enabled",
                                    toggleOnExecute: !1
                                })]), t.providers)), eM.parts.arrow({
                                    dom: {
                                        tag: "button",
                                        classes: ["tox-tbtn", "tox-split-button__chevron"],
                                        innerHtml: Ip("chevron-down", t.providers.icons)
                                    },
                                    buttonBehaviours: gl([ay(t.providers.isDisabled), ry(), Pp()])
                                }), eM.parts["aria-descriptor"]({
                                    text: t.providers.translate("To open the popup, press Shift+Enter")
                                })]
                            })
                        })(e, t.shared))),
                        grouptoolbarbutton: uM((e => Fn("GroupToolbarButton", ET, e)), ((e, t, o) => {
                            const n = o.ui.registry.getAll().buttons,
                                r = {
                                    [lc]: t.shared.header.isPositionedAtTop() ? ic.TopToBottom : ic.BottomToTop
                                };
                            if (df(o) === Up.floating) return ((e, t, o, n) => {
                                const r = t.shared;
                                return AE.sketch({
                                    lazySink: r.getSink,
                                    fetch: () => Uw((t => {
                                        t(z(o(e.items), ZE))
                                    })),
                                    markers: {
                                        toggledClass: "tox-tbtn--enabled"
                                    },
                                    parts: {
                                        button: sM(e.icon, e.text, e.tooltip, A.none(), A.none(), r.providers),
                                        toolbar: {
                                            dom: {
                                                tag: "div",
                                                classes: ["tox-toolbar__overflow"],
                                                attributes: n
                                            }
                                        }
                                    }
                                })
                            })(e, t, (e => hM(o, {
                                buttons: n,
                                toolbar: e,
                                allowToolbarGroups: !1
                            }, t, A.none())), r);
                            throw new Error("Toolbar groups are only supported when using floating toolbar mode")
                        }))
                    },
                    gM = {
                        styles: (e, t) => {
                            const o = {
                                type: "advanced",
                                ...t.styles
                            };
                            return MA(e, t, WA(e, o))
                        },
                        fontsize: (e, t) => MA(e, t, jA(e)),
                        fontfamily: (e, t) => MA(e, t, zA(e)),
                        blocks: (e, t) => MA(e, t, HA(e)),
                        align: (e, t) => MA(e, t, BA(e))
                    },
                    hM = (e, t, o, n) => {
                        const r = (e => {
                                const t = e.toolbar,
                                    o = e.buttons;
                                return !1 === t ? [] : void 0 === t || !0 === t ? (e => {
                                    const t = z(dM, (t => {
                                        const o = Z(t.items, (t => be(e, t) || be(gM, t)));
                                        return {
                                            name: t.name,
                                            items: o
                                        }
                                    }));
                                    return Z(t, (e => e.items.length > 0))
                                })(o) : s(t) ? (e => {
                                    const t = e.split("|");
                                    return z(t, (e => ({
                                        items: e.trim().split(" ")
                                    })))
                                })(t) : (e => f(e, (e => be(e, "name") && be(e, "items"))))(t) ? t : (console.error("Toolbar type should be string, string[], boolean or ToolbarGroup[]"), [])
                            })(t),
                            a = z(r, (r => {
                                const s = G(r.items, (r => 0 === r.trim().length ? [] : ((e, t, o, n, r, s) => ve(t, o.toLowerCase()).orThunk((() => s.bind((e => se(e, (e => ve(t, e + o.toLowerCase()))))))).fold((() => ve(gM, o.toLowerCase()).map((t => t(e, r)))), (t => "grouptoolbarbutton" !== t.type || n ? ((e, t, o) => ve(mM, e.type).fold((() => (console.error("skipping button defined by", e), A.none())), (n => A.some(n(e, t, o)))))(t, r, e) : (console.warn(`Ignoring the '${o}' toolbar button. Group toolbar buttons are only supported when using floating toolbar mode and cannot be nested.`), A.none()))))(e, t.buttons, r, t.allowToolbarGroups, o, n).toArray()));
                                return {
                                    title: A.from(e.translate(r.name)),
                                    items: s
                                }
                            }));
                        return Z(a, (e => e.items.length > 0))
                    },
                    pM = (e, t, o, n) => {
                        const r = t.mainUi.outerContainer,
                            a = o.toolbar,
                            i = o.buttons;
                        if (f(a, s)) {
                            const t = a.map((t => {
                                const r = {
                                    toolbar: t,
                                    buttons: i,
                                    allowToolbarGroups: o.allowToolbarGroups
                                };
                                return hM(e, r, n, A.none())
                            }));
                            gA.setToolbars(r, t)
                        } else gA.setToolbar(r, hM(e, o, n, A.none()))
                    },
                    fM = Oo(),
                    vM = fM.os.isiOS() && fM.os.version.major <= 12;
                var bM = Object.freeze({
                    __proto__: null,
                    render: (e, t, o, n, r) => {
                        const {
                            mainUi: s,
                            uiMotherships: a
                        } = t, i = wr(0), l = s.outerContainer;
                        CA(e);
                        const d = Be(r.targetNode),
                            u = ut(dt(d));
                        ((e, t) => {
                            kd(e, t, No)
                        })(d, s.mothership), ((e, t) => {
                            Sd(e, t.dialogUi.mothership)
                        })(u, t), e.on("PostRender", (() => {
                            gA.setSidebar(l, o.sidebar, Nf(e)), pM(e, t, o, n), i.set(e.getWin().innerWidth), gA.setMenubar(l, fA(e, o)), gA.setViews(l, o.views), ((e, t) => {
                                const {
                                    uiMotherships: o
                                } = t, n = e.dom;
                                let r = e.getWin();
                                const s = e.getDoc().documentElement,
                                    a = wr(Vt(r.innerWidth, r.innerHeight)),
                                    i = wr(Vt(s.offsetWidth, s.offsetHeight)),
                                    l = () => {
                                        const t = a.get();
                                        t.left === r.innerWidth && t.top === r.innerHeight || (a.set(Vt(r.innerWidth, r.innerHeight)), Ky(e))
                                    },
                                    c = () => {
                                        const t = e.getDoc().documentElement,
                                            o = i.get();
                                        o.left === t.offsetWidth && o.top === t.offsetHeight || (i.set(Vt(t.offsetWidth, t.offsetHeight)), Ky(e))
                                    },
                                    d = t => {
                                        ((e, t) => {
                                            e.dispatch("ScrollContent", t)
                                        })(e, t)
                                    };
                                n.bind(r, "resize", l), n.bind(r, "scroll", d);
                                const u = Wl(Be(e.getBody()), "load", c);
                                e.on("hide", (() => {
                                    F(o, (e => {
                                        Ot(e.element, "display", "none")
                                    }))
                                })), e.on("show", (() => {
                                    F(o, (e => {
                                        Bt(e.element, "display")
                                    }))
                                })), e.on("NodeChange", c), e.on("remove", (() => {
                                    u.unbind(), n.unbind(r, "resize", l), n.unbind(r, "scroll", d), r = null
                                }))
                            })(e, t)
                        }));
                        const m = gA.getSocket(l).getOrDie("Could not find expected socket element");
                        if (vM) {
                            Tt(m.element, {
                                overflow: "scroll",
                                "-webkit-overflow-scrolling": "touch"
                            });
                            const t = ((e, t) => {
                                    let o = null;
                                    return {
                                        cancel: () => {
                                            c(o) || (clearTimeout(o), o = null)
                                        },
                                        throttle: (...t) => {
                                            c(o) && (o = setTimeout((() => {
                                                o = null, e.apply(null, t)
                                            }), 20))
                                        }
                                    }
                                })((() => {
                                    e.dispatch("ScrollContent")
                                })),
                                o = jl(m.element, "scroll", t.throttle);
                            e.on("remove", o.unbind)
                        }
                        ny(e, t), e.addCommand("ToggleSidebar", ((t, o) => {
                            gA.toggleSidebar(l, o), e.dispatch("ToggleSidebar")
                        })), e.addQueryValueHandler("ToggleSidebar", (() => {
                            var e;
                            return null !== (e = gA.whichSidebar(l)) && void 0 !== e ? e : ""
                        })), e.addCommand("ToggleView", ((t, o) => {
                            if (gA.toggleView(l, o)) {
                                const t = l.element;
                                s.mothership.broadcastOn([Id()], {
                                    target: t
                                }), F(a, (e => {
                                    e.broadcastOn([Id()], {
                                        target: t
                                    })
                                })), c(gA.whichView(l)) && (e.focus(), e.nodeChanged())
                            }
                        })), e.addQueryValueHandler("ToggleView", (() => {
                            var e;
                            return null !== (e = gA.whichView(l)) && void 0 !== e ? e : ""
                        }));
                        const g = df(e);
                        g !== Up.sliding && g !== Up.floating || e.on("ResizeWindow ResizeEditor ResizeContent", (() => {
                            const o = e.getWin().innerWidth;
                            o !== i.get() && (gA.refreshToolbar(t.mainUi.outerContainer), i.set(o))
                        }));
                        const h = {
                            setEnabled: e => {
                                oy(t, !e)
                            },
                            isEnabled: () => !Sm.isDisabled(l)
                        };
                        return {
                            iframeContainer: m.element.dom,
                            editorContainer: l.element.dom,
                            api: h
                        }
                    }
                });
                const yM = e => /^[0-9\.]+(|px)$/i.test("" + e) ? A.some(parseInt("" + e, 10)) : A.none(),
                    wM = e => p(e) ? e + "px" : e,
                    xM = (e, t, o) => {
                        const n = t.filter((t => e < t)),
                            r = o.filter((t => e > t));
                        return n.or(r).getOr(e)
                    },
                    CM = e => {
                        const t = Qp(e),
                            o = ef(e),
                            n = of (e);
                        return yM(t).map((e => xM(e, o, n)))
                    },
                    {
                        ToolbarLocation: SM,
                        ToolbarMode: kM
                    } = qf,
                    _M = (e, t) => {
                        const o = $o(e);
                        return {
                            pos: t ? o.y : o.bottom,
                            bounds: o
                        }
                    };
                var OM = Object.freeze({
                    __proto__: null,
                    render: (e, t, o, n, r) => {
                        const {
                            mainUi: s
                        } = t, a = Zl(), i = Be(r.targetNode), l = ((e, t, o, n, r) => {
                            const {
                                mainUi: s,
                                uiMotherships: a
                            } = o, i = Wp.DOM, l = Zf(e), c = Wf(e), d = of (e).or(CM(e)), u = n.shared.header, m = u.isPositionedAtTop, g = df(e), h = g === kM.sliding || g === kM.floating, p = wr(!1), f = () => p.get() && !e.removed, v = e => h ? e.fold(y(0), (e => e.components().length > 1 ? Pt(e.components()[1].element) : 0)) : 0, b = () => {
                                F(a, (e => {
                                    e.broadcastOn([Pd()], {})
                                }))
                            }, w = (e = !1) => {
                                if (f()) {
                                    if (l || r.on((e => {
                                            const o = d.getOrThunk((() => {
                                                const e = yM(At(pt(), "margin-left")).getOr(0);
                                                return $t(pt()) - Ut(t).left + e
                                            }));
                                            Ot(e.element, "max-width", o + "px")
                                        })), h && gA.refreshToolbar(s.outerContainer), l || r.on((e => {
                                            const o = gA.getToolbar(s.outerContainer),
                                                n = v(o),
                                                r = $o(t),
                                                a = m() ? Math.max(r.y - Pt(e.element) + n, 0) : r.bottom;
                                            Tt(s.outerContainer.element, {
                                                position: "absolute",
                                                top: Math.round(a) + "px",
                                                left: Math.round(r.x) + "px"
                                            })
                                        })), c) {
                                        const t = e ? vT.reset : vT.refresh;
                                        r.on(t)
                                    }
                                    b()
                                }
                            }, x = (o = !0) => {
                                !l && c && f() && r.on((n => {
                                    const a = u.getDockingMode(),
                                        i = (o => {
                                            switch (mf(e)) {
                                                case SM.auto:
                                                    const e = gA.getToolbar(s.outerContainer),
                                                        n = v(e),
                                                        r = Pt(o.element) - n,
                                                        a = $o(t);
                                                    if (a.y > r) return "top"; {
                                                        const e = Je(t),
                                                            o = Math.max(e.dom.scrollHeight, Pt(e));
                                                        return a.bottom < o - r || Go().bottom < a.bottom - r ? "bottom" : "top"
                                                    }
                                                case SM.bottom:
                                                    return "bottom";
                                                case SM.top:
                                                default:
                                                    return "top"
                                            }
                                        })(n);
                                    var l;
                                    i !== a && (l = i, r.on((e => {
                                        vT.setModes(e, [l]), u.setDockingMode(l);
                                        const t = m() ? ic.TopToBottom : ic.BottomToTop;
                                        bt(e.element, lc, t)
                                    })), o && w(!0))
                                }))
                            };
                            return {
                                isVisible: f,
                                isPositionedAtTop: m,
                                show: () => {
                                    p.set(!0), Ot(s.outerContainer.element, "display", "flex"), i.addClass(e.getBody(), "mce-edit-focus"), F(a, (e => {
                                        Bt(e.element, "display")
                                    })), x(!1), w()
                                },
                                hide: () => {
                                    p.set(!1), Ot(s.outerContainer.element, "display", "none"), i.removeClass(e.getBody(), "mce-edit-focus"), F(a, (e => {
                                        Ot(e.element, "display", "none")
                                    }))
                                },
                                update: w,
                                updateMode: x,
                                repositionPopups: b
                            }
                        })(e, i, t, n, a), c = pf(e);
                        SA(e);
                        const d = () => {
                            if (a.isSet()) return void l.show();
                            a.set(gA.getHeader(s.outerContainer).getOrDie());
                            const r = Uf(e);
                            Sd(r, s.mothership), ((e, t) => {
                                Sd(e, t.dialogUi.mothership)
                            })(r, t), pM(e, t, o, n), gA.setMenubar(s.outerContainer, fA(e, o)), l.show(), ((e, t, o, n) => {
                                const r = wr(_M(t, o.isPositionedAtTop())),
                                    s = n => {
                                        const {
                                            pos: s,
                                            bounds: a
                                        } = _M(t, o.isPositionedAtTop()), {
                                            pos: i,
                                            bounds: l
                                        } = r.get(), c = a.height !== l.height || a.width !== l.width;
                                        r.set({
                                            pos: s,
                                            bounds: a
                                        }), c && Ky(e, n), o.isVisible() && (i !== s ? o.update(!0) : c && (o.updateMode(), o.repositionPopups()))
                                    };
                                n || (e.on("activate", o.show), e.on("deactivate", o.hide)), e.on("SkinLoaded ResizeWindow", (() => o.update(!0))), e.on("NodeChange keydown", (e => {
                                    requestAnimationFrame((() => s(e)))
                                })), e.on("ScrollWindow", (() => o.updateMode()));
                                const a = Vl();
                                a.set(Wl(Be(e.getBody()), "load", (e => s(e.raw)))), e.on("remove", (() => {
                                    a.clear()
                                }))
                            })(e, i, l, c), e.nodeChanged()
                        };
                        e.on("show", d), e.on("hide", l.hide), c || (e.on("focus", d), e.on("blur", l.hide)), e.on("init", (() => {
                            (e.hasFocus() || c) && d()
                        })), ny(e, t);
                        const u = {
                            show: d,
                            hide: l.hide,
                            setEnabled: e => {
                                oy(t, !e)
                            },
                            isEnabled: () => !Sm.isDisabled(s.outerContainer)
                        };
                        return {
                            editorContainer: s.outerContainer.element.dom,
                            api: u
                        }
                    }
                });
                const TM = "contexttoolbar-hide",
                    EM = (e, t) => Ds(bk, ((o, n) => {
                        const r = (e => ({
                            hide: () => ks(e, is()),
                            getValue: () => ou.getValue(e)
                        }))(e.get(o));
                        t.onAction(r, n.event.buttonApi)
                    })),
                    AM = (e, t) => {
                        const o = e.label.fold((() => ({})), (e => ({
                                "aria-label": e
                            }))),
                            n = Mp(wv.sketch({
                                inputClasses: ["tox-toolbar-textfield", "tox-toolbar-nav-js"],
                                data: e.initValue(),
                                inputAttributes: o,
                                selectOnFocus: !0,
                                inputBehaviours: gl([Th.config({
                                    mode: "special",
                                    onEnter: e => r.findPrimary(e).map((e => (Os(e), !0))),
                                    onLeft: (e, t) => (t.cut(), A.none()),
                                    onRight: (e, t) => (t.cut(), A.none())
                                })])
                            })),
                            r = ((e, t, o) => {
                                const n = z(t, (t => Mp(((e, t, o) => (e => "contextformtogglebutton" === e.type)(t) ? ((e, t, o) => {
                                    const {
                                        primary: n,
                                        ...r
                                    } = t.original, s = Vn(yb({ ...r,
                                        type: "togglebutton",
                                        onAction: v
                                    }));
                                    return lM(s, o, [EM(e, t)])
                                })(e, t, o) : ((e, t, o) => {
                                    const {
                                        primary: n,
                                        ...r
                                    } = t.original, s = Vn(fb({ ...r,
                                        type: "button",
                                        onAction: v
                                    }));
                                    return iM(s, o, [EM(e, t)])
                                })(e, t, o))(e, t, o))));
                                return {
                                    asSpecs: () => z(n, (e => e.asSpec())),
                                    findPrimary: e => se(t, ((t, o) => t.primary ? A.from(n[o]).bind((t => t.getOpt(e))).filter(S(Sm.isDisabled)) : A.none()))
                                }
                            })(n, e.commands, t);
                        return [{
                            title: A.none(),
                            items: [n.asSpec()]
                        }, {
                            title: A.none(),
                            items: r.asSpecs()
                        }]
                    },
                    MM = (e, t, o) => t.bottom - e.y >= o && e.bottom - t.y >= o,
                    NM = e => {
                        const t = (e => {
                            const t = e.getBoundingClientRect();
                            if (t.height <= 0 && t.width <= 0) {
                                const o = at(Be(e.startContainer), e.startOffset).element;
                                return (Ze(o) ? et(o) : A.some(o)).filter(Ve).map((e => e.dom.getBoundingClientRect())).getOr(t)
                            }
                            return t
                        })(e.selection.getRng());
                        if (e.inline) {
                            const e = Io();
                            return Wo(e.left + t.left, e.top + t.top, t.width, t.height)
                        } {
                            const o = qo(Be(e.getBody()));
                            return Wo(o.x + t.left, o.y + t.top, t.width, t.height)
                        }
                    },
                    RM = (e, t, o, n = 0) => {
                        const r = Fo(window),
                            s = $o(Be(e.getContentAreaContainer())),
                            a = Bf(e) || If(e) || zf(e),
                            {
                                x: i,
                                width: l
                            } = ((e, t, o) => {
                                const n = Math.max(e.x + o, t.x);
                                return {
                                    x: n,
                                    width: Math.min(e.right - o, t.right) - n
                                }
                            })(s, r, n);
                        if (e.inline && !a) return Wo(i, r.y, l, r.height); {
                            const a = t.header.isPositionedAtTop(),
                                {
                                    y: c,
                                    bottom: d
                                } = ((e, t, o, n, r, s) => {
                                    const a = Be(e.getContainer()),
                                        i = ri(a, ".tox-editor-header").getOr(a),
                                        l = $o(i),
                                        c = l.y >= t.bottom,
                                        d = n && !c;
                                    if (e.inline && d) return {
                                        y: Math.max(l.bottom + s, o.y),
                                        bottom: o.bottom
                                    };
                                    if (e.inline && !d) return {
                                        y: o.y,
                                        bottom: Math.min(l.y - s, o.bottom)
                                    };
                                    const u = "line" === r ? $o(a) : t;
                                    return d ? {
                                        y: Math.max(l.bottom + s, o.y),
                                        bottom: Math.min(u.bottom - s, o.bottom)
                                    } : {
                                        y: Math.max(u.y + s, o.y),
                                        bottom: Math.min(l.y - s, o.bottom)
                                    }
                                })(e, s, r, a, o, n);
                            return Wo(i, c, l, d - c)
                        }
                    },
                    DM = {
                        valignCentre: [],
                        alignCentre: [],
                        alignLeft: ["tox-pop--align-left"],
                        alignRight: ["tox-pop--align-right"],
                        right: ["tox-pop--right"],
                        left: ["tox-pop--left"],
                        bottom: ["tox-pop--bottom"],
                        top: ["tox-pop--top"],
                        inset: ["tox-pop--inset"]
                    },
                    BM = {
                        maxHeightFunction: Jl(),
                        maxWidthFunction: SE()
                    },
                    LM = e => "node" === e,
                    HM = (e, t, o, n, r) => {
                        const s = NM(e),
                            a = n.lastElement().exists((e => Ge(o, e)));
                        return ((e, t) => {
                            const o = e.selection.getRng(),
                                n = at(Be(o.startContainer), o.startOffset);
                            return o.startContainer === o.endContainer && o.startOffset === o.endOffset - 1 && Ge(n.element, t)
                        })(e, o) ? a ? G_ : U_ : a ? ((e, o, r) => {
                            const a = Nt(e, "position");
                            Ot(e, "position", o);
                            const i = MM(s, $o(t), -20) && !n.isReposition() ? Y_ : G_;
                            return a.each((t => Ot(e, "position", t))), i
                        })(t, n.getMode()) : ("fixed" === n.getMode() ? r.y + Io().top : r.y) + (Pt(t) + 12) <= s.y ? U_ : j_
                    },
                    IM = (e, t, o, n) => {
                        const r = t => (n, r, s, a, i) => ({ ...HM(e, a, t, o, i)({ ...n,
                                    y: i.y,
                                    height: i.height
                                }, r, s, a, i),
                                alwaysFit: !0
                            }),
                            s = e => LM(n) ? [r(e)] : [];
                        return t ? {
                            onLtr: e => [Qi, Gi, Ki, Yi, Xi, Ji].concat(s(e)),
                            onRtl: e => [Qi, Ki, Gi, Xi, Yi, Ji].concat(s(e))
                        } : {
                            onLtr: e => [Ji, Qi, Yi, Gi, Xi, Ki].concat(s(e)),
                            onRtl: e => [Ji, Qi, Xi, Ki, Yi, Gi].concat(s(e))
                        }
                    },
                    PM = (e, t) => {
                        const o = Z(t, (t => t.predicate(e.dom))),
                            {
                                pass: n,
                                fail: r
                            } = V(o, (e => "contexttoolbar" === e.type));
                        return {
                            contextToolbars: n,
                            contextForms: r
                        }
                    },
                    zM = (e, t) => {
                        const o = {},
                            n = [],
                            r = [],
                            s = {},
                            a = {},
                            i = ae(e);
                        return F(i, (i => {
                            const l = e[i];
                            "contextform" === l.type ? ((e, i) => {
                                const l = Vn(Fn("ContextForm", Ob, i));
                                o[e] = l, l.launch.map((o => {
                                    s["form:" + e] = { ...i.launch,
                                        type: "contextformtogglebutton" === o.type ? "togglebutton" : "button",
                                        onAction: () => {
                                            t(l)
                                        }
                                    }
                                })), "editor" === l.scope ? r.push(l) : n.push(l), a[e] = l
                            })(i, l) : "contexttoolbar" === l.type && ((e, t) => {
                                var o;
                                (o = t, Fn("ContextToolbar", Tb, o)).each((o => {
                                    "editor" === t.scope ? r.push(o) : n.push(o), a[e] = o
                                }))
                            })(i, l)
                        })), {
                            forms: o,
                            inNodeScope: n,
                            inEditorScope: r,
                            lookupTable: a,
                            formNavigators: s
                        }
                    },
                    FM = Qs("forward-slide"),
                    VM = Qs("backward-slide"),
                    ZM = Qs("change-slide-event"),
                    UM = "tox-pop--resizing",
                    jM = "tox-pop--transition",
                    WM = (e, t, o, n) => {
                        const r = n.backstage,
                            s = r.shared,
                            a = Oo().deviceType.isTouch,
                            i = Zl(),
                            l = Zl(),
                            c = Zl(),
                            d = Ka((e => {
                                const t = wr([]);
                                return Tp.sketch({
                                    dom: {
                                        tag: "div",
                                        classes: ["tox-pop"]
                                    },
                                    fireDismissalEventInstead: {
                                        event: "doNotDismissYet"
                                    },
                                    onShow: e => {
                                        t.set([]), Tp.getContent(e).each((e => {
                                            Bt(e.element, "visibility")
                                        })), Ra(e.element, UM), Bt(e.element, "width")
                                    },
                                    inlineBehaviours: gl([Ih("context-toolbar-events", [Fs(Gr(), ((e, t) => {
                                        "width" === t.event.raw.propertyName && (Ra(e.element, UM), Bt(e.element, "width"))
                                    })), Ds(ZM, ((e, t) => {
                                        const o = e.element;
                                        Bt(o, "width");
                                        const n = $t(o);
                                        Tp.setContent(e, t.event.contents), Na(o, UM);
                                        const r = $t(o);
                                        Ot(o, "width", n + "px"), Tp.getContent(e).each((e => {
                                            t.event.focus.bind((e => (xl(e), kl(o)))).orThunk((() => (Th.focusIn(e), Sl(dt(o)))))
                                        })), setTimeout((() => {
                                            Ot(e.element, "width", r + "px")
                                        }), 0)
                                    })), Ds(FM, ((e, o) => {
                                        Tp.getContent(e).each((o => {
                                            t.set(t.get().concat([{
                                                bar: o,
                                                focus: Sl(dt(e.element))
                                            }]))
                                        })), _s(e, ZM, {
                                            contents: o.event.forwardContents,
                                            focus: A.none()
                                        })
                                    })), Ds(VM, ((e, o) => {
                                        ne(t.get()).each((o => {
                                            t.set(t.get().slice(0, t.get().length - 1)), _s(e, ZM, {
                                                contents: Ya(o.bar),
                                                focus: o.focus
                                            })
                                        }))
                                    }))]), Th.config({
                                        mode: "special",
                                        onEscape: o => ne(t.get()).fold((() => e.onEscape()), (e => (ks(o, VM), A.some(!0))))
                                    })]),
                                    lazySink: () => Xo.value(e.sink)
                                })
                            })({
                                sink: o,
                                onEscape: () => (e.focus(), A.some(!0))
                            })),
                            u = () => {
                                const t = c.get().getOr("node"),
                                    o = LM(t) ? 1 : 0;
                                return RM(e, s, t, o)
                            },
                            m = () => !(e.removed || a() && r.isContextMenuOpen()),
                            g = () => {
                                if (m()) {
                                    const t = u(),
                                        o = we(c.get(), "node") ? ((e, t) => t.filter((e => ht(e) && (e => Ve(e) && Pe(e.dom))(e))).map(qo).getOrThunk((() => NM(e))))(e, i.get()) : NM(e);
                                    return t.height <= 0 || !MM(o, t, .01)
                                }
                                return !0
                            },
                            h = () => {
                                i.clear(), l.clear(), c.clear(), Tp.hide(d)
                            },
                            p = () => {
                                if (Tp.isOpen(d)) {
                                    const e = d.element;
                                    Bt(e, "display"), g() ? Ot(e, "display", "none") : (l.set(0), Tp.reposition(d))
                                }
                            },
                            f = t => ({
                                dom: {
                                    tag: "div",
                                    classes: ["tox-pop__dialog"]
                                },
                                components: [t],
                                behaviours: gl([Th.config({
                                    mode: "acyclic"
                                }), Ih("pop-dialog-wrap-events", [Vs((t => {
                                    e.shortcuts.add("ctrl+F9", "focus statusbar", (() => Th.focusIn(t)))
                                })), Zs((t => {
                                    e.shortcuts.remove("ctrl+F9")
                                }))])])
                            }),
                            b = Gt((() => zM(t, (e => {
                                const t = y([e]);
                                _s(d, FM, {
                                    forwardContents: f(t)
                                })
                            })))),
                            y = t => {
                                const {
                                    buttons: o
                                } = e.ui.registry.getAll(), r = { ...o,
                                    ...b().formNavigators
                                }, a = df(e) === Up.scrolling ? Up.scrolling : Up.default, i = q(z(t, (t => "contexttoolbar" === t.type ? ((t, o) => hM(e, {
                                    buttons: t,
                                    toolbar: o.items,
                                    allowToolbarGroups: !1
                                }, n.backstage, A.some(["form:"])))(r, t) : ((e, t) => AM(e, t))(t, s.providers))));
                                return qE({
                                    type: a,
                                    uid: Qs("context-toolbar"),
                                    initGroups: i,
                                    onEscape: A.none,
                                    cyclicKeying: !0,
                                    providers: s.providers
                                })
                            },
                            w = (t, n) => {
                                if (x.cancel(), !m()) return;
                                const r = y(t),
                                    h = t[0].position,
                                    p = ((t, n) => {
                                        const r = "node" === t ? s.anchors.node(n) : s.anchors.cursor(),
                                            c = ((e, t, o, n) => "line" === t ? {
                                                bubble: oc(12, 0, DM),
                                                layouts: {
                                                    onLtr: () => [el],
                                                    onRtl: () => [tl]
                                                },
                                                overrides: BM
                                            } : {
                                                bubble: oc(0, 12, DM, 1 / 12),
                                                layouts: IM(e, o, n, t),
                                                overrides: BM
                                            })(e, t, a(), {
                                                lastElement: i.get,
                                                isReposition: () => we(l.get(), 0),
                                                getMode: () => ud.getMode(o)
                                            });
                                        return cn(r, c)
                                    })(h, n);
                                c.set(h), l.set(1);
                                const v = d.element;
                                Bt(v, "display"), (e => we(Ce(e, i.get(), Ge), !0))(n) || (Ra(v, jM), ud.reset(o, d)), Tp.showWithinBounds(d, f(r), {
                                    anchor: p,
                                    transition: {
                                        classes: [jM],
                                        mode: "placement"
                                    }
                                }, (() => A.some(u()))), n.fold(i.clear, i.set), g() && Ot(v, "display", "none")
                            },
                            x = Wk((() => {
                                e.hasFocus() && !e.removed && (Da(d.element, jM) ? x.throttle() : ((e, t) => {
                                    const o = Be(t.getBody()),
                                        n = e => Ge(e, o),
                                        r = Be(t.selection.getNode());
                                    return (e => !n(e) && !Ke(o, e))(r) ? A.none() : ((e, t, o) => {
                                        const n = PM(e, t);
                                        if (n.contextForms.length > 0) return A.some({
                                            elem: e,
                                            toolbars: [n.contextForms[0]]
                                        }); {
                                            const t = PM(e, o);
                                            if (t.contextForms.length > 0) return A.some({
                                                elem: e,
                                                toolbars: [t.contextForms[0]]
                                            });
                                            if (n.contextToolbars.length > 0 || t.contextToolbars.length > 0) {
                                                const o = (e => {
                                                    if (e.length <= 1) return e; {
                                                        const t = t => H(e, (e => e.position === t)),
                                                            o = t => Z(e, (e => e.position === t)),
                                                            n = t("selection"),
                                                            r = t("node");
                                                        if (n || r) {
                                                            if (r && n) {
                                                                const e = o("node"),
                                                                    t = z(o("selection"), (e => ({ ...e,
                                                                        position: "node"
                                                                    })));
                                                                return e.concat(t)
                                                            }
                                                            return o(n ? "selection" : "node")
                                                        }
                                                        return o("line")
                                                    }
                                                })(n.contextToolbars.concat(t.contextToolbars));
                                                return A.some({
                                                    elem: e,
                                                    toolbars: o
                                                })
                                            }
                                            return A.none()
                                        }
                                    })(r, e.inNodeScope, e.inEditorScope).orThunk((() => ((e, t, o) => e(t) ? A.none() : _r(t, (e => {
                                        if (Ve(e)) {
                                            const {
                                                contextToolbars: t,
                                                contextForms: n
                                            } = PM(e, o.inNodeScope), r = n.length > 0 ? n : (e => {
                                                if (e.length <= 1) return e; {
                                                    const t = t => W(e, (e => e.position === t));
                                                    return t("selection").orThunk((() => t("node"))).orThunk((() => t("line"))).map((e => e.position)).fold((() => []), (t => Z(e, (e => e.position === t))))
                                                }
                                            })(t);
                                            return r.length > 0 ? A.some({
                                                elem: e,
                                                toolbars: r
                                            }) : A.none()
                                        }
                                        return A.none()
                                    }), e))(n, r, e)))
                                })(b(), e).fold(h, (e => {
                                    w(e.toolbars, A.some(e.elem))
                                })))
                            }), 17);
                        e.on("init", (() => {
                            e.on("remove", h), e.on("ScrollContent ScrollWindow ObjectResized ResizeEditor longpress", p), e.on("click keyup focus SetContent", x.throttle), e.on(TM, h), e.on("contexttoolbar-show", (t => {
                                const o = b();
                                ve(o.lookupTable, t.toolbarKey).each((o => {
                                    w([o], Se(t.target !== e, t.target)), Tp.getContent(d).each(Th.focusIn)
                                }))
                            })), e.on("focusout", (t => {
                                Ep.setEditorTimeout(e, (() => {
                                    kl(o.element).isNone() && kl(d.element).isNone() && h()
                                }), 0)
                            })), e.on("SwitchMode", (() => {
                                e.mode.isReadOnly() && h()
                            })), e.on("AfterProgressState", (t => {
                                t.state ? h() : e.hasFocus() && x.throttle()
                            })), e.on("NodeChange", (e => {
                                kl(d.element).fold(x.throttle, v)
                            }))
                        }))
                    },
                    $M = {
                        unsupportedLength: ["em", "ex", "cap", "ch", "ic", "rem", "lh", "rlh", "vw", "vh", "vi", "vb", "vmin", "vmax", "cm", "mm", "Q", "in", "pc", "pt", "px"],
                        fixed: ["px", "pt"],
                        relative: ["%"],
                        empty: [""]
                    },
                    qM = (() => {
                        const e = "[0-9]+",
                            t = "[eE][+-]?" + e,
                            o = e => `(?:${e})?`,
                            n = ["Infinity", e + "\\." + o(e) + o(t), "\\." + e + o(t), e + o(t)].join("|");
                        return new RegExp(`^([+-]?(?:${n}))(.*)$`)
                    })(),
                    GM = (e, t) => {
                        const o = () => {
                            const o = t.getOptions(e),
                                n = t.getCurrent(e).map(t.hash),
                                r = Zl();
                            return z(o, (o => ({
                                type: "togglemenuitem",
                                text: t.display(o),
                                onSetup: s => {
                                    const a = e => {
                                        e && (r.on((e => e.setActive(!1))), r.set(s)), s.setActive(e)
                                    };
                                    a(we(n, t.hash(o)));
                                    const i = t.watcher(e, o, a);
                                    return () => {
                                        r.clear(), i()
                                    }
                                },
                                onAction: () => t.setCurrent(e, o)
                            })))
                        };
                        e.ui.registry.addMenuButton(t.name, {
                            tooltip: t.text,
                            icon: t.icon,
                            fetch: e => e(o()),
                            onSetup: t.onToolbarSetup
                        }), e.ui.registry.addNestedMenuItem(t.name, {
                            type: "nestedmenuitem",
                            text: t.text,
                            getSubmenuItems: o,
                            onSetup: t.onMenuSetup
                        })
                    },
                    KM = {
                        name: "lineheight",
                        text: "Line height",
                        icon: "line-height",
                        getOptions: Hf,
                        hash: e => ((e, t) => ((e, t) => A.from(qM.exec(e)).bind((e => {
                            const o = Number(e[1]),
                                n = e[2];
                            return ((e, t) => H(t, (t => H($M[t], (t => e === t)))))(n, t) ? A.some({
                                value: o,
                                unit: n
                            }) : A.none()
                        })))(e, ["fixed", "relative", "empty"]).map((({
                            value: e,
                            unit: t
                        }) => e + t)))(e).getOr(e),
                        display: w,
                        watcher: (e, t, o) => e.formatter.formatChanged("lineheight", o, !1, {
                            value: t
                        }).unbind,
                        getCurrent: e => A.from(e.queryCommandValue("LineHeight")),
                        setCurrent: (e, t) => e.execCommand("LineHeight", !1, t)
                    },
                    YM = e => _A(e, "NodeChange", (t => {
                        t.setEnabled(e.queryCommandState("outdent"))
                    })),
                    XM = (e, t) => o => {
                        o.setActive(t.get());
                        const n = e => {
                            t.set(e.state), o.setActive(e.state)
                        };
                        return e.on("PastePlainTextToggle", n), () => e.off("PastePlainTextToggle", n)
                    },
                    JM = (e, t) => () => {
                        e.execCommand("mceToggleFormat", !1, t)
                    },
                    QM = e => {
                        (e => {
                            (e => {
                                dk.each([{
                                    name: "bold",
                                    text: "Bold",
                                    icon: "bold"
                                }, {
                                    name: "italic",
                                    text: "Italic",
                                    icon: "italic"
                                }, {
                                    name: "underline",
                                    text: "Underline",
                                    icon: "underline"
                                }, {
                                    name: "strikethrough",
                                    text: "Strikethrough",
                                    icon: "strike-through"
                                }, {
                                    name: "subscript",
                                    text: "Subscript",
                                    icon: "subscript"
                                }, {
                                    name: "superscript",
                                    text: "Superscript",
                                    icon: "superscript"
                                }], ((t, o) => {
                                    e.ui.registry.addToggleButton(t.name, {
                                        tooltip: t.text,
                                        icon: t.icon,
                                        onSetup: kA(e, t.name),
                                        onAction: JM(e, t.name)
                                    })
                                }));
                                for (let t = 1; t <= 6; t++) {
                                    const o = "h" + t;
                                    e.ui.registry.addToggleButton(o, {
                                        text: o.toUpperCase(),
                                        tooltip: "Heading " + t,
                                        onSetup: kA(e, o),
                                        onAction: JM(e, o)
                                    })
                                }
                            })(e), (e => {
                                dk.each([{
                                    name: "cut",
                                    text: "Cut",
                                    action: "Cut",
                                    icon: "cut"
                                }, {
                                    name: "copy",
                                    text: "Copy",
                                    action: "Copy",
                                    icon: "copy"
                                }, {
                                    name: "paste",
                                    text: "Paste",
                                    action: "Paste",
                                    icon: "paste"
                                }, {
                                    name: "help",
                                    text: "Help",
                                    action: "mceHelp",
                                    icon: "help"
                                }, {
                                    name: "selectall",
                                    text: "Select all",
                                    action: "SelectAll",
                                    icon: "select-all"
                                }, {
                                    name: "newdocument",
                                    text: "New document",
                                    action: "mceNewDocument",
                                    icon: "new-document"
                                }, {
                                    name: "removeformat",
                                    text: "Clear formatting",
                                    action: "RemoveFormat",
                                    icon: "remove-formatting"
                                }, {
                                    name: "remove",
                                    text: "Remove",
                                    action: "Delete",
                                    icon: "remove"
                                }, {
                                    name: "print",
                                    text: "Print",
                                    action: "mcePrint",
                                    icon: "print"
                                }, {
                                    name: "hr",
                                    text: "Horizontal line",
                                    action: "InsertHorizontalRule",
                                    icon: "horizontal-rule"
                                }], (t => {
                                    e.ui.registry.addButton(t.name, {
                                        tooltip: t.text,
                                        icon: t.icon,
                                        onAction: TA(e, t.action)
                                    })
                                }))
                            })(e), (e => {
                                dk.each([{
                                    name: "blockquote",
                                    text: "Blockquote",
                                    action: "mceBlockQuote",
                                    icon: "quote"
                                }], (t => {
                                    e.ui.registry.addToggleButton(t.name, {
                                        tooltip: t.text,
                                        icon: t.icon,
                                        onAction: TA(e, t.action),
                                        onSetup: kA(e, t.name)
                                    })
                                }))
                            })(e)
                        })(e), (e => {
                            dk.each([{
                                name: "bold",
                                text: "Bold",
                                action: "Bold",
                                icon: "bold",
                                shortcut: "Meta+B"
                            }, {
                                name: "italic",
                                text: "Italic",
                                action: "Italic",
                                icon: "italic",
                                shortcut: "Meta+I"
                            }, {
                                name: "underline",
                                text: "Underline",
                                action: "Underline",
                                icon: "underline",
                                shortcut: "Meta+U"
                            }, {
                                name: "strikethrough",
                                text: "Strikethrough",
                                action: "Strikethrough",
                                icon: "strike-through"
                            }, {
                                name: "subscript",
                                text: "Subscript",
                                action: "Subscript",
                                icon: "subscript"
                            }, {
                                name: "superscript",
                                text: "Superscript",
                                action: "Superscript",
                                icon: "superscript"
                            }, {
                                name: "removeformat",
                                text: "Clear formatting",
                                action: "RemoveFormat",
                                icon: "remove-formatting"
                            }, {
                                name: "newdocument",
                                text: "New document",
                                action: "mceNewDocument",
                                icon: "new-document"
                            }, {
                                name: "cut",
                                text: "Cut",
                                action: "Cut",
                                icon: "cut",
                                shortcut: "Meta+X"
                            }, {
                                name: "copy",
                                text: "Copy",
                                action: "Copy",
                                icon: "copy",
                                shortcut: "Meta+C"
                            }, {
                                name: "paste",
                                text: "Paste",
                                action: "Paste",
                                icon: "paste",
                                shortcut: "Meta+V"
                            }, {
                                name: "selectall",
                                text: "Select all",
                                action: "SelectAll",
                                icon: "select-all",
                                shortcut: "Meta+A"
                            }, {
                                name: "print",
                                text: "Print...",
                                action: "mcePrint",
                                icon: "print",
                                shortcut: "Meta+P"
                            }, {
                                name: "hr",
                                text: "Horizontal line",
                                action: "InsertHorizontalRule",
                                icon: "horizontal-rule"
                            }], (t => {
                                e.ui.registry.addMenuItem(t.name, {
                                    text: t.text,
                                    icon: t.icon,
                                    shortcut: t.shortcut,
                                    onAction: TA(e, t.action)
                                })
                            })), e.ui.registry.addMenuItem("codeformat", {
                                text: "Code",
                                icon: "sourcecode",
                                onAction: JM(e, "code")
                            })
                        })(e)
                    },
                    eN = (e, t) => _A(e, "Undo Redo AddUndo TypingUndo ClearUndos SwitchMode", (o => {
                        o.setEnabled(!e.mode.isReadOnly() && e.undoManager[t]())
                    })),
                    tN = e => _A(e, "VisualAid", (t => {
                        t.setActive(e.hasVisual)
                    })),
                    oN = (e, t) => {
                        (e => {
                            F([{
                                name: "alignleft",
                                text: "Align left",
                                cmd: "JustifyLeft",
                                icon: "align-left"
                            }, {
                                name: "aligncenter",
                                text: "Align center",
                                cmd: "JustifyCenter",
                                icon: "align-center"
                            }, {
                                name: "alignright",
                                text: "Align right",
                                cmd: "JustifyRight",
                                icon: "align-right"
                            }, {
                                name: "alignjustify",
                                text: "Justify",
                                cmd: "JustifyFull",
                                icon: "align-justify"
                            }], (t => {
                                e.ui.registry.addToggleButton(t.name, {
                                    tooltip: t.text,
                                    icon: t.icon,
                                    onAction: TA(e, t.cmd),
                                    onSetup: kA(e, t.name)
                                })
                            })), e.ui.registry.addButton("alignnone", {
                                tooltip: "No alignment",
                                icon: "align-none",
                                onAction: TA(e, "JustifyNone")
                            })
                        })(e), QM(e), ((e, t) => {
                            ((e, t) => {
                                const o = AA(0, t, BA(e));
                                e.ui.registry.addNestedMenuItem("align", {
                                    text: t.shared.providers.translate("Align"),
                                    getSubmenuItems: () => o.items.validateItems(o.getStyleItems())
                                })
                            })(e, t), ((e, t) => {
                                const o = AA(0, t, zA(e));
                                e.ui.registry.addNestedMenuItem("fontfamily", {
                                    text: t.shared.providers.translate("Fonts"),
                                    getSubmenuItems: () => o.items.validateItems(o.getStyleItems())
                                })
                            })(e, t), ((e, t) => {
                                const o = {
                                        type: "advanced",
                                        ...t.styles
                                    },
                                    n = AA(0, t, WA(e, o));
                                e.ui.registry.addNestedMenuItem("styles", {
                                    text: "Formats",
                                    getSubmenuItems: () => n.items.validateItems(n.getStyleItems())
                                })
                            })(e, t), ((e, t) => {
                                const o = AA(0, t, HA(e));
                                e.ui.registry.addNestedMenuItem("blocks", {
                                    text: "Blocks",
                                    getSubmenuItems: () => o.items.validateItems(o.getStyleItems())
                                })
                            })(e, t), ((e, t) => {
                                const o = AA(0, t, jA(e));
                                e.ui.registry.addNestedMenuItem("fontsize", {
                                    text: "Font sizes",
                                    getSubmenuItems: () => o.items.validateItems(o.getStyleItems())
                                })
                            })(e, t)
                        })(e, t), (e => {
                            (e => {
                                e.ui.registry.addMenuItem("undo", {
                                    text: "Undo",
                                    icon: "undo",
                                    shortcut: "Meta+Z",
                                    onSetup: eN(e, "hasUndo"),
                                    onAction: TA(e, "undo")
                                }), e.ui.registry.addMenuItem("redo", {
                                    text: "Redo",
                                    icon: "redo",
                                    shortcut: "Meta+Y",
                                    onSetup: eN(e, "hasRedo"),
                                    onAction: TA(e, "redo")
                                })
                            })(e), (e => {
                                e.ui.registry.addButton("undo", {
                                    tooltip: "Undo",
                                    icon: "undo",
                                    enabled: !1,
                                    onSetup: eN(e, "hasUndo"),
                                    onAction: TA(e, "undo")
                                }), e.ui.registry.addButton("redo", {
                                    tooltip: "Redo",
                                    icon: "redo",
                                    enabled: !1,
                                    onSetup: eN(e, "hasRedo"),
                                    onAction: TA(e, "redo")
                                })
                            })(e)
                        })(e), (e => {
                            (e => {
                                e.addCommand("mceApplyTextcolor", ((t, o) => {
                                    ((e, t, o) => {
                                        e.undoManager.transact((() => {
                                            e.focus(), e.formatter.apply(t, {
                                                value: o
                                            }), e.nodeChanged()
                                        }))
                                    })(e, t, o)
                                })), e.addCommand("mceRemoveTextcolor", (t => {
                                    ((e, t) => {
                                        e.undoManager.transact((() => {
                                            e.focus(), e.formatter.remove(t, {
                                                value: null
                                            }, void 0, !0), e.nodeChanged()
                                        }))
                                    })(e, t)
                                }))
                            })(e);
                            const t = hw(e),
                                o = pw(e),
                                n = wr(t),
                                r = wr(o);
                            Cw(e, "forecolor", "forecolor", "Text color", n), Cw(e, "backcolor", "hilitecolor", "Background color", r), Sw(e, "forecolor", "forecolor", "Text color"), Sw(e, "backcolor", "hilitecolor", "Background color")
                        })(e), (e => {
                            (e => {
                                e.ui.registry.addButton("visualaid", {
                                    tooltip: "Visual aids",
                                    text: "Visual aids",
                                    onAction: TA(e, "mceToggleVisualAid")
                                })
                            })(e), (e => {
                                e.ui.registry.addToggleMenuItem("visualaid", {
                                    text: "Visual aids",
                                    onSetup: tN(e),
                                    onAction: TA(e, "mceToggleVisualAid")
                                })
                            })(e)
                        })(e), (e => {
                            (e => {
                                e.ui.registry.addButton("outdent", {
                                    tooltip: "Decrease indent",
                                    icon: "outdent",
                                    onSetup: YM(e),
                                    onAction: TA(e, "outdent")
                                }), e.ui.registry.addButton("indent", {
                                    tooltip: "Increase indent",
                                    icon: "indent",
                                    onAction: TA(e, "indent")
                                })
                            })(e)
                        })(e), (e => {
                            GM(e, KM), (e => A.from(lf(e)).map((t => ({
                                name: "language",
                                text: "Language",
                                icon: "language",
                                getOptions: y(t),
                                hash: e => u(e.customCode) ? e.code : `${e.code}/${e.customCode}`,
                                display: e => e.title,
                                watcher: (e, t, o) => {
                                    var n;
                                    return e.formatter.formatChanged("lang", o, !1, {
                                        value: t.code,
                                        customValue: null !== (n = t.customCode) && void 0 !== n ? n : null
                                    }).unbind
                                },
                                getCurrent: e => {
                                    const t = Be(e.selection.getNode());
                                    return Or(t, (e => A.some(e).filter(Ve).bind((e => xt(e, "lang").map((t => ({
                                        code: t,
                                        customCode: xt(e, "data-mce-lang").getOrUndefined(),
                                        title: ""
                                    })))))))
                                },
                                setCurrent: (e, t) => e.execCommand("Lang", !1, t),
                                onToolbarSetup: t => {
                                    const o = Vl();
                                    return t.setActive(e.formatter.match("lang", {}, void 0, !0)), o.set(e.formatter.formatChanged("lang", t.setActive, !0)), o.clear
                                }
                            }))))(e).each((t => GM(e, t)))
                        })(e), (e => {
                            const t = wr(Mf(e)),
                                o = () => e.execCommand("mceTogglePlainTextPaste");
                            e.ui.registry.addToggleButton("pastetext", {
                                active: !1,
                                icon: "paste-text",
                                tooltip: "Paste as text",
                                onAction: o,
                                onSetup: XM(e, t)
                            }), e.ui.registry.addToggleMenuItem("pastetext", {
                                text: "Paste as text",
                                icon: "paste-text",
                                onAction: o,
                                onSetup: XM(e, t)
                            })
                        })(e)
                    },
                    nN = e => s(e) ? e.split(/[ ,]/) : e,
                    rN = e => t => t.options.get(e),
                    sN = rN("contextmenu_never_use_native"),
                    aN = rN("contextmenu_avoid_overlap"),
                    iN = e => {
                        const t = e.ui.registry.getAll().contextMenus,
                            o = e.options.get("contextmenu");
                        return e.options.isSet("contextmenu") ? o : Z(o, (e => be(t, e)))
                    },
                    lN = (e, t) => ({
                        type: "makeshift",
                        x: e,
                        y: t
                    }),
                    cN = e => "longpress" === e.type || 0 === e.type.indexOf("touch"),
                    dN = (e, t) => "contextmenu" === t.type || "longpress" === t.type ? e.inline ? (e => {
                        if (cN(e)) {
                            const t = e.touches[0];
                            return lN(t.pageX, t.pageY)
                        }
                        return lN(e.pageX, e.pageY)
                    })(t) : ((e, t) => {
                        const o = Wp.DOM.getPos(e);
                        return ((e, t, o) => lN(e.x + t, e.y + o))(t, o.x, o.y)
                    })(e.getContentAreaContainer(), (e => {
                        if (cN(e)) {
                            const t = e.touches[0];
                            return lN(t.clientX, t.clientY)
                        }
                        return lN(e.clientX, e.clientY)
                    })(t)) : uN(e),
                    uN = e => ({
                        type: "selection",
                        root: Be(e.selection.getNode())
                    }),
                    mN = (e, t, o) => {
                        switch (o) {
                            case "node":
                                return (e => ({
                                    type: "node",
                                    node: A.some(Be(e.selection.getNode())),
                                    root: Be(e.getBody())
                                }))(e);
                            case "point":
                                return dN(e, t);
                            case "selection":
                                return uN(e)
                        }
                    },
                    gN = (e, t, o, n, r, s) => {
                        const a = o(),
                            i = mN(e, t, s);
                        Mk(a, Xf.CLOSE_ON_EXECUTE, n, {
                            isHorizontalMenu: !1,
                            search: A.none()
                        }).map((e => {
                            t.preventDefault(), Tp.showMenuAt(r, {
                                anchor: i
                            }, {
                                menu: {
                                    markers: mv("normal")
                                },
                                data: e
                            })
                        }))
                    },
                    hN = {
                        onLtr: () => [Qi, Gi, Ki, Yi, Xi, Ji, U_, j_, Z_, F_, V_, z_],
                        onRtl: () => [Qi, Ki, Gi, Xi, Yi, Ji, U_, j_, V_, z_, Z_, F_]
                    },
                    pN = {
                        valignCentre: [],
                        alignCentre: [],
                        alignLeft: ["tox-pop--align-left"],
                        alignRight: ["tox-pop--align-right"],
                        right: ["tox-pop--right"],
                        left: ["tox-pop--left"],
                        bottom: ["tox-pop--bottom"],
                        top: ["tox-pop--top"]
                    },
                    fN = (e, t, o, n, r, s) => {
                        const a = Oo(),
                            i = a.os.isiOS(),
                            l = a.os.isMacOS(),
                            c = a.os.isAndroid(),
                            d = a.deviceType.isTouch(),
                            u = () => {
                                const a = o();
                                ((e, t, o, n, r, s, a) => {
                                    const i = ((e, t, o) => {
                                        const n = mN(e, t, o);
                                        return {
                                            bubble: oc(0, "point" === o ? 12 : 0, pN),
                                            layouts: hN,
                                            overrides: {
                                                maxWidthFunction: SE(),
                                                maxHeightFunction: Jl()
                                            },
                                            ...n
                                        }
                                    })(e, t, s);
                                    Mk(o, Xf.CLOSE_ON_EXECUTE, n, {
                                        isHorizontalMenu: !0,
                                        search: A.none()
                                    }).map((o => {
                                        t.preventDefault();
                                        const l = a ? kp.HighlightMenuAndItem : kp.HighlightNone;
                                        Tp.showMenuWithinBounds(r, {
                                            anchor: i
                                        }, {
                                            menu: {
                                                markers: mv("normal"),
                                                highlightOnOpen: l
                                            },
                                            data: o,
                                            type: "horizontal"
                                        }, (() => A.some(RM(e, n.shared, "node" === s ? "node" : "selection")))), e.dispatch(TM)
                                    }))
                                })(e, t, a, n, r, s, !(c || i || l && d))
                            };
                        if ((l || i) && "node" !== s) {
                            const o = () => {
                                (e => {
                                    const t = e.selection.getRng(),
                                        o = () => {
                                            Ep.setEditorTimeout(e, (() => {
                                                e.selection.setRng(t)
                                            }), 10), s()
                                        };
                                    e.once("touchend", o);
                                    const n = e => {
                                        e.preventDefault(), e.stopImmediatePropagation()
                                    };
                                    e.on("mousedown", n, !0);
                                    const r = () => s();
                                    e.once("longpresscancel", r);
                                    const s = () => {
                                        e.off("touchend", o), e.off("longpresscancel", r), e.off("mousedown", n)
                                    }
                                })(e), u()
                            };
                            ((e, t) => {
                                const o = e.selection;
                                if (o.isCollapsed() || t.touches.length < 1) return !1; {
                                    const n = t.touches[0],
                                        r = o.getRng();
                                    return zc(e.getWin(), Ac.domRange(r)).exists((e => e.left <= n.clientX && e.right >= n.clientX && e.top <= n.clientY && e.bottom >= n.clientY))
                                }
                            })(e, t) ? o(): (e.once("selectionchange", o), e.once("touchend", (() => e.off("selectionchange", o))))
                        } else u()
                    },
                    vN = e => s(e) ? "|" === e : "separator" === e.type,
                    bN = {
                        type: "separator"
                    },
                    yN = e => {
                        const t = e => ({
                            text: e.text,
                            icon: e.icon,
                            enabled: e.enabled,
                            shortcut: e.shortcut
                        });
                        if (s(e)) return e;
                        switch (e.type) {
                            case "separator":
                                return bN;
                            case "submenu":
                                return {
                                    type: "nestedmenuitem",
                                    ...t(e),
                                    getSubmenuItems: () => {
                                        const t = e.getSubmenuItems();
                                        return s(t) ? t : z(t, yN)
                                    }
                                };
                            default:
                                const n = e;
                                return {
                                    type: "menuitem",
                                    ...t(n),
                                    onAction: (o = n.onAction, () => o())
                                }
                        }
                        var o
                    },
                    wN = (e, t) => {
                        if (0 === t.length) return e;
                        const o = ne(e).filter((e => !vN(e))).fold((() => []), (e => [bN]));
                        return e.concat(o).concat(t).concat([bN])
                    },
                    xN = (e, t) => !(e => "longpress" === e.type || be(e, "touches"))(t) && (2 !== t.button || t.target === e.getBody() && "" === t.pointerType),
                    CN = (e, t) => xN(e, t) ? e.selection.getStart(!0) : t.target,
                    SN = (e, t, o) => {
                        const n = Oo().deviceType.isTouch,
                            r = Ka(Tp.sketch({
                                dom: {
                                    tag: "div"
                                },
                                lazySink: t,
                                onEscape: () => e.focus(),
                                onShow: () => o.setContextMenuState(!0),
                                onHide: () => o.setContextMenuState(!1),
                                fireDismissalEventInstead: {},
                                inlineBehaviours: gl([Ih("dismissContextMenu", [Ds(fs(), ((t, o) => {
                                    Hd.close(t), e.focus()
                                }))])])
                            })),
                            a = () => Tp.hide(r),
                            i = t => {
                                if (sN(e) && t.preventDefault(), ((e, t) => t.ctrlKey && !sN(e))(e, t) || (e => 0 === iN(e).length)(e)) return;
                                const a = ((e, t) => {
                                    const o = aN(e),
                                        n = xN(e, t) ? "selection" : "point";
                                    if (Ee(o)) {
                                        const r = CN(e, t);
                                        return hx(Be(r), o) ? "node" : n
                                    }
                                    return n
                                })(e, t);
                                (n() ? fN : gN)(e, t, (() => {
                                    const o = CN(e, t),
                                        n = e.ui.registry.getAll(),
                                        r = iN(e);
                                    return ((e, t, o) => {
                                        const n = j(t, ((t, n) => ve(e, n.toLowerCase()).map((e => {
                                            const n = e.update(o);
                                            if (s(n)) return wN(t, n.split(" "));
                                            if (n.length > 0) {
                                                const e = z(n, yN);
                                                return wN(t, e)
                                            }
                                            return t
                                        })).getOrThunk((() => t.concat([n])))), []);
                                        return n.length > 0 && vN(n[n.length - 1]) && n.pop(), n
                                    })(n.contextMenus, r, o)
                                }), o, r, a)
                            };
                        e.on("init", (() => {
                            const t = "ResizeEditor ScrollContent ScrollWindow longpresscancel" + (n() ? "" : " ResizeWindow");
                            e.on(t, a), e.on("longpress contextmenu", i)
                        }))
                    },
                    kN = xr([{
                        offset: ["x", "y"]
                    }, {
                        absolute: ["x", "y"]
                    }, {
                        fixed: ["x", "y"]
                    }]),
                    _N = e => t => t.translate(-e.left, -e.top),
                    ON = e => t => t.translate(e.left, e.top),
                    TN = e => (t, o) => j(e, ((e, t) => t(e)), Vt(t, o)),
                    EN = (e, t, o) => e.fold(TN([ON(o), _N(t)]), TN([_N(t)]), TN([])),
                    AN = (e, t, o) => e.fold(TN([ON(o)]), TN([]), TN([ON(t)])),
                    MN = (e, t, o) => e.fold(TN([]), TN([_N(o)]), TN([ON(t), _N(o)])),
                    NN = (e, t, o) => {
                        const n = e.fold(((e, t) => ({
                            position: A.some("absolute"),
                            left: A.some(e + "px"),
                            top: A.some(t + "px")
                        })), ((e, t) => ({
                            position: A.some("absolute"),
                            left: A.some(e - o.left + "px"),
                            top: A.some(t - o.top + "px")
                        })), ((e, t) => ({
                            position: A.some("fixed"),
                            left: A.some(e + "px"),
                            top: A.some(t + "px")
                        })));
                        return {
                            right: A.none(),
                            bottom: A.none(),
                            ...n
                        }
                    },
                    RN = (e, t, o, n) => {
                        const r = (e, r) => (s, a) => {
                            const i = e(t, o, n);
                            return r(s.getOr(i.left), a.getOr(i.top))
                        };
                        return e.fold(r(MN, DN), r(AN, BN), r(EN, LN))
                    },
                    DN = kN.offset,
                    BN = kN.absolute,
                    LN = kN.fixed,
                    HN = (e, t) => {
                        const o = wt(e, t);
                        return u(o) ? NaN : parseInt(o, 10)
                    },
                    IN = (e, t, o, n, r, s) => {
                        const a = ((e, t, o, n) => ((e, t) => {
                                const o = e.element,
                                    n = HN(o, t.leftAttr),
                                    r = HN(o, t.topAttr);
                                return isNaN(n) || isNaN(r) ? A.none() : A.some(Vt(n, r))
                            })(e, t).fold((() => o), (e => LN(e.left + n.left, e.top + n.top))))(e, t, o, n),
                            i = t.mustSnap ? zN(e, t, a, r, s) : FN(e, t, a, r, s),
                            l = EN(a, r, s);
                        return ((e, t, o) => {
                            const n = e.element;
                            bt(n, t.leftAttr, o.left + "px"), bt(n, t.topAttr, o.top + "px")
                        })(e, t, l), i.fold((() => ({
                            coord: LN(l.left, l.top),
                            extra: A.none()
                        })), (e => ({
                            coord: e.output,
                            extra: e.extra
                        })))
                    },
                    PN = (e, t, o, n) => se(e, (e => {
                        const r = e.sensor,
                            s = ((e, t, o, n, r, s) => {
                                const a = AN(e, r, s),
                                    i = AN(t, r, s);
                                return Math.abs(a.left - i.left) <= o && Math.abs(a.top - i.top) <= n
                            })(t, r, e.range.left, e.range.top, o, n);
                        return s ? A.some({
                            output: RN(e.output, t, o, n),
                            extra: e.extra
                        }) : A.none()
                    })),
                    zN = (e, t, o, n, r) => {
                        const s = t.getSnapPoints(e);
                        return PN(s, o, n, r).orThunk((() => {
                            const e = j(s, ((e, t) => {
                                const s = t.sensor,
                                    a = ((e, t, o, n, r, s) => {
                                        const a = AN(e, r, s),
                                            i = AN(t, r, s),
                                            l = Math.abs(a.left - i.left),
                                            c = Math.abs(a.top - i.top);
                                        return Vt(l, c)
                                    })(o, s, t.range.left, t.range.top, n, r);
                                return e.deltas.fold((() => ({
                                    deltas: A.some(a),
                                    snap: A.some(t)
                                })), (o => (a.left + a.top) / 2 <= (o.left + o.top) / 2 ? {
                                    deltas: A.some(a),
                                    snap: A.some(t)
                                } : e))
                            }), {
                                deltas: A.none(),
                                snap: A.none()
                            });
                            return e.snap.map((e => ({
                                output: RN(e.output, o, n, r),
                                extra: e.extra
                            })))
                        }))
                    },
                    FN = (e, t, o, n, r) => {
                        const s = t.getSnapPoints(e);
                        return PN(s, o, n, r)
                    };
                var VN = Object.freeze({
                    __proto__: null,
                    snapTo: (e, t, o, n) => {
                        const r = t.getTarget(e.element);
                        if (t.repositionTarget) {
                            const t = Ye(e.element),
                                o = Io(t),
                                s = tT(r),
                                a = ((e, t, o) => ({
                                    coord: RN(e.output, e.output, t, o),
                                    extra: e.extra
                                }))(n, o, s),
                                i = NN(a.coord, 0, s);
                            Et(r, i)
                        }
                    }
                });
                const ZN = "data-initial-z-index",
                    UN = (e, t) => {
                        e.getSystem().addToGui(t), (e => {
                            et(e.element).filter(Ve).each((t => {
                                Nt(t, "z-index").each((e => {
                                    bt(t, ZN, e)
                                })), Ot(t, "z-index", At(e.element, "z-index"))
                            }))
                        })(t)
                    },
                    jN = e => {
                        (e => {
                            et(e.element).filter(Ve).each((e => {
                                xt(e, ZN).fold((() => Bt(e, "z-index")), (t => Ot(e, "z-index", t))), St(e, ZN)
                            }))
                        })(e), e.getSystem().removeFromGui(e)
                    },
                    WN = (e, t, o) => e.getSystem().build(kx.sketch({
                        dom: {
                            styles: {
                                left: "0px",
                                top: "0px",
                                width: "100%",
                                height: "100%",
                                position: "fixed",
                                "z-index": "1000000000000000"
                            },
                            classes: [t]
                        },
                        events: o
                    }));
                var $N = dr("snaps", [Gn("getSnapPoints"), xi("onSensor"), Gn("leftAttr"), Gn("topAttr"), ur("lazyViewport", Go), ur("mustSnap", !1)]);
                const qN = [ur("useFixed", O), Gn("blockerClass"), ur("getTarget", w), ur("onDrag", v), ur("repositionTarget", !0), ur("onDrop", v), vr("getBounds", Go), $N],
                    GN = (e, t) => ({
                        bounds: e.getBounds(),
                        height: zt(t.element),
                        width: qt(t.element)
                    }),
                    KN = (e, t, o, n, r) => {
                        const s = o.update(n, r),
                            a = o.getStartData().getOrThunk((() => GN(t, e)));
                        s.each((o => {
                            ((e, t, o, n) => {
                                const r = t.getTarget(e.element);
                                if (t.repositionTarget) {
                                    const s = Ye(e.element),
                                        a = Io(s),
                                        i = tT(r),
                                        l = (e => {
                                            return (t = Nt(e, "left"), o = Nt(e, "top"), n = Nt(e, "position"), r = (e, t, o) => ("fixed" === o ? LN : DN)(parseInt(e, 10), parseInt(t, 10)), t.isSome() && o.isSome() && n.isSome() ? A.some(r(t.getOrDie(), o.getOrDie(), n.getOrDie())) : A.none()).getOrThunk((() => {
                                                const t = Ut(e);
                                                return BN(t.left, t.top)
                                            }));
                                            var t, o, n, r
                                        })(r),
                                        c = ((e, t, o, n, r, s, a) => ((e, t, o, n, r) => {
                                            const s = r.bounds,
                                                a = AN(t, o, n),
                                                i = zi(a.left, s.x, s.x + s.width - r.width),
                                                l = zi(a.top, s.y, s.y + s.height - r.height),
                                                c = BN(i, l);
                                            return t.fold((() => {
                                                const e = MN(c, o, n);
                                                return DN(e.left, e.top)
                                            }), y(c), (() => {
                                                const e = EN(c, o, n);
                                                return LN(e.left, e.top)
                                            }))
                                        })(0, t.fold((() => {
                                            const e = (t = o, a = s.left, i = s.top, t.fold(((e, t) => DN(e + a, t + i)), ((e, t) => BN(e + a, t + i)), ((e, t) => LN(e + a, t + i))));
                                            var t, a, i;
                                            const l = EN(e, n, r);
                                            return LN(l.left, l.top)
                                        }), (t => {
                                            const a = IN(e, t, o, s, n, r);
                                            return a.extra.each((o => {
                                                t.onSensor(e, o)
                                            })), a.coord
                                        })), n, r, a))(e, t.snaps, l, a, i, n, o),
                                        d = NN(c, 0, i);
                                    Et(r, d)
                                }
                                t.onDrag(e, r, n)
                            })(e, t, a, o)
                        }))
                    },
                    YN = (e, t, o, n) => {
                        t.each(jN), o.snaps.each((t => {
                            ((e, t) => {
                                ((e, t) => {
                                    const o = e.element;
                                    St(o, t.leftAttr), St(o, t.topAttr)
                                })(e, t)
                            })(e, t)
                        }));
                        const r = o.getTarget(e.element);
                        n.reset(), o.onDrop(e, r)
                    },
                    XN = e => (t, o) => {
                        const n = e => {
                            o.setStartData(GN(t, e))
                        };
                        return Ms([Ds(ms(), (e => {
                            o.getStartData().each((() => n(e)))
                        })), ...e(t, o, n)])
                    };
                var JN = Object.freeze({
                    __proto__: null,
                    getData: e => A.from(Vt(e.x, e.y)),
                    getDelta: (e, t) => Vt(t.left - e.left, t.top - e.top)
                });
                const QN = (e, t, o) => [Ds(Lr(), ((n, r) => {
                        if (0 !== r.event.raw.button) return;
                        r.stop();
                        const s = () => YN(n, A.some(l), e, t),
                            a = px(s, 200),
                            i = {
                                drop: s,
                                delayDrop: a.schedule,
                                forceDrop: s,
                                move: o => {
                                    a.cancel(), KN(n, e, t, JN, o)
                                }
                            },
                            l = WN(n, e.blockerClass, (e => Ms([Ds(Lr(), e.forceDrop), Ds(Pr(), e.drop), Ds(Hr(), ((t, o) => {
                                e.move(o.event)
                            })), Ds(Ir(), e.delayDrop)]))(i));
                        o(n), UN(n, l)
                    }))],
                    eR = [...qN, _i("dragger", {
                        handlers: XN(QN)
                    })];
                var tR = Object.freeze({
                    __proto__: null,
                    getData: e => {
                        const t = e.raw.touches;
                        return 1 === t.length ? (e => {
                            const t = e[0];
                            return A.some(Vt(t.clientX, t.clientY))
                        })(t) : A.none()
                    },
                    getDelta: (e, t) => Vt(t.left - e.left, t.top - e.top)
                });
                const oR = (e, t, o) => {
                        const n = Zl(),
                            r = o => {
                                YN(o, n.get(), e, t), n.clear()
                            };
                        return [Ds(Nr(), ((s, a) => {
                            a.stop();
                            const i = () => r(s),
                                l = {
                                    drop: i,
                                    delayDrop: v,
                                    forceDrop: i,
                                    move: o => {
                                        KN(s, e, t, tR, o)
                                    }
                                },
                                c = WN(s, e.blockerClass, (e => Ms([Ds(Nr(), e.forceDrop), Ds(Dr(), e.drop), Ds(Br(), e.drop), Ds(Rr(), ((t, o) => {
                                    e.move(o.event)
                                }))]))(l));
                            n.set(c), o(s), UN(s, c)
                        })), Ds(Rr(), ((o, n) => {
                            n.stop(), KN(o, e, t, tR, n.event)
                        })), Ds(Dr(), ((e, t) => {
                            t.stop(), r(e)
                        })), Ds(Br(), r)]
                    },
                    nR = eR,
                    rR = [...qN, _i("dragger", {
                        handlers: XN(oR)
                    })],
                    sR = [...qN, _i("dragger", {
                        handlers: XN(((e, t, o) => [...QN(e, t, o), ...oR(e, t, o)]))
                    })];
                var aR = Object.freeze({
                        __proto__: null,
                        mouse: nR,
                        touch: rR,
                        mouseOrTouch: sR
                    }),
                    iR = Object.freeze({
                        __proto__: null,
                        init: () => {
                            let e = A.none(),
                                t = A.none();
                            const o = y({});
                            return va({
                                readState: o,
                                reset: () => {
                                    e = A.none(), t = A.none()
                                },
                                update: (t, o) => t.getData(o).bind((o => ((t, o) => {
                                    const n = e.map((e => t.getDelta(e, o)));
                                    return e = A.some(o), n
                                })(t, o))),
                                getStartData: () => t,
                                setStartData: e => {
                                    t = A.some(e)
                                }
                            })
                        }
                    });
                const lR = vl({
                        branchKey: "mode",
                        branches: aR,
                        name: "dragging",
                        active: {
                            events: (e, t) => e.dragger.handlers(e, t)
                        },
                        extra: {
                            snap: e => ({
                                sensor: e.sensor,
                                range: e.range,
                                output: e.output,
                                extra: A.from(e.extra)
                            })
                        },
                        state: iR,
                        apis: VN
                    }),
                    cR = (e, t, o, n, r, s) => e.fold((() => lR.snap({
                        sensor: BN(o - 20, n - 20),
                        range: Vt(r, s),
                        output: BN(A.some(o), A.some(n)),
                        extra: {
                            td: t
                        }
                    })), (e => {
                        const r = o - 20,
                            s = n - 20,
                            a = e.element.dom.getBoundingClientRect();
                        return lR.snap({
                            sensor: BN(r, s),
                            range: Vt(40, 40),
                            output: BN(A.some(o - a.width / 2), A.some(n - a.height / 2)),
                            extra: {
                                td: t
                            }
                        })
                    })),
                    dR = (e, t, o) => ({
                        getSnapPoints: e,
                        leftAttr: "data-drag-left",
                        topAttr: "data-drag-top",
                        onSensor: (e, n) => {
                            const r = n.td;
                            ((e, t) => e.exists((e => Ge(e, t))))(t.get(), r) || (t.set(r), o(r))
                        },
                        mustSnap: !0
                    }),
                    uR = e => Mp(Ap.sketch({
                        dom: {
                            tag: "div",
                            classes: ["tox-selector"]
                        },
                        buttonBehaviours: gl([lR.config({
                            mode: "mouseOrTouch",
                            blockerClass: "blocker",
                            snaps: e
                        }), oC.config({})]),
                        eventOrder: {
                            mousedown: ["dragging", "alloy.base.behaviour"],
                            touchstart: ["dragging", "alloy.base.behaviour"]
                        }
                    })),
                    mR = (e, t) => {
                        const o = wr([]),
                            n = wr([]),
                            r = wr(!1),
                            s = Zl(),
                            a = Zl(),
                            i = e => {
                                const o = qo(e);
                                return cR(u.getOpt(t), e, o.x, o.y, o.width, o.height)
                            },
                            l = e => {
                                const o = qo(e);
                                return cR(m.getOpt(t), e, o.right, o.bottom, o.width, o.height)
                            },
                            c = dR((() => z(o.get(), (e => i(e)))), s, (t => {
                                a.get().each((o => {
                                    e.dispatch("TableSelectorChange", {
                                        start: t,
                                        finish: o
                                    })
                                }))
                            })),
                            d = dR((() => z(n.get(), (e => l(e)))), a, (t => {
                                s.get().each((o => {
                                    e.dispatch("TableSelectorChange", {
                                        start: o,
                                        finish: t
                                    })
                                }))
                            })),
                            u = uR(c),
                            m = uR(d),
                            g = Ka(u.asSpec()),
                            h = Ka(m.asSpec()),
                            p = (t, o, n, r) => {
                                const s = n(o);
                                lR.snapTo(t, s), ((t, o, n, s) => {
                                    const a = o.dom.getBoundingClientRect();
                                    Bt(t.element, "display");
                                    const i = Qe(Be(e.getBody())).dom.innerHeight,
                                        l = a[r] < 0,
                                        c = ((e, t) => e[r] > t)(a, i);
                                    (l || c) && Ot(t.element, "display", "none")
                                })(t, o)
                            },
                            f = e => p(g, e, i, "top"),
                            v = e => p(h, e, l, "bottom");
                        Oo().deviceType.isTouch() && (e.on("TableSelectionChange", (e => {
                            r.get() || (bd(t, g), bd(t, h), r.set(!0)), s.set(e.start), a.set(e.finish), e.otherCells.each((t => {
                                o.set(t.upOrLeftCells), n.set(t.downOrRightCells), f(e.start), v(e.finish)
                            }))
                        })), e.on("ResizeEditor ResizeWindow ScrollContent", (() => {
                            s.get().each(f), a.get().each(v)
                        })), e.on("TableSelectionClear", (() => {
                            r.get() && (xd(g), xd(h), r.set(!1)), s.clear(), a.clear()
                        })))
                    },
                    gR = (e, t, o) => {
                        var n;
                        const r = null !== (n = t.delimiter) && void 0 !== n ? n : "";
                        return {
                            dom: {
                                tag: "div",
                                classes: ["tox-statusbar__path"],
                                attributes: {
                                    role: "navigation"
                                }
                            },
                            behaviours: gl([Th.config({
                                mode: "flow",
                                selector: "div[role=button]"
                            }), Sm.config({
                                disabled: o.isDisabled
                            }), ry(), Nx.config({}), Hh.config({}), Ih("elementPathEvents", [Vs(((t, n) => {
                                e.shortcuts.add("alt+F11", "focus statusbar elementpath", (() => Th.focusIn(t))), e.on("NodeChange", (n => {
                                    const s = (t => {
                                            const o = [];
                                            let n = t.length;
                                            for (; n-- > 0;) {
                                                const s = t[n];
                                                if (1 === s.nodeType && "BR" !== (r = s).nodeName && !r.getAttribute("data-mce-bogus") && "bookmark" !== r.getAttribute("data-mce-type")) {
                                                    const t = Yy(e, s);
                                                    if (t.isDefaultPrevented() || o.push({
                                                            name: t.name,
                                                            element: s
                                                        }), t.isPropagationStopped()) break
                                                }
                                            }
                                            var r;
                                            return o
                                        })(n.parents),
                                        a = s.length > 0 ? j(s, ((t, n, s) => {
                                            const a = ((t, n, r) => Ap.sketch({
                                                dom: {
                                                    tag: "div",
                                                    classes: ["tox-statusbar__path-item"],
                                                    attributes: {
                                                        "data-index": r,
                                                        "aria-level": r + 1
                                                    }
                                                },
                                                components: [Wa(t)],
                                                action: t => {
                                                    e.focus(), e.selection.select(n), e.nodeChanged()
                                                },
                                                buttonBehaviours: gl([sy(o.isDisabled), ry()])
                                            }))(n.name, n.element, s);
                                            return 0 === s ? t.concat([a]) : t.concat([{
                                                dom: {
                                                    tag: "div",
                                                    classes: ["tox-statusbar__path-divider"],
                                                    attributes: {
                                                        "aria-hidden": !0
                                                    }
                                                },
                                                components: [Wa(` ${r} `)]
                                            }, a])
                                        }), []) : [];
                                    Hh.set(t, a)
                                }))
                            }))])]),
                            components: []
                        }
                    };
                var hR;
                ! function(e) {
                    e[e.None = 0] = "None", e[e.Both = 1] = "Both", e[e.Vertical = 2] = "Vertical"
                }(hR || (hR = {}));
                const pR = (e, t, o) => {
                        const n = Be(e.getContainer()),
                            r = ((e, t, o, n, r) => {
                                const s = {
                                    height: xM(n + t.top, tf(e), nf(e))
                                };
                                return o === hR.Both && (s.width = xM(r + t.left, ef(e), of (e))), s
                            })(e, t, o, Pt(n), $t(n));
                        le(r, ((e, t) => {
                            p(e) && Ot(n, t, wM(e))
                        })), (e => {
                            e.dispatch("ResizeEditor")
                        })(e)
                    },
                    fR = (e, t, o, n) => {
                        const r = Vt(20 * o, 20 * n);
                        return pR(e, r, t), A.some(!0)
                    },
                    vR = (e, t) => ({
                        dom: {
                            tag: "div",
                            classes: ["tox-statusbar"]
                        },
                        components: (() => {
                            const o = (() => {
                                    const o = [];
                                    return Tf(e) && o.push(gR(e, {}, t)), e.hasPlugin("wordcount") && o.push(((e, t) => {
                                        const o = (e, o, n) => Hh.set(e, [Wa(t.translate(["{0} " + n, o[n]]))]);
                                        return Ap.sketch({
                                            dom: {
                                                tag: "button",
                                                classes: ["tox-statusbar__wordcount"]
                                            },
                                            components: [],
                                            buttonBehaviours: gl([sy(t.isDisabled), ry(), Nx.config({}), Hh.config({}), ou.config({
                                                store: {
                                                    mode: "memory",
                                                    initialValue: {
                                                        mode: "words",
                                                        count: {
                                                            words: 0,
                                                            characters: 0
                                                        }
                                                    }
                                                }
                                            }), Ih("wordcount-events", [js((e => {
                                                const t = ou.getValue(e),
                                                    n = "words" === t.mode ? "characters" : "words";
                                                ou.setValue(e, {
                                                    mode: n,
                                                    count: t.count
                                                }), o(e, t.count, n)
                                            })), Vs((t => {
                                                e.on("wordCountUpdate", (e => {
                                                    const {
                                                        mode: n
                                                    } = ou.getValue(t);
                                                    ou.setValue(t, {
                                                        mode: n,
                                                        count: e.wordCount
                                                    }), o(t, e.wordCount, n)
                                                }))
                                            }))])]),
                                            eventOrder: {
                                                [ns()]: ["disabling", "alloy.base.behaviour", "wordcount-events"]
                                            }
                                        })
                                    })(e, t)), Ef(e) && o.push({
                                        dom: {
                                            tag: "span",
                                            classes: ["tox-statusbar__branding"]
                                        },
                                        components: [{
                                            dom: {
                                                tag: "a",
                                                attributes: {
                                                    href: "https://www.tiny.cloud/powered-by-tiny?utm_campaign=editor_referral&utm_medium=poweredby&utm_source=tinymce&utm_content=v6",
                                                    rel: "noopener",
                                                    target: "_blank",
                                                    "aria-label": Np.translate(["Powered by {0}", "Tiny"])
                                                },
                                                innerHtml: '<svg width="50px" height="16px" viewBox="0 0 50 16" xmlns="http://www.w3.org/2000/svg">\n  <path fill-rule="evenodd" clip-rule="evenodd" d="M10.143 0c2.608.015 5.186 2.178 5.186 5.331 0 0 .077 3.812-.084 4.87-.361 2.41-2.164 4.074-4.65 4.496-1.453.284-2.523.49-3.212.623-.373.071-.634.122-.785.152-.184.038-.997.145-1.35.145-2.732 0-5.21-2.04-5.248-5.33 0 0 0-3.514.03-4.442.093-2.4 1.758-4.342 4.926-4.963 0 0 3.875-.752 4.036-.782.368-.07.775-.1 1.15-.1Zm1.826 2.8L5.83 3.989v2.393l-2.455.475v5.968l6.137-1.189V9.243l2.456-.476V2.8ZM5.83 6.382l3.682-.713v3.574l-3.682.713V6.382Zm27.173-1.64-.084-1.066h-2.226v9.132h2.456V7.743c-.008-1.151.998-2.064 2.149-2.072 1.15-.008 1.987.92 1.995 2.072v5.065h2.455V7.359c-.015-2.18-1.657-3.929-3.837-3.913a3.993 3.993 0 0 0-2.908 1.296Zm-6.3-4.266L29.16 0v2.387l-2.456.475V.476Zm0 3.2v9.132h2.456V3.676h-2.456Zm18.179 11.787L49.11 3.676H46.58l-1.612 4.527-.46 1.382-.384-1.382-1.611-4.527H39.98l3.3 9.132L42.15 16l2.732-.537ZM22.867 9.738c0 .752.568 1.075.921 1.075.353 0 .668-.047.998-.154l.537 1.765c-.23.154-.92.537-2.225.537-1.305 0-2.655-.997-2.686-2.686a136.877 136.877 0 0 1 0-4.374H18.8V3.676h1.612v-1.98l2.455-.476v2.456h2.302V5.9h-2.302v3.837Z"/>\n</svg>\n'.trim()
                                            },
                                            behaviours: gl([Zh.config({})])
                                        }]
                                    }), o.length > 0 ? [{
                                        dom: {
                                            tag: "div",
                                            classes: ["tox-statusbar__text-container"]
                                        },
                                        components: o
                                    }] : []
                                })(),
                                n = ((e, t) => {
                                    const o = (e => {
                                        const t = Af(e);
                                        return !1 === t ? hR.None : "both" === t ? hR.Both : hR.Vertical
                                    })(e);
                                    return o === hR.None ? A.none() : A.some(Fp("resize-handle", {
                                        tag: "div",
                                        classes: ["tox-statusbar__resize-handle"],
                                        attributes: {
                                            title: t.translate("Resize")
                                        },
                                        behaviours: [lR.config({
                                            mode: "mouse",
                                            repositionTarget: !1,
                                            onDrag: (t, n, r) => pR(e, r, o),
                                            blockerClass: "tox-blocker"
                                        }), Th.config({
                                            mode: "special",
                                            onLeft: () => fR(e, o, -1, 0),
                                            onRight: () => fR(e, o, 1, 0),
                                            onUp: () => fR(e, o, 0, -1),
                                            onDown: () => fR(e, o, 0, 1)
                                        }), Nx.config({}), Zh.config({})]
                                    }, t.icons))
                                })(e, t);
                            return o.concat(n.toArray())
                        })()
                    }),
                    bR = (e, t) => t.get().getOrDie(`UI for ${e} has not been rendered`),
                    yR = e => {
                        const t = e.inline,
                            o = t ? OM : bM,
                            n = Wf(e) ? TT : QO,
                            r = (() => {
                                const e = Zl(),
                                    t = Zl(),
                                    o = Zl();
                                return {
                                    dialogUi: e,
                                    popupUi: t,
                                    mainUi: o,
                                    getUiMotherships: () => [...e.get().map((e => e.mothership)).toArray()],
                                    setupDialogUi: t => {
                                        e.set(t)
                                    },
                                    lazyGetInOuterOrDie: (e, t) => () => o.get().bind((e => t(e.outerContainer))).getOrDie(`Could not find ${e} element in OuterContainer`)
                                }
                            })(),
                            s = Zl(),
                            a = Zl(),
                            i = Oo().deviceType.isTouch() ? ["tox-platform-touch"] : [],
                            l = Ff(e),
                            c = df(e),
                            d = Mp({
                                dom: {
                                    tag: "div",
                                    classes: ["tox-anchorbar"]
                                }
                            }),
                            u = () => r.mainUi.get().map((e => e.outerContainer)).bind(gA.getHeader),
                            m = r.lazyGetInOuterOrDie("anchor bar", d.getOpt),
                            g = r.lazyGetInOuterOrDie("toolbar", gA.getToolbar),
                            h = r.lazyGetInOuterOrDie("throbber", gA.getThrobber),
                            p = ((e, t, o) => {
                                const n = wr(!1),
                                    r = (e => {
                                        const t = wr(Ff(e) ? "bottom" : "top");
                                        return {
                                            isPositionedAtTop: () => "top" === t.get(),
                                            getDockingMode: t.get,
                                            setDockingMode: t.set
                                        }
                                    })(t),
                                    s = {
                                        icons: () => t.ui.registry.getAll().icons,
                                        menuItems: () => t.ui.registry.getAll().menuItems,
                                        translate: Np.translate,
                                        isDisabled: () => t.mode.isReadOnly() || !t.ui.isEnabled(),
                                        getOption: t.options.get
                                    },
                                    a = zO(t),
                                    i = (e => {
                                        const t = t => () => e.formatter.match(t),
                                            o = t => () => {
                                                const o = e.formatter.get(t);
                                                return void 0 !== o ? A.some({
                                                    tag: o.length > 0 && (o[0].inline || o[0].block) || "div",
                                                    styles: e.dom.parseStyle(e.formatter.getCssText(t))
                                                }) : A.none()
                                            },
                                            n = wr([]),
                                            r = wr([]),
                                            s = wr(!1);
                                        return e.on("PreInit", (r => {
                                            const s = mO(e),
                                                a = hO(e, s, t, o);
                                            n.set(a)
                                        })), e.on("addStyleModifications", (n => {
                                            const a = hO(e, n.items, t, o);
                                            r.set(a), s.set(n.replace)
                                        })), {
                                            getData: () => {
                                                const e = s.get() ? [] : n.get(),
                                                    t = r.get();
                                                return e.concat(t)
                                            }
                                        }
                                    })(t),
                                    l = (e => ({
                                        colorPicker: nO(e),
                                        hasCustomColors: rO(e),
                                        getColors: sO(e),
                                        getColorCols: aO(e)
                                    }))(t),
                                    c = (e => ({
                                        isDraggableModal: iO(e)
                                    }))(t),
                                    d = {
                                        shared: {
                                            providers: s,
                                            anchors: oO(t, o, r.isPositionedAtTop),
                                            header: r
                                        },
                                        urlinput: a,
                                        styles: i,
                                        colorinput: l,
                                        dialog: c,
                                        isContextMenuOpen: () => n.get(),
                                        setContextMenuState: e => n.set(e)
                                    },
                                    u = { ...d,
                                        shared: { ...d.shared,
                                            interpreter: e => N_(e, {}, u),
                                            getSink: e.popup
                                        }
                                    },
                                    m = { ...d,
                                        shared: { ...d.shared,
                                            interpreter: e => N_(e, {}, m),
                                            getSink: e.dialog
                                        }
                                    };
                                return {
                                    popup: u,
                                    dialog: m
                                }
                            })({
                                popup: () => Xo.fromOption(r.popupUi.get().map((e => e.sink)), "(popup) UI has not been rendered"),
                                dialog: () => Xo.fromOption(r.dialogUi.get().map((e => e.sink)), "UI has not been rendered")
                            }, e, m),
                            f = w,
                            v = () => {
                                const o = (() => {
                                        const t = {
                                                attributes: {
                                                    [lc]: l ? ic.BottomToTop : ic.TopToBottom
                                                }
                                            },
                                            o = gA.parts.menubar({
                                                dom: {
                                                    tag: "div",
                                                    classes: ["tox-menubar"]
                                                },
                                                backstage: p.popup,
                                                onEscape: () => {
                                                    e.focus()
                                                }
                                            }),
                                            n = gA.parts.toolbar({
                                                dom: {
                                                    tag: "div",
                                                    classes: ["tox-toolbar"]
                                                },
                                                getSink: p.popup.shared.getSink,
                                                providers: p.popup.shared.providers,
                                                onEscape: () => {
                                                    e.focus()
                                                },
                                                onToolbarToggled: t => {
                                                    ((e, t) => {
                                                        e.dispatch("ToggleToolbarDrawer", {
                                                            state: t
                                                        })
                                                    })(e, t)
                                                },
                                                type: c,
                                                lazyToolbar: g,
                                                lazyHeader: () => u().getOrDie("Could not find header element"),
                                                ...t
                                            }),
                                            r = gA.parts["multiple-toolbar"]({
                                                dom: {
                                                    tag: "div",
                                                    classes: ["tox-toolbar-overlord"]
                                                },
                                                providers: p.popup.shared.providers,
                                                onEscape: () => {
                                                    e.focus()
                                                },
                                                type: c
                                            }),
                                            s = zf(e),
                                            a = If(e),
                                            i = Bf(e),
                                            m = Rf(e),
                                            h = gA.parts.promotion({
                                                dom: {
                                                    tag: "div",
                                                    classes: ["tox-promotion"]
                                                }
                                            }),
                                            f = s || a || i,
                                            v = m ? [h, o] : [o];
                                        return gA.parts.header({
                                            dom: {
                                                tag: "div",
                                                classes: ["tox-editor-header"].concat(f ? [] : ["tox-editor-header--empty"]),
                                                ...t
                                            },
                                            components: q([i ? v : [], s ? [r] : a ? [n] : [], Zf(e) ? [] : [d.asSpec()]]),
                                            sticky: Wf(e),
                                            editor: e,
                                            sharedBackstage: p.popup.shared
                                        })
                                    })(),
                                    n = {
                                        dom: {
                                            tag: "div",
                                            classes: ["tox-sidebar-wrap"]
                                        },
                                        components: [gA.parts.socket({
                                            dom: {
                                                tag: "div",
                                                classes: ["tox-edit-area"]
                                            }
                                        }), gA.parts.sidebar({
                                            dom: {
                                                tag: "div",
                                                classes: ["tox-sidebar"]
                                            }
                                        })]
                                    },
                                    r = gA.parts.throbber({
                                        dom: {
                                            tag: "div",
                                            classes: ["tox-throbber"]
                                        },
                                        backstage: p.popup
                                    }),
                                    a = gA.parts.viewWrapper({
                                        backstage: p.popup
                                    }),
                                    m = Of(e) && !t ? A.some(vR(e, p.popup.shared.providers)) : A.none(),
                                    h = q([l ? [] : [o], t ? [] : [n], l ? [o] : []]),
                                    f = gA.parts.editorContainer({
                                        components: q([h, t ? [] : m.toArray()])
                                    }),
                                    v = jf(e),
                                    b = {
                                        role: "application",
                                        ...Np.isRtl() ? {
                                            dir: "rtl"
                                        } : {},
                                        ...v ? {
                                            "aria-hidden": "true"
                                        } : {}
                                    },
                                    y = Ka(gA.sketch({
                                        dom: {
                                            tag: "div",
                                            classes: ["tox", "tox-tinymce"].concat(t ? ["tox-tinymce-inline"] : []).concat(l ? ["tox-tinymce--toolbar-bottom"] : []).concat(i),
                                            styles: {
                                                visibility: "hidden",
                                                ...v ? {
                                                    opacity: "0",
                                                    border: "0"
                                                } : {}
                                            },
                                            attributes: b
                                        },
                                        components: [f, ...t ? [] : [a], r],
                                        behaviours: gl([ry(), Sm.config({
                                            disableClass: "tox-tinymce--disabled"
                                        }), Th.config({
                                            mode: "cyclic",
                                            selector: ".tox-menubar, .tox-toolbar, .tox-toolbar__primary, .tox-toolbar__overflow--open, .tox-sidebar__overflow--open, .tox-statusbar__path, .tox-statusbar__wordcount, .tox-statusbar__branding a, .tox-statusbar__resize-handle"
                                        })])
                                    })),
                                    w = _x(y);
                                return s.set(w), {
                                    mothership: w,
                                    outerContainer: y
                                }
                            },
                            b = t => {
                                const o = wM((e => {
                                        const t = (e => {
                                            const t = Jp(e),
                                                o = tf(e),
                                                n = nf(e);
                                            return yM(t).map((e => xM(e, o, n)))
                                        })(e);
                                        return t.getOr(Jp(e))
                                    })(e)),
                                    n = wM((e => CM(e).getOr(Qp(e)))(e));
                                return e.inline || (Dt("div", "width", n) && Ot(t.element, "width", n), Dt("div", "height", o) ? Ot(t.element, "height", o) : Ot(t.element, "height", "400px")), o
                            };
                        return {
                            popups: {
                                backstage: p.popup,
                                getMothership: () => bR("popups", a)
                            },
                            dialogs: {
                                backstage: p.dialog,
                                getMothership: () => bR("dialogs", a)
                            },
                            renderUI: () => {
                                const t = v(),
                                    s = (() => {
                                        const t = Uf(e),
                                            o = Ge(pt(), t) && "grid" === At(t, "display"),
                                            r = {
                                                dom: {
                                                    tag: "div",
                                                    classes: ["tox", "tox-silver-sink", "tox-tinymce-aux"].concat(i),
                                                    attributes: { ...Np.isRtl() ? {
                                                            dir: "rtl"
                                                        } : {}
                                                    }
                                                },
                                                behaviours: gl([ud.config({
                                                    useFixed: () => n.isDocked(u)
                                                })])
                                            },
                                            s = {
                                                dom: {
                                                    styles: {
                                                        width: document.body.clientWidth + "px"
                                                    }
                                                },
                                                events: Ms([Ds(gs(), (e => {
                                                    Ot(e.element, "width", document.body.clientWidth + "px")
                                                }))])
                                            },
                                            l = Ka(cn(r, o ? s : {})),
                                            c = _x(l);
                                        return a.set(c), {
                                            sink: l,
                                            mothership: c
                                        }
                                    })(),
                                    l = f(s);
                                r.dialogUi.set(s), r.popupUi.set(l), r.mainUi.set(t);
                                return (t => {
                                    const {
                                        mainUi: r,
                                        popupUi: s,
                                        uiMotherships: a
                                    } = t;
                                    ce(uf(e), ((t, o) => {
                                        e.ui.registry.addGroupToolbarButton(o, t)
                                    }));
                                    const {
                                        buttons: i,
                                        menuItems: l,
                                        contextToolbars: d,
                                        sidebars: m,
                                        views: g
                                    } = e.ui.registry.getAll(), f = Pf(e), v = {
                                        menuItems: l,
                                        menus: $f(e),
                                        menubar: vf(e),
                                        toolbar: f.getOrThunk((() => bf(e))),
                                        allowToolbarGroups: c === Up.floating,
                                        buttons: i,
                                        sidebar: m,
                                        views: g
                                    };
                                    var y;
                                    y = r.outerContainer, e.addShortcut("alt+F9", "focus menubar", (() => {
                                        gA.focusMenubar(y)
                                    })), e.addShortcut("alt+F10", "focus toolbar", (() => {
                                        gA.focusToolbar(y)
                                    })), e.addCommand("ToggleToolbarDrawer", (() => {
                                        gA.toggleToolbarDrawer(y)
                                    })), e.addQueryStateHandler("ToggleToolbarDrawer", (() => gA.isToolbarDrawerToggled(y))), ((e, t, o) => {
                                        const n = (e, n) => {
                                                F([t, ...o], (t => {
                                                    t.broadcastEvent(e, n)
                                                }))
                                            },
                                            r = (e, n) => {
                                                F([t, ...o], (t => {
                                                    t.broadcastOn([e], n)
                                                }))
                                            },
                                            s = e => r(Id(), {
                                                target: e.target
                                            }),
                                            a = Vo(),
                                            i = jl(a, "touchstart", s),
                                            l = jl(a, "touchmove", (e => n(ds(), e))),
                                            c = jl(a, "touchend", (e => n(us(), e))),
                                            d = jl(a, "mousedown", s),
                                            u = jl(a, "mouseup", (e => {
                                                0 === e.raw.button && r(zd(), {
                                                    target: e.target
                                                })
                                            })),
                                            m = e => r(Id(), {
                                                target: Be(e.target)
                                            }),
                                            g = e => {
                                                0 === e.button && r(zd(), {
                                                    target: Be(e.target)
                                                })
                                            },
                                            h = () => {
                                                F(e.editorManager.get(), (t => {
                                                    e !== t && t.dispatch("DismissPopups", {
                                                        relatedTarget: e
                                                    })
                                                }))
                                            },
                                            p = e => n(ms(), $l(e)),
                                            f = e => {
                                                r(Pd(), {}), n(gs(), $l(e))
                                            },
                                            v = () => r(Pd(), {}),
                                            b = t => {
                                                t.state && r(Id(), {
                                                    target: Be(e.getContainer())
                                                })
                                            },
                                            y = e => {
                                                r(Id(), {
                                                    target: Be(e.relatedTarget.getContainer())
                                                })
                                            };
                                        e.on("PostRender", (() => {
                                            e.on("click", m), e.on("tap", m), e.on("mouseup", g), e.on("mousedown", h), e.on("ScrollWindow", p), e.on("ResizeWindow", f), e.on("ResizeEditor", v), e.on("AfterProgressState", b), e.on("DismissPopups", y)
                                        })), e.on("remove", (() => {
                                            e.off("click", m), e.off("tap", m), e.off("mouseup", g), e.off("mousedown", h), e.off("ScrollWindow", p), e.off("ResizeWindow", f), e.off("ResizeEditor", v), e.off("AfterProgressState", b), e.off("DismissPopups", y), d.unbind(), i.unbind(), l.unbind(), c.unbind(), u.unbind()
                                        })), e.on("detach", (() => {
                                            F([t, ...o], _d), F([t, ...o], (e => e.destroy()))
                                        }))
                                    })(e, r.mothership, a), n.setup(e, p.popup.shared, u), oN(e, p.popup), SN(e, p.popup.shared.getSink, p.popup), (e => {
                                        const {
                                            sidebars: t
                                        } = e.ui.registry.getAll();
                                        F(ae(t), (o => {
                                            const n = t[o],
                                                r = () => we(A.from(e.queryCommandValue("ToggleSidebar")), o);
                                            e.ui.registry.addToggleButton(o, {
                                                icon: n.icon,
                                                tooltip: n.tooltip,
                                                onAction: t => {
                                                    e.execCommand("ToggleSidebar", !1, o), t.setActive(r())
                                                },
                                                onSetup: t => {
                                                    t.setActive(r());
                                                    const o = () => t.setActive(r());
                                                    return e.on("ToggleSidebar", o), () => {
                                                        e.off("ToggleSidebar", o)
                                                    }
                                                }
                                            })
                                        }))
                                    })(e), hE(e, h, p.popup.shared), WM(e, d, s.sink, {
                                        backstage: p.popup
                                    }), mR(e, s.sink);
                                    const w = {
                                        targetNode: e.getElement(),
                                        height: b(r.outerContainer)
                                    };
                                    return o.render(e, t, v, p.popup, w)
                                })({
                                    popupUi: l,
                                    dialogUi: s,
                                    mainUi: t,
                                    uiMotherships: r.getUiMotherships()
                                })
                            }
                        }
                    },
                    wR = y([Gn("lazySink"), nr("dragBlockClass"), vr("getBounds", Go), ur("useTabstopAt", T), ur("eventOrder", {}), nu("modalBehaviours", [Th]), Ci("onExecute"), ki("onEscape")]),
                    xR = {
                        sketch: w
                    },
                    CR = y([Ru({
                        name: "draghandle",
                        overrides: (e, t) => ({
                            behaviours: gl([lR.config({
                                mode: "mouse",
                                getTarget: e => oi(e, '[role="dialog"]').getOr(e),
                                blockerClass: e.dragBlockClass.getOrDie(new Error("The drag blocker class was not specified for a dialog with a drag handle: \n" + JSON.stringify(t, null, 2)).message),
                                getBounds: e.getDragBounds
                            })])
                        })
                    }), Mu({
                        schema: [Gn("dom")],
                        name: "title"
                    }), Mu({
                        factory: xR,
                        schema: [Gn("dom")],
                        name: "close"
                    }), Mu({
                        factory: xR,
                        schema: [Gn("dom")],
                        name: "body"
                    }), Ru({
                        factory: xR,
                        schema: [Gn("dom")],
                        name: "footer"
                    }), Nu({
                        factory: {
                            sketch: (e, t) => ({ ...e,
                                dom: t.dom,
                                components: t.components
                            })
                        },
                        schema: [ur("dom", {
                            tag: "div",
                            styles: {
                                position: "fixed",
                                left: "0px",
                                top: "0px",
                                right: "0px",
                                bottom: "0px"
                            }
                        }), ur("components", [])],
                        name: "blocker"
                    })]),
                    SR = sm({
                        name: "ModalDialog",
                        configFields: wR(),
                        partFields: CR(),
                        factory: (e, t, o, n) => {
                            const r = Zl(),
                                s = Qs("modal-events"),
                                a = { ...e.eventOrder,
                                    [hs()]: [s].concat(e.eventOrder["alloy.system.attached"] || [])
                                };
                            return {
                                uid: e.uid,
                                dom: e.dom,
                                components: t,
                                apis: {
                                    show: t => {
                                        r.set(t);
                                        const o = e.lazySink(t).getOrDie(),
                                            s = n.blocker(),
                                            a = o.getSystem().build({ ...s,
                                                components: s.components.concat([Ya(t)]),
                                                behaviours: gl([Zh.config({}), Ih("dialog-blocker-events", [Fs(Fr(), (() => {
                                                    Th.focusIn(t)
                                                }))])])
                                            });
                                        bd(o, a), Th.focusIn(t)
                                    },
                                    hide: e => {
                                        r.clear(), et(e.element).each((t => {
                                            e.getSystem().getByDom(t).each((e => {
                                                xd(e)
                                            }))
                                        }))
                                    },
                                    getBody: t => Wu(t, e, "body"),
                                    getFooter: t => Wu(t, e, "footer"),
                                    setIdle: e => {
                                        uE.unblock(e)
                                    },
                                    setBusy: (e, t) => {
                                        uE.block(e, t)
                                    }
                                },
                                eventOrder: a,
                                domModification: {
                                    attributes: {
                                        role: "dialog",
                                        "aria-modal": "true"
                                    }
                                },
                                behaviours: su(e.modalBehaviours, [Hh.config({}), Th.config({
                                    mode: "cyclic",
                                    onEnter: e.onExecute,
                                    onEscape: e.onEscape,
                                    useTabstopAt: e.useTabstopAt
                                }), uE.config({
                                    getRoot: r.get
                                }), Ih(s, [Vs((t => {
                                    ((e, t) => {
                                        const o = xt(e, "id").fold((() => {
                                            const e = Qs("dialog-label");
                                            return bt(t, "id", e), e
                                        }), w);
                                        bt(e, "aria-labelledby", o)
                                    })(t.element, Wu(t, e, "title").element), ((e, t) => {
                                        const o = A.from(wt(e, "id")).fold((() => {
                                            const e = Qs("dialog-describe");
                                            return bt(t, "id", e), e
                                        }), w);
                                        bt(e, "aria-describedby", o)
                                    })(t.element, Wu(t, e, "body").element)
                                }))])])
                            }
                        },
                        apis: {
                            show: (e, t) => {
                                e.show(t)
                            },
                            hide: (e, t) => {
                                e.hide(t)
                            },
                            getBody: (e, t) => e.getBody(t),
                            getFooter: (e, t) => e.getFooter(t),
                            setBusy: (e, t, o) => {
                                e.setBusy(t, o)
                            },
                            setIdle: (e, t) => {
                                e.setIdle(t)
                            }
                        }
                    }),
                    kR = kn([Pv, zv].concat(Bb)),
                    _R = Dn,
                    OR = [ub("button"), Jv, pr("align", "end", ["start", "end"]), ab, sb, ir("buttonType", ["primary", "secondary"])],
                    TR = [...OR, Vv],
                    ER = [Jn("type", ["submit", "cancel", "custom"]), ...TR],
                    AR = [Jn("type", ["menu"]), Xv, Qv, Jv, or("items", kR), ...OR],
                    MR = jn("type", {
                        submit: ER,
                        cancel: ER,
                        custom: ER,
                        menu: AR
                    }),
                    NR = [Pv, Vv, Jn("level", ["info", "warn", "error", "success"]), Uv, ur("url", "")],
                    RR = kn(NR),
                    DR = [Pv, Vv, sb, ub("button"), Jv, rb, ir("buttonType", ["primary", "secondary", "toolbar"]), ab],
                    BR = kn(DR),
                    LR = [Pv, zv],
                    HR = LR.concat([eb]),
                    IR = LR.concat([Fv, sb]),
                    PR = kn(IR),
                    zR = Dn,
                    FR = HR.concat([ib("auto")]),
                    VR = kn(FR),
                    ZR = En([jv, Vv, Uv]),
                    UR = HR.concat([hr("storageKey", "default")]),
                    jR = kn(UR),
                    WR = Rn,
                    $R = kn(HR),
                    qR = Rn,
                    GR = LR.concat([hr("tag", "textarea"), Xn("scriptId"), Xn("scriptUrl"), mr("settings", void 0, Hn)]),
                    KR = LR.concat([hr("tag", "textarea"), Qn("init")]),
                    YR = Pn((e => Fn("customeditor.old", Sn(KR), e).orThunk((() => Fn("customeditor.new", Sn(GR), e))))),
                    XR = Rn,
                    JR = kn(HR),
                    QR = _n(bn),
                    eD = e => [Pv, Yn("columns"), e],
                    tD = [Pv, Xn("html"), pr("presets", "presentation", ["presentation", "document"])],
                    oD = kn(tD),
                    nD = HR.concat([fr("sandboxed", !0), fr("transparent", !0)]),
                    rD = kn(nD),
                    sD = Rn,
                    aD = kn(LR.concat([ar("height")])),
                    iD = kn([Xn("url"), sr("zoom"), sr("cachedWidth"), sr("cachedHeight")]),
                    lD = HR.concat([ar("inputMode"), ar("placeholder"), fr("maximized", !1), sb]),
                    cD = kn(lD),
                    dD = Rn,
                    uD = e => [Pv, Fv, e],
                    mD = [Vv, jv],
                    gD = [Vv, or("items", ((e, t) => {
                        const o = Gt(t);
                        return {
                            extract: (e, t) => o().extract(e, t),
                            toString: () => o().toString()
                        }
                    })(0, (() => hD)))],
                    hD = On([kn(mD), kn(gD)]),
                    pD = HR.concat([or("items", hD), sb]),
                    fD = kn(pD),
                    vD = Rn,
                    bD = HR.concat([tr("items", [Vv, jv]), gr("size", 1), sb]),
                    yD = kn(bD),
                    wD = Rn,
                    xD = HR.concat([fr("constrain", !0), sb]),
                    CD = kn(xD),
                    SD = kn([Xn("width"), Xn("height")]),
                    kD = LR.concat([Fv, gr("min", 0), gr("max", 0)]),
                    _D = kn(kD),
                    OD = Nn,
                    TD = [Pv, or("header", Rn), or("cells", _n(Rn))],
                    ED = kn(TD),
                    AD = HR.concat([ar("placeholder"), fr("maximized", !1), sb]),
                    MD = kn(AD),
                    ND = Rn,
                    RD = HR.concat([pr("filetype", "file", ["image", "media", "file"]), sb]),
                    DD = kn(RD),
                    BD = kn([jv, lb]),
                    LD = e => Wn("items", "items", {
                        tag: "required",
                        process: {}
                    }, _n(Pn((t => Fn(`Checking item of ${e}`, HD, t).fold((e => Xo.error(Un(e))), (e => Xo.value(e))))))),
                    HD = xn((() => {
                        return In("type", {
                            alertbanner: RR,
                            bar: kn((e = LD("bar"), [Pv, e])),
                            button: BR,
                            checkbox: PR,
                            colorinput: jR,
                            colorpicker: $R,
                            dropzone: JR,
                            grid: kn(eD(LD("grid"))),
                            iframe: rD,
                            input: cD,
                            listbox: fD,
                            selectbox: yD,
                            sizeinput: CD,
                            slider: _D,
                            textarea: MD,
                            urlinput: DD,
                            customeditor: YR,
                            htmlpanel: oD,
                            imagepreview: aD,
                            collection: VR,
                            label: kn(uD(LD("label"))),
                            table: ED,
                            panel: PD
                        });
                        var e
                    })),
                    ID = [Pv, ur("classes", []), or("items", HD)],
                    PD = kn(ID),
                    zD = [ub("tab"), Zv, or("items", HD)],
                    FD = [Pv, tr("tabs", zD)],
                    VD = kn(FD),
                    ZD = TR,
                    UD = MR,
                    jD = kn([Xn("title"), Kn("body", In("type", {
                        panel: PD,
                        tabpanel: VD
                    })), hr("size", "normal"), or("buttons", UD), ur("initialData", {}), vr("onAction", v), vr("onChange", v), vr("onSubmit", v), vr("onClose", v), vr("onCancel", v), vr("onTabChange", v)]),
                    WD = kn([Jn("type", ["cancel", "custom"]), ...ZD]),
                    $D = kn([Xn("title"), Xn("url"), sr("height"), sr("width"), cr("buttons", WD), vr("onAction", v), vr("onCancel", v), vr("onClose", v), vr("onMessage", v)]),
                    qD = e => a(e) ? [e].concat(G(fe(e), qD)) : l(e) ? G(e, qD) : [],
                    GD = e => s(e.type) && s(e.name),
                    KD = {
                        checkbox: zR,
                        colorinput: WR,
                        colorpicker: qR,
                        dropzone: QR,
                        input: dD,
                        iframe: sD,
                        imagepreview: iD,
                        selectbox: wD,
                        sizeinput: SD,
                        slider: OD,
                        listbox: vD,
                        size: SD,
                        textarea: ND,
                        urlinput: BD,
                        customeditor: XR,
                        collection: ZR,
                        togglemenuitem: _R
                    },
                    YD = e => {
                        const t = (e => Z(qD(e), GD))(e),
                            o = G(t, (e => (e => A.from(KD[e.type]))(e).fold((() => []), (t => [Kn(e.name, t)]))));
                        return kn(o)
                    },
                    XD = e => {
                        var t;
                        return {
                            internalDialog: Vn(Fn("dialog", jD, e)),
                            dataValidator: YD(e),
                            initialData: null !== (t = e.initialData) && void 0 !== t ? t : {}
                        }
                    },
                    JD = {
                        open: (e, t) => {
                            const o = XD(t);
                            return e(o.internalDialog, o.initialData, o.dataValidator)
                        },
                        openUrl: (e, t) => e(Vn(Fn("dialog", $D, t))),
                        redial: e => XD(e)
                    },
                    QD = e => {
                        const t = [],
                            o = {};
                        return le(e, ((e, n) => {
                            e.fold((() => {
                                t.push(n)
                            }), (e => {
                                o[n] = e
                            }))
                        })), t.length > 0 ? Xo.error(t) : Xo.value(o)
                    },
                    eB = (e, t, o) => {
                        const n = Mp($S.sketch((n => ({
                            dom: {
                                tag: "div",
                                classes: ["tox-form"].concat(e.classes)
                            },
                            components: z(e.items, (e => A_(n, e, t, o)))
                        }))));
                        return {
                            dom: {
                                tag: "div",
                                classes: ["tox-dialog__body"]
                            },
                            components: [{
                                dom: {
                                    tag: "div",
                                    classes: ["tox-dialog__body-content"]
                                },
                                components: [n.asSpec()]
                            }],
                            behaviours: gl([Th.config({
                                mode: "acyclic",
                                useTabstopAt: S(vk)
                            }), (r = n, cm.config({
                                find: r.getOpt
                            })), rk(n, {
                                postprocess: e => QD(e).fold((e => (console.error(e), {})), w)
                            })])
                        };
                        var r
                    },
                    tB = rm({
                        name: "TabButton",
                        configFields: [ur("uid", void 0), Gn("value"), Wn("dom", "dom", gn((() => ({
                            attributes: {
                                role: "tab",
                                id: Qs("aria"),
                                "aria-selected": "false"
                            }
                        }))), An()), nr("action"), ur("domModification", {}), nu("tabButtonBehaviours", [Zh, Th, ou]), Gn("view")],
                        factory: (e, t) => ({
                            uid: e.uid,
                            dom: e.dom,
                            components: e.components,
                            events: Jh(e.action),
                            behaviours: su(e.tabButtonBehaviours, [Zh.config({}), Th.config({
                                mode: "execution",
                                useSpace: !0,
                                useEnter: !0
                            }), ou.config({
                                store: {
                                    mode: "memory",
                                    initialValue: e.value
                                }
                            })]),
                            domModification: e.domModification
                        })
                    }),
                    oB = y([Gn("tabs"), Gn("dom"), ur("clickToDismiss", !1), nu("tabbarBehaviours", [Dm, Th]), yi(["tabClass", "selectedClass"])]),
                    nB = Du({
                        factory: tB,
                        name: "tabs",
                        unit: "tab",
                        overrides: e => {
                            const t = (e, t) => {
                                    Dm.dehighlight(e, t), _s(e, xs(), {
                                        tabbar: e,
                                        button: t
                                    })
                                },
                                o = (e, t) => {
                                    Dm.highlight(e, t), _s(e, ws(), {
                                        tabbar: e,
                                        button: t
                                    })
                                };
                            return {
                                action: n => {
                                    const r = n.getSystem().getByUid(e.uid).getOrDie(),
                                        s = Dm.isHighlighted(r, n);
                                    (s && e.clickToDismiss ? t : s ? v : o)(r, n)
                                },
                                domModification: {
                                    classes: [e.markers.tabClass]
                                }
                            }
                        }
                    }),
                    rB = y([nB]),
                    sB = sm({
                        name: "Tabbar",
                        configFields: oB(),
                        partFields: rB(),
                        factory: (e, t, o, n) => ({
                            uid: e.uid,
                            dom: e.dom,
                            components: t,
                            "debug.sketcher": "Tabbar",
                            domModification: {
                                attributes: {
                                    role: "tablist"
                                }
                            },
                            behaviours: su(e.tabbarBehaviours, [Dm.config({
                                highlightClass: e.markers.selectedClass,
                                itemClass: e.markers.tabClass,
                                onHighlight: (e, t) => {
                                    bt(t.element, "aria-selected", "true")
                                },
                                onDehighlight: (e, t) => {
                                    bt(t.element, "aria-selected", "false")
                                }
                            }), Th.config({
                                mode: "flow",
                                getInitial: e => Dm.getHighlighted(e).map((e => e.element)),
                                selector: "." + e.markers.tabClass,
                                executeOnMove: !0
                            })])
                        })
                    }),
                    aB = rm({
                        name: "Tabview",
                        configFields: [nu("tabviewBehaviours", [Hh])],
                        factory: (e, t) => ({
                            uid: e.uid,
                            dom: e.dom,
                            behaviours: su(e.tabviewBehaviours, [Hh.config({})]),
                            domModification: {
                                attributes: {
                                    role: "tabpanel"
                                }
                            }
                        })
                    }),
                    iB = y([ur("selectFirst", !0), xi("onChangeTab"), xi("onDismissTab"), ur("tabs", []), nu("tabSectionBehaviours", [])]),
                    lB = Mu({
                        factory: sB,
                        schema: [Gn("dom"), er("markers", [Gn("tabClass"), Gn("selectedClass")])],
                        name: "tabbar",
                        defaults: e => ({
                            tabs: e.tabs
                        })
                    }),
                    cB = Mu({
                        factory: aB,
                        name: "tabview"
                    }),
                    dB = y([lB, cB]),
                    uB = sm({
                        name: "TabSection",
                        configFields: iB(),
                        partFields: dB(),
                        factory: (e, t, o, n) => {
                            const r = (t, o) => {
                                ju(t, e, "tabbar").each((e => {
                                    o(e).each(Os)
                                }))
                            };
                            return {
                                uid: e.uid,
                                dom: e.dom,
                                components: t,
                                behaviours: ru(e.tabSectionBehaviours),
                                events: Ms(q([e.selectFirst ? [Vs(((e, t) => {
                                        r(e, Dm.getFirst)
                                    }))] : [],
                                    [Ds(ws(), ((t, o) => {
                                        (t => {
                                            const o = ou.getValue(t);
                                            ju(t, e, "tabview").each((n => {
                                                W(e.tabs, (e => e.value === o)).each((o => {
                                                    const r = o.view();
                                                    xt(t.element, "id").each((e => {
                                                        bt(n.element, "aria-labelledby", e)
                                                    })), Hh.set(n, r), e.onChangeTab(n, t, r)
                                                }))
                                            }))
                                        })(o.event.button)
                                    })), Ds(xs(), ((t, o) => {
                                        const n = o.event.button;
                                        e.onDismissTab(t, n)
                                    }))]
                                ])),
                                apis: {
                                    getViewItems: t => ju(t, e, "tabview").map((e => Hh.contents(e))).getOr([]),
                                    showTab: (e, t) => {
                                        r(e, (e => {
                                            const o = Dm.getCandidates(e);
                                            return W(o, (e => ou.getValue(e) === t)).filter((t => !Dm.isHighlighted(e, t)))
                                        }))
                                    }
                                }
                            }
                        },
                        apis: {
                            getViewItems: (e, t) => e.getViewItems(t),
                            showTab: (e, t, o) => {
                                e.showTab(t, o)
                            }
                        }
                    }),
                    mB = (e, t) => {
                        Ot(e, "height", t + "px"), Ot(e, "flex-basis", t + "px")
                    },
                    gB = (e, t, o) => {
                        oi(e, '[role="dialog"]').each((e => {
                            ri(e, '[role="tablist"]').each((n => {
                                o.get().map((o => (Ot(t, "height", "0"), Ot(t, "flex-basis", "0"), Math.min(o, ((e, t, o) => {
                                    const n = Je(e).dom,
                                        r = oi(e, ".tox-dialog-wrap").getOr(e);
                                    let s;
                                    s = "fixed" === At(r, "position") ? Math.max(n.clientHeight, window.innerHeight) : Math.max(n.offsetHeight, n.scrollHeight);
                                    const a = Pt(t),
                                        i = t.dom.offsetLeft >= o.dom.offsetLeft + $t(o) ? Math.max(Pt(o), a) : a,
                                        l = parseInt(At(e, "margin-top"), 10) || 0,
                                        c = parseInt(At(e, "margin-bottom"), 10) || 0;
                                    return s - (Pt(e) + l + c - i)
                                })(e, t, n))))).each((e => {
                                    mB(t, e)
                                }))
                            }))
                        }))
                    },
                    hB = e => ri(e, '[role="tabpanel"]'),
                    pB = "send-data-to-section",
                    fB = "send-data-to-view",
                    vB = (e, t, o) => {
                        const n = wr({}),
                            r = e => {
                                const t = ou.getValue(e),
                                    o = QD(t).getOr({}),
                                    r = n.get(),
                                    s = cn(r, o);
                                n.set(s)
                            },
                            s = e => {
                                const t = n.get();
                                ou.setValue(e, t)
                            },
                            a = wr(null),
                            i = z(e.tabs, (e => ({
                                value: e.name,
                                dom: {
                                    tag: "div",
                                    classes: ["tox-dialog__body-nav-item"]
                                },
                                components: [Wa(o.shared.providers.translate(e.title))],
                                view: () => [$S.sketch((n => ({
                                    dom: {
                                        tag: "div",
                                        classes: ["tox-form"]
                                    },
                                    components: z(e.items, (e => A_(n, e, t, o))),
                                    formBehaviours: gl([Th.config({
                                        mode: "acyclic",
                                        useTabstopAt: S(vk)
                                    }), Ih("TabView.form.events", [Vs(s), Zs(r)]), yl.config({
                                        channels: Sr([{
                                            key: pB,
                                            value: {
                                                onReceive: r
                                            }
                                        }, {
                                            key: fB,
                                            value: {
                                                onReceive: s
                                            }
                                        }])
                                    })])
                                })))]
                            }))),
                            l = (e => {
                                const t = Zl(),
                                    o = [Vs((o => {
                                        const n = o.element;
                                        hB(n).each((r => {
                                            Ot(r, "visibility", "hidden"), o.getSystem().getByDom(r).toOptional().each((o => {
                                                const n = ((e, t, o) => z(e, ((n, r) => {
                                                        Hh.set(o, e[r].view());
                                                        const s = t.dom.getBoundingClientRect();
                                                        return Hh.set(o, []), s.height
                                                    })))(e, r, o),
                                                    s = (e => oe(ee(e, ((e, t) => e > t ? -1 : e < t ? 1 : 0))))(n);
                                                s.fold(t.clear, t.set)
                                            })), gB(n, r, t), Bt(r, "visibility"), ((e, t) => {
                                                oe(e).each((e => uB.showTab(t, e.value)))
                                            })(e, o), requestAnimationFrame((() => {
                                                gB(n, r, t)
                                            }))
                                        }))
                                    })), Ds(gs(), (e => {
                                        const o = e.element;
                                        hB(o).each((e => {
                                            gB(o, e, t)
                                        }))
                                    })), Ds(Wx, ((e, o) => {
                                        const n = e.element;
                                        hB(n).each((e => {
                                            const o = Sl(dt(e));
                                            Ot(e, "visibility", "hidden");
                                            const r = Nt(e, "height").map((e => parseInt(e, 10)));
                                            Bt(e, "height"), Bt(e, "flex-basis");
                                            const s = e.dom.getBoundingClientRect().height;
                                            r.forall((e => s > e)) ? (t.set(s), gB(n, e, t)) : r.each((t => {
                                                mB(e, t)
                                            })), Bt(e, "visibility"), o.each(xl)
                                        }))
                                    }))];
                                return {
                                    extraEvents: o,
                                    selectFirst: !1
                                }
                            })(i);
                        return uB.sketch({
                            dom: {
                                tag: "div",
                                classes: ["tox-dialog__body"]
                            },
                            onChangeTab: (e, t, o) => {
                                const n = ou.getValue(t);
                                _s(e, jx, {
                                    name: n,
                                    oldName: a.get()
                                }), a.set(n)
                            },
                            tabs: i,
                            components: [uB.parts.tabbar({
                                dom: {
                                    tag: "div",
                                    classes: ["tox-dialog__body-nav"]
                                },
                                components: [sB.parts.tabs({})],
                                markers: {
                                    tabClass: "tox-tab",
                                    selectedClass: "tox-dialog__body-nav-item--active"
                                },
                                tabbarBehaviours: gl([Nx.config({})])
                            }), uB.parts.tabview({
                                dom: {
                                    tag: "div",
                                    classes: ["tox-dialog__body-content"]
                                }
                            })],
                            selectFirst: l.selectFirst,
                            tabSectionBehaviours: gl([Ih("tabpanel", l.extraEvents), Th.config({
                                mode: "acyclic"
                            }), cm.config({
                                find: e => oe(uB.getViewItems(e))
                            }), ak(A.none(), (e => (e.getSystem().broadcastOn([pB], {}), n.get())), ((e, t) => {
                                n.set(t), e.getSystem().broadcastOn([fB], {})
                            }))])
                        })
                    },
                    bB = Qs("update-dialog"),
                    yB = Qs("update-title"),
                    wB = Qs("update-body"),
                    xB = Qs("update-footer"),
                    CB = Qs("body-send-message"),
                    SB = (e, t, o, n, r) => ({
                        dom: {
                            tag: "div",
                            classes: ["tox-dialog__content-js"],
                            attributes: { ...o.map((e => ({
                                    id: e
                                }))).getOr({}),
                                ...r ? {
                                    "aria-live": "polite"
                                } : {}
                            }
                        },
                        components: [],
                        behaviours: gl([ek(0), KA.config({
                            channel: `${wB}-${t}`,
                            updateState: (e, t) => A.some({
                                isTabPanel: () => "tabpanel" === t.body.type
                            }),
                            renderComponents: e => {
                                const t = e.body;
                                return "tabpanel" === t.type ? [vB(t, e.initialData, n)] : [eB(t, e.initialData, n)]
                            },
                            initialData: e
                        })])
                    });

                function kB(e) {
                    return kB = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                        return typeof e
                    } : function(e) {
                        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                    }, kB(e)
                }

                function _B(e, t) {
                    return _B = Object.setPrototypeOf || function(e, t) {
                        return e.__proto__ = t, e
                    }, _B(e, t)
                }

                function OB() {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                    if (Reflect.construct.sham) return !1;
                    if ("function" == typeof Proxy) return !0;
                    try {
                        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
                    } catch (e) {
                        return !1
                    }
                }

                function TB(e, t, o) {
                    return TB = OB() ? Reflect.construct : function(e, t, o) {
                        var n = [null];
                        n.push.apply(n, t);
                        var r = new(Function.bind.apply(e, n));
                        return o && _B(r, o.prototype), r
                    }, TB.apply(null, arguments)
                }

                function EB(e) {
                    return function(e) {
                        if (Array.isArray(e)) return AB(e)
                    }(e) || function(e) {
                        if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"]) return Array.from(e)
                    }(e) || function(e, t) {
                        if (e) {
                            if ("string" == typeof e) return AB(e, t);
                            var o = Object.prototype.toString.call(e).slice(8, -1);
                            return "Object" === o && e.constructor && (o = e.constructor.name), "Map" === o || "Set" === o ? Array.from(e) : "Arguments" === o || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(o) ? AB(e, t) : void 0
                        }
                    }(e) || function() {
                        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                    }()
                }

                function AB(e, t) {
                    (null == t || t > e.length) && (t = e.length);
                    for (var o = 0, n = new Array(t); o < t; o++) n[o] = e[o];
                    return n
                }
                var MB = Object.hasOwnProperty,
                    NB = Object.setPrototypeOf,
                    RB = Object.isFrozen,
                    DB = Object.getPrototypeOf,
                    BB = Object.getOwnPropertyDescriptor,
                    LB = Object.freeze,
                    HB = Object.seal,
                    IB = Object.create,
                    PB = "undefined" != typeof Reflect && Reflect,
                    zB = PB.apply,
                    FB = PB.construct;
                zB || (zB = function(e, t, o) {
                    return e.apply(t, o)
                }), LB || (LB = function(e) {
                    return e
                }), HB || (HB = function(e) {
                    return e
                }), FB || (FB = function(e, t) {
                    return TB(e, EB(t))
                });
                var VB, ZB = JB(Array.prototype.forEach),
                    UB = JB(Array.prototype.pop),
                    jB = JB(Array.prototype.push),
                    WB = JB(String.prototype.toLowerCase),
                    $B = JB(String.prototype.match),
                    qB = JB(String.prototype.replace),
                    GB = JB(String.prototype.indexOf),
                    KB = JB(String.prototype.trim),
                    YB = JB(RegExp.prototype.test),
                    XB = (VB = TypeError, function() {
                        for (var e = arguments.length, t = new Array(e), o = 0; o < e; o++) t[o] = arguments[o];
                        return FB(VB, t)
                    });

                function JB(e) {
                    return function(t) {
                        for (var o = arguments.length, n = new Array(o > 1 ? o - 1 : 0), r = 1; r < o; r++) n[r - 1] = arguments[r];
                        return zB(e, t, n)
                    }
                }

                function QB(e, t) {
                    NB && NB(e, null);
                    for (var o = t.length; o--;) {
                        var n = t[o];
                        if ("string" == typeof n) {
                            var r = WB(n);
                            r !== n && (RB(t) || (t[o] = r), n = r)
                        }
                        e[n] = !0
                    }
                    return e
                }

                function eL(e) {
                    var t, o = IB(null);
                    for (t in e) zB(MB, e, [t]) && (o[t] = e[t]);
                    return o
                }

                function tL(e, t) {
                    for (; null !== e;) {
                        var o = BB(e, t);
                        if (o) {
                            if (o.get) return JB(o.get);
                            if ("function" == typeof o.value) return JB(o.value)
                        }
                        e = DB(e)
                    }
                    return function(e) {
                        return console.warn("fallback value for", e), null
                    }
                }
                var oL = LB(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]),
                    nL = LB(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]),
                    rL = LB(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]),
                    sL = LB(["animate", "color-profile", "cursor", "discard", "fedropshadow", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]),
                    aL = LB(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover"]),
                    iL = LB(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]),
                    lL = LB(["#text"]),
                    cL = LB(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "xmlns", "slot"]),
                    dL = LB(["accent-height", "accumulate", "additive", "alignment-baseline", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]),
                    uL = LB(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]),
                    mL = LB(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]),
                    gL = HB(/\{\{[\w\W]*|[\w\W]*\}\}/gm),
                    hL = HB(/<%[\w\W]*|[\w\W]*%>/gm),
                    pL = HB(/^data-[\-\w.\u00B7-\uFFFF]/),
                    fL = HB(/^aria-[\-\w]+$/),
                    vL = HB(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i),
                    bL = HB(/^(?:\w+script|data):/i),
                    yL = HB(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g),
                    wL = HB(/^html$/i),
                    xL = function() {
                        return "undefined" == typeof window ? null : window
                    },
                    CL = function(e, t) {
                        if ("object" !== kB(e) || "function" != typeof e.createPolicy) return null;
                        var o = null,
                            n = "data-tt-policy-suffix";
                        t.currentScript && t.currentScript.hasAttribute(n) && (o = t.currentScript.getAttribute(n));
                        var r = "dompurify" + (o ? "#" + o : "");
                        try {
                            return e.createPolicy(r, {
                                createHTML: function(e) {
                                    return e
                                }
                            })
                        } catch (e) {
                            return console.warn("TrustedTypes policy " + r + " could not be created."), null
                        }
                    },
                    SL = function e() {
                        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : xL(),
                            o = function(t) {
                                return e(t)
                            };
                        if (o.version = "2.3.8", o.removed = [], !t || !t.document || 9 !== t.document.nodeType) return o.isSupported = !1, o;
                        var n = t.document,
                            r = t.document,
                            s = t.DocumentFragment,
                            a = t.HTMLTemplateElement,
                            i = t.Node,
                            l = t.Element,
                            c = t.NodeFilter,
                            d = t.NamedNodeMap,
                            u = void 0 === d ? t.NamedNodeMap || t.MozNamedAttrMap : d,
                            m = t.HTMLFormElement,
                            g = t.DOMParser,
                            h = t.trustedTypes,
                            p = l.prototype,
                            f = tL(p, "cloneNode"),
                            v = tL(p, "nextSibling"),
                            b = tL(p, "childNodes"),
                            y = tL(p, "parentNode");
                        if ("function" == typeof a) {
                            var w = r.createElement("template");
                            w.content && w.content.ownerDocument && (r = w.content.ownerDocument)
                        }
                        var x = CL(h, n),
                            C = x ? x.createHTML("") : "",
                            S = r,
                            k = S.implementation,
                            _ = S.createNodeIterator,
                            O = S.createDocumentFragment,
                            T = S.getElementsByTagName,
                            E = n.importNode,
                            A = {};
                        try {
                            A = eL(r).documentMode ? r.documentMode : {}
                        } catch (e) {}
                        var M = {};
                        o.isSupported = "function" == typeof y && k && void 0 !== k.createHTMLDocument && 9 !== A;
                        var N, R, D = gL,
                            B = hL,
                            L = pL,
                            H = fL,
                            I = bL,
                            P = yL,
                            z = vL,
                            F = null,
                            V = QB({}, [].concat(EB(oL), EB(nL), EB(rL), EB(aL), EB(lL))),
                            Z = null,
                            U = QB({}, [].concat(EB(cL), EB(dL), EB(uL), EB(mL))),
                            j = Object.seal(Object.create(null, {
                                tagNameCheck: {
                                    writable: !0,
                                    configurable: !1,
                                    enumerable: !0,
                                    value: null
                                },
                                attributeNameCheck: {
                                    writable: !0,
                                    configurable: !1,
                                    enumerable: !0,
                                    value: null
                                },
                                allowCustomizedBuiltInElements: {
                                    writable: !0,
                                    configurable: !1,
                                    enumerable: !0,
                                    value: !1
                                }
                            })),
                            W = null,
                            $ = null,
                            q = !0,
                            G = !0,
                            K = !1,
                            Y = !1,
                            X = !1,
                            J = !1,
                            Q = !1,
                            ee = !1,
                            te = !1,
                            oe = !1,
                            ne = !0,
                            re = !0,
                            se = !1,
                            ae = {},
                            ie = null,
                            le = QB({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]),
                            ce = null,
                            de = QB({}, ["audio", "video", "img", "source", "image", "track"]),
                            ue = null,
                            me = QB({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]),
                            ge = "http://www.w3.org/1998/Math/MathML",
                            he = "http://www.w3.org/2000/svg",
                            pe = "http://www.w3.org/1999/xhtml",
                            fe = pe,
                            ve = !1,
                            be = ["application/xhtml+xml", "text/html"],
                            ye = "text/html",
                            we = null,
                            xe = r.createElement("form"),
                            Ce = function(e) {
                                return e instanceof RegExp || e instanceof Function
                            },
                            Se = function(e) {
                                we && we === e || (e && "object" === kB(e) || (e = {}), e = eL(e), F = "ALLOWED_TAGS" in e ? QB({}, e.ALLOWED_TAGS) : V, Z = "ALLOWED_ATTR" in e ? QB({}, e.ALLOWED_ATTR) : U, ue = "ADD_URI_SAFE_ATTR" in e ? QB(eL(me), e.ADD_URI_SAFE_ATTR) : me, ce = "ADD_DATA_URI_TAGS" in e ? QB(eL(de), e.ADD_DATA_URI_TAGS) : de, ie = "FORBID_CONTENTS" in e ? QB({}, e.FORBID_CONTENTS) : le, W = "FORBID_TAGS" in e ? QB({}, e.FORBID_TAGS) : {}, $ = "FORBID_ATTR" in e ? QB({}, e.FORBID_ATTR) : {}, ae = "USE_PROFILES" in e && e.USE_PROFILES, q = !1 !== e.ALLOW_ARIA_ATTR, G = !1 !== e.ALLOW_DATA_ATTR, K = e.ALLOW_UNKNOWN_PROTOCOLS || !1, Y = e.SAFE_FOR_TEMPLATES || !1, X = e.WHOLE_DOCUMENT || !1, ee = e.RETURN_DOM || !1, te = e.RETURN_DOM_FRAGMENT || !1, oe = e.RETURN_TRUSTED_TYPE || !1, Q = e.FORCE_BODY || !1, ne = !1 !== e.SANITIZE_DOM, re = !1 !== e.KEEP_CONTENT, se = e.IN_PLACE || !1, z = e.ALLOWED_URI_REGEXP || z, fe = e.NAMESPACE || pe, e.CUSTOM_ELEMENT_HANDLING && Ce(e.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (j.tagNameCheck = e.CUSTOM_ELEMENT_HANDLING.tagNameCheck), e.CUSTOM_ELEMENT_HANDLING && Ce(e.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (j.attributeNameCheck = e.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), e.CUSTOM_ELEMENT_HANDLING && "boolean" == typeof e.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (j.allowCustomizedBuiltInElements = e.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), N = N = -1 === be.indexOf(e.PARSER_MEDIA_TYPE) ? ye : e.PARSER_MEDIA_TYPE, R = "application/xhtml+xml" === N ? function(e) {
                                    return e
                                } : WB, Y && (G = !1), te && (ee = !0), ae && (F = QB({}, EB(lL)), Z = [], !0 === ae.html && (QB(F, oL), QB(Z, cL)), !0 === ae.svg && (QB(F, nL), QB(Z, dL), QB(Z, mL)), !0 === ae.svgFilters && (QB(F, rL), QB(Z, dL), QB(Z, mL)), !0 === ae.mathMl && (QB(F, aL), QB(Z, uL), QB(Z, mL))), e.ADD_TAGS && (F === V && (F = eL(F)), QB(F, e.ADD_TAGS)), e.ADD_ATTR && (Z === U && (Z = eL(Z)), QB(Z, e.ADD_ATTR)), e.ADD_URI_SAFE_ATTR && QB(ue, e.ADD_URI_SAFE_ATTR), e.FORBID_CONTENTS && (ie === le && (ie = eL(ie)), QB(ie, e.FORBID_CONTENTS)), re && (F["#text"] = !0), X && QB(F, ["html", "head", "body"]), F.table && (QB(F, ["tbody"]), delete W.tbody), LB && LB(e), we = e)
                            },
                            ke = QB({}, ["mi", "mo", "mn", "ms", "mtext"]),
                            _e = QB({}, ["foreignobject", "desc", "title", "annotation-xml"]),
                            Oe = QB({}, ["title", "style", "font", "a", "script"]),
                            Te = QB({}, nL);
                        QB(Te, rL), QB(Te, sL);
                        var Ee = QB({}, aL);
                        QB(Ee, iL);
                        var Ae = function(e) {
                                var t = y(e);
                                t && t.tagName || (t = {
                                    namespaceURI: pe,
                                    tagName: "template"
                                });
                                var o = WB(e.tagName),
                                    n = WB(t.tagName);
                                return e.namespaceURI === he ? t.namespaceURI === pe ? "svg" === o : t.namespaceURI === ge ? "svg" === o && ("annotation-xml" === n || ke[n]) : Boolean(Te[o]) : e.namespaceURI === ge ? t.namespaceURI === pe ? "math" === o : t.namespaceURI === he ? "math" === o && _e[n] : Boolean(Ee[o]) : e.namespaceURI === pe && !(t.namespaceURI === he && !_e[n]) && !(t.namespaceURI === ge && !ke[n]) && !Ee[o] && (Oe[o] || !Te[o])
                            },
                            Me = function(e) {
                                jB(o.removed, {
                                    element: e
                                });
                                try {
                                    e.parentNode.removeChild(e)
                                } catch (t) {
                                    try {
                                        e.outerHTML = C
                                    } catch (t) {
                                        e.remove()
                                    }
                                }
                            },
                            Ne = function(e, t) {
                                try {
                                    jB(o.removed, {
                                        attribute: t.getAttributeNode(e),
                                        from: t
                                    })
                                } catch (e) {
                                    jB(o.removed, {
                                        attribute: null,
                                        from: t
                                    })
                                }
                                if (t.removeAttribute(e), "is" === e && !Z[e])
                                    if (ee || te) try {
                                        Me(t)
                                    } catch (e) {} else try {
                                        t.setAttribute(e, "")
                                    } catch (e) {}
                            },
                            Re = function(e) {
                                var t, o;
                                if (Q) e = "<remove></remove>" + e;
                                else {
                                    var n = $B(e, /^[\r\n\t ]+/);
                                    o = n && n[0]
                                }
                                "application/xhtml+xml" === N && (e = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + e + "</body></html>");
                                var s = x ? x.createHTML(e) : e;
                                if (fe === pe) try {
                                    t = (new g).parseFromString(s, N)
                                } catch (e) {}
                                if (!t || !t.documentElement) {
                                    t = k.createDocument(fe, "template", null);
                                    try {
                                        t.documentElement.innerHTML = ve ? "" : s
                                    } catch (e) {}
                                }
                                var a = t.body || t.documentElement;
                                return e && o && a.insertBefore(r.createTextNode(o), a.childNodes[0] || null), fe === pe ? T.call(t, X ? "html" : "body")[0] : X ? t.documentElement : a
                            },
                            De = function(e) {
                                return _.call(e.ownerDocument || e, e, c.SHOW_ELEMENT | c.SHOW_COMMENT | c.SHOW_TEXT, null, !1)
                            },
                            Be = function(e) {
                                return e instanceof m && ("string" != typeof e.nodeName || "string" != typeof e.textContent || "function" != typeof e.removeChild || !(e.attributes instanceof u) || "function" != typeof e.removeAttribute || "function" != typeof e.setAttribute || "string" != typeof e.namespaceURI || "function" != typeof e.insertBefore)
                            },
                            Le = function(e) {
                                return "object" === kB(i) ? e instanceof i : e && "object" === kB(e) && "number" == typeof e.nodeType && "string" == typeof e.nodeName
                            },
                            He = function(e, t, n) {
                                M[e] && ZB(M[e], (function(e) {
                                    e.call(o, t, n, we)
                                }))
                            },
                            Ie = function(e) {
                                var t;
                                if (He("beforeSanitizeElements", e, null), Be(e)) return Me(e), !0;
                                if (YB(/[\u0080-\uFFFF]/, e.nodeName)) return Me(e), !0;
                                var n = R(e.nodeName);
                                if (He("uponSanitizeElement", e, {
                                        tagName: n,
                                        allowedTags: F
                                    }), e.hasChildNodes() && !Le(e.firstElementChild) && (!Le(e.content) || !Le(e.content.firstElementChild)) && YB(/<[/\w]/g, e.innerHTML) && YB(/<[/\w]/g, e.textContent)) return Me(e), !0;
                                if ("select" === n && YB(/<template/i, e.innerHTML)) return Me(e), !0;
                                if (!F[n] || W[n]) {
                                    if (!W[n] && ze(n)) {
                                        if (j.tagNameCheck instanceof RegExp && YB(j.tagNameCheck, n)) return !1;
                                        if (j.tagNameCheck instanceof Function && j.tagNameCheck(n)) return !1
                                    }
                                    if (re && !ie[n]) {
                                        var r = y(e) || e.parentNode,
                                            s = b(e) || e.childNodes;
                                        if (s && r)
                                            for (var a = s.length - 1; a >= 0; --a) r.insertBefore(f(s[a], !0), v(e))
                                    }
                                    return Me(e), !0
                                }
                                return e instanceof l && !Ae(e) ? (Me(e), !0) : "noscript" !== n && "noembed" !== n || !YB(/<\/no(script|embed)/i, e.innerHTML) ? (Y && 3 === e.nodeType && (t = e.textContent, t = qB(t, D, " "), t = qB(t, B, " "), e.textContent !== t && (jB(o.removed, {
                                    element: e.cloneNode()
                                }), e.textContent = t)), He("afterSanitizeElements", e, null), !1) : (Me(e), !0)
                            },
                            Pe = function(e, t, o) {
                                if (ne && ("id" === t || "name" === t) && (o in r || o in xe)) return !1;
                                if (G && !$[t] && YB(L, t));
                                else if (q && YB(H, t));
                                else if (!Z[t] || $[t]) {
                                    if (!(ze(e) && (j.tagNameCheck instanceof RegExp && YB(j.tagNameCheck, e) || j.tagNameCheck instanceof Function && j.tagNameCheck(e)) && (j.attributeNameCheck instanceof RegExp && YB(j.attributeNameCheck, t) || j.attributeNameCheck instanceof Function && j.attributeNameCheck(t)) || "is" === t && j.allowCustomizedBuiltInElements && (j.tagNameCheck instanceof RegExp && YB(j.tagNameCheck, o) || j.tagNameCheck instanceof Function && j.tagNameCheck(o)))) return !1
                                } else if (ue[t]);
                                else if (YB(z, qB(o, P, "")));
                                else if ("src" !== t && "xlink:href" !== t && "href" !== t || "script" === e || 0 !== GB(o, "data:") || !ce[e])
                                    if (K && !YB(I, qB(o, P, "")));
                                    else if (o) return !1;
                                return !0
                            },
                            ze = function(e) {
                                return e.indexOf("-") > 0
                            },
                            Fe = function(e) {
                                var t, o, n, r;
                                He("beforeSanitizeAttributes", e, null);
                                var s = e.attributes;
                                if (s) {
                                    var a = {
                                        attrName: "",
                                        attrValue: "",
                                        keepAttr: !0,
                                        allowedAttributes: Z
                                    };
                                    for (r = s.length; r--;) {
                                        var i = t = s[r],
                                            l = i.name,
                                            c = i.namespaceURI;
                                        o = "value" === l ? t.value : KB(t.value), n = R(l);
                                        var d = o;
                                        if (a.attrName = n, a.attrValue = o, a.keepAttr = !0, a.forceKeepAttr = void 0, He("uponSanitizeAttribute", e, a), o = a.attrValue, !a.forceKeepAttr)
                                            if (a.keepAttr)
                                                if (YB(/\/>/i, o)) Ne(l, e);
                                                else {
                                                    Y && (o = qB(o, D, " "), o = qB(o, B, " "));
                                                    var u = R(e.nodeName);
                                                    if (Pe(u, n, o)) {
                                                        if (o !== d) try {
                                                            c ? e.setAttributeNS(c, l, o) : e.setAttribute(l, o)
                                                        } catch (t) {
                                                            Ne(l, e)
                                                        }
                                                    } else Ne(l, e)
                                                }
                                        else Ne(l, e)
                                    }
                                    He("afterSanitizeAttributes", e, null)
                                }
                            },
                            Ve = function e(t) {
                                var o, n = De(t);
                                for (He("beforeSanitizeShadowDOM", t, null); o = n.nextNode();) He("uponSanitizeShadowNode", o, null), Ie(o) || (o.content instanceof s && e(o.content), Fe(o));
                                He("afterSanitizeShadowDOM", t, null)
                            };
                        return o.sanitize = function(e, r) {
                            var a, l, c, d, u;
                            if ((ve = !e) && (e = "\x3c!--\x3e"), "string" != typeof e && !Le(e)) {
                                if ("function" != typeof e.toString) throw XB("toString is not a function");
                                if ("string" != typeof(e = e.toString())) throw XB("dirty is not a string, aborting")
                            }
                            if (!o.isSupported) {
                                if ("object" === kB(t.toStaticHTML) || "function" == typeof t.toStaticHTML) {
                                    if ("string" == typeof e) return t.toStaticHTML(e);
                                    if (Le(e)) return t.toStaticHTML(e.outerHTML)
                                }
                                return e
                            }
                            if (J || Se(r), o.removed = [], "string" == typeof e && (se = !1), se) {
                                if (e.nodeName) {
                                    var m = R(e.nodeName);
                                    if (!F[m] || W[m]) throw XB("root node is forbidden and cannot be sanitized in-place")
                                }
                            } else if (e instanceof i) 1 === (l = (a = Re("\x3c!----\x3e")).ownerDocument.importNode(e, !0)).nodeType && "BODY" === l.nodeName || "HTML" === l.nodeName ? a = l : a.appendChild(l);
                            else {
                                if (!ee && !Y && !X && -1 === e.indexOf("<")) return x && oe ? x.createHTML(e) : e;
                                if (!(a = Re(e))) return ee ? null : oe ? C : ""
                            }
                            a && Q && Me(a.firstChild);
                            for (var g = De(se ? e : a); c = g.nextNode();) 3 === c.nodeType && c === d || Ie(c) || (c.content instanceof s && Ve(c.content), Fe(c), d = c);
                            if (d = null, se) return e;
                            if (ee) {
                                if (te)
                                    for (u = O.call(a.ownerDocument); a.firstChild;) u.appendChild(a.firstChild);
                                else u = a;
                                return Z.shadowroot && (u = E.call(n, u, !0)), u
                            }
                            var h = X ? a.outerHTML : a.innerHTML;
                            return X && F["!doctype"] && a.ownerDocument && a.ownerDocument.doctype && a.ownerDocument.doctype.name && YB(wL, a.ownerDocument.doctype.name) && (h = "<!DOCTYPE " + a.ownerDocument.doctype.name + ">\n" + h), Y && (h = qB(h, D, " "), h = qB(h, B, " ")), x && oe ? x.createHTML(h) : h
                        }, o.setConfig = function(e) {
                            Se(e), J = !0
                        }, o.clearConfig = function() {
                            we = null, J = !1
                        }, o.isValidAttribute = function(e, t, o) {
                            we || Se({});
                            var n = R(e),
                                r = R(t);
                            return Pe(n, r, o)
                        }, o.addHook = function(e, t) {
                            "function" == typeof t && (M[e] = M[e] || [], jB(M[e], t))
                        }, o.removeHook = function(e) {
                            if (M[e]) return UB(M[e])
                        }, o.removeHooks = function(e) {
                            M[e] && (M[e] = [])
                        }, o.removeAllHooks = function() {
                            M = {}
                        }, o
                    }();
                const kL = e => SL().sanitize(e),
                    _L = qp.deviceType.isTouch(),
                    OL = (e, t) => ({
                        dom: {
                            tag: "div",
                            styles: {
                                display: "none"
                            },
                            classes: ["tox-dialog__header"]
                        },
                        components: [e, t]
                    }),
                    TL = (e, t) => SR.parts.close(Ap.sketch({
                        dom: {
                            tag: "button",
                            classes: ["tox-button", "tox-button--icon", "tox-button--naked"],
                            attributes: {
                                type: "button",
                                "aria-label": t.translate("Close")
                            }
                        },
                        action: e,
                        buttonBehaviours: gl([Nx.config({})])
                    })),
                    EL = () => SR.parts.title({
                        dom: {
                            tag: "div",
                            classes: ["tox-dialog__title"],
                            innerHtml: "",
                            styles: {
                                display: "none"
                            }
                        }
                    }),
                    AL = (e, t) => SR.parts.body({
                        dom: {
                            tag: "div",
                            classes: ["tox-dialog__body"]
                        },
                        components: [{
                            dom: {
                                tag: "div",
                                classes: ["tox-dialog__body-content"]
                            },
                            components: [{
                                dom: mE(`<p>${kL(t.translate(e))}</p>`)
                            }]
                        }]
                    }),
                    ML = e => SR.parts.footer({
                        dom: {
                            tag: "div",
                            classes: ["tox-dialog__footer"]
                        },
                        components: e
                    }),
                    NL = (e, t) => [kx.sketch({
                        dom: {
                            tag: "div",
                            classes: ["tox-dialog__footer-start"]
                        },
                        components: e
                    }), kx.sketch({
                        dom: {
                            tag: "div",
                            classes: ["tox-dialog__footer-end"]
                        },
                        components: t
                    })],
                    RL = e => {
                        const t = "tox-dialog",
                            o = t + "-wrap",
                            n = o + "__backdrop",
                            r = t + "__disable-scroll";
                        return SR.sketch({
                            lazySink: e.lazySink,
                            onEscape: t => (e.onEscape(t), A.some(!0)),
                            useTabstopAt: e => !vk(e),
                            dom: {
                                tag: "div",
                                classes: [t].concat(e.extraClasses),
                                styles: {
                                    position: "relative",
                                    ...e.extraStyles
                                }
                            },
                            components: [e.header, e.body, ...e.footer.toArray()],
                            parts: {
                                blocker: {
                                    dom: mE(`<div class="${o}"></div>`),
                                    components: [{
                                        dom: {
                                            tag: "div",
                                            classes: _L ? [n, n + "--opaque"] : [n]
                                        }
                                    }]
                                }
                            },
                            dragBlockClass: o,
                            modalBehaviours: gl([Zh.config({}), Ih("dialog-events", e.dialogEvents.concat([Fs(Fr(), ((e, t) => {
                                Th.focusIn(e)
                            }))])), Ih("scroll-lock", [Vs((() => {
                                Na(pt(), r)
                            })), Zs((() => {
                                Ra(pt(), r)
                            }))]), ...e.extraBehaviours]),
                            eventOrder: {
                                [ns()]: ["dialog-events"],
                                [hs()]: ["scroll-lock", "dialog-events", "alloy.base.behaviour"],
                                [ps()]: ["alloy.base.behaviour", "dialog-events", "scroll-lock"],
                                ...e.eventOrder
                            }
                        })
                    },
                    DL = e => Ap.sketch({
                        dom: {
                            tag: "button",
                            classes: ["tox-button", "tox-button--icon", "tox-button--naked"],
                            attributes: {
                                type: "button",
                                "aria-label": e.translate("Close"),
                                title: e.translate("Close")
                            }
                        },
                        components: [Fp("close", {
                            tag: "div",
                            classes: ["tox-icon"]
                        }, e.icons)],
                        action: e => {
                            ks(e, zx)
                        }
                    }),
                    BL = (e, t, o, n) => ({
                        dom: {
                            tag: "div",
                            classes: ["tox-dialog__title"],
                            attributes: { ...o.map((e => ({
                                    id: e
                                }))).getOr({})
                            }
                        },
                        components: [],
                        behaviours: gl([KA.config({
                            channel: `${yB}-${t}`,
                            initialData: e,
                            renderComponents: e => [Wa(n.translate(e.title))]
                        })])
                    }),
                    LL = () => ({
                        dom: mE('<div class="tox-dialog__draghandle"></div>')
                    }),
                    HL = (e, t, o) => ((e, t, o) => {
                        const n = SR.parts.title(BL(e, t, A.none(), o)),
                            r = SR.parts.draghandle(LL()),
                            s = SR.parts.close(DL(o)),
                            a = [n].concat(e.draggable ? [r] : []).concat([s]);
                        return kx.sketch({
                            dom: mE('<div class="tox-dialog__header"></div>'),
                            components: a
                        })
                    })({
                        title: o.shared.providers.translate(e),
                        draggable: o.dialog.isDraggableModal()
                    }, t, o.shared.providers),
                    IL = (e, t, o) => ({
                        dom: {
                            tag: "div",
                            classes: ["tox-dialog__busy-spinner"],
                            attributes: {
                                "aria-label": o.translate(e)
                            },
                            styles: {
                                left: "0px",
                                right: "0px",
                                bottom: "0px",
                                top: "0px",
                                position: "absolute"
                            }
                        },
                        behaviours: t,
                        components: [{
                            dom: mE('<div class="tox-spinner"><div></div><div></div><div></div></div>')
                        }]
                    }),
                    PL = (e, t, o) => ({
                        onClose: () => o.closeWindow(),
                        onBlock: o => {
                            SR.setBusy(e(), ((e, n) => IL(o.message, n, t)))
                        },
                        onUnblock: () => {
                            SR.setIdle(e())
                        }
                    }),
                    zL = (e, t, o, n) => Ka(RL({ ...e,
                        lazySink: n.shared.getSink,
                        extraBehaviours: [KA.config({
                            channel: `${bB}-${e.id}`,
                            updateState: (e, t) => A.some(t),
                            initialData: t
                        }), ik({}), ...e.extraBehaviours],
                        onEscape: e => {
                            ks(e, zx)
                        },
                        dialogEvents: o,
                        eventOrder: {
                            [os()]: [KA.name(), yl.name()],
                            [hs()]: ["scroll-lock", KA.name(), "messages", "dialog-events", "alloy.base.behaviour"],
                            [ps()]: ["alloy.base.behaviour", "dialog-events", "messages", KA.name(), "scroll-lock"]
                        }
                    })),
                    FL = e => z(e, (e => "menu" === e.type ? (e => {
                        const t = z(e.items, (e => ({ ...e,
                            storage: wr(!1)
                        })));
                        return { ...e,
                            items: t
                        }
                    })(e) : e)),
                    VL = e => j(e, ((e, t) => "menu" === t.type ? j(t.items, ((e, t) => (e[t.name] = t.storage, e)), e) : e), {}),
                    ZL = (e, t) => [Is(Fr(), fk), e(Px, ((e, o) => {
                        t.onClose(), o.onClose()
                    })), e(zx, ((e, t, o, n) => {
                        t.onCancel(e), ks(n, Px)
                    })), Ds(Ux, ((e, o) => t.onUnblock())), Ds(Zx, ((e, o) => t.onBlock(o.event)))],
                    UL = (e, t, o) => {
                        const n = (t, o) => Ds(t, ((t, n) => {
                                r(t, ((r, s) => {
                                    o(e(), r, n.event, t)
                                }))
                            })),
                            r = (e, t) => {
                                KA.getState(e).get().each((o => {
                                    t(o.internalDialog, e)
                                }))
                            };
                        return [...ZL(n, t), n(Vx, ((e, t) => t.onSubmit(e))), n(Ix, ((e, t, o) => {
                            t.onChange(e, {
                                name: o.name
                            })
                        })), n(Fx, ((e, t, n, r) => {
                            const s = () => Th.focusIn(r),
                                a = e => Ct(e, "disabled") || xt(e, "aria-disabled").exists((e => "true" === e)),
                                i = dt(r.element),
                                l = Sl(i);
                            t.onAction(e, {
                                name: n.name,
                                value: n.value
                            }), Sl(i).fold(s, (e => {
                                a(e) || l.exists((t => Ke(e, t) && a(t))) ? s() : o().toOptional().filter((t => !Ke(t.element, e))).each(s)
                            }))
                        })), n(jx, ((e, t, o) => {
                            t.onTabChange(e, {
                                newTabName: o.name,
                                oldTabName: o.oldName
                            })
                        })), Zs((t => {
                            const o = e();
                            ou.setValue(t, o.getData())
                        }))]
                    },
                    jL = (e, t) => {
                        const o = t.map((e => e.footerButtons)).getOr([]),
                            n = V(o, (e => "start" === e.align)),
                            r = (e, t) => kx.sketch({
                                dom: {
                                    tag: "div",
                                    classes: [`tox-dialog__footer-${e}`]
                                },
                                components: z(t, (e => e.memento.asSpec()))
                            });
                        return [r("start", n.pass), r("end", n.fail)]
                    },
                    WL = (e, t, o) => ({
                        dom: mE('<div class="tox-dialog__footer"></div>'),
                        components: [],
                        behaviours: gl([KA.config({
                            channel: `${xB}-${t}`,
                            initialData: e,
                            updateState: (e, t) => {
                                const n = z(t.buttons, (e => {
                                    const t = Mp(((e, t) => g_(e, e.type, t))(e, o));
                                    return {
                                        name: e.name,
                                        align: e.align,
                                        memento: t
                                    }
                                }));
                                return A.some({
                                    lookupByName: t => ((e, t, o) => W(t, (e => e.name === o)).bind((t => t.memento.getOpt(e))))(e, n, t),
                                    footerButtons: n
                                })
                            },
                            renderComponents: jL
                        })])
                    }),
                    $L = (e, t, o) => SR.parts.footer(WL(e, t, o)),
                    qL = (e, t) => {
                        if (e.getRoot().getSystem().isConnected()) {
                            const o = cm.getCurrent(e.getFormWrapper()).getOr(e.getFormWrapper());
                            return $S.getField(o, t).orThunk((() => {
                                const o = e.getFooter();
                                return KA.getState(o).get().bind((e => e.lookupByName(t)))
                            }))
                        }
                        return A.none()
                    },
                    GL = (e, t, o) => {
                        const n = t => {
                                const o = e.getRoot();
                                o.getSystem().isConnected() && t(o)
                            },
                            r = {
                                getData: () => {
                                    const t = e.getRoot(),
                                        n = t.getSystem().isConnected() ? e.getFormWrapper() : t;
                                    return { ...ou.getValue(n),
                                        ...ce(o, (e => e.get()))
                                    }
                                },
                                setData: t => {
                                    n((n => {
                                        const s = r.getData(),
                                            a = cn(s, t),
                                            i = ((e, t) => {
                                                const o = e.getRoot();
                                                return KA.getState(o).get().map((e => Vn(Fn("data", e.dataValidator, t)))).getOr(t)
                                            })(e, a),
                                            l = e.getFormWrapper();
                                        ou.setValue(l, i), le(o, ((e, t) => {
                                            be(a, t) && e.set(a[t])
                                        }))
                                    }))
                                },
                                setEnabled: (t, o) => {
                                    qL(e, t).each(o ? Sm.enable : Sm.disable)
                                },
                                focus: t => {
                                    qL(e, t).each(Zh.focus)
                                },
                                block: e => {
                                    if (!s(e)) throw new Error("The dialogInstanceAPI.block function should be passed a blocking message of type string as an argument");
                                    n((t => {
                                        _s(t, Zx, {
                                            message: e
                                        })
                                    }))
                                },
                                unblock: () => {
                                    n((e => {
                                        ks(e, Ux)
                                    }))
                                },
                                showTab: t => {
                                    n((o => {
                                        const n = e.getBody();
                                        KA.getState(n).get().exists((e => e.isTabPanel())) && cm.getCurrent(n).each((e => {
                                            uB.showTab(e, t)
                                        }))
                                    }))
                                },
                                redial: o => {
                                    n((n => {
                                        const s = e.getId(),
                                            a = t(o);
                                        n.getSystem().broadcastOn([`${bB}-${s}`], a), n.getSystem().broadcastOn([`${yB}-${s}`], a.internalDialog), n.getSystem().broadcastOn([`${wB}-${s}`], a.internalDialog), n.getSystem().broadcastOn([`${xB}-${s}`], a.internalDialog), r.setData(a.initialData)
                                    }))
                                },
                                close: () => {
                                    n((e => {
                                        ks(e, Px)
                                    }))
                                }
                            };
                        return r
                    };
                var KL = tinymce.util.Tools.resolve("tinymce.util.URI");
                const YL = ["insertContent", "setContent", "execCommand", "close", "block", "unblock"],
                    XL = e => a(e) && -1 !== YL.indexOf(e.mceAction),
                    JL = (e, t, o, n) => {
                        const r = Qs("dialog"),
                            i = HL(e.title, r, n),
                            l = (e => {
                                const t = {
                                    dom: {
                                        tag: "div",
                                        classes: ["tox-dialog__content-js"]
                                    },
                                    components: [{
                                        dom: {
                                            tag: "div",
                                            classes: ["tox-dialog__body-iframe"]
                                        },
                                        components: [hk({
                                            dom: {
                                                tag: "iframe",
                                                attributes: {
                                                    src: e.url
                                                }
                                            },
                                            behaviours: gl([Nx.config({}), Zh.config({})])
                                        })]
                                    }],
                                    behaviours: gl([Th.config({
                                        mode: "acyclic",
                                        useTabstopAt: S(vk)
                                    })])
                                };
                                return SR.parts.body(t)
                            })(e),
                            c = e.buttons.bind((e => 0 === e.length ? A.none() : A.some($L({
                                buttons: e
                            }, r, n)))),
                            u = ((e, t) => {
                                const o = (t, o) => Ds(t, ((t, r) => {
                                        n(t, ((n, s) => {
                                            o(e(), n, r.event, t)
                                        }))
                                    })),
                                    n = (e, t) => {
                                        KA.getState(e).get().each((o => {
                                            t(o, e)
                                        }))
                                    };
                                return [...ZL(o, t), o(Fx, ((e, t, o) => {
                                    t.onAction(e, {
                                        name: o.name
                                    })
                                }))]
                            })((() => w), PL((() => y), n.shared.providers, t)),
                            m = { ...e.height.fold((() => ({})), (e => ({
                                    height: e + "px",
                                    "max-height": e + "px"
                                }))),
                                ...e.width.fold((() => ({})), (e => ({
                                    width: e + "px",
                                    "max-width": e + "px"
                                })))
                            },
                            h = e.width.isNone() && e.height.isNone() ? ["tox-dialog--width-lg"] : [],
                            p = new KL(e.url, {
                                base_uri: new KL(window.location.href)
                            }),
                            f = `${p.protocol}://${p.host}${p.port?":"+p.port:""}`,
                            v = Vl(),
                            b = [Ih("messages", [Vs((() => {
                                const t = jl(Be(window), "message", (t => {
                                    if (p.isSameOrigin(new KL(t.raw.origin))) {
                                        const n = t.raw.data;
                                        XL(n) ? ((e, t, o) => {
                                            switch (o.mceAction) {
                                                case "insertContent":
                                                    e.insertContent(o.content);
                                                    break;
                                                case "setContent":
                                                    e.setContent(o.content);
                                                    break;
                                                case "execCommand":
                                                    const n = !!d(o.ui) && o.ui;
                                                    e.execCommand(o.cmd, n, o.value);
                                                    break;
                                                case "close":
                                                    t.close();
                                                    break;
                                                case "block":
                                                    t.block(o.message);
                                                    break;
                                                case "unblock":
                                                    t.unblock()
                                            }
                                        })(o, w, n) : (e => !XL(e) && a(e) && be(e, "mceAction"))(n) && e.onMessage(w, n)
                                    }
                                }));
                                v.set(t)
                            })), Zs(v.clear)]), yl.config({
                                channels: {
                                    [CB]: {
                                        onReceive: (e, t) => {
                                            ri(e.element, "iframe").each((e => {
                                                const o = e.dom.contentWindow;
                                                g(o) && o.postMessage(t, f)
                                            }))
                                        }
                                    }
                                }
                            })],
                            y = zL({
                                id: r,
                                header: i,
                                body: l,
                                footer: c,
                                extraClasses: h,
                                extraBehaviours: b,
                                extraStyles: m
                            }, e, u, n),
                            w = (e => {
                                const t = t => {
                                    e.getSystem().isConnected() && t(e)
                                };
                                return {
                                    block: e => {
                                        if (!s(e)) throw new Error("The urlDialogInstanceAPI.block function should be passed a blocking message of type string as an argument");
                                        t((t => {
                                            _s(t, Zx, {
                                                message: e
                                            })
                                        }))
                                    },
                                    unblock: () => {
                                        t((e => {
                                            ks(e, Ux)
                                        }))
                                    },
                                    close: () => {
                                        t((e => {
                                            ks(e, Px)
                                        }))
                                    },
                                    sendMessage: e => {
                                        t((t => {
                                            t.getSystem().broadcastOn([CB], e)
                                        }))
                                    }
                                }
                            })(y);
                        return {
                            dialog: y,
                            instanceApi: w
                        }
                    },
                    QL = (e, t, o) => t && o ? [] : [vT.config({
                        contextual: {
                            lazyContext: () => A.some($o(Be(e.getContentAreaContainer()))),
                            fadeInClass: "tox-dialog-dock-fadein",
                            fadeOutClass: "tox-dialog-dock-fadeout",
                            transitionClass: "tox-dialog-dock-transition"
                        },
                        modes: ["top"]
                    })],
                    eH = e => {
                        const t = e.editor,
                            o = Wf(t),
                            n = (e => {
                                const t = e.shared;
                                return {
                                    open: (o, n) => {
                                        const r = () => {
                                                SR.hide(l), n()
                                            },
                                            s = Mp(g_({
                                                name: "close-alert",
                                                text: "OK",
                                                primary: !0,
                                                buttonType: A.some("primary"),
                                                align: "end",
                                                enabled: !0,
                                                icon: A.none()
                                            }, "cancel", e)),
                                            a = EL(),
                                            i = TL(r, t.providers),
                                            l = Ka(RL({
                                                lazySink: () => t.getSink(),
                                                header: OL(a, i),
                                                body: AL(o, t.providers),
                                                footer: A.some(ML(NL([], [s.asSpec()]))),
                                                onEscape: r,
                                                extraClasses: ["tox-alert-dialog"],
                                                extraBehaviours: [],
                                                extraStyles: {},
                                                dialogEvents: [Ds(zx, r)],
                                                eventOrder: {}
                                            }));
                                        SR.show(l);
                                        const c = s.get(l);
                                        Zh.focus(c)
                                    }
                                }
                            })(e.backstages.dialog),
                            r = (e => {
                                const t = e.shared;
                                return {
                                    open: (o, n) => {
                                        const r = e => {
                                                SR.hide(c), n(e)
                                            },
                                            s = Mp(g_({
                                                name: "yes",
                                                text: "Yes",
                                                primary: !0,
                                                buttonType: A.some("primary"),
                                                align: "end",
                                                enabled: !0,
                                                icon: A.none()
                                            }, "submit", e)),
                                            a = g_({
                                                name: "no",
                                                text: "No",
                                                primary: !1,
                                                buttonType: A.some("secondary"),
                                                align: "end",
                                                enabled: !0,
                                                icon: A.none()
                                            }, "cancel", e),
                                            i = EL(),
                                            l = TL((() => r(!1)), t.providers),
                                            c = Ka(RL({
                                                lazySink: () => t.getSink(),
                                                header: OL(i, l),
                                                body: AL(o, t.providers),
                                                footer: A.some(ML(NL([], [a, s.asSpec()]))),
                                                onEscape: () => r(!1),
                                                extraClasses: ["tox-confirm-dialog"],
                                                extraBehaviours: [],
                                                extraStyles: {},
                                                dialogEvents: [Ds(zx, (() => r(!1))), Ds(Vx, (() => r(!0)))],
                                                eventOrder: {}
                                            }));
                                        SR.show(c);
                                        const d = s.get(c);
                                        Zh.focus(d)
                                    }
                                }
                            })(e.backstages.dialog),
                            s = (t, o) => JD.open(((t, n, r) => {
                                const s = n,
                                    a = ((e, t, o) => {
                                        const n = Qs("dialog"),
                                            r = e.internalDialog,
                                            s = HL(r.title, n, o),
                                            a = ((e, t, o) => {
                                                const n = SB(e, t, A.none(), o, !1);
                                                return SR.parts.body(n)
                                            })({
                                                body: r.body,
                                                initialData: r.initialData
                                            }, n, o),
                                            i = FL(r.buttons),
                                            l = VL(i),
                                            c = $L({
                                                buttons: i
                                            }, n, o),
                                            d = UL((() => p), PL((() => g), o.shared.providers, t), o.shared.getSink),
                                            u = (e => {
                                                switch (e) {
                                                    case "large":
                                                        return ["tox-dialog--width-lg"];
                                                    case "medium":
                                                        return ["tox-dialog--width-md"];
                                                    default:
                                                        return []
                                                }
                                            })(r.size),
                                            m = {
                                                id: n,
                                                header: s,
                                                body: a,
                                                footer: A.some(c),
                                                extraClasses: u,
                                                extraBehaviours: [],
                                                extraStyles: {}
                                            },
                                            g = zL(m, e, d, o),
                                            h = {
                                                getId: y(n),
                                                getRoot: y(g),
                                                getBody: () => SR.getBody(g),
                                                getFooter: () => SR.getFooter(g),
                                                getFormWrapper: () => {
                                                    const e = SR.getBody(g);
                                                    return cm.getCurrent(e).getOr(e)
                                                }
                                            },
                                            p = GL(h, t.redial, l);
                                        return {
                                            dialog: g,
                                            instanceApi: p
                                        }
                                    })({
                                        dataValidator: r,
                                        initialData: s,
                                        internalDialog: t
                                    }, {
                                        redial: JD.redial,
                                        closeWindow: () => {
                                            SR.hide(a.dialog), o(a.instanceApi)
                                        }
                                    }, e.backstages.dialog);
                                return SR.show(a.dialog), a.instanceApi.setData(s), a.instanceApi
                            }), t),
                            a = (n, r, s, a = !1) => JD.open(((n, i, l) => {
                                const c = Vn(Fn("data", l, i)),
                                    d = Zl(),
                                    u = e.backstages.popup.shared.header.isPositionedAtTop(),
                                    m = () => d.on((e => {
                                        Tp.reposition(e), vT.refresh(e)
                                    })),
                                    g = ((e, t, o, n) => {
                                        const r = Qs("dialog"),
                                            s = Qs("dialog-label"),
                                            a = Qs("dialog-content"),
                                            i = e.internalDialog,
                                            l = Mp(((e, t, o, n) => kx.sketch({
                                                dom: mE('<div class="tox-dialog__header"></div>'),
                                                components: [BL(e, t, A.some(o), n), LL(), DL(n)],
                                                containerBehaviours: gl([lR.config({
                                                    mode: "mouse",
                                                    blockerClass: "blocker",
                                                    getTarget: e => si(e, '[role="dialog"]').getOrDie(),
                                                    snaps: {
                                                        getSnapPoints: () => [],
                                                        leftAttr: "data-drag-left",
                                                        topAttr: "data-drag-top"
                                                    }
                                                })])
                                            }))({
                                                title: i.title,
                                                draggable: !0
                                            }, r, s, o.shared.providers)),
                                            c = Mp(((e, t, o, n, r) => SB(e, t, A.some(o), n, r))({
                                                body: i.body,
                                                initialData: i.initialData
                                            }, r, a, o, n)),
                                            d = FL(i.buttons),
                                            u = VL(d),
                                            m = Mp(((e, t, o) => WL(e, t, o))({
                                                buttons: d
                                            }, r, o)),
                                            g = UL((() => p), {
                                                onBlock: e => {
                                                    uE.block(h, ((t, n) => IL(e.message, n, o.shared.providers)))
                                                },
                                                onUnblock: () => {
                                                    uE.unblock(h)
                                                },
                                                onClose: () => t.closeWindow()
                                            }, o.shared.getSink),
                                            h = Ka({
                                                dom: {
                                                    tag: "div",
                                                    classes: ["tox-dialog", "tox-dialog-inline"],
                                                    attributes: {
                                                        role: "dialog",
                                                        "aria-labelledby": s,
                                                        "aria-describedby": a
                                                    }
                                                },
                                                eventOrder: {
                                                    [os()]: [KA.name(), yl.name()],
                                                    [ns()]: ["execute-on-form"],
                                                    [hs()]: ["reflecting", "execute-on-form"]
                                                },
                                                behaviours: gl([Th.config({
                                                    mode: "cyclic",
                                                    onEscape: e => (ks(e, Px), A.some(!0)),
                                                    useTabstopAt: e => !vk(e) && ("button" !== ze(e) || "disabled" !== wt(e, "disabled"))
                                                }), KA.config({
                                                    channel: `${bB}-${r}`,
                                                    updateState: (e, t) => A.some(t),
                                                    initialData: e
                                                }), Zh.config({}), Ih("execute-on-form", g.concat([Fs(Fr(), ((e, t) => {
                                                    Th.focusIn(e)
                                                }))])), uE.config({
                                                    getRoot: () => A.some(h)
                                                }), Hh.config({}), ik({})]),
                                                components: [l.asSpec(), c.asSpec(), m.asSpec()]
                                            }),
                                            p = GL({
                                                getId: y(r),
                                                getRoot: y(h),
                                                getFooter: () => m.get(h),
                                                getBody: () => c.get(h),
                                                getFormWrapper: () => {
                                                    const e = c.get(h);
                                                    return cm.getCurrent(e).getOr(e)
                                                }
                                            }, t.redial, u);
                                        return {
                                            dialog: h,
                                            instanceApi: p
                                        }
                                    })({
                                        dataValidator: l,
                                        initialData: c,
                                        internalDialog: n
                                    }, {
                                        redial: JD.redial,
                                        closeWindow: () => {
                                            d.on(Tp.hide), t.off("ResizeEditor", m), d.clear(), s(g.instanceApi)
                                        }
                                    }, e.backstages.popup, a),
                                    h = Ka(Tp.sketch({
                                        lazySink: e.backstages.popup.shared.getSink,
                                        dom: {
                                            tag: "div",
                                            classes: []
                                        },
                                        fireDismissalEventInstead: {},
                                        ...u ? {} : {
                                            fireRepositionEventInstead: {}
                                        },
                                        inlineBehaviours: gl([Ih("window-manager-inline-events", [Ds(fs(), ((e, t) => {
                                            ks(g.dialog, zx)
                                        }))]), ...QL(t, o, u)]),
                                        isExtraPart: (e, t) => (e => hx(e, ".tox-alert-dialog") || hx(e, ".tox-confirm-dialog"))(t)
                                    }));
                                return d.set(h), Tp.showWithin(h, Ya(g.dialog), {
                                    anchor: r
                                }, A.some(pt())), o && u || (vT.refresh(h), t.on("ResizeEditor", m)), g.instanceApi.setData(c), Th.focusIn(g.dialog), g.instanceApi
                            }), n);
                        return {
                            open: (t, o, n) => void 0 !== o && "toolbar" === o.inline ? a(t, e.backstages.popup.shared.anchors.inlineDialog(), n, o.ariaAttrs) : void 0 !== o && "cursor" === o.inline ? a(t, e.backstages.popup.shared.anchors.cursor(), n, o.ariaAttrs) : s(t, n),
                            openUrl: (o, n) => ((o, n) => JD.openUrl((o => {
                                const r = JL(o, {
                                    closeWindow: () => {
                                        SR.hide(r.dialog), n(r.instanceApi)
                                    }
                                }, t, e.backstages.dialog);
                                return SR.show(r.dialog), r.instanceApi
                            }), o))(o, n),
                            alert: (e, t) => {
                                n.open(e, t)
                            },
                            close: e => {
                                e.close()
                            },
                            confirm: (e, t) => {
                                r.open(e, t)
                            }
                        }
                    };
                E.add("silver", (e => {
                    (e => {
                        Yp(e), (e => {
                            const t = e.options.register,
                                o = e => f(e, s) ? {
                                    value: lw(e),
                                    valid: !0
                                } : {
                                    valid: !1,
                                    message: "Must be an array of strings."
                                };
                            t("color_map", {
                                processor: o,
                                default: ["#BFEDD2", "Light Green", "#FBEEB8", "Light Yellow", "#F8CAC6", "Light Red", "#ECCAFA", "Light Purple", "#C2E0F4", "Light Blue", "#2DC26B", "Green", "#F1C40F", "Yellow", "#E03E2D", "Red", "#B96AD9", "Purple", "#3598DB", "Blue", "#169179", "Dark Turquoise", "#E67E23", "Orange", "#BA372A", "Dark Red", "#843FA1", "Dark Purple", "#236FA1", "Dark Blue", "#ECF0F1", "Light Gray", "#CED4D9", "Medium Gray", "#95A5A6", "Gray", "#7E8C8D", "Dark Gray", "#34495E", "Navy Blue", "#000000", "Black", "#ffffff", "White"]
                            }), t("color_map_background", {
                                processor: o
                            }), t("color_map_foreground", {
                                processor: o
                            }), t("color_cols", {
                                processor: "number",
                                default: iw(gw(e, "default").length)
                            }), t("color_cols_foreground", {
                                processor: "number",
                                default: iw(gw(e, sw).length)
                            }), t("color_cols_background", {
                                processor: "number",
                                default: iw(gw(e, aw).length)
                            }), t("custom_colors", {
                                processor: "boolean",
                                default: !0
                            }), t("color_default_foreground", {
                                processor: "string",
                                default: dw
                            }), t("color_default_background", {
                                processor: "string",
                                default: dw
                            })
                        })(e), (e => {
                            const t = e.options.register;
                            t("contextmenu_avoid_overlap", {
                                processor: "string",
                                default: ""
                            }), t("contextmenu_never_use_native", {
                                processor: "boolean",
                                default: !1
                            }), t("contextmenu", {
                                processor: e => !1 === e ? {
                                    value: [],
                                    valid: !0
                                } : s(e) || f(e, s) ? {
                                    value: nN(e),
                                    valid: !0
                                } : {
                                    valid: !1,
                                    message: "Must be false or a string."
                                },
                                default: "link linkchecker image editimage table spellchecker configurepermanentpen"
                            })
                        })(e)
                    })(e);
                    const {
                        dialogs: t,
                        popups: o,
                        renderUI: n
                    } = yR(e);
                    gx(e, o.backstage.shared);
                    const r = eH({
                        editor: e,
                        backstages: {
                            popup: o.backstage,
                            dialog: t.backstage
                        }
                    });
                    return {
                        renderUI: n,
                        getWindowManagerImpl: y(r),
                        getNotificationManagerImpl: () => ((e, t, o) => {
                            const n = t.backstage.shared,
                                r = () => {
                                    const t = $o(Be(e.getContentAreaContainer())),
                                        o = Go(),
                                        n = zi(o.x, t.x, t.right),
                                        r = zi(o.y, t.y, t.bottom),
                                        s = Math.max(t.right, o.right),
                                        a = Math.max(t.bottom, o.bottom);
                                    return A.some(Wo(n, r, s - n, a - r))
                                };
                            return {
                                open: (t, s) => {
                                    const a = () => {
                                            s(), Tp.hide(l)
                                        },
                                        i = Ka(Zp.sketch({
                                            text: t.text,
                                            level: L(["success", "error", "warning", "warn", "info"], t.type) ? t.type : void 0,
                                            progress: !0 === t.progressBar,
                                            icon: t.icon,
                                            closeButton: t.closeButton,
                                            onAction: a,
                                            iconProvider: n.providers.icons,
                                            translationProvider: n.providers.translate
                                        })),
                                        l = Ka(Tp.sketch({
                                            dom: {
                                                tag: "div",
                                                classes: ["tox-notifications-container"]
                                            },
                                            lazySink: n.getSink,
                                            fireDismissalEventInstead: {},
                                            ...n.header.isPositionedAtTop() ? {} : {
                                                fireRepositionEventInstead: {}
                                            }
                                        }));
                                    o.add(l), p(t.timeout) && t.timeout > 0 && Ep.setEditorTimeout(e, (() => {
                                        a()
                                    }), t.timeout);
                                    const c = {
                                        close: a,
                                        reposition: () => {
                                            const t = Ya(i),
                                                o = {
                                                    maxHeightFunction: Jl()
                                                },
                                                s = e.notificationManager.getNotifications();
                                            if (s[0] === c) {
                                                const e = { ...n.anchors.banner(),
                                                    overrides: o
                                                };
                                                Tp.showWithinBounds(l, t, {
                                                    anchor: e
                                                }, r)
                                            } else B(s, c).each((e => {
                                                const n = s[e - 1].getEl(),
                                                    a = {
                                                        type: "node",
                                                        root: pt(),
                                                        node: A.some(Be(n)),
                                                        overrides: o,
                                                        layouts: {
                                                            onRtl: () => [Qi],
                                                            onLtr: () => [Qi]
                                                        }
                                                    };
                                                Tp.showWithinBounds(l, t, {
                                                    anchor: a
                                                }, r)
                                            }))
                                        },
                                        text: e => {
                                            Zp.updateText(i, e)
                                        },
                                        settings: t,
                                        getEl: () => i.element.dom,
                                        progressBar: {
                                            value: e => {
                                                Zp.updateProgress(i, e)
                                            }
                                        }
                                    };
                                    return c
                                },
                                close: e => {
                                    e.close()
                                },
                                getArgs: e => e.settings
                            }
                        })(e, {
                            backstage: o.backstage
                        }, o.getMothership())
                    }
                }))
            }()
        },
        47575: function(e) {
            ! function() {
                "use strict";
                var t = function(e) {
                        if (null === e) return "null";
                        if (void 0 === e) return "undefined";
                        var t = typeof e;
                        return "object" === t && (Array.prototype.isPrototypeOf(e) || e.constructor && "Array" === e.constructor.name) ? "array" : "object" === t && (String.prototype.isPrototypeOf(e) || e.constructor && "String" === e.constructor.name) ? "string" : t
                    },
                    o = function(e) {
                        return {
                            eq: e
                        }
                    },
                    n = o((function(e, t) {
                        return e === t
                    })),
                    r = function(e) {
                        return o((function(t, o) {
                            if (t.length !== o.length) return !1;
                            for (var n = t.length, r = 0; r < n; r++)
                                if (!e.eq(t[r], o[r])) return !1;
                            return !0
                        }))
                    },
                    s = function(e) {
                        return o((function(t, s) {
                            var a = Object.keys(t),
                                i = Object.keys(s);
                            if (! function(e, t) {
                                    return function(e, t) {
                                        return o((function(o, n) {
                                            return e.eq(t(o), t(n))
                                        }))
                                    }(r(e), (function(e) {
                                        return function(e, t) {
                                            return Array.prototype.slice.call(e).sort(t)
                                        }(e, t)
                                    }))
                                }(n).eq(a, i)) return !1;
                            for (var l = a.length, c = 0; c < l; c++) {
                                var d = a[c];
                                if (!e.eq(t[d], s[d])) return !1
                            }
                            return !0
                        }))
                    },
                    a = o((function(e, o) {
                        if (e === o) return !0;
                        var n = t(e);
                        return n === t(o) && (function(e) {
                            return -1 !== ["undefined", "boolean", "number", "string", "function", "xml", "null"].indexOf(e)
                        }(n) ? e === o : "array" === n ? r(a).eq(e, o) : "object" === n && s(a).eq(e, o))
                    }));
                const i = Object.getPrototypeOf,
                    l = (e, t, o) => {
                        var n;
                        return !!o(e, t.prototype) || (null === (n = e.constructor) || void 0 === n ? void 0 : n.name) === t.name
                    },
                    c = e => t => (e => {
                        const t = typeof e;
                        return null === e ? "null" : "object" === t && Array.isArray(e) ? "array" : "object" === t && l(e, String, ((e, t) => t.isPrototypeOf(e))) ? "string" : t
                    })(t) === e,
                    d = e => t => typeof t === e,
                    u = e => t => e === t,
                    m = (e, t) => h(e) && l(e, t, ((e, t) => i(e) === t)),
                    g = c("string"),
                    h = c("object"),
                    p = e => m(e, Object),
                    f = c("array"),
                    v = u(null),
                    b = d("boolean"),
                    y = u(void 0),
                    w = e => null == e,
                    x = e => !w(e),
                    C = d("function"),
                    S = d("number"),
                    k = (e, t) => {
                        if (f(e)) {
                            for (let o = 0, n = e.length; o < n; ++o)
                                if (!t(e[o])) return !1;
                            return !0
                        }
                        return !1
                    },
                    _ = () => {},
                    O = (e, t) => (...o) => e(t.apply(null, o)),
                    T = (e, t) => o => e(t(o)),
                    E = e => () => e,
                    A = e => e,
                    M = (e, t) => e === t;

                function N(e, ...t) {
                    return (...o) => {
                        const n = t.concat(o);
                        return e.apply(null, n)
                    }
                }
                const R = e => t => !e(t),
                    D = e => e(),
                    B = e => {
                        e()
                    },
                    L = E(!1),
                    H = E(!0);
                class I {
                    constructor(e, t) {
                        this.tag = e, this.value = t
                    }
                    static some(e) {
                        return new I(!0, e)
                    }
                    static none() {
                        return I.singletonNone
                    }
                    fold(e, t) {
                        return this.tag ? t(this.value) : e()
                    }
                    isSome() {
                        return this.tag
                    }
                    isNone() {
                        return !this.tag
                    }
                    map(e) {
                        return this.tag ? I.some(e(this.value)) : I.none()
                    }
                    bind(e) {
                        return this.tag ? e(this.value) : I.none()
                    }
                    exists(e) {
                        return this.tag && e(this.value)
                    }
                    forall(e) {
                        return !this.tag || e(this.value)
                    }
                    filter(e) {
                        return !this.tag || e(this.value) ? this : I.none()
                    }
                    getOr(e) {
                        return this.tag ? this.value : e
                    }
                    or(e) {
                        return this.tag ? this : e
                    }
                    getOrThunk(e) {
                        return this.tag ? this.value : e()
                    }
                    orThunk(e) {
                        return this.tag ? this : e()
                    }
                    getOrDie(e) {
                        if (this.tag) return this.value;
                        throw new Error(null != e ? e : "Called getOrDie on None")
                    }
                    static from(e) {
                        return x(e) ? I.some(e) : I.none()
                    }
                    getOrNull() {
                        return this.tag ? this.value : null
                    }
                    getOrUndefined() {
                        return this.value
                    }
                    each(e) {
                        this.tag && e(this.value)
                    }
                    toArray() {
                        return this.tag ? [this.value] : []
                    }
                    toString() {
                        return this.tag ? `some(${this.value})` : "none()"
                    }
                }
                I.singletonNone = new I(!1);
                const P = Array.prototype.slice,
                    z = Array.prototype.indexOf,
                    F = Array.prototype.push,
                    V = (e, t) => z.call(e, t),
                    Z = (e, t) => V(e, t) > -1,
                    U = (e, t) => {
                        for (let o = 0, n = e.length; o < n; o++)
                            if (t(e[o], o)) return !0;
                        return !1
                    },
                    j = (e, t) => {
                        const o = e.length,
                            n = new Array(o);
                        for (let r = 0; r < o; r++) {
                            const o = e[r];
                            n[r] = t(o, r)
                        }
                        return n
                    },
                    W = (e, t) => {
                        for (let o = 0, n = e.length; o < n; o++) t(e[o], o)
                    },
                    $ = (e, t) => {
                        for (let o = e.length - 1; o >= 0; o--) t(e[o], o)
                    },
                    q = (e, t) => {
                        const o = [],
                            n = [];
                        for (let r = 0, s = e.length; r < s; r++) {
                            const s = e[r];
                            (t(s, r) ? o : n).push(s)
                        }
                        return {
                            pass: o,
                            fail: n
                        }
                    },
                    G = (e, t) => {
                        const o = [];
                        for (let n = 0, r = e.length; n < r; n++) {
                            const r = e[n];
                            t(r, n) && o.push(r)
                        }
                        return o
                    },
                    K = (e, t, o) => ($(e, ((e, n) => {
                        o = t(o, e, n)
                    })), o),
                    Y = (e, t, o) => (W(e, ((e, n) => {
                        o = t(o, e, n)
                    })), o),
                    X = (e, t, o) => {
                        for (let n = 0, r = e.length; n < r; n++) {
                            const r = e[n];
                            if (t(r, n)) return I.some(r);
                            if (o(r, n)) break
                        }
                        return I.none()
                    },
                    J = (e, t) => X(e, t, L),
                    Q = (e, t) => {
                        for (let o = 0, n = e.length; o < n; o++)
                            if (t(e[o], o)) return I.some(o);
                        return I.none()
                    },
                    ee = e => {
                        const t = [];
                        for (let o = 0, n = e.length; o < n; ++o) {
                            if (!f(e[o])) throw new Error("Arr.flatten item " + o + " was not an array, input: " + e);
                            F.apply(t, e[o])
                        }
                        return t
                    },
                    te = (e, t) => ee(j(e, t)),
                    oe = (e, t) => {
                        for (let o = 0, n = e.length; o < n; ++o)
                            if (!0 !== t(e[o], o)) return !1;
                        return !0
                    },
                    ne = e => {
                        const t = P.call(e, 0);
                        return t.reverse(), t
                    },
                    re = (e, t) => G(e, (e => !Z(t, e))),
                    se = (e, t) => {
                        const o = {};
                        for (let n = 0, r = e.length; n < r; n++) {
                            const r = e[n];
                            o[String(r)] = t(r, n)
                        }
                        return o
                    },
                    ae = (e, t) => {
                        const o = P.call(e, 0);
                        return o.sort(t), o
                    },
                    ie = (e, t) => t >= 0 && t < e.length ? I.some(e[t]) : I.none(),
                    le = e => ie(e, 0),
                    ce = e => ie(e, e.length - 1),
                    de = C(Array.from) ? Array.from : e => P.call(e),
                    ue = (e, t) => {
                        for (let o = 0; o < e.length; o++) {
                            const n = t(e[o], o);
                            if (n.isSome()) return n
                        }
                        return I.none()
                    },
                    me = Object.keys,
                    ge = Object.hasOwnProperty,
                    he = (e, t) => {
                        const o = me(e);
                        for (let n = 0, r = o.length; n < r; n++) {
                            const r = o[n];
                            t(e[r], r)
                        }
                    },
                    pe = (e, t) => fe(e, ((e, o) => ({
                        k: o,
                        v: t(e, o)
                    }))),
                    fe = (e, t) => {
                        const o = {};
                        return he(e, ((e, n) => {
                            const r = t(e, n);
                            o[r.k] = r.v
                        })), o
                    },
                    ve = e => (t, o) => {
                        e[o] = t
                    },
                    be = (e, t, o, n) => {
                        he(e, ((e, r) => {
                            (t(e, r) ? o : n)(e, r)
                        }))
                    },
                    ye = (e, t) => {
                        const o = {};
                        return be(e, t, ve(o), _), o
                    },
                    we = (e, t) => {
                        const o = [];
                        return he(e, ((e, n) => {
                            o.push(t(e, n))
                        })), o
                    },
                    xe = e => we(e, A),
                    Ce = (e, t) => Se(e, t) ? I.from(e[t]) : I.none(),
                    Se = (e, t) => ge.call(e, t),
                    ke = (e, t) => Se(e, t) && void 0 !== e[t] && null !== e[t],
                    _e = e => {
                        const t = {};
                        return W(e, (e => {
                            t[e] = {}
                        })), me(t)
                    },
                    Oe = e => void 0 !== e.length,
                    Te = Array.isArray,
                    Ee = (e, t, o) => {
                        if (!e) return !1;
                        if (o = o || e, Oe(e)) {
                            for (let n = 0, r = e.length; n < r; n++)
                                if (!1 === t.call(o, e[n], n, e)) return !1
                        } else
                            for (const n in e)
                                if (Se(e, n) && !1 === t.call(o, e[n], n, e)) return !1;
                        return !0
                    },
                    Ae = (e, t) => {
                        const o = [];
                        return Ee(e, ((n, r) => {
                            o.push(t(n, r, e))
                        })), o
                    },
                    Me = (e, t) => {
                        const o = [];
                        return Ee(e, ((n, r) => {
                            t && !t(n, r, e) || o.push(n)
                        })), o
                    },
                    Ne = (e, t, o, n) => {
                        let r = y(o) ? e[0] : o;
                        for (let o = 0; o < e.length; o++) r = t.call(n, r, e[o], o);
                        return r
                    },
                    Re = (e, t, o) => {
                        for (let n = 0, r = e.length; n < r; n++)
                            if (t.call(o, e[n], n, e)) return n;
                        return -1
                    },
                    De = e => e[e.length - 1],
                    Be = e => {
                        let t, o = !1;
                        return (...n) => (o || (o = !0, t = e.apply(null, n)), t)
                    },
                    Le = () => He(0, 0),
                    He = (e, t) => ({
                        major: e,
                        minor: t
                    }),
                    Ie = {
                        nu: He,
                        detect: (e, t) => {
                            const o = String(t).toLowerCase();
                            return 0 === e.length ? Le() : ((e, t) => {
                                const o = ((e, t) => {
                                    for (let o = 0; o < e.length; o++) {
                                        const n = e[o];
                                        if (n.test(t)) return n
                                    }
                                })(e, t);
                                if (!o) return {
                                    major: 0,
                                    minor: 0
                                };
                                const n = e => Number(t.replace(o, "$" + e));
                                return He(n(1), n(2))
                            })(e, o)
                        },
                        unknown: Le
                    },
                    Pe = (e, t) => {
                        const o = String(t).toLowerCase();
                        return J(e, (e => e.search(o)))
                    },
                    ze = (e, t, o) => "" === t || e.length >= t.length && e.substr(o, o + t.length) === t,
                    Fe = (e, t, o = 0, n) => {
                        const r = e.indexOf(t, o);
                        return -1 !== r && (!!y(n) || r + t.length <= n)
                    },
                    Ve = (e, t) => ze(e, t, 0),
                    Ze = (e, t) => ze(e, t, e.length - t.length),
                    Ue = e => t => t.replace(e, ""),
                    je = Ue(/^\s+|\s+$/g),
                    We = Ue(/^\s+/g),
                    $e = Ue(/\s+$/g),
                    qe = e => e.length > 0,
                    Ge = e => !qe(e),
                    Ke = (e, t = 10) => {
                        const o = parseInt(e, t);
                        return isNaN(o) ? I.none() : I.some(o)
                    },
                    Ye = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/,
                    Xe = e => t => Fe(t, e),
                    Je = [{
                        name: "Edge",
                        versionRegexes: [/.*?edge\/ ?([0-9]+)\.([0-9]+)$/],
                        search: e => Fe(e, "edge/") && Fe(e, "chrome") && Fe(e, "safari") && Fe(e, "applewebkit")
                    }, {
                        name: "Chromium",
                        brand: "Chromium",
                        versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/, Ye],
                        search: e => Fe(e, "chrome") && !Fe(e, "chromeframe")
                    }, {
                        name: "IE",
                        versionRegexes: [/.*?msie\ ?([0-9]+)\.([0-9]+).*/, /.*?rv:([0-9]+)\.([0-9]+).*/],
                        search: e => Fe(e, "msie") || Fe(e, "trident")
                    }, {
                        name: "Opera",
                        versionRegexes: [Ye, /.*?opera\/([0-9]+)\.([0-9]+).*/],
                        search: Xe("opera")
                    }, {
                        name: "Firefox",
                        versionRegexes: [/.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/],
                        search: Xe("firefox")
                    }, {
                        name: "Safari",
                        versionRegexes: [Ye, /.*?cpu os ([0-9]+)_([0-9]+).*/],
                        search: e => (Fe(e, "safari") || Fe(e, "mobile/")) && Fe(e, "applewebkit")
                    }],
                    Qe = [{
                        name: "Windows",
                        search: Xe("win"),
                        versionRegexes: [/.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/]
                    }, {
                        name: "iOS",
                        search: e => Fe(e, "iphone") || Fe(e, "ipad"),
                        versionRegexes: [/.*?version\/\ ?([0-9]+)\.([0-9]+).*/, /.*cpu os ([0-9]+)_([0-9]+).*/, /.*cpu iphone os ([0-9]+)_([0-9]+).*/]
                    }, {
                        name: "Android",
                        search: Xe("android"),
                        versionRegexes: [/.*?android\ ?([0-9]+)\.([0-9]+).*/]
                    }, {
                        name: "macOS",
                        search: Xe("mac os x"),
                        versionRegexes: [/.*?mac\ os\ x\ ?([0-9]+)_([0-9]+).*/]
                    }, {
                        name: "Linux",
                        search: Xe("linux"),
                        versionRegexes: []
                    }, {
                        name: "Solaris",
                        search: Xe("sunos"),
                        versionRegexes: []
                    }, {
                        name: "FreeBSD",
                        search: Xe("freebsd"),
                        versionRegexes: []
                    }, {
                        name: "ChromeOS",
                        search: Xe("cros"),
                        versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/]
                    }],
                    et = {
                        browsers: E(Je),
                        oses: E(Qe)
                    },
                    tt = "Edge",
                    ot = "Chromium",
                    nt = "Opera",
                    rt = "Firefox",
                    st = "Safari",
                    at = e => {
                        const t = e.current,
                            o = e.version,
                            n = e => () => t === e;
                        return {
                            current: t,
                            version: o,
                            isEdge: n(tt),
                            isChromium: n(ot),
                            isIE: n("IE"),
                            isOpera: n(nt),
                            isFirefox: n(rt),
                            isSafari: n(st)
                        }
                    },
                    it = () => at({
                        current: void 0,
                        version: Ie.unknown()
                    }),
                    lt = at,
                    ct = (E(tt), E(ot), E("IE"), E(nt), E(rt), E(st), "Windows"),
                    dt = "Android",
                    ut = "Linux",
                    mt = "macOS",
                    gt = "Solaris",
                    ht = "FreeBSD",
                    pt = "ChromeOS",
                    ft = e => {
                        const t = e.current,
                            o = e.version,
                            n = e => () => t === e;
                        return {
                            current: t,
                            version: o,
                            isWindows: n(ct),
                            isiOS: n("iOS"),
                            isAndroid: n(dt),
                            isMacOS: n(mt),
                            isLinux: n(ut),
                            isSolaris: n(gt),
                            isFreeBSD: n(ht),
                            isChromeOS: n(pt)
                        }
                    },
                    vt = () => ft({
                        current: void 0,
                        version: Ie.unknown()
                    }),
                    bt = ft,
                    yt = (E(ct), E("iOS"), E(dt), E(ut), E(mt), E(gt), E(ht), E(pt), e => window.matchMedia(e).matches);
                let wt = Be((() => ((e, t, o) => {
                    const n = et.browsers(),
                        r = et.oses(),
                        s = t.bind((e => ((e, t) => ue(t.brands, (t => {
                            const o = t.brand.toLowerCase();
                            return J(e, (e => {
                                var t;
                                return o === (null === (t = e.brand) || void 0 === t ? void 0 : t.toLowerCase())
                            })).map((e => ({
                                current: e.name,
                                version: Ie.nu(parseInt(t.version, 10), 0)
                            })))
                        })))(n, e))).orThunk((() => ((e, t) => Pe(e, t).map((e => {
                            const o = Ie.detect(e.versionRegexes, t);
                            return {
                                current: e.name,
                                version: o
                            }
                        })))(n, e))).fold(it, lt),
                        a = ((e, t) => Pe(e, t).map((e => {
                            const o = Ie.detect(e.versionRegexes, t);
                            return {
                                current: e.name,
                                version: o
                            }
                        })))(r, e).fold(vt, bt),
                        i = ((e, t, o, n) => {
                            const r = e.isiOS() && !0 === /ipad/i.test(o),
                                s = e.isiOS() && !r,
                                a = e.isiOS() || e.isAndroid(),
                                i = a || n("(pointer:coarse)"),
                                l = r || !s && a && n("(min-device-width:768px)"),
                                c = s || a && !l,
                                d = t.isSafari() && e.isiOS() && !1 === /safari/i.test(o),
                                u = !c && !l && !d;
                            return {
                                isiPad: E(r),
                                isiPhone: E(s),
                                isTablet: E(l),
                                isPhone: E(c),
                                isTouch: E(i),
                                isAndroid: e.isAndroid,
                                isiOS: e.isiOS,
                                isWebView: E(d),
                                isDesktop: E(u)
                            }
                        })(a, s, e, o);
                    return {
                        browser: s,
                        os: a,
                        deviceType: i
                    }
                })(navigator.userAgent, I.from(navigator.userAgentData), yt)));
                const xt = () => wt(),
                    Ct = navigator.userAgent,
                    St = xt(),
                    kt = St.browser,
                    _t = St.os,
                    Ot = St.deviceType,
                    Tt = -1 !== Ct.indexOf("Windows Phone"),
                    Et = {
                        transparentSrc: "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
                        documentMode: kt.isIE() ? document.documentMode || 7 : 10,
                        cacheSuffix: null,
                        container: null,
                        canHaveCSP: !kt.isIE(),
                        windowsPhone: Tt,
                        browser: {
                            current: kt.current,
                            version: kt.version,
                            isChromium: kt.isChromium,
                            isEdge: kt.isEdge,
                            isFirefox: kt.isFirefox,
                            isIE: kt.isIE,
                            isOpera: kt.isOpera,
                            isSafari: kt.isSafari
                        },
                        os: {
                            current: _t.current,
                            version: _t.version,
                            isAndroid: _t.isAndroid,
                            isChromeOS: _t.isChromeOS,
                            isFreeBSD: _t.isFreeBSD,
                            isiOS: _t.isiOS,
                            isLinux: _t.isLinux,
                            isMacOS: _t.isMacOS,
                            isSolaris: _t.isSolaris,
                            isWindows: _t.isWindows
                        },
                        deviceType: {
                            isDesktop: Ot.isDesktop,
                            isiPad: Ot.isiPad,
                            isiPhone: Ot.isiPhone,
                            isPhone: Ot.isPhone,
                            isTablet: Ot.isTablet,
                            isTouch: Ot.isTouch,
                            isWebView: Ot.isWebView
                        }
                    },
                    At = /^\s*|\s*$/g,
                    Mt = e => w(e) ? "" : ("" + e).replace(At, ""),
                    Nt = function(e, t, o, n) {
                        n = n || this, e && (o && (e = e[o]), Ee(e, ((e, r) => !1 !== t.call(n, e, r, o) && (Nt(e, t, o, n), !0))))
                    },
                    Rt = {
                        trim: Mt,
                        isArray: Te,
                        is: (e, t) => t ? !("array" !== t || !Te(e)) || typeof e === t : void 0 !== e,
                        toArray: e => {
                            if (Te(e)) return e; {
                                const t = [];
                                for (let o = 0, n = e.length; o < n; o++) t[o] = e[o];
                                return t
                            }
                        },
                        makeMap: (e, t, o = {}) => {
                            const n = g(e) ? e.split(t || ",") : e || [];
                            let r = n.length;
                            for (; r--;) o[n[r]] = {};
                            return o
                        },
                        each: Ee,
                        map: Ae,
                        grep: Me,
                        inArray: (e, t) => {
                            if (e)
                                for (let o = 0, n = e.length; o < n; o++)
                                    if (e[o] === t) return o;
                            return -1
                        },
                        hasOwn: Se,
                        extend: (e, ...t) => {
                            for (let o = 0; o < t.length; o++) {
                                const n = t[o];
                                for (const t in n)
                                    if (Se(n, t)) {
                                        const o = n[t];
                                        void 0 !== o && (e[t] = o)
                                    }
                            }
                            return e
                        },
                        walk: Nt,
                        resolve: (e, t = window) => {
                            const o = e.split(".");
                            for (let e = 0, n = o.length; e < n && (t = t[o[e]]); e++);
                            return t
                        },
                        explode: (e, t) => f(e) ? e : "" === e ? [] : Ae(e.split(t || ","), Mt),
                        _addCacheSuffix: e => {
                            const t = Et.cacheSuffix;
                            return t && (e += (-1 === e.indexOf("?") ? "?" : "&") + t), e
                        }
                    },
                    Dt = (e, t, o = M) => e.exists((e => o(e, t))),
                    Bt = (e, t, o) => e.isSome() && t.isSome() ? I.some(o(e.getOrDie(), t.getOrDie())) : I.none(),
                    Lt = (e, t) => e ? I.some(t) : I.none();
                "undefined" != typeof window ? window : Function("return this;")();
                const Ht = e => e.dom.nodeName.toLowerCase(),
                    It = e => e.dom.nodeType,
                    Pt = e => t => It(t) === e,
                    zt = Pt(1),
                    Ft = Pt(3),
                    Vt = Pt(9),
                    Zt = Pt(11),
                    Ut = e => t => zt(t) && Ht(t) === e,
                    jt = (e, t, o) => {
                        if (!(g(o) || b(o) || S(o))) throw console.error("Invalid call to Attribute.set. Key ", t, ":: Value ", o, ":: Element ", e), new Error("Attribute value was not simple");
                        e.setAttribute(t, o + "")
                    },
                    Wt = (e, t, o) => {
                        jt(e.dom, t, o)
                    },
                    $t = (e, t) => {
                        const o = e.dom;
                        he(t, ((e, t) => {
                            jt(o, t, e)
                        }))
                    },
                    qt = (e, t) => {
                        const o = e.dom.getAttribute(t);
                        return null === o ? void 0 : o
                    },
                    Gt = (e, t) => I.from(qt(e, t)),
                    Kt = (e, t) => {
                        const o = e.dom;
                        return !(!o || !o.hasAttribute) && o.hasAttribute(t)
                    },
                    Yt = (e, t) => {
                        e.dom.removeAttribute(t)
                    },
                    Xt = e => Y(e.dom.attributes, ((e, t) => (e[t.name] = t.value, e)), {}),
                    Jt = (e, t) => {
                        const o = qt(e, t);
                        return void 0 === o || "" === o ? [] : o.split(" ")
                    },
                    Qt = e => void 0 !== e.dom.classList,
                    eo = e => Jt(e, "class"),
                    to = (e, t) => ((e, t, o) => {
                        const n = Jt(e, t).concat([o]);
                        return Wt(e, t, n.join(" ")), !0
                    })(e, "class", t),
                    oo = (e, t) => ((e, t, o) => {
                        const n = G(Jt(e, t), (e => e !== o));
                        return n.length > 0 ? Wt(e, t, n.join(" ")) : Yt(e, t), !1
                    })(e, "class", t),
                    no = (e, t) => {
                        Qt(e) ? e.dom.classList.add(t) : to(e, t)
                    },
                    ro = e => {
                        0 === (Qt(e) ? e.dom.classList : eo(e)).length && Yt(e, "class")
                    },
                    so = (e, t) => {
                        Qt(e) ? e.dom.classList.remove(t) : oo(e, t), ro(e)
                    },
                    ao = (e, t) => Qt(e) && e.dom.classList.contains(t),
                    io = e => void 0 !== e.style && C(e.style.getPropertyValue),
                    lo = e => {
                        if (null == e) throw new Error("Node cannot be null or undefined");
                        return {
                            dom: e
                        }
                    },
                    co = (e, t) => {
                        const o = (t || document).createElement("div");
                        if (o.innerHTML = e, !o.hasChildNodes() || o.childNodes.length > 1) {
                            const t = "HTML does not have a single root node";
                            throw console.error(t, e), new Error(t)
                        }
                        return lo(o.childNodes[0])
                    },
                    uo = (e, t) => {
                        const o = (t || document).createElement(e);
                        return lo(o)
                    },
                    mo = (e, t) => {
                        const o = (t || document).createTextNode(e);
                        return lo(o)
                    },
                    go = lo,
                    ho = (e, t, o) => I.from(e.dom.elementFromPoint(t, o)).map(lo),
                    po = (e, t) => {
                        const o = [],
                            n = e => (o.push(e), t(e));
                        let r = t(e);
                        do {
                            r = r.bind(n)
                        } while (r.isSome());
                        return o
                    },
                    fo = (e, t) => {
                        const o = e.dom;
                        if (1 !== o.nodeType) return !1; {
                            const e = o;
                            if (void 0 !== e.matches) return e.matches(t);
                            if (void 0 !== e.msMatchesSelector) return e.msMatchesSelector(t);
                            if (void 0 !== e.webkitMatchesSelector) return e.webkitMatchesSelector(t);
                            if (void 0 !== e.mozMatchesSelector) return e.mozMatchesSelector(t);
                            throw new Error("Browser lacks native selectors")
                        }
                    },
                    vo = e => 1 !== e.nodeType && 9 !== e.nodeType && 11 !== e.nodeType || 0 === e.childElementCount,
                    bo = (e, t) => e.dom === t.dom,
                    yo = (e, t) => {
                        const o = e.dom,
                            n = t.dom;
                        return o !== n && o.contains(n)
                    },
                    wo = e => go(e.dom.ownerDocument),
                    xo = e => Vt(e) ? e : wo(e),
                    Co = e => go(xo(e).dom.defaultView),
                    So = e => I.from(e.dom.parentNode).map(go),
                    ko = e => I.from(e.dom.parentElement).map(go),
                    _o = (e, t) => {
                        const o = C(t) ? t : L;
                        let n = e.dom;
                        const r = [];
                        for (; null !== n.parentNode && void 0 !== n.parentNode;) {
                            const e = n.parentNode,
                                t = go(e);
                            if (r.push(t), !0 === o(t)) break;
                            n = e
                        }
                        return r
                    },
                    Oo = e => I.from(e.dom.previousSibling).map(go),
                    To = e => I.from(e.dom.nextSibling).map(go),
                    Eo = e => ne(po(e, Oo)),
                    Ao = e => po(e, To),
                    Mo = e => j(e.dom.childNodes, go),
                    No = (e, t) => {
                        const o = e.dom.childNodes;
                        return I.from(o[t]).map(go)
                    },
                    Ro = e => No(e, 0),
                    Do = e => No(e, e.dom.childNodes.length - 1),
                    Bo = e => e.dom.childNodes.length,
                    Lo = e => Zt(e) && x(e.dom.host),
                    Ho = C(Element.prototype.attachShadow) && C(Node.prototype.getRootNode),
                    Io = E(Ho),
                    Po = Ho ? e => go(e.dom.getRootNode()) : xo,
                    zo = e => Lo(e) ? e : (e => {
                        const t = e.dom.head;
                        if (null == t) throw new Error("Head is not available yet");
                        return go(t)
                    })(xo(e)),
                    Fo = e => go(e.dom.host),
                    Vo = e => {
                        if (Io() && x(e.target)) {
                            const t = go(e.target);
                            if (zt(t) && Zo(t) && e.composed && e.composedPath) {
                                const t = e.composedPath();
                                if (t) return le(t)
                            }
                        }
                        return I.from(e.target)
                    },
                    Zo = e => x(e.dom.shadowRoot),
                    Uo = e => {
                        const t = Ft(e) ? e.dom.parentNode : e.dom;
                        if (null == t || null === t.ownerDocument) return !1;
                        const o = t.ownerDocument;
                        return (e => {
                            const t = Po(e);
                            return Lo(t) ? I.some(t) : I.none()
                        })(go(t)).fold((() => o.body.contains(t)), T(Uo, Fo))
                    },
                    jo = (e, t, o) => {
                        if (!g(o)) throw console.error("Invalid call to CSS.set. Property ", t, ":: Value ", o, ":: Element ", e), new Error("CSS value must be a string: " + o);
                        io(e) && e.style.setProperty(t, o)
                    },
                    Wo = (e, t, o) => {
                        const n = e.dom;
                        jo(n, t, o)
                    },
                    $o = (e, t) => {
                        const o = e.dom;
                        he(t, ((e, t) => {
                            jo(o, t, e)
                        }))
                    },
                    qo = (e, t) => {
                        const o = e.dom,
                            n = window.getComputedStyle(o).getPropertyValue(t);
                        return "" !== n || Uo(e) ? n : Go(o, t)
                    },
                    Go = (e, t) => io(e) ? e.style.getPropertyValue(t) : "",
                    Ko = (e, t) => {
                        const o = e.dom,
                            n = Go(o, t);
                        return I.from(n).filter((e => e.length > 0))
                    },
                    Yo = e => {
                        const t = {},
                            o = e.dom;
                        if (io(o))
                            for (let e = 0; e < o.style.length; e++) {
                                const n = o.style.item(e);
                                t[n] = o.style[n]
                            }
                        return t
                    },
                    Xo = (e, t) => {
                        ((e, t) => {
                            io(e) && e.style.removeProperty(t)
                        })(e.dom, t), Dt(Gt(e, "style").map(je), "") && Yt(e, "style")
                    },
                    Jo = (e, t) => {
                        So(e).each((o => {
                            o.dom.insertBefore(t.dom, e.dom)
                        }))
                    },
                    Qo = (e, t) => {
                        To(e).fold((() => {
                            So(e).each((e => {
                                tn(e, t)
                            }))
                        }), (e => {
                            Jo(e, t)
                        }))
                    },
                    en = (e, t) => {
                        Ro(e).fold((() => {
                            tn(e, t)
                        }), (o => {
                            e.dom.insertBefore(t.dom, o.dom)
                        }))
                    },
                    tn = (e, t) => {
                        e.dom.appendChild(t.dom)
                    },
                    on = (e, t) => {
                        W(t, (t => {
                            tn(e, t)
                        }))
                    },
                    nn = e => {
                        e.dom.textContent = "", W(Mo(e), (e => {
                            rn(e)
                        }))
                    },
                    rn = e => {
                        const t = e.dom;
                        null !== t.parentNode && t.parentNode.removeChild(t)
                    },
                    sn = e => {
                        const t = Mo(e);
                        var o, n;
                        t.length > 0 && (o = e, W(n = t, ((e, t) => {
                            const r = 0 === t ? o : n[t - 1];
                            Qo(r, e)
                        }))), rn(e)
                    },
                    an = e => j(e, go),
                    ln = e => e.dom.innerHTML,
                    cn = (e, t) => {
                        const o = wo(e).dom,
                            n = go(o.createDocumentFragment()),
                            r = ((e, t) => {
                                const o = (t || document).createElement("div");
                                return o.innerHTML = e, Mo(go(o))
                            })(t, o);
                        on(n, r), nn(e), tn(e, n)
                    },
                    dn = (e, t, o, n) => ((e, t, o, n, r) => {
                        const s = ((e, t) => o => {
                            e(o) && t((e => {
                                const t = go(Vo(e).getOr(e.target)),
                                    o = () => e.stopPropagation(),
                                    n = () => e.preventDefault(),
                                    r = O(n, o);
                                return ((e, t, o, n, r, s, a) => ({
                                    target: e,
                                    x: t,
                                    y: o,
                                    stop: n,
                                    prevent: r,
                                    kill: s,
                                    raw: a
                                }))(t, e.clientX, e.clientY, o, n, r, e)
                            })(o))
                        })(o, n);
                        return e.dom.addEventListener(t, s, false), {
                            unbind: N(un, e, t, s, false)
                        }
                    })(e, t, o, n),
                    un = (e, t, o, n) => {
                        e.dom.removeEventListener(t, o, n)
                    },
                    mn = (e, t) => ({
                        left: e,
                        top: t,
                        translate: (o, n) => mn(e + o, t + n)
                    }),
                    gn = mn,
                    hn = (e, t) => void 0 !== e ? e : void 0 !== t ? t : 0,
                    pn = e => {
                        const t = e.dom,
                            o = t.ownerDocument.body;
                        return o === t ? gn(o.offsetLeft, o.offsetTop) : Uo(e) ? (e => {
                            const t = e.getBoundingClientRect();
                            return gn(t.left, t.top)
                        })(t) : gn(0, 0)
                    },
                    fn = e => {
                        const t = void 0 !== e ? e.dom : document,
                            o = t.body.scrollLeft || t.documentElement.scrollLeft,
                            n = t.body.scrollTop || t.documentElement.scrollTop;
                        return gn(o, n)
                    },
                    vn = (e, t, o) => {
                        const n = (void 0 !== o ? o.dom : document).defaultView;
                        n && n.scrollTo(e, t)
                    },
                    bn = (e, t) => {
                        xt().browser.isSafari() && C(e.dom.scrollIntoViewIfNeeded) ? e.dom.scrollIntoViewIfNeeded(!1) : e.dom.scrollIntoView(t)
                    },
                    yn = (e, t, o, n) => ({
                        x: e,
                        y: t,
                        width: o,
                        height: n,
                        right: e + o,
                        bottom: t + n
                    }),
                    wn = e => {
                        const t = void 0 === e ? window : e,
                            o = t.document,
                            n = fn(go(o));
                        return (e => {
                            const t = void 0 === e ? window : e;
                            return xt().browser.isFirefox() ? I.none() : I.from(t.visualViewport)
                        })(t).fold((() => {
                            const e = t.document.documentElement,
                                o = e.clientWidth,
                                r = e.clientHeight;
                            return yn(n.left, n.top, o, r)
                        }), (e => yn(Math.max(e.pageLeft, n.left), Math.max(e.pageTop, n.top), e.width, e.height)))
                    },
                    xn = (e, t) => {
                        let o = [];
                        return W(Mo(e), (e => {
                            t(e) && (o = o.concat([e])), o = o.concat(xn(e, t))
                        })), o
                    };
                var Cn = (e, t, o, n, r) => e(o, n) ? I.some(o) : C(r) && r(o) ? I.none() : t(o, n, r);
                const Sn = (e, t, o) => {
                        let n = e.dom;
                        const r = C(o) ? o : L;
                        for (; n.parentNode;) {
                            n = n.parentNode;
                            const e = go(n);
                            if (t(e)) return I.some(e);
                            if (r(e)) break
                        }
                        return I.none()
                    },
                    kn = (e, t, o) => Cn(((e, t) => t(e)), Sn, e, t, o),
                    _n = (e, t, o) => Sn(e, (e => fo(e, t)), o),
                    On = (e, t) => ((e, t) => {
                        const o = void 0 === t ? document : t.dom;
                        return vo(o) ? I.none() : I.from(o.querySelector(e)).map(go)
                    })(t, e),
                    Tn = (e, t, o) => Cn(((e, t) => fo(e, t)), _n, e, t, o),
                    En = (e, t, o) => _n(e, t, o).isSome();
                class An {
                    constructor(e, t) {
                        this.node = e, this.rootNode = t, this.current = this.current.bind(this), this.next = this.next.bind(this), this.prev = this.prev.bind(this), this.prev2 = this.prev2.bind(this)
                    }
                    current() {
                        return this.node
                    }
                    next(e) {
                        return this.node = this.findSibling(this.node, "firstChild", "nextSibling", e), this.node
                    }
                    prev(e) {
                        return this.node = this.findSibling(this.node, "lastChild", "previousSibling", e), this.node
                    }
                    prev2(e) {
                        return this.node = this.findPreviousNode(this.node, e), this.node
                    }
                    findSibling(e, t, o, n) {
                        if (e) {
                            if (!n && e[t]) return e[t];
                            if (e !== this.rootNode) {
                                let t = e[o];
                                if (t) return t;
                                for (let n = e.parentNode; n && n !== this.rootNode; n = n.parentNode)
                                    if (t = n[o], t) return t
                            }
                        }
                    }
                    findPreviousNode(e, t) {
                        if (e) {
                            const o = e.previousSibling;
                            if (this.rootNode && o === this.rootNode) return;
                            if (o) {
                                if (!t)
                                    for (let e = o.lastChild; e; e = e.lastChild)
                                        if (!e.lastChild) return e;
                                return o
                            }
                            const n = e.parentNode;
                            if (n && n !== this.rootNode) return n
                        }
                    }
                }
                const Mn = e => t => !!t && t.nodeType === e,
                    Nn = e => !!e && !Object.getPrototypeOf(e),
                    Rn = Mn(1),
                    Dn = e => {
                        const t = e.toLowerCase();
                        return e => x(e) && e.nodeName.toLowerCase() === t
                    },
                    Bn = e => {
                        const t = e.map((e => e.toLowerCase()));
                        return e => {
                            if (e && e.nodeName) {
                                const o = e.nodeName.toLowerCase();
                                return Z(t, o)
                            }
                            return !1
                        }
                    },
                    Ln = (e, t) => {
                        const o = t.toLowerCase().split(" ");
                        return t => {
                            if (Rn(t)) {
                                const n = t.ownerDocument.defaultView;
                                if (n)
                                    for (let r = 0; r < o.length; r++) {
                                        const s = n.getComputedStyle(t, null);
                                        if ((s ? s.getPropertyValue(e) : null) === o[r]) return !0
                                    }
                            }
                            return !1
                        }
                    },
                    Hn = e => t => Rn(t) && t.hasAttribute(e),
                    In = e => Rn(e) && e.hasAttribute("data-mce-bogus"),
                    Pn = e => Rn(e) && "TABLE" === e.tagName,
                    zn = e => t => {
                        if (Rn(t)) {
                            if (t.contentEditable === e) return !0;
                            if (t.getAttribute("data-mce-contenteditable") === e) return !0
                        }
                        return !1
                    },
                    Fn = Bn(["textarea", "input"]),
                    Vn = Mn(3),
                    Zn = Mn(4),
                    Un = Mn(7),
                    jn = Mn(8),
                    Wn = Mn(9),
                    $n = Mn(11),
                    qn = Dn("br"),
                    Gn = Dn("img"),
                    Kn = zn("true"),
                    Yn = zn("false"),
                    Xn = Bn(["td", "th"]),
                    Jn = Bn(["td", "th", "caption"]),
                    Qn = Bn(["video", "audio", "object", "embed"]),
                    er = Dn("li"),
                    tr = "\ufeff",
                    or = "",
                    nr = e => e === tr,
                    rr = (e, t) => ((e, t) => {
                        const o = void 0 === t ? document : t.dom;
                        return vo(o) ? [] : j(o.querySelectorAll(e), go)
                    })(t, e),
                    sr = ((e, t) => {
                        const o = t => e(t) ? I.from(t.dom.nodeValue) : I.none();
                        return {
                            get: t => {
                                if (!e(t)) throw new Error("Can only get text value of a text node");
                                return o(t).getOr("")
                            },
                            getOption: o,
                            set: (t, o) => {
                                if (!e(t)) throw new Error("Can only set raw text value of a text node");
                                t.dom.nodeValue = o
                            }
                        }
                    })(Ft),
                    ar = e => sr.get(e),
                    ir = e => sr.getOption(e),
                    lr = ["pre"].concat(["h1", "h2", "h3", "h4", "h5", "h6"]),
                    cr = e => {
                        let t;
                        return o => (t = t || se(e, H), Se(t, Ht(o)))
                    },
                    dr = cr(["article", "aside", "details", "div", "dt", "figcaption", "footer", "form", "fieldset", "header", "hgroup", "html", "main", "nav", "section", "summary", "body", "p", "dl", "multicol", "dd", "figure", "address", "center", "blockquote", "h1", "h2", "h3", "h4", "h5", "h6", "listing", "xmp", "pre", "plaintext", "menu", "dir", "ul", "ol", "li", "hr", "table", "tbody", "thead", "tfoot", "th", "tr", "td", "caption"]),
                    ur = e => zt(e) && !dr(e),
                    mr = e => zt(e) && "br" === Ht(e),
                    gr = cr(["h1", "h2", "h3", "h4", "h5", "h6", "p", "div", "address", "pre", "form", "blockquote", "center", "dir", "fieldset", "header", "footer", "article", "section", "hgroup", "aside", "nav", "figure"]),
                    hr = cr(["ul", "ol", "dl"]),
                    pr = cr(["li", "dd", "dt"]),
                    fr = cr(["thead", "tbody", "tfoot"]),
                    vr = cr(["td", "th"]),
                    br = cr(["pre", "script", "textarea", "style"]),
                    yr = cr(lr),
                    wr = e => yr(e) || ur(e),
                    xr = () => {
                        const e = uo("br");
                        return Wt(e, "data-mce-bogus", "1"), e
                    },
                    Cr = e => {
                        nn(e), tn(e, xr())
                    },
                    Sr = e => {
                        Do(e).each((t => {
                            Oo(t).each((o => {
                                dr(e) && mr(t) && dr(o) && rn(t)
                            }))
                        }))
                    },
                    kr = tr,
                    _r = nr,
                    Or = e => e.replace(/\uFEFF/g, ""),
                    Tr = Rn,
                    Er = Vn,
                    Ar = e => (Er(e) && (e = e.parentNode), Tr(e) && e.hasAttribute("data-mce-caret")),
                    Mr = e => Er(e) && _r(e.data),
                    Nr = e => Ar(e) || Mr(e),
                    Rr = e => e.firstChild !== e.lastChild || !qn(e.firstChild),
                    Dr = e => {
                        const t = e.container();
                        return !!Vn(t) && (t.data.charAt(e.offset()) === kr || e.isAtStart() && Mr(t.previousSibling))
                    },
                    Br = e => {
                        const t = e.container();
                        return !!Vn(t) && (t.data.charAt(e.offset() - 1) === kr || e.isAtEnd() && Mr(t.nextSibling))
                    },
                    Lr = e => Er(e) && e.data[0] === kr,
                    Hr = e => Er(e) && e.data[e.data.length - 1] === kr,
                    Ir = e => e && e.hasAttribute("data-mce-caret") ? ((e => {
                        var t;
                        const o = e.getElementsByTagName("br"),
                            n = o[o.length - 1];
                        In(n) && (null === (t = n.parentNode) || void 0 === t || t.removeChild(n))
                    })(e), e.removeAttribute("data-mce-caret"), e.removeAttribute("data-mce-bogus"), e.removeAttribute("style"), e.removeAttribute("data-mce-style"), e.removeAttribute("_moz_abspos"), e) : null,
                    Pr = e => Ar(e.startContainer),
                    zr = Kn,
                    Fr = Yn,
                    Vr = qn,
                    Zr = Vn,
                    Ur = Bn(["script", "style", "textarea"]),
                    jr = Bn(["img", "input", "textarea", "hr", "iframe", "video", "audio", "object", "embed"]),
                    Wr = Bn(["table"]),
                    $r = Nr,
                    qr = e => !$r(e) && (Zr(e) ? !Ur(e.parentNode) : jr(e) || Vr(e) || Wr(e) || Gr(e)),
                    Gr = e => !(e => Rn(e) && "true" === e.getAttribute("unselectable"))(e) && Fr(e),
                    Kr = (e, t) => qr(e) && ((e, t) => {
                        for (let o = e.parentNode; o && o !== t; o = o.parentNode) {
                            if (Gr(o)) return !1;
                            if (zr(o)) return !0
                        }
                        return !0
                    })(e, t),
                    Yr = /^[ \t\r\n]*$/,
                    Xr = e => Yr.test(e),
                    Jr = e => "\n" === e || "\r" === e,
                    Qr = (e, t = 4, o = !0, n = !0) => {
                        const r = ((e, t) => t <= 0 ? "" : new Array(t + 1).join(" "))(0, t),
                            s = e.replace(/\t/g, r),
                            a = Y(s, ((e, t) => (e => -1 !== " \f\t\v".indexOf(e))(t) || t === or ? e.pcIsSpace || "" === e.str && o || e.str.length === s.length - 1 && n || ((e, t) => t < e.length && t >= 0 && Jr(e[t]))(s, e.str.length + 1) ? {
                                pcIsSpace: !1,
                                str: e.str + or
                            } : {
                                pcIsSpace: !0,
                                str: e.str + " "
                            } : {
                                pcIsSpace: Jr(t),
                                str: e.str + t
                            }), {
                                pcIsSpace: !1,
                                str: ""
                            });
                        return a.str
                    },
                    es = (e, t) => qr(e) && !((e, t) => Vn(e) && Xr(e.data) && !((e, t) => {
                        const o = go(t),
                            n = go(e);
                        return En(n, "pre,code", N(bo, o))
                    })(e, t))(e, t) || (e => Rn(e) && "A" === e.nodeName && !e.hasAttribute("href") && (e.hasAttribute("name") || e.hasAttribute("id")))(e) || ts(e),
                    ts = Hn("data-mce-bookmark"),
                    os = Hn("data-mce-bogus"),
                    ns = ("data-mce-bogus", "all", e => Rn(e) && "all" === e.getAttribute("data-mce-bogus"));
                const rs = (e, t = !0) => ((e, t) => {
                        let o = 0;
                        if (es(e, e)) return !1; {
                            let n = e.firstChild;
                            if (!n) return !0;
                            const r = new An(n, e);
                            do {
                                if (t) {
                                    if (ns(n)) {
                                        n = r.next(!0);
                                        continue
                                    }
                                    if (os(n)) {
                                        n = r.next();
                                        continue
                                    }
                                }
                                if (qn(n)) o++, n = r.next();
                                else {
                                    if (es(n, e)) return !1;
                                    n = r.next()
                                }
                            } while (n);
                            return o <= 1
                        }
                    })(e.dom, t),
                    ss = "data-mce-block",
                    as = e => (e => G(me(e), (e => !/[A-Z]/.test(e))))(e).join(","),
                    is = (e, t) => x(t.querySelector(e)) ? (t.setAttribute(ss, "true"), "inline-boundary" === t.getAttribute("data-mce-selected") && t.removeAttribute("data-mce-selected"), !0) : (t.removeAttribute(ss), !1),
                    ls = (e, t) => {
                        const o = as(e.getTransparentElements()),
                            n = as(e.getBlockElements());
                        return G(t.querySelectorAll(o), (e => is(n, e)))
                    },
                    cs = (e, t) => {
                        var o;
                        const n = t ? "lastChild" : "firstChild";
                        for (let t = e[n]; t; t = t[n])
                            if (rs(go(t))) return void(null === (o = t.parentNode) || void 0 === o || o.removeChild(t))
                    },
                    ds = (e, t, o) => {
                        const n = e.getBlockElements(),
                            r = go(t),
                            s = e => Ht(e) in n,
                            a = e => bo(e, r);
                        W(an(o), (t => {
                            Sn(t, s, a).each((o => {
                                const n = ((t, n) => G(Mo(t), (t => s(t) && !e.isValidChild(Ht(o), Ht(t)))))(t);
                                if (n.length > 0) {
                                    const t = ko(o);
                                    W(n, (e => {
                                        Sn(e, s, a).each((t => {
                                            ((e, t) => {
                                                const o = document.createRange(),
                                                    n = e.parentNode;
                                                if (n) {
                                                    o.setStartBefore(e), o.setEndBefore(t);
                                                    const r = o.extractContents();
                                                    cs(r, !0), o.setStartAfter(t), o.setEndAfter(e);
                                                    const s = o.extractContents();
                                                    cs(s, !1), rs(go(r)) || n.insertBefore(r, e), rs(go(t)) || n.insertBefore(t, e), rs(go(s)) || n.insertBefore(s, e), n.removeChild(e)
                                                }
                                            })(t.dom, e.dom)
                                        }))
                                    })), t.each((t => ls(e, t.dom)))
                                }
                            }))
                        }))
                    },
                    us = (e, t) => {
                        const o = ls(e, t);
                        ds(e, t, o)
                    },
                    ms = (e, t) => {
                        if (ps(e, t)) {
                            const o = as(e.getBlockElements());
                            is(o, t)
                        }
                    },
                    gs = e => e.hasAttribute(ss),
                    hs = (e, t) => Se(e.getTransparentElements(), t),
                    ps = (e, t) => Rn(t) && hs(e, t.nodeName),
                    fs = (e, t) => ps(e, t) && gs(t),
                    vs = (e, t) => 1 === t.type && hs(e, t.name) && y(t.attr(ss)),
                    bs = xt().browser,
                    ys = e => J(e, zt),
                    ws = (e, t) => e.children && Z(e.children, t),
                    xs = (e, t = {}) => {
                        let o = 0;
                        const n = {},
                            r = go(e),
                            s = xo(r),
                            a = t.maxLoadTime || 5e3,
                            i = i => new Promise(((l, c) => {
                                let d;
                                const u = Rt._addCacheSuffix(i),
                                    m = (e => Ce(n, e).getOrThunk((() => ({
                                        id: "mce-u" + o++,
                                        passed: [],
                                        failed: [],
                                        count: 0
                                    }))))(u);
                                n[u] = m, m.count++;
                                const g = (e, t) => {
                                        W(e, B), m.status = t, m.passed = [], m.failed = [], d && (d.onload = null, d.onerror = null, d = null)
                                    },
                                    h = () => g(m.passed, 2),
                                    p = () => g(m.failed, 3),
                                    f = () => {
                                        var t;
                                        t = f, (() => {
                                            const t = e.styleSheets;
                                            let o = t.length;
                                            for (; o--;) {
                                                const e = t[o].ownerNode;
                                                if (e && d && e.id === d.id) return h(), !0
                                            }
                                            return !1
                                        })() || (Date.now() - b < a ? setTimeout(t) : p())
                                    };
                                if (l && m.passed.push(l), c && m.failed.push(c), 1 === m.status) return;
                                if (2 === m.status) return void h();
                                if (3 === m.status) return void p();
                                m.status = 1;
                                const v = uo("link", s.dom);
                                $t(v, {
                                    rel: "stylesheet",
                                    type: "text/css",
                                    id: m.id
                                });
                                const b = Date.now();
                                var y;
                                t.contentCssCors && Wt(v, "crossOrigin", "anonymous"), t.referrerPolicy && Wt(v, "referrerpolicy", t.referrerPolicy), d = v.dom, d.onload = f, d.onerror = p, y = v, tn(zo(r), y), Wt(v, "href", u)
                            })),
                            l = e => {
                                const t = Rt._addCacheSuffix(e);
                                Ce(n, t).each((e => {
                                    0 == --e.count && (delete n[t], (e => {
                                        const t = zo(r);
                                        On(t, "#" + e).each(rn)
                                    })(e.id))
                                }))
                            };
                        return {
                            load: i,
                            loadAll: e => Promise.allSettled(j(e, (e => i(e).then(E(e))))).then((e => {
                                const t = q(e, (e => "fulfilled" === e.status));
                                return t.fail.length > 0 ? Promise.reject(j(t.fail, (e => e.reason))) : j(t.pass, (e => e.value))
                            })),
                            unload: l,
                            unloadAll: e => {
                                W(e, (e => {
                                    l(e)
                                }))
                            },
                            _setReferrerPolicy: e => {
                                t.referrerPolicy = e
                            },
                            _setContentCssCors: e => {
                                t.contentCssCors = e
                            }
                        }
                    },
                    Cs = (() => {
                        const e = new WeakMap;
                        return {
                            forElement: (t, o) => {
                                const n = Po(t).dom;
                                return I.from(e.get(n)).getOrThunk((() => {
                                    const t = xs(n, o);
                                    return e.set(n, t), t
                                }))
                            }
                        }
                    })(),
                    Ss = (e, t) => x(e) && (es(e, t) || ur(go(e))),
                    ks = e => (e => "span" === e.nodeName.toLowerCase())(e) && "bookmark" === e.getAttribute("data-mce-type"),
                    _s = (e, t, o) => {
                        var n;
                        const r = o || t;
                        if (Rn(t) && ks(t)) return t;
                        const s = t.childNodes;
                        for (let t = s.length - 1; t >= 0; t--) _s(e, s[t], r);
                        if (Rn(t)) {
                            const e = t.childNodes;
                            1 === e.length && ks(e[0]) && (null === (n = t.parentNode) || void 0 === n || n.insertBefore(e[0], t))
                        }
                        return (e => $n(e) || Wn(e))(t) || es(t, r) || (e => !!Rn(e) && e.childNodes.length > 0)(t) || ((e, t) => Vn(e) && e.data.length > 0 && ((e, t) => {
                            const o = new An(e, t).prev(!1),
                                n = new An(e, t).next(!1),
                                r = y(o) || Ss(o, t),
                                s = y(n) || Ss(n, t);
                            return r && s
                        })(e, t))(t, r) || e.remove(t), t
                    },
                    Os = Rt.makeMap,
                    Ts = /[&<>\"\u0060\u007E-\uD7FF\uE000-\uFFEF]|[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
                    Es = /[<>&\u007E-\uD7FF\uE000-\uFFEF]|[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
                    As = /[<>&\"\']/g,
                    Ms = /&#([a-z0-9]+);?|&([a-z0-9]+);/gi,
                    Ns = {
                        128: "",
                        130: "",
                        131: "",
                        132: "",
                        133: "",
                        134: "",
                        135: "",
                        136: "",
                        137: "",
                        138: "",
                        139: "",
                        140: "",
                        142: "",
                        145: "",
                        146: "",
                        147: "",
                        148: "",
                        149: "",
                        150: "",
                        151: "",
                        152: "",
                        153: "",
                        154: "",
                        155: "",
                        156: "",
                        158: "",
                        159: ""
                    },
                    Rs = {
                        '"': "&quot;",
                        "'": "&#39;",
                        "<": "&lt;",
                        ">": "&gt;",
                        "&": "&amp;",
                        "`": "&#96;"
                    },
                    Ds = {
                        "&lt;": "<",
                        "&gt;": ">",
                        "&amp;": "&",
                        "&quot;": '"',
                        "&apos;": "'"
                    },
                    Bs = (e, t) => {
                        const o = {};
                        if (e) {
                            const n = e.split(",");
                            t = t || 10;
                            for (let e = 0; e < n.length; e += 2) {
                                const r = String.fromCharCode(parseInt(n[e], t));
                                if (!Rs[r]) {
                                    const t = "&" + n[e + 1] + ";";
                                    o[r] = t, o[t] = r
                                }
                            }
                            return o
                        }
                    },
                    Ls = Bs("50,nbsp,51,iexcl,52,cent,53,pound,54,curren,55,yen,56,brvbar,57,sect,58,uml,59,copy,5a,ordf,5b,laquo,5c,not,5d,shy,5e,reg,5f,macr,5g,deg,5h,plusmn,5i,sup2,5j,sup3,5k,acute,5l,micro,5m,para,5n,middot,5o,cedil,5p,sup1,5q,ordm,5r,raquo,5s,frac14,5t,frac12,5u,frac34,5v,iquest,60,Agrave,61,Aacute,62,Acirc,63,Atilde,64,Auml,65,Aring,66,AElig,67,Ccedil,68,Egrave,69,Eacute,6a,Ecirc,6b,Euml,6c,Igrave,6d,Iacute,6e,Icirc,6f,Iuml,6g,ETH,6h,Ntilde,6i,Ograve,6j,Oacute,6k,Ocirc,6l,Otilde,6m,Ouml,6n,times,6o,Oslash,6p,Ugrave,6q,Uacute,6r,Ucirc,6s,Uuml,6t,Yacute,6u,THORN,6v,szlig,70,agrave,71,aacute,72,acirc,73,atilde,74,auml,75,aring,76,aelig,77,ccedil,78,egrave,79,eacute,7a,ecirc,7b,euml,7c,igrave,7d,iacute,7e,icirc,7f,iuml,7g,eth,7h,ntilde,7i,ograve,7j,oacute,7k,ocirc,7l,otilde,7m,ouml,7n,divide,7o,oslash,7p,ugrave,7q,uacute,7r,ucirc,7s,uuml,7t,yacute,7u,thorn,7v,yuml,ci,fnof,sh,Alpha,si,Beta,sj,Gamma,sk,Delta,sl,Epsilon,sm,Zeta,sn,Eta,so,Theta,sp,Iota,sq,Kappa,sr,Lambda,ss,Mu,st,Nu,su,Xi,sv,Omicron,t0,Pi,t1,Rho,t3,Sigma,t4,Tau,t5,Upsilon,t6,Phi,t7,Chi,t8,Psi,t9,Omega,th,alpha,ti,beta,tj,gamma,tk,delta,tl,epsilon,tm,zeta,tn,eta,to,theta,tp,iota,tq,kappa,tr,lambda,ts,mu,tt,nu,tu,xi,tv,omicron,u0,pi,u1,rho,u2,sigmaf,u3,sigma,u4,tau,u5,upsilon,u6,phi,u7,chi,u8,psi,u9,omega,uh,thetasym,ui,upsih,um,piv,812,bull,816,hellip,81i,prime,81j,Prime,81u,oline,824,frasl,88o,weierp,88h,image,88s,real,892,trade,89l,alefsym,8cg,larr,8ch,uarr,8ci,rarr,8cj,darr,8ck,harr,8dl,crarr,8eg,lArr,8eh,uArr,8ei,rArr,8ej,dArr,8ek,hArr,8g0,forall,8g2,part,8g3,exist,8g5,empty,8g7,nabla,8g8,isin,8g9,notin,8gb,ni,8gf,prod,8gh,sum,8gi,minus,8gn,lowast,8gq,radic,8gt,prop,8gu,infin,8h0,ang,8h7,and,8h8,or,8h9,cap,8ha,cup,8hb,int,8hk,there4,8hs,sim,8i5,cong,8i8,asymp,8j0,ne,8j1,equiv,8j4,le,8j5,ge,8k2,sub,8k3,sup,8k4,nsub,8k6,sube,8k7,supe,8kl,oplus,8kn,otimes,8l5,perp,8m5,sdot,8o8,lceil,8o9,rceil,8oa,lfloor,8ob,rfloor,8p9,lang,8pa,rang,9ea,loz,9j0,spades,9j3,clubs,9j5,hearts,9j6,diams,ai,OElig,aj,oelig,b0,Scaron,b1,scaron,bo,Yuml,m6,circ,ms,tilde,802,ensp,803,emsp,809,thinsp,80c,zwnj,80d,zwj,80e,lrm,80f,rlm,80j,ndash,80k,mdash,80o,lsquo,80p,rsquo,80q,sbquo,80s,ldquo,80t,rdquo,80u,bdquo,810,dagger,811,Dagger,81g,permil,81p,lsaquo,81q,rsaquo,85c,euro", 32),
                    Hs = (e, t) => e.replace(t ? Ts : Es, (e => Rs[e] || e)),
                    Is = (e, t) => e.replace(t ? Ts : Es, (e => e.length > 1 ? "&#" + (1024 * (e.charCodeAt(0) - 55296) + (e.charCodeAt(1) - 56320) + 65536) + ";" : Rs[e] || "&#" + e.charCodeAt(0) + ";")),
                    Ps = (e, t, o) => {
                        const n = o || Ls;
                        return e.replace(t ? Ts : Es, (e => Rs[e] || n[e] || e))
                    },
                    zs = {
                        encodeRaw: Hs,
                        encodeAllRaw: e => ("" + e).replace(As, (e => Rs[e] || e)),
                        encodeNumeric: Is,
                        encodeNamed: Ps,
                        getEncodeFunc: (e, t) => {
                            const o = Bs(t) || Ls,
                                n = Os(e.replace(/\+/g, ","));
                            return n.named && n.numeric ? (e, t) => e.replace(t ? Ts : Es, (e => void 0 !== Rs[e] ? Rs[e] : void 0 !== o[e] ? o[e] : e.length > 1 ? "&#" + (1024 * (e.charCodeAt(0) - 55296) + (e.charCodeAt(1) - 56320) + 65536) + ";" : "&#" + e.charCodeAt(0) + ";")) : n.named ? t ? (e, t) => Ps(e, t, o) : Ps : n.numeric ? Is : Hs
                        },
                        decode: e => e.replace(Ms, ((e, t) => t ? (t = "x" === t.charAt(0).toLowerCase() ? parseInt(t.substr(1), 16) : parseInt(t, 10)) > 65535 ? (t -= 65536, String.fromCharCode(55296 + (t >> 10), 56320 + (1023 & t))) : Ns[t] || String.fromCharCode(t) : Ds[e] || Ls[e] || (e => {
                            const t = uo("div").dom;
                            return t.innerHTML = e, t.textContent || t.innerText || e
                        })(e)))
                    },
                    Fs = {},
                    Vs = {},
                    Zs = {},
                    Us = Rt.makeMap,
                    js = Rt.each,
                    Ws = Rt.extend,
                    $s = Rt.explode,
                    qs = Rt.inArray,
                    Gs = (e, t) => (e = Rt.trim(e)) ? e.split(t || " ") : [],
                    Ks = (e, t = {}) => {
                        const o = Us(e, " ", Us(e.toUpperCase(), " "));
                        return Ws(o, t)
                    },
                    Ys = e => Ks("td th li dt dd figcaption caption details summary", e.getTextBlockElements()),
                    Xs = (e, t) => {
                        if (e) {
                            const o = {};
                            return g(e) && (e = {
                                "*": e
                            }), js(e, ((e, n) => {
                                o[n] = o[n.toUpperCase()] = "map" === t ? Us(e, /[, ]/) : $s(e, /[, ]/)
                            })), o
                        }
                    },
                    Js = (e = {}) => {
                        var t;
                        const o = {},
                            n = {};
                        let r = [];
                        const s = {},
                            a = {},
                            i = (t, o, n) => {
                                const r = e[t];
                                if (r) return Us(r, /[, ]/, Us(r.toUpperCase(), /[, ]/)); {
                                    let e = Vs[t];
                                    return e || (e = Ks(o, n), Vs[t] = e), e
                                }
                            },
                            l = null !== (t = e.schema) && void 0 !== t ? t : "html5",
                            c = (e => {
                                const t = {};
                                let o, n, r, s;
                                const a = (e, n = "", r = "") => {
                                        const s = Gs(r),
                                            a = Gs(e);
                                        let i = a.length;
                                        for (; i--;) {
                                            const e = Gs([o, n].join(" "));
                                            t[a[i]] = {
                                                attributes: se(e, (() => ({}))),
                                                attributesOrder: e,
                                                children: se(s, E(Zs))
                                            }
                                        }
                                    },
                                    i = (e, o) => {
                                        const n = Gs(e),
                                            r = Gs(o);
                                        let s = n.length;
                                        for (; s--;) {
                                            const e = t[n[s]];
                                            for (let t = 0, o = r.length; t < o; t++) e.attributes[r[t]] = {}, e.attributesOrder.push(r[t])
                                        }
                                    };
                                if (Fs[e]) return Fs[e];
                                if (o = "id accesskey class dir lang style tabindex title role", n = "address blockquote div dl fieldset form h1 h2 h3 h4 h5 h6 hr menu ol p pre table ul", r = "a abbr b bdo br button cite code del dfn em embed i iframe img input ins kbd label map noscript object q s samp script select small span strong sub sup textarea u var #text #comment", "html4" !== e && (o += " contenteditable contextmenu draggable dropzone hidden spellcheck translate", n += " article aside details dialog figure main header footer hgroup section nav a ins del canvas map", r += " audio canvas command datalist mark meter output picture progress time wbr video ruby bdi keygen"), "html5-strict" !== e) {
                                    o += " xml:lang";
                                    const e = "acronym applet basefont big font strike tt";
                                    r = [r, e].join(" "), js(Gs(e), (e => {
                                        a(e, "", r)
                                    }));
                                    const t = "center dir isindex noframes";
                                    n = [n, t].join(" "), s = [n, r].join(" "), js(Gs(t), (e => {
                                        a(e, "", s)
                                    }))
                                }
                                return s = s || [n, r].join(" "), a("html", "manifest", "head body"), a("head", "", "base command link meta noscript script style title"), a("title hr noscript br"), a("base", "href target"), a("link", "href rel media hreflang type sizes hreflang"), a("meta", "name http-equiv content charset"), a("style", "media type scoped"), a("script", "src async defer type charset"), a("body", "onafterprint onbeforeprint onbeforeunload onblur onerror onfocus onhashchange onload onmessage onoffline ononline onpagehide onpageshow onpopstate onresize onscroll onstorage onunload", s), a("address dt dd div caption", "", s), a("h1 h2 h3 h4 h5 h6 pre p abbr code var samp kbd sub sup i b u bdo span legend em strong small s cite dfn", "", r), a("blockquote", "cite", s), a("ol", "reversed start type", "li"), a("ul", "", "li"), a("li", "value", s), a("dl", "", "dt dd"), a("a", "href target rel media hreflang type", s), a("q", "cite", r), a("ins del", "cite datetime", s), a("img", "src sizes srcset alt usemap ismap width height"), a("iframe", "src name width height", s), a("embed", "src type width height"), a("object", "data type typemustmatch name usemap form width height", [s, "param"].join(" ")), a("param", "name value"), a("map", "name", [s, "area"].join(" ")), a("area", "alt coords shape href target rel media hreflang type"), a("table", "border", "caption colgroup thead tfoot tbody tr" + ("html4" === e ? " col" : "")), a("colgroup", "span", "col"), a("col", "span"), a("tbody thead tfoot", "", "tr"), a("tr", "", "td th"), a("td", "colspan rowspan headers", s), a("th", "colspan rowspan headers scope abbr", s), a("form", "accept-charset action autocomplete enctype method name novalidate target", s), a("fieldset", "disabled form name", [s, "legend"].join(" ")), a("label", "form for", r), a("input", "accept alt autocomplete checked dirname disabled form formaction formenctype formmethod formnovalidate formtarget height list max maxlength min multiple name pattern readonly required size src step type value width"), a("button", "disabled form formaction formenctype formmethod formnovalidate formtarget name type value", "html4" === e ? s : r), a("select", "disabled form multiple name required size", "option optgroup"), a("optgroup", "disabled label", "option"), a("option", "disabled label selected value"), a("textarea", "cols dirname disabled form maxlength name readonly required rows wrap"), a("menu", "type label", [s, "li"].join(" ")), a("noscript", "", s), "html4" !== e && (a("wbr"), a("ruby", "", [r, "rt rp"].join(" ")), a("figcaption", "", s), a("mark rt rp summary bdi", "", r), a("canvas", "width height", s), a("video", "src crossorigin poster preload autoplay mediagroup loop muted controls width height buffered", [s, "track source"].join(" ")), a("audio", "src crossorigin preload autoplay mediagroup loop muted controls buffered volume", [s, "track source"].join(" ")), a("picture", "", "img source"), a("source", "src srcset type media sizes"), a("track", "kind src srclang label default"), a("datalist", "", [r, "option"].join(" ")), a("article section nav aside main header footer", "", s), a("hgroup", "", "h1 h2 h3 h4 h5 h6"), a("figure", "", [s, "figcaption"].join(" ")), a("time", "datetime", r), a("dialog", "open", s), a("command", "type label icon disabled checked radiogroup command"), a("output", "for form name", r), a("progress", "value max", r), a("meter", "value min max low high optimum", r), a("details", "open", [s, "summary"].join(" ")), a("keygen", "autofocus challenge disabled form keytype name")), "html5-strict" !== e && (i("script", "language xml:space"), i("style", "xml:space"), i("object", "declare classid code codebase codetype archive standby align border hspace vspace"), i("embed", "align name hspace vspace"), i("param", "valuetype type"), i("a", "charset name rev shape coords"), i("br", "clear"), i("applet", "codebase archive code object alt name width height align hspace vspace"), i("img", "name longdesc align border hspace vspace"), i("iframe", "longdesc frameborder marginwidth marginheight scrolling align"), i("font basefont", "size color face"), i("input", "usemap align"), i("select"), i("textarea"), i("h1 h2 h3 h4 h5 h6 div p legend caption", "align"), i("ul", "type compact"), i("li", "type"), i("ol dl menu dir", "compact"), i("pre", "width xml:space"), i("hr", "align noshade size width"), i("isindex", "prompt"), i("table", "summary width frame rules cellspacing cellpadding align bgcolor"), i("col", "width align char charoff valign"), i("colgroup", "width align char charoff valign"), i("thead", "align char charoff valign"), i("tr", "align char charoff valign bgcolor"), i("th", "axis align char charoff valign nowrap bgcolor width height"), i("form", "accept"), i("td", "abbr axis scope align char charoff valign nowrap bgcolor width height"), i("tfoot", "align char charoff valign"), i("tbody", "align char charoff valign"), i("area", "nohref"), i("body", "background bgcolor text link vlink alink")), "html4" !== e && (i("input button select textarea", "autofocus"), i("input textarea", "placeholder"), i("a", "download"), i("link script img", "crossorigin"), i("img", "loading"), i("iframe", "sandbox seamless allow allowfullscreen loading")), "html4" !== e && W([t.video, t.audio], (e => {
                                    delete e.children.audio, delete e.children.video
                                })), js(Gs("a form meter progress dfn"), (e => {
                                    t[e] && delete t[e].children[e]
                                })), delete t.caption.children.table, delete t.script, Fs[e] = t, t
                            })(l);
                        !1 === e.verify_html && (e.valid_elements = "*[*]");
                        const d = Xs(e.valid_styles),
                            u = Xs(e.invalid_styles, "map"),
                            m = Xs(e.valid_classes, "map"),
                            g = i("whitespace_elements", "pre script noscript style textarea video audio iframe object code"),
                            h = i("self_closing_elements", "colgroup dd dt li option p td tfoot th thead tr"),
                            p = i("void_elements", "area base basefont br col frame hr img input isindex link meta param embed source wbr track"),
                            f = i("boolean_attributes", "checked compact declare defer disabled ismap multiple nohref noresize noshade nowrap readonly selected autoplay loop controls allowfullscreen"),
                            v = "td th iframe video audio object script code",
                            b = i("non_empty_elements", v + " pre", p),
                            y = i("move_caret_before_on_enter_elements", v + " table", p),
                            w = i("text_block_elements", "h1 h2 h3 h4 h5 h6 p div address pre form blockquote center dir fieldset header footer article section hgroup aside main nav figure"),
                            x = i("block_elements", "hr table tbody thead tfoot th tr td li ol ul caption dl dt dd noscript menu isindex option datalist select optgroup figcaption details summary", w),
                            C = i("text_inline_elements", "span strong b em i font s strike u var cite dfn code mark q sup sub samp"),
                            S = i("transparent_elements", "a ins del canvas map");
                        js("script noscript iframe noframes noembed title style textarea xmp plaintext".split(" "), (e => {
                            a[e] = new RegExp("</" + e + "[^>]*>", "gi")
                        }));
                        const k = e => new RegExp("^" + e.replace(/([?+*])/g, ".$1") + "$"),
                            _ = e => {
                                const t = /^([#+\-])?([^\[!\/]+)(?:\/([^\[!]+))?(?:(!?)\[([^\]]+)])?$/,
                                    n = /^([!\-])?(\w+[\\:]:\w+|[^=~<]+)?(?:([=~<])(.*))?$/,
                                    s = /[*?+]/;
                                if (e) {
                                    const a = Gs(e, ",");
                                    let i, l;
                                    o["@"] && (i = o["@"].attributes, l = o["@"].attributesOrder);
                                    for (let e = 0, c = a.length; e < c; e++) {
                                        let c = t.exec(a[e]);
                                        if (c) {
                                            const e = c[1],
                                                t = c[2],
                                                a = c[3],
                                                d = c[5],
                                                u = {},
                                                m = [],
                                                g = {
                                                    attributes: u,
                                                    attributesOrder: m
                                                };
                                            if ("#" === e && (g.paddEmpty = !0), "-" === e && (g.removeEmpty = !0), "!" === c[4] && (g.removeEmptyAttrs = !0), i && (he(i, ((e, t) => {
                                                    u[t] = e
                                                })), l && m.push(...l)), d) {
                                                const e = Gs(d, "|");
                                                for (let t = 0, o = e.length; t < o; t++)
                                                    if (c = n.exec(e[t]), c) {
                                                        const e = {},
                                                            t = c[1],
                                                            o = c[2].replace(/[\\:]:/g, ":"),
                                                            n = c[3],
                                                            r = c[4];
                                                        if ("!" === t && (g.attributesRequired = g.attributesRequired || [], g.attributesRequired.push(o), e.required = !0), "-" === t) {
                                                            delete u[o], m.splice(qs(m, o), 1);
                                                            continue
                                                        }
                                                        if (n && ("=" === n && (g.attributesDefault = g.attributesDefault || [], g.attributesDefault.push({
                                                                name: o,
                                                                value: r
                                                            }), e.defaultValue = r), "~" === n && (g.attributesForced = g.attributesForced || [], g.attributesForced.push({
                                                                name: o,
                                                                value: r
                                                            }), e.forcedValue = r), "<" === n && (e.validValues = Us(r, "?"))), s.test(o)) {
                                                            const t = e;
                                                            g.attributePatterns = g.attributePatterns || [], t.pattern = k(o), g.attributePatterns.push(t)
                                                        } else u[o] || m.push(o), u[o] = e
                                                    }
                                            }
                                            if (i || "@" !== t || (i = u, l = m), a && (g.outputName = t, o[a] = g), s.test(t)) {
                                                const e = g;
                                                e.pattern = k(t), r.push(e)
                                            } else o[t] = g
                                        }
                                    }
                                }
                            },
                            O = e => {
                                r = [], W(me(o), (e => {
                                    delete o[e]
                                })), _(e), js(c, ((e, t) => {
                                    n[t] = e.children
                                }))
                            },
                            T = e => {
                                const t = /^(~)?(.+)$/;
                                e && (delete Vs.text_block_elements, delete Vs.block_elements, js(Gs(e, ","), (e => {
                                    const r = t.exec(e);
                                    if (r) {
                                        const e = "~" === r[1],
                                            t = e ? "span" : "div",
                                            a = r[2];
                                        if (n[a] = n[t], s[a] = t, b[a.toUpperCase()] = {}, b[a] = {}, e || (x[a.toUpperCase()] = {}, x[a] = {}), !o[a]) {
                                            let e = o[t];
                                            e = Ws({}, e), delete e.removeEmptyAttrs, delete e.removeEmpty, o[a] = e
                                        }
                                        js(n, ((e, o) => {
                                            e[t] && (n[o] = e = Ws({}, n[o]), e[a] = e[t])
                                        }))
                                    }
                                })))
                            },
                            A = e => {
                                const t = /^([+\-]?)([A-Za-z0-9_\-.\u00b7\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u037d\u037f-\u1fff\u200c-\u200d\u203f-\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]+)\[([^\]]+)]$/;
                                delete Fs[l], e && js(Gs(e, ","), (e => {
                                    const o = t.exec(e);
                                    if (o) {
                                        const e = o[1];
                                        let t;
                                        t = e ? n[o[2]] : n[o[2]] = {
                                            "#comment": {}
                                        }, t = n[o[2]], js(Gs(o[3], "|"), (o => {
                                            "-" === e ? delete t[o] : t[o] = {}
                                        }))
                                    }
                                }))
                            },
                            M = e => {
                                const t = o[e];
                                if (t) return t;
                                let n = r.length;
                                for (; n--;) {
                                    const t = r[n];
                                    if (t.pattern.test(e)) return t
                                }
                            };
                        e.valid_elements ? O(e.valid_elements) : (js(c, ((e, t) => {
                            o[t] = {
                                attributes: e.attributes,
                                attributesOrder: e.attributesOrder
                            }, n[t] = e.children
                        })), js(Gs("strong/b em/i"), (e => {
                            const t = Gs(e, "/");
                            o[t[1]].outputName = t[0]
                        })), js(C, ((t, n) => {
                            o[n] && (e.padd_empty_block_inline_children && (o[n].paddInEmptyBlock = !0), o[n].removeEmpty = !0)
                        })), js(Gs("ol ul blockquote a table tbody"), (e => {
                            o[e] && (o[e].removeEmpty = !0)
                        })), js(Gs("p h1 h2 h3 h4 h5 h6 th td pre div address caption li"), (e => {
                            o[e].paddEmpty = !0
                        })), js(Gs("span"), (e => {
                            o[e].removeEmptyAttrs = !0
                        }))), T(e.custom_elements), A(e.valid_children), _(e.extended_valid_elements), A("+ol[ul|ol],+ul[ul|ol]"), js({
                            dd: "dl",
                            dt: "dl",
                            li: "ul ol",
                            td: "tr",
                            th: "tr",
                            tr: "tbody thead tfoot",
                            tbody: "table",
                            thead: "table",
                            tfoot: "table",
                            legend: "fieldset",
                            area: "map",
                            param: "video audio object"
                        }, ((e, t) => {
                            o[t] && (o[t].parentsRequired = Gs(e))
                        })), e.invalid_elements && js($s(e.invalid_elements), (e => {
                            o[e] && delete o[e]
                        })), M("span") || _("span[!data-mce-type|*]");
                        const N = E(d),
                            R = E(u),
                            D = E(m),
                            B = E(f),
                            L = E(x),
                            H = E(w),
                            I = E(C),
                            P = E(Object.seal(p)),
                            z = E(h),
                            F = E(b),
                            V = E(y),
                            Z = E(g),
                            U = E(S),
                            j = E(Object.seal(a)),
                            $ = E(s);
                        return {
                            type: l,
                            children: n,
                            elements: o,
                            getValidStyles: N,
                            getValidClasses: D,
                            getBlockElements: L,
                            getInvalidStyles: R,
                            getVoidElements: P,
                            getTextBlockElements: H,
                            getTextInlineElements: I,
                            getBoolAttrs: B,
                            getElementRule: M,
                            getSelfClosingElements: z,
                            getNonEmptyElements: F,
                            getMoveCaretBeforeOnEnterElements: V,
                            getWhitespaceElements: Z,
                            getTransparentElements: U,
                            getSpecialElements: j,
                            isValidChild: (e, t) => {
                                const o = n[e.toLowerCase()];
                                return !(!o || !o[t.toLowerCase()])
                            },
                            isValid: (e, t) => {
                                const o = M(e);
                                if (o) {
                                    if (!t) return !0; {
                                        if (o.attributes[t]) return !0;
                                        const e = o.attributePatterns;
                                        if (e) {
                                            let o = e.length;
                                            for (; o--;)
                                                if (e[o].pattern.test(t)) return !0
                                        }
                                    }
                                }
                                return !1
                            },
                            getCustomElements: $,
                            addValidElements: _,
                            setValidElements: O,
                            addCustomElements: T,
                            addValidChildren: A
                        }
                    },
                    Qs = (e = {}, t) => {
                        const o = /(?:url(?:(?:\(\s*\"([^\"]+)\"\s*\))|(?:\(\s*\'([^\']+)\'\s*\))|(?:\(\s*([^)\s]+)\s*\))))|(?:\'([^\']+)\')|(?:\"([^\"]+)\")/gi,
                            n = /\s*([^:]+):\s*([^;]+);?/g,
                            r = /\s+$/,
                            s = {};
                        let a, i;
                        const l = tr;
                        t && (a = t.getValidStyles(), i = t.getInvalidStyles());
                        const c = "\\\" \\' \\; \\: ; : \ufeff".split(" ");
                        for (let e = 0; e < c.length; e++) s[c[e]] = l + e, s[l + e] = c[e];
                        const d = {
                            parse: t => {
                                const a = {};
                                let i = !1;
                                const c = e.url_converter,
                                    u = e.url_converter_scope || d,
                                    m = (e, t, o) => {
                                        const n = a[e + "-top" + t];
                                        if (!n) return;
                                        const r = a[e + "-right" + t];
                                        if (!r) return;
                                        const s = a[e + "-bottom" + t];
                                        if (!s) return;
                                        const i = a[e + "-left" + t];
                                        if (!i) return;
                                        const l = [n, r, s, i];
                                        let c = l.length - 1;
                                        for (; c-- && l[c] === l[c + 1];);
                                        c > -1 && o || (a[e + t] = -1 === c ? l[0] : l.join(" "), delete a[e + "-top" + t], delete a[e + "-right" + t], delete a[e + "-bottom" + t], delete a[e + "-left" + t])
                                    },
                                    g = e => {
                                        const t = a[e];
                                        if (!t) return;
                                        const o = t.split(" ");
                                        let n = o.length;
                                        for (; n--;)
                                            if (o[n] !== o[0]) return !1;
                                        return a[e] = o[0], !0
                                    },
                                    h = e => (i = !0, s[e]),
                                    p = (e, t) => (i && (e = e.replace(/\uFEFF[0-9]/g, (e => s[e]))), t || (e = e.replace(/\\([\'\";:])/g, "$1")), e),
                                    f = e => String.fromCharCode(parseInt(e.slice(1), 16)),
                                    v = e => e.replace(/\\[0-9a-f]+/gi, f),
                                    b = (t, o, n, r, s, a) => {
                                        if (s = s || a) return "'" + (s = p(s)).replace(/\'/g, "\\'") + "'";
                                        if (o = p(o || n || r || ""), !e.allow_script_urls) {
                                            const t = o.replace(/[\s\r\n]+/g, "");
                                            if (/(java|vb)script:/i.test(t)) return "";
                                            if (!e.allow_svg_data_urls && /^data:image\/svg/i.test(t)) return ""
                                        }
                                        return c && (o = c.call(u, o, "style")), "url('" + o.replace(/\'/g, "\\'") + "')"
                                    };
                                if (t) {
                                    let s;
                                    for (t = (t = t.replace(/[\u0000-\u001F]/g, "")).replace(/\\[\"\';:\uFEFF]/g, h).replace(/\"[^\"]+\"|\'[^\']+\'/g, (e => e.replace(/[;:]/g, h))); s = n.exec(t);) {
                                        n.lastIndex = s.index + s[0].length;
                                        let t = s[1].replace(r, "").toLowerCase(),
                                            c = s[2].replace(r, "");
                                        if (t && c) {
                                            if (t = v(t), c = v(c), -1 !== t.indexOf(l) || -1 !== t.indexOf('"')) continue;
                                            if (!e.allow_script_urls && ("behavior" === t || /expression\s*\(|\/\*|\*\//.test(c))) continue;
                                            "font-weight" === t && "700" === c ? c = "bold" : "color" !== t && "background-color" !== t || (c = c.toLowerCase()), c = c.replace(o, b), a[t] = i ? p(c, !0) : c
                                        }
                                    }
                                    m("border", "", !0), m("border", "-width"), m("border", "-color"), m("border", "-style"), m("padding", ""), m("margin", ""), "border", w = "border-style", x = "border-color", g(y = "border-width") && g(w) && g(x) && (a.border = a[y] + " " + a[w] + " " + a[x], delete a[y], delete a[w], delete a[x]), "medium none" === a.border && delete a.border, "none" === a["border-image"] && delete a["border-image"]
                                }
                                var y, w, x;
                                return a
                            },
                            serialize: (e, t) => {
                                let o = "";
                                const n = (t, n) => {
                                    const r = n[t];
                                    if (r)
                                        for (let t = 0, n = r.length; t < n; t++) {
                                            const n = r[t],
                                                s = e[n];
                                            s && (o += (o.length > 0 ? " " : "") + n + ": " + s + ";")
                                        }
                                };
                                return t && a ? (n("*", a), n(t, a)) : he(e, ((e, n) => {
                                    e && ((e, t) => {
                                        if (!i || !t) return !0;
                                        let o = i["*"];
                                        return !(o && o[e] || (o = i[t], o && o[e]))
                                    })(n, t) && (o += (o.length > 0 ? " " : "") + n + ": " + e + ";")
                                })), o
                            }
                        };
                        return d
                    },
                    ea = {
                        keyLocation: !0,
                        layerX: !0,
                        layerY: !0,
                        returnValue: !0,
                        webkitMovementX: !0,
                        webkitMovementY: !0,
                        keyIdentifier: !0,
                        mozPressure: !0
                    },
                    ta = (e, t) => {
                        const o = null != t ? t : {};
                        for (const t in e) Se(ea, t) || (o[t] = e[t]);
                        return x(e.composedPath) && (o.composedPath = () => e.composedPath()), o
                    },
                    oa = (e, t, o, n) => {
                        var r;
                        const s = ta(t, n);
                        return s.type = e, w(s.target) && (s.target = null !== (r = s.srcElement) && void 0 !== r ? r : o), (e => w(e.preventDefault) || (e => e instanceof Event || C(e.initEvent))(e))(t) && (s.preventDefault = () => {
                            s.defaultPrevented = !0, s.isDefaultPrevented = H, C(t.preventDefault) && t.preventDefault()
                        }, s.stopPropagation = () => {
                            s.cancelBubble = !0, s.isPropagationStopped = H, C(t.stopPropagation) && t.stopPropagation()
                        }, s.stopImmediatePropagation = () => {
                            s.isImmediatePropagationStopped = H, s.stopPropagation()
                        }, (e => e.isDefaultPrevented === H || e.isDefaultPrevented === L)(s) || (s.isDefaultPrevented = !0 === s.defaultPrevented ? H : L, s.isPropagationStopped = !0 === s.cancelBubble ? H : L, s.isImmediatePropagationStopped = L)), s
                    },
                    na = /^(?:mouse|contextmenu)|click/,
                    ra = (e, t, o, n) => {
                        e.addEventListener(t, o, n || !1)
                    },
                    sa = (e, t, o, n) => {
                        e.removeEventListener(t, o, n || !1)
                    },
                    aa = (e, t) => {
                        const o = oa(e.type, e, document, t);
                        if ((e => x(e) && na.test(e.type))(e) && y(e.pageX) && !y(e.clientX)) {
                            const t = o.target.ownerDocument || document,
                                n = t.documentElement,
                                r = t.body,
                                s = o;
                            s.pageX = e.clientX + (n && n.scrollLeft || r && r.scrollLeft || 0) - (n && n.clientLeft || r && r.clientLeft || 0), s.pageY = e.clientY + (n && n.scrollTop || r && r.scrollTop || 0) - (n && n.clientTop || r && r.clientTop || 0)
                        }
                        return o
                    },
                    ia = (e, t, o) => {
                        const n = e.document,
                            r = {
                                type: "ready"
                            };
                        if (o.domLoaded) return void t(r);
                        const s = () => {
                            sa(e, "DOMContentLoaded", s), sa(e, "load", s), o.domLoaded || (o.domLoaded = !0, t(r)), e = null
                        };
                        "complete" === n.readyState || "interactive" === n.readyState && n.body ? s() : ra(e, "DOMContentLoaded", s), o.domLoaded || ra(e, "load", s)
                    };
                class la {
                    constructor() {
                        this.domLoaded = !1, this.events = {}, this.count = 1, this.expando = "mce-data-" + (+new Date).toString(32), this.hasFocusIn = "onfocusin" in document.documentElement, this.count = 1
                    }
                    bind(e, t, o, n) {
                        const r = this;
                        let s;
                        const a = window,
                            i = e => {
                                r.executeHandlers(aa(e || a.event), l)
                            };
                        if (!e || Vn(e) || jn(e)) return o;
                        let l;
                        e[r.expando] ? l = e[r.expando] : (l = r.count++, e[r.expando] = l, r.events[l] = {}), n = n || e;
                        const c = t.split(" ");
                        let d = c.length;
                        for (; d--;) {
                            let t = c[d],
                                u = i,
                                m = !1,
                                g = !1;
                            "DOMContentLoaded" === t && (t = "ready"), r.domLoaded && "ready" === t && "complete" === e.readyState ? o.call(n, aa({
                                type: t
                            })) : (r.hasFocusIn || "focusin" !== t && "focusout" !== t || (m = !0, g = "focusin" === t ? "focus" : "blur", u = e => {
                                const t = aa(e || a.event);
                                t.type = "focus" === t.type ? "focusin" : "focusout", r.executeHandlers(t, l)
                            }), s = r.events[l][t], s ? "ready" === t && r.domLoaded ? o(aa({
                                type: t
                            })) : s.push({
                                func: o,
                                scope: n
                            }) : (r.events[l][t] = s = [{
                                func: o,
                                scope: n
                            }], s.fakeName = g, s.capture = m, s.nativeHandler = u, "ready" === t ? ia(e, u, r) : ra(e, g || t, u, m)))
                        }
                        return e = s = null, o
                    }
                    unbind(e, t, o) {
                        if (!e || Vn(e) || jn(e)) return this;
                        const n = e[this.expando];
                        if (n) {
                            let r = this.events[n];
                            if (t) {
                                const n = t.split(" ");
                                let s = n.length;
                                for (; s--;) {
                                    const t = n[s],
                                        a = r[t];
                                    if (a) {
                                        if (o) {
                                            let e = a.length;
                                            for (; e--;)
                                                if (a[e].func === o) {
                                                    const o = a.nativeHandler,
                                                        n = a.fakeName,
                                                        s = a.capture,
                                                        i = a.slice(0, e).concat(a.slice(e + 1));
                                                    i.nativeHandler = o, i.fakeName = n, i.capture = s, r[t] = i
                                                }
                                        }
                                        o && 0 !== a.length || (delete r[t], sa(e, a.fakeName || t, a.nativeHandler, a.capture))
                                    }
                                }
                            } else he(r, ((t, o) => {
                                sa(e, t.fakeName || o, t.nativeHandler, t.capture)
                            })), r = {};
                            for (const e in r)
                                if (Se(r, e)) return this;
                            delete this.events[n];
                            try {
                                delete e[this.expando]
                            } catch (t) {
                                e[this.expando] = null
                            }
                        }
                        return this
                    }
                    fire(e, t, o) {
                        return this.dispatch(e, t, o)
                    }
                    dispatch(e, t, o) {
                        if (!e || Vn(e) || jn(e)) return this;
                        const n = aa({
                            type: t,
                            target: e
                        }, o);
                        do {
                            const t = e[this.expando];
                            t && this.executeHandlers(n, t), e = e.parentNode || e.ownerDocument || e.defaultView || e.parentWindow
                        } while (e && !n.isPropagationStopped());
                        return this
                    }
                    clean(e) {
                        if (!e || Vn(e) || jn(e)) return this;
                        if (e[this.expando] && this.unbind(e), e.getElementsByTagName || (e = e.document), e && e.getElementsByTagName) {
                            this.unbind(e);
                            const t = e.getElementsByTagName("*");
                            let o = t.length;
                            for (; o--;)(e = t[o])[this.expando] && this.unbind(e)
                        }
                        return this
                    }
                    destroy() {
                        this.events = {}
                    }
                    cancel(e) {
                        return e && (e.preventDefault(), e.stopImmediatePropagation()), !1
                    }
                    executeHandlers(e, t) {
                        const o = this.events[t],
                            n = o && o[e.type];
                        if (n)
                            for (let t = 0, o = n.length; t < o; t++) {
                                const o = n[t];
                                if (o && !1 === o.func.call(o.scope, e) && e.preventDefault(), e.isImmediatePropagationStopped()) return
                            }
                    }
                }
                la.Event = new la;
                const ca = Rt.each,
                    da = Rt.grep,
                    ua = "data-mce-style",
                    ma = Rt.makeMap("fill-opacity font-weight line-height opacity orphans widows z-index zoom", " "),
                    ga = (e, t, o) => {
                        w(o) || "" === o ? Yt(e, t) : Wt(e, t, o)
                    },
                    ha = e => e.replace(/[A-Z]/g, (e => "-" + e.toLowerCase())),
                    pa = (e, t) => {
                        let o = 0;
                        if (e)
                            for (let n = e.nodeType, r = e.previousSibling; r; r = r.previousSibling) {
                                const e = r.nodeType;
                                (!t || !Vn(r) || e !== n && r.data.length) && (o++, n = e)
                            }
                        return o
                    },
                    fa = (e, t) => {
                        const o = qt(t, "style"),
                            n = e.serialize(e.parse(o), Ht(t));
                        ga(t, ua, n)
                    },
                    va = (e, t, o) => {
                        const n = ha(t);
                        w(o) || "" === o ? Xo(e, n) : Wo(e, n, ((e, t) => S(e) ? Se(ma, t) ? e + "" : e + "px" : e)(o, n))
                    },
                    ba = (e, t = {}) => {
                        const o = {},
                            n = window,
                            r = {};
                        let s = 0;
                        const a = Cs.forElement(go(e), {
                                contentCssCors: t.contentCssCors,
                                referrerPolicy: t.referrerPolicy
                            }),
                            i = [],
                            l = t.schema ? t.schema : Js({}),
                            c = Qs({
                                url_converter: t.url_converter,
                                url_converter_scope: t.url_converter_scope
                            }, t.schema),
                            d = t.ownEvents ? new la : la.Event,
                            u = l.getBlockElements(),
                            m = t => t && e && g(t) ? e.getElementById(t) : t,
                            h = e => {
                                const t = m(e);
                                return x(t) ? go(t) : null
                            },
                            p = (e, t, o = "") => {
                                let n;
                                const r = h(e);
                                if (x(r) && zt(r)) {
                                    const e = K[t];
                                    n = e && e.get ? e.get(r.dom, t) : qt(r, t)
                                }
                                return x(n) ? n : o
                            },
                            v = e => {
                                const t = m(e);
                                return w(t) ? [] : t.attributes
                            },
                            b = (e, o, n) => {
                                N(e, (e => {
                                    if (Rn(e)) {
                                        const r = go(e),
                                            s = "" === n ? null : n,
                                            a = qt(r, o),
                                            i = K[o];
                                        i && i.set ? i.set(r.dom, s, o) : ga(r, o, s), a !== s && t.onSetAttrib && t.onSetAttrib({
                                            attrElm: r.dom,
                                            attrName: o,
                                            attrValue: s
                                        })
                                    }
                                }))
                            },
                            y = () => t.root_element || e.body,
                            S = (t, o) => ((e, t, o) => {
                                let n = 0,
                                    r = 0;
                                const s = e.ownerDocument;
                                if (o = o || e, t) {
                                    if (o === e && t.getBoundingClientRect && "static" === qo(go(e), "position")) {
                                        const o = t.getBoundingClientRect();
                                        return n = o.left + (s.documentElement.scrollLeft || e.scrollLeft) - s.documentElement.clientLeft, r = o.top + (s.documentElement.scrollTop || e.scrollTop) - s.documentElement.clientTop, {
                                            x: n,
                                            y: r
                                        }
                                    }
                                    let a = t;
                                    for (; a && a !== o && a.nodeType && !ws(a, o);) {
                                        const e = a;
                                        n += e.offsetLeft || 0, r += e.offsetTop || 0, a = e.offsetParent
                                    }
                                    for (a = t.parentNode; a && a !== o && a.nodeType && !ws(a, o);) n -= a.scrollLeft || 0, r -= a.scrollTop || 0, a = a.parentNode;
                                    r += (e => bs.isFirefox() && "table" === Ht(e) ? ys(Mo(e)).filter((e => "caption" === Ht(e))).bind((e => ys(Ao(e)).map((t => {
                                        const o = t.dom.offsetTop,
                                            n = e.dom.offsetTop,
                                            r = e.dom.offsetHeight;
                                        return o <= n ? -r : 0
                                    })))).getOr(0) : 0)(go(t))
                                }
                                return {
                                    x: n,
                                    y: r
                                }
                            })(e.body, m(t), o),
                            k = (e, t, o) => {
                                const n = m(e);
                                if (!w(n) && Rn(n)) return o ? qo(go(n), ha(t)) : ("float" === (t = t.replace(/-(\D)/g, ((e, t) => t.toUpperCase()))) && (t = "cssFloat"), n.style ? n.style[t] : void 0)
                            },
                            O = e => {
                                const t = m(e);
                                if (!t) return {
                                    w: 0,
                                    h: 0
                                };
                                let o = k(t, "width"),
                                    n = k(t, "height");
                                return o && -1 !== o.indexOf("px") || (o = "0"), n && -1 !== n.indexOf("px") || (n = "0"), {
                                    w: parseInt(o, 10) || t.offsetWidth || t.clientWidth,
                                    h: parseInt(n, 10) || t.offsetHeight || t.clientHeight
                                }
                            },
                            T = (e, t) => {
                                if (!e) return !1;
                                const o = f(e) ? e : [e];
                                return U(o, (e => fo(go(e), t)))
                            },
                            A = (e, t, o, n) => {
                                const r = [];
                                let s = m(e);
                                n = void 0 === n;
                                const a = o || ("BODY" !== y().nodeName ? y().parentNode : null);
                                if (g(t))
                                    if ("*" === t) t = Rn;
                                    else {
                                        const e = t;
                                        t = t => T(t, e)
                                    }
                                for (; s && !(s === a || w(s.nodeType) || Wn(s) || $n(s));) {
                                    if (!t || t(s)) {
                                        if (!n) return [s];
                                        r.push(s)
                                    }
                                    s = s.parentNode
                                }
                                return n ? r : null
                            },
                            M = (e, t, o) => {
                                let n = t;
                                if (e) {
                                    g(t) && (n = e => T(e, t));
                                    for (let t = e[o]; t; t = t[o])
                                        if (C(n) && n(t)) return t
                                }
                                return null
                            },
                            N = function(e, t, o) {
                                const n = null != o ? o : this;
                                if (f(e)) {
                                    const o = [];
                                    return ca(e, ((e, r) => {
                                        const s = m(e);
                                        s && o.push(t.call(n, s, r))
                                    })), o
                                } {
                                    const o = m(e);
                                    return !!o && t.call(n, o)
                                }
                            },
                            R = (e, t) => {
                                N(e, (e => {
                                    he(t, ((t, o) => {
                                        b(e, o, t)
                                    }))
                                }))
                            },
                            D = (e, t) => {
                                N(e, (e => {
                                    const o = go(e);
                                    cn(o, t)
                                }))
                            },
                            B = (t, o, n, r, s) => N(t, (t => {
                                const a = g(o) ? e.createElement(o) : o;
                                return x(n) && R(a, n), r && (!g(r) && r.nodeType ? a.appendChild(r) : g(r) && D(a, r)), s ? a : t.appendChild(a)
                            })),
                            L = (t, o, n) => B(e.createElement(t), t, o, n, !0),
                            H = zs.encodeAllRaw,
                            I = (e, t) => N(e, (e => {
                                const o = go(e);
                                return t && W(Mo(o), (e => {
                                    Ft(e) && 0 === e.dom.length ? rn(e) : Jo(o, e)
                                })), rn(o), o.dom
                            })),
                            P = (e, t, o) => {
                                N(e, (e => {
                                    if (Rn(e)) {
                                        const n = go(e),
                                            r = t.split(" ");
                                        W(r, (e => {
                                            x(o) ? (o ? no : so)(n, e) : ((e, t) => {
                                                const o = Qt(e) ? e.dom.classList.toggle(t) : ((e, t) => Z(eo(e), t) ? oo(e, t) : to(e, t))(e, t);
                                                ro(e)
                                            })(n, e)
                                        }))
                                    }
                                }))
                            },
                            z = (e, t, o) => N(t, (n => {
                                var r;
                                const s = f(t) ? e.cloneNode(!0) : e;
                                return o && ca(da(n.childNodes), (e => {
                                    s.appendChild(e)
                                })), null === (r = n.parentNode) || void 0 === r || r.replaceChild(s, n), n
                            })),
                            F = e => {
                                if (Rn(e)) {
                                    const t = "a" === e.nodeName.toLowerCase() && !p(e, "href") && p(e, "id");
                                    if (p(e, "name") || p(e, "data-mce-bookmark") || t) return !0
                                }
                                return !1
                            },
                            V = () => e.createRange(),
                            j = (o, r, s, a) => {
                                if (f(o)) {
                                    let e = o.length;
                                    const t = [];
                                    for (; e--;) t[e] = j(o[e], r, s, a);
                                    return t
                                }
                                return !t.collect || o !== e && o !== n || i.push([o, r, s, a]), d.bind(o, r, s, a || G)
                            },
                            $ = (t, o, r) => {
                                if (f(t)) {
                                    let e = t.length;
                                    const n = [];
                                    for (; e--;) n[e] = $(t[e], o, r);
                                    return n
                                }
                                if (i.length > 0 && (t === e || t === n)) {
                                    let e = i.length;
                                    for (; e--;) {
                                        const [n, s, a] = i[e];
                                        t !== n || o && o !== s || r && r !== a || d.unbind(n, s, a)
                                    }
                                }
                                return d.unbind(t, o, r)
                            },
                            q = e => {
                                if (e && Rn(e)) {
                                    const t = e.getAttribute("data-mce-contenteditable");
                                    return t && "inherit" !== t ? t : "inherit" !== e.contentEditable ? e.contentEditable : null
                                }
                                return null
                            },
                            G = {
                                doc: e,
                                settings: t,
                                win: n,
                                files: r,
                                stdMode: !0,
                                boxModel: !0,
                                styleSheetLoader: a,
                                boundEvents: i,
                                styles: c,
                                schema: l,
                                events: d,
                                isBlock: e => g(e) ? Se(u, e) : Rn(e) && (Se(u, e.nodeName) || fs(l, e)),
                                root: null,
                                clone: (e, t) => e.cloneNode(t),
                                getRoot: y,
                                getViewPort: e => {
                                    const t = wn(e);
                                    return {
                                        x: t.x,
                                        y: t.y,
                                        w: t.width,
                                        h: t.height
                                    }
                                },
                                getRect: e => {
                                    const t = m(e),
                                        o = S(t),
                                        n = O(t);
                                    return {
                                        x: o.x,
                                        y: o.y,
                                        w: n.w,
                                        h: n.h
                                    }
                                },
                                getSize: O,
                                getParent: (e, t, o) => {
                                    const n = A(e, t, o, !1);
                                    return n && n.length > 0 ? n[0] : null
                                },
                                getParents: A,
                                get: m,
                                getNext: (e, t) => M(e, t, "nextSibling"),
                                getPrev: (e, t) => M(e, t, "previousSibling"),
                                select: (o, n) => {
                                    var r, s;
                                    const a = null !== (s = null !== (r = m(n)) && void 0 !== r ? r : t.root_element) && void 0 !== s ? s : e;
                                    return C(a.querySelectorAll) ? de(a.querySelectorAll(o)) : []
                                },
                                is: T,
                                add: B,
                                create: L,
                                createHTML: (e, t, o = "") => {
                                    let n = "<" + e;
                                    for (const e in t) ke(t, e) && (n += " " + e + '="' + H(t[e]) + '"');
                                    return Ge(o) && Se(l.getVoidElements(), e) ? n + " />" : n + ">" + o + "</" + e + ">"
                                },
                                createFragment: t => {
                                    const o = e.createElement("div"),
                                        n = e.createDocumentFragment();
                                    let r;
                                    for (n.appendChild(o), t && (o.innerHTML = t); r = o.firstChild;) n.appendChild(r);
                                    return n.removeChild(o), n
                                },
                                remove: I,
                                setStyle: (e, o, n) => {
                                    N(e, (e => {
                                        const r = go(e);
                                        va(r, o, n), t.update_styles && fa(c, r)
                                    }))
                                },
                                getStyle: k,
                                setStyles: (e, o) => {
                                    N(e, (e => {
                                        const n = go(e);
                                        he(o, ((e, t) => {
                                            va(n, t, e)
                                        })), t.update_styles && fa(c, n)
                                    }))
                                },
                                removeAllAttribs: e => N(e, (e => {
                                    const t = e.attributes;
                                    for (let o = t.length - 1; o >= 0; o--) e.removeAttributeNode(t.item(o))
                                })),
                                setAttrib: b,
                                setAttribs: R,
                                getAttrib: p,
                                getPos: S,
                                parseStyle: e => c.parse(e),
                                serializeStyle: (e, t) => c.serialize(e, t),
                                addStyle: t => {
                                    if (G !== ba.DOM && e === document) {
                                        if (o[t]) return;
                                        o[t] = !0
                                    }
                                    let n = e.getElementById("mceDefaultStyles");
                                    if (!n) {
                                        n = e.createElement("style"), n.id = "mceDefaultStyles", n.type = "text/css";
                                        const t = e.head;
                                        t.firstChild ? t.insertBefore(n, t.firstChild) : t.appendChild(n)
                                    }
                                    n.styleSheet ? n.styleSheet.cssText += t : n.appendChild(e.createTextNode(t))
                                },
                                loadCSS: e => {
                                    e || (e = ""), W(e.split(","), (e => {
                                        r[e] = !0, a.load(e).catch(_)
                                    }))
                                },
                                addClass: (e, t) => {
                                    P(e, t, !0)
                                },
                                removeClass: (e, t) => {
                                    P(e, t, !1)
                                },
                                hasClass: (e, t) => {
                                    const o = h(e),
                                        n = t.split(" ");
                                    return x(o) && oe(n, (e => ao(o, e)))
                                },
                                toggleClass: P,
                                show: e => {
                                    N(e, (e => Xo(go(e), "display")))
                                },
                                hide: e => {
                                    N(e, (e => Wo(go(e), "display", "none")))
                                },
                                isHidden: e => {
                                    const t = h(e);
                                    return x(t) && Dt(Ko(t, "display"), "none")
                                },
                                uniqueId: e => (e || "mce_") + s++,
                                setHTML: D,
                                getOuterHTML: e => {
                                    const t = h(e);
                                    return x(t) ? Rn(t.dom) ? t.dom.outerHTML : (e => {
                                        const t = uo("div"),
                                            o = go(e.dom.cloneNode(!0));
                                        return tn(t, o), ln(t)
                                    })(t) : ""
                                },
                                setOuterHTML: (e, t) => {
                                    N(e, (e => {
                                        Rn(e) && (e.outerHTML = t)
                                    }))
                                },
                                decode: zs.decode,
                                encode: H,
                                insertAfter: (e, t) => {
                                    const o = m(t);
                                    return N(e, (e => {
                                        const t = null == o ? void 0 : o.parentNode,
                                            n = null == o ? void 0 : o.nextSibling;
                                        return t && (n ? t.insertBefore(e, n) : t.appendChild(e)), e
                                    }))
                                },
                                replace: z,
                                rename: (e, t) => {
                                    if (e.nodeName !== t.toUpperCase()) {
                                        const o = L(t);
                                        return ca(v(e), (t => {
                                            b(o, t.nodeName, p(e, t.nodeName))
                                        })), z(o, e, !0), o
                                    }
                                    return e
                                },
                                findCommonAncestor: (e, t) => {
                                    let o = e;
                                    for (; o;) {
                                        let e = t;
                                        for (; e && o !== e;) e = e.parentNode;
                                        if (o === e) break;
                                        o = o.parentNode
                                    }
                                    return !o && e.ownerDocument ? e.ownerDocument.documentElement : o
                                },
                                run: N,
                                getAttribs: v,
                                isEmpty: (e, t) => {
                                    let o = 0;
                                    if (F(e)) return !1;
                                    const n = e.firstChild;
                                    if (n) {
                                        const r = new An(n, e),
                                            s = l ? l.getWhitespaceElements() : {},
                                            a = t || (l ? l.getNonEmptyElements() : null);
                                        let i = n;
                                        do {
                                            if (Rn(i)) {
                                                const e = i.getAttribute("data-mce-bogus");
                                                if (e) {
                                                    i = r.next("all" === e);
                                                    continue
                                                }
                                                const t = i.nodeName.toLowerCase();
                                                if (a && a[t]) {
                                                    if ("br" === t) {
                                                        o++, i = r.next();
                                                        continue
                                                    }
                                                    return !1
                                                }
                                                if (F(i)) return !1
                                            }
                                            if (jn(i)) return !1;
                                            if (Vn(i) && !Xr(i.data)) return !1;
                                            if (Vn(i) && i.parentNode && s[i.parentNode.nodeName] && Xr(i.data)) return !1;
                                            i = r.next()
                                        } while (i)
                                    }
                                    return o <= 1
                                },
                                createRng: V,
                                nodeIndex: pa,
                                split: (e, t, o) => {
                                    let n, r, s = V();
                                    if (e && t && e.parentNode && t.parentNode) {
                                        const a = e.parentNode;
                                        return s.setStart(a, pa(e)), s.setEnd(t.parentNode, pa(t)), n = s.extractContents(), s = V(), s.setStart(t.parentNode, pa(t) + 1), s.setEnd(a, pa(e) + 1), r = s.extractContents(), a.insertBefore(_s(G, n), e), o ? a.insertBefore(o, e) : a.insertBefore(t, e), a.insertBefore(_s(G, r), e), I(e), o || t
                                    }
                                },
                                bind: j,
                                unbind: $,
                                fire: (e, t, o) => d.dispatch(e, t, o),
                                dispatch: (e, t, o) => d.dispatch(e, t, o),
                                getContentEditable: q,
                                getContentEditableParent: e => {
                                    const t = y();
                                    let o = null;
                                    for (let n = e; n && n !== t && (o = q(n), null === o); n = n.parentNode);
                                    return o
                                },
                                destroy: () => {
                                    if (i.length > 0) {
                                        let e = i.length;
                                        for (; e--;) {
                                            const [t, o, n] = i[e];
                                            d.unbind(t, o, n)
                                        }
                                    }
                                    he(r, ((e, t) => {
                                        a.unload(t), delete r[t]
                                    }))
                                },
                                isChildOf: (e, t) => e === t || t.contains(e),
                                dumpRng: e => "startContainer: " + e.startContainer.nodeName + ", startOffset: " + e.startOffset + ", endContainer: " + e.endContainer.nodeName + ", endOffset: " + e.endOffset
                            },
                            K = ((e, t, o) => {
                                const n = t.keep_values,
                                    r = {
                                        set: (e, n, r) => {
                                            const s = go(e);
                                            C(t.url_converter) && x(n) && (n = t.url_converter.call(t.url_converter_scope || o(), String(n), r, e)), ga(s, "data-mce-" + r, n), ga(s, r, n)
                                        },
                                        get: (e, t) => {
                                            const o = go(e);
                                            return qt(o, "data-mce-" + t) || qt(o, t)
                                        }
                                    },
                                    s = {
                                        style: {
                                            set: (t, o) => {
                                                const r = go(t);
                                                n && ga(r, ua, o), Yt(r, "style"), g(o) && $o(r, e.parse(o))
                                            },
                                            get: t => {
                                                const o = go(t),
                                                    n = qt(o, ua) || qt(o, "style");
                                                return e.serialize(e.parse(n), Ht(o))
                                            }
                                        }
                                    };
                                return n && (s.href = s.src = r), s
                            })(c, t, E(G));
                        return G
                    };
                ba.DOM = ba(document), ba.nodeIndex = pa;
                const ya = ba.DOM;
                class wa {
                    constructor(e = {}) {
                        this.states = {}, this.queue = [], this.scriptLoadedCallbacks = {}, this.queueLoadedCallbacks = [], this.loading = !1, this.settings = e
                    }
                    _setReferrerPolicy(e) {
                        this.settings.referrerPolicy = e
                    }
                    loadScript(e) {
                        return new Promise(((t, o) => {
                            const n = ya;
                            let r;
                            const s = () => {
                                    n.remove(a), r && (r.onerror = r.onload = r = null)
                                },
                                a = n.uniqueId();
                            r = document.createElement("script"), r.id = a, r.type = "text/javascript", r.src = Rt._addCacheSuffix(e), this.settings.referrerPolicy && n.setAttrib(r, "referrerpolicy", this.settings.referrerPolicy), r.onload = () => {
                                s(), t()
                            }, r.onerror = () => {
                                s(), o("Failed to load script: " + e)
                            }, (document.getElementsByTagName("head")[0] || document.body).appendChild(r)
                        }))
                    }
                    isDone(e) {
                        return 2 === this.states[e]
                    }
                    markDone(e) {
                        this.states[e] = 2
                    }
                    add(e) {
                        const t = this;
                        return t.queue.push(e), void 0 === t.states[e] && (t.states[e] = 0), new Promise(((o, n) => {
                            t.scriptLoadedCallbacks[e] || (t.scriptLoadedCallbacks[e] = []), t.scriptLoadedCallbacks[e].push({
                                resolve: o,
                                reject: n
                            })
                        }))
                    }
                    load(e) {
                        return this.add(e)
                    }
                    remove(e) {
                        delete this.states[e], delete this.scriptLoadedCallbacks[e]
                    }
                    loadQueue() {
                        const e = this.queue;
                        return this.queue = [], this.loadScripts(e)
                    }
                    loadScripts(e) {
                        const t = this,
                            o = (e, o) => {
                                Ce(t.scriptLoadedCallbacks, o).each((t => {
                                    W(t, (t => t[e](o)))
                                })), delete t.scriptLoadedCallbacks[o]
                            },
                            n = e => {
                                const t = G(e, (e => "rejected" === e.status));
                                return t.length > 0 ? Promise.reject(te(t, (({
                                    reason: e
                                }) => f(e) ? e : [e]))) : Promise.resolve()
                            },
                            r = e => Promise.allSettled(j(e, (e => 2 === t.states[e] ? (o("resolve", e), Promise.resolve()) : 3 === t.states[e] ? (o("reject", e), Promise.reject(e)) : (t.states[e] = 1, t.loadScript(e).then((() => {
                                t.states[e] = 2, o("resolve", e);
                                const s = t.queue;
                                return s.length > 0 ? (t.queue = [], r(s).then(n)) : Promise.resolve()
                            }), (() => (t.states[e] = 3, o("reject", e), Promise.reject(e)))))))),
                            s = e => (t.loading = !0, r(e).then((e => {
                                t.loading = !1;
                                const o = t.queueLoadedCallbacks.shift();
                                return I.from(o).each(B), n(e)
                            }))),
                            a = _e(e);
                        return t.loading ? new Promise(((e, o) => {
                            t.queueLoadedCallbacks.push((() => s(a).then(e, o)))
                        })) : s(a)
                    }
                }
                wa.ScriptLoader = new wa;
                const xa = e => {
                        let t = e;
                        return {
                            get: () => t,
                            set: e => {
                                t = e
                            }
                        }
                    },
                    Ca = {},
                    Sa = xa("en"),
                    ka = () => Ce(Ca, Sa.get()),
                    _a = {
                        getData: () => pe(Ca, (e => ({ ...e
                        }))),
                        setCode: e => {
                            e && Sa.set(e)
                        },
                        getCode: () => Sa.get(),
                        add: (e, t) => {
                            let o = Ca[e];
                            o || (Ca[e] = o = {}), he(t, ((e, t) => {
                                o[t.toLowerCase()] = e
                            }))
                        },
                        translate: e => {
                            const t = ka().getOr({}),
                                o = e => C(e) ? Object.prototype.toString.call(e) : n(e) ? "" : "" + e,
                                n = e => "" === e || null == e,
                                r = e => {
                                    const n = o(e);
                                    return Ce(t, n.toLowerCase()).map(o).getOr(n)
                                },
                                s = e => e.replace(/{context:\w+}$/, "");
                            if (n(e)) return "";
                            if (h(a = e) && Se(a, "raw")) return o(e.raw);
                            var a;
                            if ((e => f(e) && e.length > 1)(e)) {
                                const t = e.slice(1);
                                return s(r(e[0]).replace(/\{([0-9]+)\}/g, ((e, n) => Se(t, n) ? o(t[n]) : e)))
                            }
                            return s(r(e))
                        },
                        isRtl: () => ka().bind((e => Ce(e, "_dir"))).exists((e => "rtl" === e)),
                        hasCode: e => Se(Ca, e)
                    },
                    Oa = () => {
                        const e = [],
                            t = {},
                            o = {},
                            n = [],
                            r = (e, t) => {
                                const o = G(n, (o => o.name === e && o.state === t));
                                W(o, (e => e.resolve()))
                            },
                            s = e => Se(t, e),
                            a = (e, o) => {
                                const n = _a.getCode();
                                !n || o && -1 === ("," + (o || "") + ",").indexOf("," + n + ",") || wa.ScriptLoader.add(t[e] + "/langs/" + n + ".js")
                            },
                            i = (e, t = "added") => "added" === t && (e => Se(o, e))(e) || "loaded" === t && s(e) ? Promise.resolve() : new Promise((o => {
                                n.push({
                                    name: e,
                                    state: t,
                                    resolve: o
                                })
                            }));
                        return {
                            items: e,
                            urls: t,
                            lookup: o,
                            get: e => {
                                if (o[e]) return o[e].instance
                            },
                            requireLangPack: (e, t) => {
                                !1 !== Oa.languageLoad && (s(e) ? a(e, t) : i(e, "loaded").then((() => a(e, t))))
                            },
                            add: (t, n) => (e.push(n), o[t] = {
                                instance: n
                            }, r(t, "added"), n),
                            remove: e => {
                                delete t[e], delete o[e]
                            },
                            createUrl: (e, t) => g(t) ? g(e) ? {
                                prefix: "",
                                resource: t,
                                suffix: ""
                            } : {
                                prefix: e.prefix,
                                resource: t,
                                suffix: e.suffix
                            } : t,
                            load: (e, n) => {
                                if (t[e]) return Promise.resolve();
                                let s = g(n) ? n : n.prefix + n.resource + n.suffix;
                                0 !== s.indexOf("/") && -1 === s.indexOf("://") && (s = Oa.baseURL + "/" + s), t[e] = s.substring(0, s.lastIndexOf("/"));
                                const a = () => (r(e, "loaded"), Promise.resolve());
                                return o[e] ? a() : wa.ScriptLoader.add(s).then(a)
                            },
                            waitFor: i
                        }
                    };
                Oa.languageLoad = !0, Oa.baseURL = "", Oa.PluginManager = Oa(), Oa.ThemeManager = Oa(), Oa.ModelManager = Oa();
                const Ta = e => {
                        const t = xa(I.none()),
                            o = () => t.get().each((e => clearInterval(e)));
                        return {
                            clear: () => {
                                o(), t.set(I.none())
                            },
                            isSet: () => t.get().isSome(),
                            get: () => t.get(),
                            set: n => {
                                o(), t.set(I.some(setInterval(n, e)))
                            }
                        }
                    },
                    Ea = () => {
                        const e = (e => {
                            const t = xa(I.none()),
                                o = () => t.get().each(e);
                            return {
                                clear: () => {
                                    o(), t.set(I.none())
                                },
                                isSet: () => t.get().isSome(),
                                get: () => t.get(),
                                set: e => {
                                    o(), t.set(I.some(e))
                                }
                            }
                        })(_);
                        return { ...e,
                            on: t => e.get().each(t)
                        }
                    },
                    Aa = (e, t) => {
                        let o = null;
                        return {
                            cancel: () => {
                                v(o) || (clearTimeout(o), o = null)
                            },
                            throttle: (...n) => {
                                v(o) && (o = setTimeout((() => {
                                    o = null, e.apply(null, n)
                                }), t))
                            }
                        }
                    },
                    Ma = (e, t) => {
                        let o = null;
                        const n = () => {
                            v(o) || (clearTimeout(o), o = null)
                        };
                        return {
                            cancel: n,
                            throttle: (...r) => {
                                n(), o = setTimeout((() => {
                                    o = null, e.apply(null, r)
                                }), t)
                            }
                        }
                    },
                    Na = E("mce-annotation"),
                    Ra = E("data-mce-annotation"),
                    Da = E("data-mce-annotation-uid"),
                    Ba = E("data-mce-annotation-active"),
                    La = E("data-mce-annotation-classes"),
                    Ha = E("data-mce-annotation-attrs"),
                    Ia = e => t => bo(t, e),
                    Pa = (e, t) => {
                        const o = e.selection.getRng(),
                            n = go(o.startContainer),
                            r = go(e.getBody()),
                            s = t.fold((() => "." + Na()), (e => `[${Ra()}="${e}"]`)),
                            a = No(n, o.startOffset).getOr(n);
                        return Tn(a, s, Ia(r)).bind((t => Gt(t, `${Da()}`).bind((o => Gt(t, `${Ra()}`).map((t => {
                            const n = Fa(e, o);
                            return {
                                uid: o,
                                name: t,
                                elements: n
                            }
                        }))))))
                    },
                    za = (e, t) => Kt(e, "data-mce-bogus") || En(e, '[data-mce-bogus="all"]', Ia(t)),
                    Fa = (e, t) => {
                        const o = go(e.getBody()),
                            n = rr(o, `[${Da()}="${t}"]`);
                        return G(n, (e => !za(e, o)))
                    },
                    Va = (e, t) => {
                        const o = go(e.getBody()),
                            n = rr(o, `[${Ra()}="${t}"]`),
                            r = {};
                        return W(n, (e => {
                            if (!za(e, o)) {
                                const t = qt(e, Da()),
                                    o = Ce(r, t).getOr([]);
                                r[t] = o.concat([e])
                            }
                        })), r
                    };
                let Za = 0;
                const Ua = e => {
                        const t = (new Date).getTime(),
                            o = Math.floor(1e9 * Math.random());
                        return Za++, e + "_" + o + Za + String(t)
                    },
                    ja = (e, t) => go(e.dom.cloneNode(t)),
                    Wa = e => ja(e, !1),
                    $a = e => ja(e, !0),
                    qa = (e, t, o = L) => {
                        const n = new An(e, t),
                            r = e => {
                                let t;
                                do {
                                    t = n[e]()
                                } while (t && !Vn(t) && !o(t));
                                return I.from(t).filter(Vn)
                            };
                        return {
                            current: () => I.from(n.current()).filter(Vn),
                            next: () => r("next"),
                            prev: () => r("prev"),
                            prev2: () => r("prev2")
                        }
                    },
                    Ga = (e, t) => {
                        const o = t || (t => e.isBlock(t) || qn(t) || Yn(t)),
                            n = (e, t, o, r) => {
                                if (Vn(e)) {
                                    const o = r(e, t, e.data);
                                    if (-1 !== o) return I.some({
                                        container: e,
                                        offset: o
                                    })
                                }
                                return o().bind((e => n(e.container, e.offset, o, r)))
                            };
                        return {
                            backwards: (t, r, s, a) => {
                                const i = qa(t, null != a ? a : e.getRoot(), o);
                                return n(t, r, (() => i.prev().map((e => ({
                                    container: e,
                                    offset: e.length
                                })))), s).getOrNull()
                            },
                            forwards: (t, r, s, a) => {
                                const i = qa(t, null != a ? a : e.getRoot(), o);
                                return n(t, r, (() => i.next().map((e => ({
                                    container: e,
                                    offset: 0
                                })))), s).getOrNull()
                            }
                        }
                    },
                    Ka = Math.round,
                    Ya = e => e ? {
                        left: Ka(e.left),
                        top: Ka(e.top),
                        bottom: Ka(e.bottom),
                        right: Ka(e.right),
                        width: Ka(e.width),
                        height: Ka(e.height)
                    } : {
                        left: 0,
                        top: 0,
                        bottom: 0,
                        right: 0,
                        width: 0,
                        height: 0
                    },
                    Xa = (e, t) => (e = Ya(e), t || (e.left = e.left + e.width), e.right = e.left, e.width = 0, e),
                    Ja = (e, t, o) => e >= 0 && e <= Math.min(t.height, o.height) / 2,
                    Qa = (e, t) => {
                        const o = Math.min(t.height / 2, e.height / 2);
                        return e.bottom - o < t.top || !(e.top > t.bottom) && Ja(t.top - e.bottom, e, t)
                    },
                    ei = (e, t) => e.top > t.bottom || !(e.bottom < t.top) && Ja(t.bottom - e.top, e, t),
                    ti = (e, t, o) => {
                        const n = Math.max(Math.min(t, e.left + e.width), e.left),
                            r = Math.max(Math.min(o, e.top + e.height), e.top);
                        return Math.sqrt((t - n) * (t - n) + (o - r) * (o - r))
                    },
                    oi = e => {
                        const t = e.startContainer,
                            o = e.startOffset;
                        return t === e.endContainer && t.hasChildNodes() && e.endOffset === o + 1 ? t.childNodes[o] : null
                    },
                    ni = (e, t) => {
                        if (Rn(e) && e.hasChildNodes()) {
                            const o = e.childNodes,
                                n = ((e, t, o) => Math.min(Math.max(e, 0), o))(t, 0, o.length - 1);
                            return o[n]
                        }
                        return e
                    },
                    ri = new RegExp("[-----------------------------------------------------------------------------------------------------------------------------------]"),
                    si = e => g(e) && e.charCodeAt(0) >= 768 && ri.test(e),
                    ai = Rn,
                    ii = qr,
                    li = Ln("display", "block table"),
                    ci = Ln("float", "left right"),
                    di = ((...e) => t => {
                        for (let o = 0; o < e.length; o++)
                            if (!e[o](t)) return !1;
                        return !0
                    })(ai, ii, R(ci)),
                    ui = R(Ln("white-space", "pre pre-line pre-wrap")),
                    mi = Vn,
                    gi = qn,
                    hi = ba.nodeIndex,
                    pi = (e, t) => t < 0 && Rn(e) && e.hasChildNodes() ? void 0 : ni(e, t),
                    fi = e => e ? e.createRange() : ba.DOM.createRng(),
                    vi = e => g(e) && /[\r\n\t ]/.test(e),
                    bi = e => !!e.setStart && !!e.setEnd,
                    yi = e => {
                        const t = e.startContainer,
                            o = e.startOffset;
                        if (vi(e.toString()) && ui(t.parentNode) && Vn(t)) {
                            const e = t.data;
                            if (vi(e[o - 1]) || vi(e[o + 1])) return !0
                        }
                        return !1
                    },
                    wi = e => 0 === e.left && 0 === e.right && 0 === e.top && 0 === e.bottom,
                    xi = e => {
                        var t;
                        let o;
                        const n = e.getClientRects();
                        return o = n.length > 0 ? Ya(n[0]) : Ya(e.getBoundingClientRect()), !bi(e) && gi(e) && wi(o) ? (e => {
                            const t = e.ownerDocument,
                                o = fi(t),
                                n = t.createTextNode(or),
                                r = e.parentNode;
                            r.insertBefore(n, e), o.setStart(n, 0), o.setEnd(n, 1);
                            const s = Ya(o.getBoundingClientRect());
                            return r.removeChild(n), s
                        })(e) : wi(o) && bi(e) && null !== (t = (e => {
                            const t = e.startContainer,
                                o = e.endContainer,
                                n = e.startOffset,
                                r = e.endOffset;
                            if (t === o && Vn(o) && 0 === n && 1 === r) {
                                const t = e.cloneRange();
                                return t.setEndAfter(o), xi(t)
                            }
                            return null
                        })(e)) && void 0 !== t ? t : o
                    },
                    Ci = (e, t) => {
                        const o = Xa(e, t);
                        return o.width = 1, o.right = o.left + 1, o
                    },
                    Si = (e, t, o) => {
                        const n = () => (o || (o = (e => {
                            const t = [],
                                o = e => {
                                    var o, n;
                                    0 !== e.height && (t.length > 0 && (o = e, n = t[t.length - 1], o.left === n.left && o.top === n.top && o.bottom === n.bottom && o.right === n.right) || t.push(e))
                                },
                                n = (e, t) => {
                                    const n = fi(e.ownerDocument);
                                    if (t < e.data.length) {
                                        if (si(e.data[t])) return;
                                        if (si(e.data[t - 1]) && (n.setStart(e, t), n.setEnd(e, t + 1), !yi(n))) return void o(Ci(xi(n), !1))
                                    }
                                    t > 0 && (n.setStart(e, t - 1), n.setEnd(e, t), yi(n) || o(Ci(xi(n), !1))), t < e.data.length && (n.setStart(e, t), n.setEnd(e, t + 1), yi(n) || o(Ci(xi(n), !0)))
                                },
                                r = e.container(),
                                s = e.offset();
                            if (mi(r)) return n(r, s), t;
                            if (ai(r))
                                if (e.isAtEnd()) {
                                    const e = pi(r, s);
                                    mi(e) && n(e, e.data.length), di(e) && !gi(e) && o(Ci(xi(e), !1))
                                } else {
                                    const a = pi(r, s);
                                    if (mi(a) && n(a, 0), di(a) && e.isAtEnd()) return o(Ci(xi(a), !1)), t;
                                    const i = pi(e.container(), e.offset() - 1);
                                    di(i) && !gi(i) && (li(i) || li(a) || !di(a)) && o(Ci(xi(i), !1)), di(a) && o(Ci(xi(a), !0))
                                }
                            return t
                        })(Si(e, t))), o);
                        return {
                            container: E(e),
                            offset: E(t),
                            toRange: () => {
                                const o = fi(e.ownerDocument);
                                return o.setStart(e, t), o.setEnd(e, t), o
                            },
                            getClientRects: n,
                            isVisible: () => n().length > 0,
                            isAtStart: () => (mi(e), 0 === t),
                            isAtEnd: () => mi(e) ? t >= e.data.length : t >= e.childNodes.length,
                            isEqual: o => o && e === o.container() && t === o.offset(),
                            getNode: o => pi(e, o ? t - 1 : t)
                        }
                    };
                Si.fromRangeStart = e => Si(e.startContainer, e.startOffset), Si.fromRangeEnd = e => Si(e.endContainer, e.endOffset), Si.after = e => Si(e.parentNode, hi(e) + 1), Si.before = e => Si(e.parentNode, hi(e)), Si.isAbove = (e, t) => Bt(le(t.getClientRects()), ce(e.getClientRects()), Qa).getOr(!1), Si.isBelow = (e, t) => Bt(ce(t.getClientRects()), le(e.getClientRects()), ei).getOr(!1), Si.isAtStart = e => !!e && e.isAtStart(), Si.isAtEnd = e => !!e && e.isAtEnd(), Si.isTextPosition = e => !!e && Vn(e.container()), Si.isElementPosition = e => !Si.isTextPosition(e);
                const ki = (e, t) => {
                        Vn(t) && 0 === t.data.length && e.remove(t)
                    },
                    _i = (e, t, o) => {
                        $n(o) ? ((e, t, o) => {
                            const n = I.from(o.firstChild),
                                r = I.from(o.lastChild);
                            t.insertNode(o), n.each((t => ki(e, t.previousSibling))), r.each((t => ki(e, t.nextSibling)))
                        })(e, t, o) : ((e, t, o) => {
                            t.insertNode(o), ki(e, o.previousSibling), ki(e, o.nextSibling)
                        })(e, t, o)
                    },
                    Oi = Vn,
                    Ti = In,
                    Ei = ba.nodeIndex,
                    Ai = e => {
                        const t = e.parentNode;
                        return Ti(t) ? Ai(t) : t
                    },
                    Mi = e => e ? Ne(e.childNodes, ((e, t) => (Ti(t) && "BR" !== t.nodeName ? e = e.concat(Mi(t)) : e.push(t), e)), []) : [],
                    Ni = e => t => e === t,
                    Ri = e => (Oi(e) ? "text()" : e.nodeName.toLowerCase()) + "[" + (e => {
                        let t, o;
                        t = Mi(Ai(e)), o = Re(t, Ni(e), e), t = t.slice(0, o + 1);
                        const n = Ne(t, ((e, o, n) => (Oi(o) && Oi(t[n - 1]) && e++, e)), 0);
                        return t = Me(t, Bn([e.nodeName])), o = Re(t, Ni(e), e), o - n
                    })(e) + "]",
                    Di = (e, t) => {
                        let o, n = [],
                            r = t.container(),
                            s = t.offset();
                        if (Oi(r)) o = ((e, t) => {
                            let o = e;
                            for (;
                                (o = o.previousSibling) && Oi(o);) t += o.data.length;
                            return t
                        })(r, s);
                        else {
                            const e = r.childNodes;
                            s >= e.length ? (o = "after", s = e.length - 1) : o = "before", r = e[s]
                        }
                        n.push(Ri(r));
                        let a = ((e, t, o) => {
                            const n = [];
                            for (let o = t.parentNode; o && o !== e; o = o.parentNode) n.push(o);
                            return n
                        })(e, r);
                        return a = Me(a, R(In)), n = n.concat(Ae(a, (e => Ri(e)))), n.reverse().join("/") + "," + o
                    },
                    Bi = (e, t) => {
                        if (!t) return null;
                        const o = t.split(","),
                            n = o[0].split("/"),
                            r = o.length > 1 ? o[1] : "before",
                            s = Ne(n, ((e, t) => {
                                const o = /([\w\-\(\)]+)\[([0-9]+)\]/.exec(t);
                                return o ? ("text()" === o[1] && (o[1] = "#text"), ((e, t, o) => {
                                    let n = Mi(e);
                                    return n = Me(n, ((e, t) => !Oi(e) || !Oi(n[t - 1]))), n = Me(n, Bn([t])), n[o]
                                })(e, o[1], parseInt(o[2], 10))) : null
                            }), e);
                        if (!s) return null;
                        if (!Oi(s) && s.parentNode) {
                            let e;
                            return e = "after" === r ? Ei(s) + 1 : Ei(s), Si(s.parentNode, e)
                        }
                        return ((e, t) => {
                            let o = e,
                                n = 0;
                            for (; Oi(o);) {
                                const r = o.data.length;
                                if (t >= n && t <= n + r) {
                                    e = o, t -= n;
                                    break
                                }
                                if (!Oi(o.nextSibling)) {
                                    e = o, t = r;
                                    break
                                }
                                n += r, o = o.nextSibling
                            }
                            return Oi(e) && t > e.data.length && (t = e.data.length), Si(e, t)
                        })(s, parseInt(r, 10))
                    },
                    Li = Yn,
                    Hi = (e, t, o, n, r) => {
                        const s = r ? n.startContainer : n.endContainer;
                        let a = r ? n.startOffset : n.endOffset;
                        const i = [],
                            l = e.getRoot();
                        if (Vn(s)) i.push(o ? ((e, t, o) => {
                            let n = e(t.data.slice(0, o)).length;
                            for (let o = t.previousSibling; o && Vn(o); o = o.previousSibling) n += e(o.data).length;
                            return n
                        })(t, s, a) : a);
                        else {
                            let t = 0;
                            const n = s.childNodes;
                            a >= n.length && n.length && (t = 1, a = Math.max(0, n.length - 1)), i.push(e.nodeIndex(n[a], o) + t)
                        }
                        for (let t = s; t && t !== l; t = t.parentNode) i.push(e.nodeIndex(t, o));
                        return i
                    },
                    Ii = (e, t, o) => {
                        let n = 0;
                        return Rt.each(e.select(t), (e => "all" === e.getAttribute("data-mce-bogus") ? void 0 : e !== o && void n++)), n
                    },
                    Pi = (e, t) => {
                        let o = t ? e.startContainer : e.endContainer,
                            n = t ? e.startOffset : e.endOffset;
                        if (Rn(o) && "TR" === o.nodeName) {
                            const r = o.childNodes;
                            o = r[Math.min(t ? n : n - 1, r.length - 1)], o && (n = t ? 0 : o.childNodes.length, t ? e.setStart(o, n) : e.setEnd(o, n))
                        }
                    },
                    zi = e => (Pi(e, !0), Pi(e, !1), e),
                    Fi = (e, t) => {
                        if (Rn(e) && (e = ni(e, t), Li(e))) return e;
                        if (Nr(e)) {
                            Vn(e) && Ar(e) && (e = e.parentNode);
                            let t = e.previousSibling;
                            if (Li(t)) return t;
                            if (t = e.nextSibling, Li(t)) return t
                        }
                    },
                    Vi = (e, t, o) => {
                        const n = o.getNode(),
                            r = o.getRng();
                        if ("IMG" === n.nodeName || Li(n)) {
                            const e = n.nodeName;
                            return {
                                name: e,
                                index: Ii(o.dom, e, n)
                            }
                        }
                        const s = (e => Fi(e.startContainer, e.startOffset) || Fi(e.endContainer, e.endOffset))(r);
                        if (s) {
                            const e = s.tagName;
                            return {
                                name: e,
                                index: Ii(o.dom, e, s)
                            }
                        }
                        return ((e, t, o, n) => {
                            const r = t.dom,
                                s = Hi(r, e, o, n, !0),
                                a = t.isForward(),
                                i = Pr(n) ? {
                                    isFakeCaret: !0
                                } : {};
                            return t.isCollapsed() ? {
                                start: s,
                                forward: a,
                                ...i
                            } : {
                                start: s,
                                end: Hi(r, e, o, n, !1),
                                forward: a,
                                ...i
                            }
                        })(e, o, t, r)
                    },
                    Zi = (e, t, o) => {
                        const n = {
                            "data-mce-type": "bookmark",
                            id: t,
                            style: "overflow:hidden;line-height:0px"
                        };
                        return o ? e.create("span", n, "&#xFEFF;") : e.create("span", n)
                    },
                    Ui = (e, t) => {
                        const o = e.dom;
                        let n = e.getRng();
                        const r = o.uniqueId(),
                            s = e.isCollapsed(),
                            a = e.getNode(),
                            i = a.nodeName,
                            l = e.isForward();
                        if ("IMG" === i) return {
                            name: i,
                            index: Ii(o, i, a)
                        };
                        const c = zi(n.cloneRange());
                        if (!s) {
                            c.collapse(!1);
                            const e = Zi(o, r + "_end", t);
                            _i(o, c, e)
                        }
                        n = zi(n), n.collapse(!0);
                        const d = Zi(o, r + "_start", t);
                        return _i(o, n, d), e.moveToBookmark({
                            id: r,
                            keep: !0,
                            forward: l
                        }), {
                            id: r,
                            forward: l
                        }
                    },
                    ji = N(Vi, A, !0),
                    Wi = e => {
                        const t = t => t(e),
                            o = E(e),
                            n = () => r,
                            r = {
                                tag: !0,
                                inner: e,
                                fold: (t, o) => o(e),
                                isValue: H,
                                isError: L,
                                map: t => qi.value(t(e)),
                                mapError: n,
                                bind: t,
                                exists: t,
                                forall: t,
                                getOr: o,
                                or: n,
                                getOrThunk: o,
                                orThunk: n,
                                getOrDie: o,
                                each: t => {
                                    t(e)
                                },
                                toOptional: () => I.some(e)
                            };
                        return r
                    },
                    $i = e => {
                        const t = () => o,
                            o = {
                                tag: !1,
                                inner: e,
                                fold: (t, o) => t(e),
                                isValue: L,
                                isError: H,
                                map: t,
                                mapError: t => qi.error(t(e)),
                                bind: t,
                                exists: L,
                                forall: H,
                                getOr: A,
                                or: A,
                                getOrThunk: D,
                                orThunk: D,
                                getOrDie: (n = String(e), () => {
                                    throw new Error(n)
                                }),
                                each: _,
                                toOptional: I.none
                            };
                        var n;
                        return o
                    },
                    qi = {
                        value: Wi,
                        error: $i,
                        fromOption: (e, t) => e.fold((() => $i(t)), Wi)
                    },
                    Gi = e => {
                        if (!f(e)) throw new Error("cases must be an array");
                        if (0 === e.length) throw new Error("there must be at least one case");
                        const t = [],
                            o = {};
                        return W(e, ((n, r) => {
                            const s = me(n);
                            if (1 !== s.length) throw new Error("one and only one name per case");
                            const a = s[0],
                                i = n[a];
                            if (void 0 !== o[a]) throw new Error("duplicate key detected:" + a);
                            if ("cata" === a) throw new Error("cannot have a case named cata (sorry)");
                            if (!f(i)) throw new Error("case arguments must be an array");
                            t.push(a), o[a] = (...o) => {
                                const n = o.length;
                                if (n !== i.length) throw new Error("Wrong number of arguments to case " + a + ". Expected " + i.length + " (" + i + "), got " + n);
                                return {
                                    fold: (...t) => {
                                        if (t.length !== e.length) throw new Error("Wrong number of arguments to fold. Expected " + e.length + ", got " + t.length);
                                        return t[r].apply(null, o)
                                    },
                                    match: e => {
                                        const n = me(e);
                                        if (t.length !== n.length) throw new Error("Wrong number of arguments to match. Expected: " + t.join(",") + "\nActual: " + n.join(","));
                                        if (!oe(t, (e => Z(n, e)))) throw new Error("Not all branches were specified when using match. Specified: " + n.join(", ") + "\nRequired: " + t.join(", "));
                                        return e[a].apply(null, o)
                                    },
                                    log: e => {
                                        console.log(e, {
                                            constructors: t,
                                            constructor: a,
                                            params: o
                                        })
                                    }
                                }
                            }
                        })), o
                    };
                Gi([{
                    bothErrors: ["error1", "error2"]
                }, {
                    firstError: ["error1", "value2"]
                }, {
                    secondError: ["value1", "error2"]
                }, {
                    bothValues: ["value1", "value2"]
                }]);
                const Ki = e => "inline-command" === e.type || "inline-format" === e.type,
                    Yi = e => "block-command" === e.type || "block-format" === e.type,
                    Xi = e => {
                        const t = t => qi.error({
                                message: t,
                                pattern: e
                            }),
                            o = (o, n, r) => {
                                if (void 0 !== e.format) {
                                    let r;
                                    if (f(e.format)) {
                                        if (!oe(e.format, g)) return t(o + " pattern has non-string items in the `format` array");
                                        r = e.format
                                    } else {
                                        if (!g(e.format)) return t(o + " pattern has non-string `format` parameter");
                                        r = [e.format]
                                    }
                                    return qi.value(n(r))
                                }
                                return void 0 !== e.cmd ? g(e.cmd) ? qi.value(r(e.cmd, e.value)) : t(o + " pattern has non-string `cmd` parameter") : t(o + " pattern is missing both `format` and `cmd` parameters")
                            };
                        if (!h(e)) return t("Raw pattern is not an object");
                        if (!g(e.start)) return t("Raw pattern is missing `start` parameter");
                        if (void 0 !== e.end) {
                            if (!g(e.end)) return t("Inline pattern has non-string `end` parameter");
                            if (0 === e.start.length && 0 === e.end.length) return t("Inline pattern has empty `start` and `end` parameters");
                            let n = e.start,
                                r = e.end;
                            return 0 === r.length && (r = n, n = ""), o("Inline", (e => ({
                                type: "inline-format",
                                start: n,
                                end: r,
                                format: e
                            })), ((e, t) => ({
                                type: "inline-command",
                                start: n,
                                end: r,
                                cmd: e,
                                value: t
                            })))
                        }
                        return void 0 !== e.replacement ? g(e.replacement) ? 0 === e.start.length ? t("Replacement pattern has empty `start` parameter") : qi.value({
                            type: "inline-command",
                            start: "",
                            end: e.start,
                            cmd: "mceInsertContent",
                            value: e.replacement
                        }) : t("Replacement pattern has non-string `replacement` parameter") : 0 === e.start.length ? t("Block pattern has empty `start` parameter") : o("Block", (t => ({
                            type: "block-format",
                            start: e.start,
                            format: t[0]
                        })), ((t, o) => ({
                            type: "block-command",
                            start: e.start,
                            cmd: t,
                            value: o
                        })))
                    },
                    Ji = e => G(e, Yi),
                    Qi = e => G(e, Ki),
                    el = e => {
                        const t = (e => {
                            const t = [],
                                o = [];
                            return W(e, (e => {
                                e.fold((e => {
                                    t.push(e)
                                }), (e => {
                                    o.push(e)
                                }))
                            })), {
                                errors: t,
                                values: o
                            }
                        })(j(e, Xi));
                        return W(t.errors, (e => console.error(e.message, e.pattern))), t.values
                    },
                    tl = xt().deviceType,
                    ol = tl.isTouch(),
                    nl = ba.DOM,
                    rl = e => m(e, RegExp),
                    sl = e => t => t.options.get(e),
                    al = e => g(e) || h(e),
                    il = (e, t = "") => o => {
                        const n = g(o);
                        if (n) {
                            if (-1 !== o.indexOf("=")) {
                                const r = (e => {
                                    const t = e.indexOf("=") > 0 ? e.split(/[;,](?![^=;,]*(?:[;,]|$))/) : e.split(",");
                                    return Y(t, ((e, t) => {
                                        const o = t.split("="),
                                            n = o[0],
                                            r = o.length > 1 ? o[1] : n;
                                        return e[je(n)] = je(r), e
                                    }), {})
                                })(o);
                                return {
                                    value: Ce(r, e.id).getOr(t),
                                    valid: n
                                }
                            }
                            return {
                                value: o,
                                valid: n
                            }
                        }
                        return {
                            valid: !1,
                            message: "Must be a string."
                        }
                    },
                    ll = sl("iframe_attrs"),
                    cl = sl("doctype"),
                    dl = sl("document_base_url"),
                    ul = sl("body_id"),
                    ml = sl("body_class"),
                    gl = sl("content_security_policy"),
                    hl = sl("br_in_pre"),
                    pl = sl("forced_root_block"),
                    fl = sl("forced_root_block_attrs"),
                    vl = sl("newline_behavior"),
                    bl = sl("br_newline_selector"),
                    yl = sl("no_newline_selector"),
                    wl = sl("keep_styles"),
                    xl = sl("end_container_on_empty_block"),
                    Cl = sl("automatic_uploads"),
                    Sl = sl("images_reuse_filename"),
                    kl = sl("images_replace_blob_uris"),
                    _l = sl("icons"),
                    Ol = sl("icons_url"),
                    Tl = sl("images_upload_url"),
                    El = sl("images_upload_base_path"),
                    Al = sl("images_upload_credentials"),
                    Ml = sl("images_upload_handler"),
                    Nl = sl("content_css_cors"),
                    Rl = sl("referrer_policy"),
                    Dl = sl("language"),
                    Bl = sl("language_url"),
                    Ll = sl("indent_use_margin"),
                    Hl = sl("indentation"),
                    Il = sl("content_css"),
                    Pl = sl("content_style"),
                    zl = sl("font_css"),
                    Fl = sl("directionality"),
                    Vl = sl("inline_boundaries_selector"),
                    Zl = sl("object_resizing"),
                    Ul = sl("resize_img_proportional"),
                    jl = sl("placeholder"),
                    Wl = sl("event_root"),
                    $l = sl("service_message"),
                    ql = sl("theme"),
                    Gl = sl("theme_url"),
                    Kl = sl("model"),
                    Yl = sl("model_url"),
                    Xl = sl("inline_boundaries"),
                    Jl = sl("formats"),
                    Ql = sl("preview_styles"),
                    ec = sl("format_empty_lines"),
                    tc = sl("format_noneditable_selector"),
                    oc = sl("custom_ui_selector"),
                    nc = sl("inline"),
                    rc = sl("hidden_input"),
                    sc = sl("submit_patch"),
                    ac = sl("add_form_submit_trigger"),
                    ic = sl("add_unload_trigger"),
                    lc = sl("custom_undo_redo_levels"),
                    cc = sl("disable_nodechange"),
                    dc = sl("readonly"),
                    uc = sl("content_css_cors"),
                    mc = sl("plugins"),
                    gc = sl("external_plugins"),
                    hc = sl("block_unsupported_drop"),
                    pc = sl("visual"),
                    fc = sl("visual_table_class"),
                    vc = sl("visual_anchor_class"),
                    bc = sl("iframe_aria_text"),
                    yc = sl("setup"),
                    wc = sl("init_instance_callback"),
                    xc = sl("urlconverter_callback"),
                    Cc = sl("auto_focus"),
                    Sc = sl("browser_spellcheck"),
                    kc = sl("protect"),
                    _c = sl("paste_block_drop"),
                    Oc = sl("paste_data_images"),
                    Tc = sl("paste_preprocess"),
                    Ec = sl("paste_postprocess"),
                    Ac = sl("paste_webkit_styles"),
                    Mc = sl("paste_remove_styles_if_webkit"),
                    Nc = sl("paste_merge_formats"),
                    Rc = sl("smart_paste"),
                    Dc = sl("paste_as_text"),
                    Bc = sl("paste_tab_spaces"),
                    Lc = sl("allow_html_data_urls"),
                    Hc = sl("text_patterns"),
                    Ic = sl("text_patterns_lookup"),
                    Pc = sl("noneditable_class"),
                    zc = sl("editable_class"),
                    Fc = sl("noneditable_regexp"),
                    Vc = sl("preserve_cdata"),
                    Zc = e => Rt.explode(e.options.get("images_file_types")),
                    Uc = sl("table_tab_navigation"),
                    jc = Rn,
                    Wc = Vn,
                    $c = e => {
                        const t = e.parentNode;
                        t && t.removeChild(e)
                    },
                    qc = e => {
                        const t = Or(e);
                        return {
                            count: e.length - t.length,
                            text: t
                        }
                    },
                    Gc = e => {
                        let t;
                        for (; - 1 !== (t = e.data.lastIndexOf(kr));) e.deleteData(t, 1)
                    },
                    Kc = (e, t) => (Xc(e), t),
                    Yc = (e, t) => Si.isTextPosition(t) ? ((e, t) => Wc(e) && t.container() === e ? ((e, t) => {
                        const o = qc(e.data.substr(0, t.offset())),
                            n = qc(e.data.substr(t.offset()));
                        return (o.text + n.text).length > 0 ? (Gc(e), Si(e, t.offset() - o.count)) : t
                    })(e, t) : Kc(e, t))(e, t) : ((e, t) => t.container() === e.parentNode ? ((e, t) => {
                        const o = t.container(),
                            n = ((e, t) => {
                                const o = V(e, t);
                                return -1 === o ? I.none() : I.some(o)
                            })(de(o.childNodes), e).map((e => e < t.offset() ? Si(o, t.offset() - 1) : t)).getOr(t);
                        return Xc(e), n
                    })(e, t) : Kc(e, t))(e, t),
                    Xc = e => {
                        jc(e) && Nr(e) && (Rr(e) ? e.removeAttribute("data-mce-caret") : $c(e)), Wc(e) && (Gc(e), 0 === e.data.length && $c(e))
                    },
                    Jc = Yn,
                    Qc = Qn,
                    ed = Xn,
                    td = (e, t, o) => {
                        const n = Xa(t.getBoundingClientRect(), o);
                        let r, s;
                        if ("BODY" === e.tagName) {
                            const t = e.ownerDocument.documentElement;
                            r = e.scrollLeft || t.scrollLeft, s = e.scrollTop || t.scrollTop
                        } else {
                            const t = e.getBoundingClientRect();
                            r = e.scrollLeft - t.left, s = e.scrollTop - t.top
                        }
                        n.left += r, n.right += r, n.top += s, n.bottom += s, n.width = 1;
                        let a = t.offsetWidth - t.clientWidth;
                        return a > 0 && (o && (a *= -1), n.left += a, n.right += a), n
                    },
                    od = (e, t, o, n) => {
                        const r = Ea();
                        let s, a;
                        const i = pl(e),
                            l = e.dom,
                            c = () => {
                                (e => {
                                    var t, o;
                                    const n = rr(go(e), "*[contentEditable=false],video,audio,embed,object");
                                    for (let e = 0; e < n.length; e++) {
                                        const r = n[e].dom;
                                        let s = r.previousSibling;
                                        if (Hr(s)) {
                                            const e = s.data;
                                            1 === e.length ? null === (t = s.parentNode) || void 0 === t || t.removeChild(s) : s.deleteData(e.length - 1, 1)
                                        }
                                        s = r.nextSibling, Lr(s) && (1 === s.data.length ? null === (o = s.parentNode) || void 0 === o || o.removeChild(s) : s.deleteData(0, 1))
                                    }
                                })(t), a && (Xc(a), a = null), r.on((e => {
                                    l.remove(e.caret), r.clear()
                                })), s && (clearInterval(s), s = void 0)
                            };
                        return {
                            show: (e, d) => {
                                let u;
                                if (c(), ed(d)) return null;
                                if (!o(d)) return a = ((e, t) => {
                                    var o;
                                    const n = (null !== (o = e.ownerDocument) && void 0 !== o ? o : document).createTextNode(kr),
                                        r = e.parentNode;
                                    if (t) {
                                        const t = e.previousSibling;
                                        if (Er(t)) {
                                            if (Nr(t)) return t;
                                            if (Hr(t)) return t.splitText(t.data.length - 1)
                                        }
                                        null == r || r.insertBefore(n, e)
                                    } else {
                                        const t = e.nextSibling;
                                        if (Er(t)) {
                                            if (Nr(t)) return t;
                                            if (Lr(t)) return t.splitText(1), t
                                        }
                                        e.nextSibling ? null == r || r.insertBefore(n, e.nextSibling) : null == r || r.appendChild(n)
                                    }
                                    return n
                                })(d, e), u = d.ownerDocument.createRange(), rd(a.nextSibling) ? (u.setStart(a, 0), u.setEnd(a, 0)) : (u.setStart(a, 1), u.setEnd(a, 1)), u; {
                                    const o = ((e, t, o) => {
                                            var n;
                                            const r = (null !== (n = t.ownerDocument) && void 0 !== n ? n : document).createElement(e);
                                            r.setAttribute("data-mce-caret", o ? "before" : "after"), r.setAttribute("data-mce-bogus", "all"), r.appendChild(xr().dom);
                                            const s = t.parentNode;
                                            return o ? null == s || s.insertBefore(r, t) : t.nextSibling ? null == s || s.insertBefore(r, t.nextSibling) : null == s || s.appendChild(r), r
                                        })(i, d, e),
                                        c = td(t, d, e);
                                    l.setStyle(o, "top", c.top), a = o;
                                    const m = l.create("div", {
                                        class: "mce-visual-caret",
                                        "data-mce-bogus": "all"
                                    });
                                    l.setStyles(m, { ...c
                                    }), l.add(t, m), r.set({
                                        caret: m,
                                        element: d,
                                        before: e
                                    }), e && l.addClass(m, "mce-visual-caret-before"), s = setInterval((() => {
                                        r.on((e => {
                                            n() ? l.toggleClass(e.caret, "mce-visual-caret-hidden") : l.addClass(e.caret, "mce-visual-caret-hidden")
                                        }))
                                    }), 500), u = d.ownerDocument.createRange(), u.setStart(o, 0), u.setEnd(o, 0)
                                }
                                return u
                            },
                            hide: c,
                            getCss: () => ".mce-visual-caret {position: absolute;background-color: black;background-color: currentcolor;}.mce-visual-caret-hidden {display: none;}*[data-mce-caret] {position: absolute;left: -1000px;right: auto;top: 0;margin: 0;padding: 0;}",
                            reposition: () => {
                                r.on((e => {
                                    const o = td(t, e.element, e.before);
                                    l.setStyles(e.caret, { ...o
                                    })
                                }))
                            },
                            destroy: () => clearInterval(s)
                        }
                    },
                    nd = () => Et.browser.isFirefox(),
                    rd = e => Jc(e) || Qc(e),
                    sd = e => rd(e) || Pn(e) && nd(),
                    ad = Kn,
                    id = Yn,
                    ld = Qn,
                    cd = Ln("display", "block table table-cell table-caption list-item"),
                    dd = Nr,
                    ud = Ar,
                    md = Rn,
                    gd = Vn,
                    hd = qr,
                    pd = e => e > 0,
                    fd = e => e < 0,
                    vd = (e, t) => {
                        let o;
                        for (; o = e(t);)
                            if (!ud(o)) return o;
                        return null
                    },
                    bd = (e, t, o, n, r) => {
                        const s = new An(e, n),
                            a = id(e) || ud(e);
                        let i;
                        if (fd(t)) {
                            if (a && (i = vd(s.prev.bind(s), !0), o(i))) return i;
                            for (; i = vd(s.prev.bind(s), r);)
                                if (o(i)) return i
                        }
                        if (pd(t)) {
                            if (a && (i = vd(s.next.bind(s), !0), o(i))) return i;
                            for (; i = vd(s.next.bind(s), r);)
                                if (o(i)) return i
                        }
                        return null
                    },
                    yd = (e, t) => {
                        for (; e && e !== t;) {
                            if (cd(e)) return e;
                            e = e.parentNode
                        }
                        return null
                    },
                    wd = (e, t, o) => yd(e.container(), o) === yd(t.container(), o),
                    xd = (e, t) => {
                        if (!t) return I.none();
                        const o = t.container(),
                            n = t.offset();
                        return md(o) ? I.from(o.childNodes[n + e]) : I.none()
                    },
                    Cd = (e, t) => {
                        var o;
                        const n = (null !== (o = t.ownerDocument) && void 0 !== o ? o : document).createRange();
                        return e ? (n.setStartBefore(t), n.setEndBefore(t)) : (n.setStartAfter(t), n.setEndAfter(t)), n
                    },
                    Sd = (e, t, o) => yd(t, e) === yd(o, e),
                    kd = (e, t, o) => {
                        const n = e ? "previousSibling" : "nextSibling";
                        let r = o;
                        for (; r && r !== t;) {
                            let e = r[n];
                            if (e && dd(e) && (e = e[n]), id(e) || ld(e)) {
                                if (Sd(t, e, r)) return e;
                                break
                            }
                            if (hd(e)) break;
                            r = r.parentNode
                        }
                        return null
                    },
                    _d = N(Cd, !0),
                    Od = N(Cd, !1),
                    Td = (e, t, o) => {
                        let n;
                        const r = N(kd, !0, t),
                            s = N(kd, !1, t),
                            a = o.startContainer,
                            i = o.startOffset;
                        if (Ar(a)) {
                            const e = gd(a) ? a.parentNode : a,
                                t = e.getAttribute("data-mce-caret");
                            if ("before" === t && (n = e.nextSibling, sd(n))) return _d(n);
                            if ("after" === t && (n = e.previousSibling, sd(n))) return Od(n)
                        }
                        if (!o.collapsed) return o;
                        if (Vn(a)) {
                            if (dd(a)) {
                                if (1 === e) {
                                    if (n = s(a), n) return _d(n);
                                    if (n = r(a), n) return Od(n)
                                }
                                if (-1 === e) {
                                    if (n = r(a), n) return Od(n);
                                    if (n = s(a), n) return _d(n)
                                }
                                return o
                            }
                            if (Hr(a) && i >= a.data.length - 1) return 1 === e && (n = s(a), n) ? _d(n) : o;
                            if (Lr(a) && i <= 1) return -1 === e && (n = r(a), n) ? Od(n) : o;
                            if (i === a.data.length) return n = s(a), n ? _d(n) : o;
                            if (0 === i) return n = r(a), n ? Od(n) : o
                        }
                        return o
                    },
                    Ed = (e, t) => xd(e ? 0 : -1, t).filter(id),
                    Ad = (e, t, o) => {
                        const n = Td(e, t, o);
                        return -1 === e ? Si.fromRangeStart(n) : Si.fromRangeEnd(n)
                    },
                    Md = e => I.from(e.getNode()).map(go),
                    Nd = (e, t) => {
                        let o = t;
                        for (; o = e(o);)
                            if (o.isVisible()) return o;
                        return o
                    },
                    Rd = (e, t) => {
                        const o = wd(e, t);
                        return !(o || !qn(e.getNode())) || o
                    };
                var Dd;
                ! function(e) {
                    e[e.Backwards = -1] = "Backwards", e[e.Forwards = 1] = "Forwards"
                }(Dd || (Dd = {}));
                const Bd = Yn,
                    Ld = Vn,
                    Hd = Rn,
                    Id = qn,
                    Pd = qr,
                    zd = e => jr(e) || (e => !!Gr(e) && !Y(de(e.getElementsByTagName("*")), ((e, t) => e || zr(t)), !1))(e),
                    Fd = Kr,
                    Vd = (e, t) => e.hasChildNodes() && t < e.childNodes.length ? e.childNodes[t] : null,
                    Zd = (e, t) => {
                        if (pd(e)) {
                            if (Pd(t.previousSibling) && !Ld(t.previousSibling)) return Si.before(t);
                            if (Ld(t)) return Si(t, 0)
                        }
                        if (fd(e)) {
                            if (Pd(t.nextSibling) && !Ld(t.nextSibling)) return Si.after(t);
                            if (Ld(t)) return Si(t, t.data.length)
                        }
                        return fd(e) ? Id(t) ? Si.before(t) : Si.after(t) : Si.before(t)
                    },
                    Ud = (e, t, o) => {
                        let n, r, s, a;
                        if (!Hd(o) || !t) return null;
                        if (t.isEqual(Si.after(o)) && o.lastChild) {
                            if (a = Si.after(o.lastChild), fd(e) && Pd(o.lastChild) && Hd(o.lastChild)) return Id(o.lastChild) ? Si.before(o.lastChild) : a
                        } else a = t;
                        const i = a.container();
                        let l = a.offset();
                        if (Ld(i)) {
                            if (fd(e) && l > 0) return Si(i, --l);
                            if (pd(e) && l < i.length) return Si(i, ++l);
                            n = i
                        } else {
                            if (fd(e) && l > 0 && (r = Vd(i, l - 1), Pd(r))) return !zd(r) && (s = bd(r, e, Fd, r), s) ? Ld(s) ? Si(s, s.data.length) : Si.after(s) : Ld(r) ? Si(r, r.data.length) : Si.before(r);
                            if (pd(e) && l < i.childNodes.length && (r = Vd(i, l), Pd(r))) return Id(r) ? ((e, t) => {
                                const o = t.nextSibling;
                                return o && Pd(o) ? Ld(o) ? Si(o, 0) : Si.before(o) : Ud(Dd.Forwards, Si.after(t), e)
                            })(o, r) : !zd(r) && (s = bd(r, e, Fd, r), s) ? Ld(s) ? Si(s, 0) : Si.before(s) : Ld(r) ? Si(r, 0) : Si.after(r);
                            n = r || a.getNode()
                        }
                        if (n && (pd(e) && a.isAtEnd() || fd(e) && a.isAtStart()) && (n = bd(n, e, H, o, !0), Fd(n, o))) return Zd(e, n);
                        r = n ? bd(n, e, Fd, o) : n;
                        const c = De(G(((e, t) => {
                            const o = [];
                            let n = e;
                            for (; n && n !== t;) o.push(n), n = n.parentNode;
                            return o
                        })(i, o), Bd));
                        return !c || r && c.contains(r) ? r ? Zd(e, r) : null : (a = pd(e) ? Si.after(c) : Si.before(c), a)
                    },
                    jd = e => ({
                        next: t => Ud(Dd.Forwards, t, e),
                        prev: t => Ud(Dd.Backwards, t, e)
                    }),
                    Wd = e => Si.isTextPosition(e) ? 0 === e.offset() : qr(e.getNode()),
                    $d = e => {
                        if (Si.isTextPosition(e)) {
                            const t = e.container();
                            return e.offset() === t.data.length
                        }
                        return qr(e.getNode(!0))
                    },
                    qd = (e, t) => !Si.isTextPosition(e) && !Si.isTextPosition(t) && e.getNode() === t.getNode(!0),
                    Gd = (e, t, o) => {
                        const n = jd(t);
                        return I.from(e ? n.next(o) : n.prev(o))
                    },
                    Kd = (e, t, o) => Gd(e, t, o).bind((n => wd(o, n, t) && ((e, t, o) => {
                        return e ? !qd(t, o) && (n = t, !(!Si.isTextPosition(n) && qn(n.getNode()))) && $d(t) && Wd(o) : !qd(o, t) && Wd(t) && $d(o);
                        var n
                    })(e, o, n) ? Gd(e, t, n) : I.some(n))),
                    Yd = (e, t, o, n) => Kd(e, t, o).bind((o => n(o) ? Yd(e, t, o, n) : I.some(o))),
                    Xd = (e, t) => {
                        const o = e ? t.firstChild : t.lastChild;
                        return Vn(o) ? I.some(Si(o, e ? 0 : o.data.length)) : o ? qr(o) ? I.some(e ? Si.before(o) : qn(n = o) ? Si.before(n) : Si.after(n)) : ((e, t, o) => {
                            const n = e ? Si.before(o) : Si.after(o);
                            return Gd(e, t, n)
                        })(e, t, o) : I.none();
                        var n
                    },
                    Jd = N(Gd, !0),
                    Qd = N(Gd, !1),
                    eu = N(Xd, !0),
                    tu = N(Xd, !1),
                    ou = "_mce_caret",
                    nu = e => Rn(e) && e.id === ou,
                    ru = (e, t) => {
                        let o = t;
                        for (; o && o !== e;) {
                            if (nu(o)) return o;
                            o = o.parentNode
                        }
                        return null
                    },
                    su = e => Se(e, "name"),
                    au = e => Rt.isArray(e.start),
                    iu = e => !(!su(e) && b(e.forward)) || e.forward,
                    lu = (e, t) => (Rn(t) && e.isBlock(t) && !t.innerHTML && (t.innerHTML = '<br data-mce-bogus="1" />'), t),
                    cu = (e, t) => tu(e).fold(L, (e => (t.setStart(e.container(), e.offset()), t.setEnd(e.container(), e.offset()), !0))),
                    du = (e, t, o) => !(!(e => !e.hasChildNodes())(t) || !ru(e, t) || (((e, t) => {
                        var o;
                        const n = (null !== (o = e.ownerDocument) && void 0 !== o ? o : document).createTextNode(kr);
                        e.appendChild(n), t.setStart(n, 0), t.setEnd(n, 0)
                    })(t, o), 0)),
                    uu = (e, t, o, n) => {
                        const r = o[t ? "start" : "end"],
                            s = e.getRoot();
                        if (r) {
                            let e = s,
                                o = r[0];
                            for (let t = r.length - 1; e && t >= 1; t--) {
                                const o = e.childNodes;
                                if (du(s, e, n)) return !0;
                                if (r[t] > o.length - 1) return !!du(s, e, n) || cu(e, n);
                                e = o[r[t]]
                            }
                            Vn(e) && (o = Math.min(r[0], e.data.length)), Rn(e) && (o = Math.min(r[0], e.childNodes.length)), t ? n.setStart(e, o) : n.setEnd(e, o)
                        }
                        return !0
                    },
                    mu = e => Vn(e) && e.data.length > 0,
                    gu = (e, t, o) => {
                        const n = e.get(o.id + "_" + t),
                            r = null == n ? void 0 : n.parentNode,
                            s = o.keep;
                        if (n && r) {
                            let a, i;
                            if ("start" === t ? s ? n.hasChildNodes() ? (a = n.firstChild, i = 1) : mu(n.nextSibling) ? (a = n.nextSibling, i = 0) : mu(n.previousSibling) ? (a = n.previousSibling, i = n.previousSibling.data.length) : (a = r, i = e.nodeIndex(n) + 1) : (a = r, i = e.nodeIndex(n)) : s ? n.hasChildNodes() ? (a = n.firstChild, i = 1) : mu(n.previousSibling) ? (a = n.previousSibling, i = n.previousSibling.data.length) : (a = r, i = e.nodeIndex(n)) : (a = r, i = e.nodeIndex(n)), !s) {
                                const r = n.previousSibling,
                                    s = n.nextSibling;
                                let l;
                                for (Rt.each(Rt.grep(n.childNodes), (e => {
                                        Vn(e) && (e.data = e.data.replace(/\uFEFF/g, ""))
                                    })); l = e.get(o.id + "_" + t);) e.remove(l, !0);
                                if (Vn(s) && Vn(r) && !Et.browser.isOpera()) {
                                    const t = r.data.length;
                                    r.appendData(s.data), e.remove(s), a = r, i = t
                                }
                            }
                            return I.some(Si(a, i))
                        }
                        return I.none()
                    },
                    hu = (e, t, o) => ((e, t, o = !1) => 2 === t ? Vi(Or, o, e) : 3 === t ? (e => {
                        const t = e.getRng();
                        return {
                            start: Di(e.dom.getRoot(), Si.fromRangeStart(t)),
                            end: Di(e.dom.getRoot(), Si.fromRangeEnd(t)),
                            forward: e.isForward()
                        }
                    })(e) : t ? (e => ({
                        rng: e.getRng(),
                        forward: e.isForward()
                    }))(e) : Ui(e, !1))(e, t, o),
                    pu = (e, t) => {
                        ((e, t) => {
                            const o = e.dom;
                            if (t) {
                                if (au(t)) return ((e, t) => {
                                    const o = e.createRng();
                                    return uu(e, !0, t, o) && uu(e, !1, t, o) ? I.some({
                                        range: o,
                                        forward: iu(t)
                                    }) : I.none()
                                })(o, t);
                                if ((e => g(e.start))(t)) return ((e, t) => {
                                    const o = I.from(Bi(e.getRoot(), t.start)),
                                        n = I.from(Bi(e.getRoot(), t.end));
                                    return Bt(o, n, ((o, n) => {
                                        const r = e.createRng();
                                        return r.setStart(o.container(), o.offset()), r.setEnd(n.container(), n.offset()), {
                                            range: r,
                                            forward: iu(t)
                                        }
                                    }))
                                })(o, t);
                                if ((e => Se(e, "id"))(t)) return ((e, t) => {
                                    const o = gu(e, "start", t),
                                        n = gu(e, "end", t);
                                    return Bt(o, n.or(o), ((o, n) => {
                                        const r = e.createRng();
                                        return r.setStart(lu(e, o.container()), o.offset()), r.setEnd(lu(e, n.container()), n.offset()), {
                                            range: r,
                                            forward: iu(t)
                                        }
                                    }))
                                })(o, t);
                                if (su(t)) return ((e, t) => I.from(e.select(t.name)[t.index]).map((t => {
                                    const o = e.createRng();
                                    return o.selectNode(t), {
                                        range: o,
                                        forward: !0
                                    }
                                })))(o, t);
                                if ((e => Se(e, "rng"))(t)) return I.some({
                                    range: t.rng,
                                    forward: iu(t)
                                })
                            }
                            return I.none()
                        })(e, t).each((({
                            range: t,
                            forward: o
                        }) => {
                            e.setRng(t, o)
                        }))
                    },
                    fu = e => Rn(e) && "SPAN" === e.tagName && "bookmark" === e.getAttribute("data-mce-type"),
                    vu = (bu = or, e => bu === e);
                var bu;
                const yu = e => "" !== e && -1 !== " \f\n\r\t\v".indexOf(e),
                    wu = e => !yu(e) && !vu(e) && !nr(e),
                    xu = e => {
                        const t = e.toString(16);
                        return (1 === t.length ? "0" + t : t).toUpperCase()
                    },
                    Cu = e => (e => ({
                        value: e
                    }))(xu(e.red) + xu(e.green) + xu(e.blue)),
                    Su = /^\s*rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)\s*$/i,
                    ku = /^\s*rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d?(?:\.\d+)?)\s*\)\s*$/i,
                    _u = (e, t, o, n) => ({
                        red: e,
                        green: t,
                        blue: o,
                        alpha: n
                    }),
                    Ou = (e, t, o, n) => {
                        const r = parseInt(e, 10),
                            s = parseInt(t, 10),
                            a = parseInt(o, 10),
                            i = parseFloat(n);
                        return _u(r, s, a, i)
                    },
                    Tu = e => (e => {
                        if ("transparent" === e) return I.some(_u(0, 0, 0, 0));
                        const t = Su.exec(e);
                        if (null !== t) return I.some(Ou(t[1], t[2], t[3], "1"));
                        const o = ku.exec(e);
                        return null !== o ? I.some(Ou(o[1], o[2], o[3], o[4])) : I.none()
                    })(e).map(Cu).map((e => "#" + e.value)).getOr(e),
                    Eu = e => {
                        const t = [];
                        if (e)
                            for (let o = 0; o < e.rangeCount; o++) t.push(e.getRangeAt(o));
                        return t
                    },
                    Au = (e, t) => {
                        const o = rr(t, "td[data-mce-selected],th[data-mce-selected]");
                        return o.length > 0 ? o : (e => G((e => te(e, (e => {
                            const t = oi(e);
                            return t ? [go(t)] : []
                        })))(e), vr))(e)
                    },
                    Mu = e => Au(Eu(e.selection.getSel()), go(e.getBody())),
                    Nu = (e, t) => _n(e, "table", t),
                    Ru = e => Ro(e).fold(E([e]), (t => [e].concat(Ru(t)))),
                    Du = e => Do(e).fold(E([e]), (t => "br" === Ht(t) ? Oo(t).map((t => [e].concat(Du(t)))).getOr([]) : [e].concat(Du(t)))),
                    Bu = (e, t) => Bt((e => {
                        const t = e.startContainer,
                            o = e.startOffset;
                        return Vn(t) ? 0 === o ? I.some(go(t)) : I.none() : I.from(t.childNodes[o]).map(go)
                    })(t), (e => {
                        const t = e.endContainer,
                            o = e.endOffset;
                        return Vn(t) ? o === t.data.length ? I.some(go(t)) : I.none() : I.from(t.childNodes[o - 1]).map(go)
                    })(t), ((t, o) => {
                        const n = J(Ru(e), N(bo, t)),
                            r = J(Du(e), N(bo, o));
                        return n.isSome() && r.isSome()
                    })).getOr(!1),
                    Lu = (e, t, o, n) => {
                        const r = o,
                            s = new An(o, r),
                            a = ye(e.schema.getMoveCaretBeforeOnEnterElements(), ((e, t) => !Z(["td", "th", "table"], t.toLowerCase())));
                        let i = o;
                        do {
                            if (Vn(i) && 0 !== Rt.trim(i.data).length) return void(n ? t.setStart(i, 0) : t.setEnd(i, i.data.length));
                            if (a[i.nodeName]) return void(n ? t.setStartBefore(i) : "BR" === i.nodeName ? t.setEndBefore(i) : t.setEndAfter(i))
                        } while (i = n ? s.next() : s.prev());
                        "BODY" === r.nodeName && (n ? t.setStart(r, 0) : t.setEnd(r, r.childNodes.length))
                    },
                    Hu = e => {
                        const t = e.selection.getSel();
                        return x(t) && t.rangeCount > 0
                    },
                    Iu = (e, t) => {
                        const o = Mu(e);
                        o.length > 0 ? W(o, (o => {
                            const n = o.dom,
                                r = e.dom.createRng();
                            r.setStartBefore(n), r.setEndAfter(n), t(r, !0)
                        })) : t(e.selection.getRng(), !1)
                    },
                    Pu = (e, t, o) => {
                        const n = Ui(e, t);
                        o(n), e.moveToBookmark(n)
                    },
                    zu = e => S(null == e ? void 0 : e.nodeType),
                    Fu = e => Rn(e) && !fu(e) && !nu(e) && !In(e),
                    Vu = e => !0 === e.isContentEditable,
                    Zu = (e, t, o) => {
                        const {
                            selection: n,
                            dom: r
                        } = e, s = n.getNode(), a = Yn(s);
                        Pu(n, !0, (() => {
                            t()
                        })), a && Yn(s) && r.isChildOf(s, e.getBody()) ? e.selection.select(s) : o(n.getStart()) && Uu(r, n)
                    },
                    Uu = (e, t) => {
                        var o, n;
                        const r = t.getRng(),
                            {
                                startContainer: s,
                                startOffset: a
                            } = r;
                        if (!((e, t) => {
                                if (Fu(t) && !/^(TD|TH)$/.test(t.nodeName)) {
                                    const o = e.getAttrib(t, "data-mce-selected"),
                                        n = parseInt(o, 10);
                                    return !isNaN(n) && n > 0
                                }
                                return !1
                            })(e, t.getNode()) && Rn(s)) {
                            const i = s.childNodes,
                                l = e.getRoot();
                            let c;
                            if (a < i.length) {
                                const t = i[a];
                                c = new An(t, null !== (o = e.getParent(t, e.isBlock)) && void 0 !== o ? o : l)
                            } else {
                                const t = i[i.length - 1];
                                c = new An(t, null !== (n = e.getParent(t, e.isBlock)) && void 0 !== n ? n : l), c.next(!0)
                            }
                            for (let o = c.current(); o; o = c.next()) {
                                if ("false" === e.getContentEditable(o)) return;
                                if (Vn(o) && !qu(o)) return r.setStart(o, 0), void t.setRng(r)
                            }
                        }
                    },
                    ju = (e, t, o) => {
                        if (e) {
                            const n = t ? "nextSibling" : "previousSibling";
                            for (e = o ? e : e[n]; e; e = e[n])
                                if (Rn(e) || !qu(e)) return e
                        }
                    },
                    Wu = (e, t) => !!e.getTextBlockElements()[t.nodeName.toLowerCase()] || fs(e, t),
                    $u = (e, t, o) => e.schema.isValidChild(t, o),
                    qu = (e, t = !1) => {
                        if (x(e) && Vn(e)) {
                            const o = t ? e.data.replace(/ /g, "") : e.data;
                            return Xr(o)
                        }
                        return !1
                    },
                    Gu = (e, t) => {
                        const o = e.dom;
                        return Fu(t) && "false" === o.getContentEditable(t) && ((e, t) => {
                            const o = "[data-mce-cef-wrappable]",
                                n = tc(e),
                                r = Ge(n) ? o : `${o},${n}`;
                            return fo(go(t), r)
                        })(e, t) && 0 === o.select('[contenteditable="true"]', t).length
                    },
                    Ku = (e, t) => C(e) ? e(t) : (x(t) && (e = e.replace(/%(\w+)/g, ((e, o) => t[o] || e))), e),
                    Yu = (e, t) => (t = t || "", e = "" + ((e = e || "").nodeName || e), t = "" + (t.nodeName || t), e.toLowerCase() === t.toLowerCase()),
                    Xu = (e, t) => {
                        if (w(e)) return null; {
                            let o = String(e);
                            return "color" !== t && "backgroundColor" !== t || (o = Tu(o)), "fontWeight" === t && 700 === e && (o = "bold"), "fontFamily" === t && (o = o.replace(/[\'\"]/g, "").replace(/,\s+/g, ",")), o
                        }
                    },
                    Ju = (e, t, o) => {
                        const n = e.getStyle(t, o);
                        return Xu(n, o)
                    },
                    Qu = (e, t) => {
                        let o;
                        return e.getParent(t, (t => !!Rn(t) && (o = e.getStyle(t, "text-decoration"), !!o && "none" !== o))), o
                    },
                    em = (e, t, o) => e.getParents(t, o, e.getRoot()),
                    tm = (e, t, o) => {
                        const n = e.formatter.get(t);
                        return x(n) && U(n, o)
                    },
                    om = e => ke(e, "block"),
                    nm = e => ke(e, "selector"),
                    rm = e => ke(e, "inline"),
                    sm = e => nm(e) && !1 !== e.expand && !rm(e),
                    am = fu,
                    im = em,
                    lm = qu,
                    cm = Wu,
                    dm = (e, t) => {
                        let o = t;
                        for (; o;) {
                            if (Rn(o) && e.getContentEditable(o)) return "false" === e.getContentEditable(o) ? o : t;
                            o = o.parentNode
                        }
                        return t
                    },
                    um = (e, t, o, n) => {
                        const r = t.data;
                        if (e) {
                            for (let e = o; e > 0; e--)
                                if (n(r.charAt(e - 1))) return e
                        } else
                            for (let e = o; e < r.length; e++)
                                if (n(r.charAt(e))) return e;
                        return -1
                    },
                    mm = (e, t, o) => um(e, t, o, (e => vu(e) || yu(e))),
                    gm = (e, t, o) => um(e, t, o, wu),
                    hm = (e, t, o, n, r, s) => {
                        let a;
                        const i = e.getParent(o, e.isBlock) || t,
                            l = (t, o, n) => {
                                const s = Ga(e),
                                    l = r ? s.backwards : s.forwards;
                                return I.from(l(t, o, ((e, t) => am(e.parentNode) ? -1 : (a = e, n(r, e, t))), i))
                            };
                        return l(o, n, mm).bind((e => s ? l(e.container, e.offset + (r ? -1 : 0), gm) : I.some(e))).orThunk((() => a ? I.some({
                            container: a,
                            offset: r ? 0 : a.length
                        }) : I.none()))
                    },
                    pm = (e, t, o, n, r) => {
                        const s = n[r];
                        Vn(n) && Ge(n.data) && s && (n = s);
                        const a = im(e, n);
                        for (let n = 0; n < a.length; n++)
                            for (let r = 0; r < t.length; r++) {
                                const s = t[r];
                                if ((!x(s.collapsed) || s.collapsed === o.collapsed) && nm(s) && e.is(a[n], s.selector)) return a[n]
                            }
                        return n
                    },
                    fm = (e, t, o, n) => {
                        var r;
                        let s = o;
                        const a = e.getRoot(),
                            i = t[0];
                        if (om(i) && (s = i.wrapper ? null : e.getParent(o, i.block, a)), !s) {
                            const t = null !== (r = e.getParent(o, "LI,TD,TH")) && void 0 !== r ? r : a;
                            s = e.getParent(Vn(o) ? o.parentNode : o, (t => t !== a && cm(e.schema, t)), t)
                        }
                        if (s && om(i) && i.wrapper && (s = im(e, s, "ul,ol").reverse()[0] || s), !s)
                            for (s = o; s && s[n] && !e.isBlock(s[n]) && (s = s[n], !Yu(s, "br")););
                        return s || o
                    },
                    vm = (e, t, o, n) => {
                        const r = o.parentNode;
                        return !x(o[n]) && (!(r !== t && !w(r) && !e.isBlock(r)) || vm(e, t, r, n))
                    },
                    bm = (e, t, o, n, r) => {
                        let s = o;
                        const a = r ? "previousSibling" : "nextSibling",
                            i = e.getRoot();
                        if (Vn(o) && !lm(o) && (r ? n > 0 : n < o.data.length)) return o;
                        for (; s;) {
                            if (!t[0].block_expand && e.isBlock(s)) return s;
                            for (let t = s[a]; t; t = t[a]) {
                                const o = Vn(t) && !vm(e, i, t, a);
                                if (!am(t) && (!qn(l = t) || !l.getAttribute("data-mce-bogus") || l.nextSibling) && !lm(t, o)) return s
                            }
                            if (s === i || s.parentNode === i) {
                                o = s;
                                break
                            }
                            s = s.parentNode
                        }
                        var l;
                        return o
                    },
                    ym = e => am(e.parentNode) || am(e),
                    wm = (e, t, o, n = !1) => {
                        let {
                            startContainer: r,
                            startOffset: s,
                            endContainer: a,
                            endOffset: i
                        } = t;
                        const l = o[0];
                        return Rn(r) && r.hasChildNodes() && (r = ni(r, s), Vn(r) && (s = 0)), Rn(a) && a.hasChildNodes() && (a = ni(a, t.collapsed ? i : i - 1), Vn(a) && (i = a.data.length)), r = dm(e, r), a = dm(e, a), ym(r) && (r = am(r) ? r : r.parentNode, r = t.collapsed ? r.previousSibling || r : r.nextSibling || r, Vn(r) && (s = t.collapsed ? r.length : 0)), ym(a) && (a = am(a) ? a : a.parentNode, a = t.collapsed ? a.nextSibling || a : a.previousSibling || a, Vn(a) && (i = t.collapsed ? 0 : a.length)), t.collapsed && (hm(e, e.getRoot(), r, s, !0, n).each((({
                            container: e,
                            offset: t
                        }) => {
                            r = e, s = t
                        })), hm(e, e.getRoot(), a, i, !1, n).each((({
                            container: e,
                            offset: t
                        }) => {
                            a = e, i = t
                        }))), (rm(l) || l.block_expand) && (rm(l) && Vn(r) && 0 !== s || (r = bm(e, o, r, s, !0)), rm(l) && Vn(a) && i !== a.data.length || (a = bm(e, o, a, i, !1))), sm(l) && (r = pm(e, o, t, r, "previousSibling"), a = pm(e, o, t, a, "nextSibling")), (om(l) || nm(l)) && (r = fm(e, o, r, "previousSibling"), a = fm(e, o, a, "nextSibling"), om(l) && (e.isBlock(r) || (r = bm(e, o, r, s, !0)), e.isBlock(a) || (a = bm(e, o, a, i, !1)))), Rn(r) && r.parentNode && (s = e.nodeIndex(r), r = r.parentNode), Rn(a) && a.parentNode && (i = e.nodeIndex(a) + 1, a = a.parentNode), {
                            startContainer: r,
                            startOffset: s,
                            endContainer: a,
                            endOffset: i
                        }
                    },
                    xm = (e, t, o) => {
                        var n;
                        const r = t.startOffset,
                            s = ni(t.startContainer, r),
                            a = t.endOffset,
                            i = ni(t.endContainer, a - 1),
                            l = e => {
                                const t = e[0];
                                Vn(t) && t === s && r >= t.data.length && e.splice(0, 1);
                                const o = e[e.length - 1];
                                return 0 === a && e.length > 0 && o === i && Vn(o) && e.splice(e.length - 1, 1), e
                            },
                            c = (e, t, o) => {
                                const n = [];
                                for (; e && e !== o; e = e[t]) n.push(e);
                                return n
                            },
                            d = (t, o) => e.getParent(t, (e => e.parentNode === o), o),
                            u = (e, t, n) => {
                                const r = n ? "nextSibling" : "previousSibling";
                                for (let s = e, a = s.parentNode; s && s !== t; s = a) {
                                    a = s.parentNode;
                                    const t = c(s === e ? s : s[r], r);
                                    t.length && (n || t.reverse(), o(l(t)))
                                }
                            };
                        if (s === i) return o(l([s]));
                        const m = null !== (n = e.findCommonAncestor(s, i)) && void 0 !== n ? n : e.getRoot();
                        if (e.isChildOf(s, i)) return u(s, m, !0);
                        if (e.isChildOf(i, s)) return u(i, m);
                        const g = d(s, m) || s,
                            h = d(i, m) || i;
                        u(s, g, !0);
                        const p = c(g === s ? g : g.nextSibling, "nextSibling", h === i ? h.nextSibling : h);
                        p.length && o(l(p)), u(i, h)
                    },
                    Cm = ['pre[class*=language-][contenteditable="false"]', "figure.image", "div[data-ephox-embed-iri]", "div.tiny-pageembed", "div.mce-toc", "div[data-mce-toc]"],
                    Sm = (e, t, o, n, r, s) => {
                        const {
                            uid: a = t,
                            ...i
                        } = o;
                        no(e, Na()), Wt(e, `${Da()}`, a), Wt(e, `${Ra()}`, n);
                        const {
                            attributes: l = {},
                            classes: c = []
                        } = r(a, i);
                        if ($t(e, l), ((e, t) => {
                                W(t, (t => {
                                    no(e, t)
                                }))
                            })(e, c), s) {
                            c.length > 0 && Wt(e, `${La()}`, c.join(","));
                            const t = me(l);
                            t.length > 0 && Wt(e, `${Ha()}`, t.join(","))
                        }
                    },
                    km = (e, t, o, n, r) => {
                        const s = uo("span", e);
                        return Sm(s, t, o, n, r, !1), s
                    },
                    _m = (e, t, o, n, r, s) => {
                        const a = [],
                            i = km(e.getDoc(), o, s, n, r),
                            l = Ea(),
                            c = () => {
                                l.clear()
                            },
                            d = e => {
                                W(e, u)
                            },
                            u = t => {
                                switch (((e, t, o, n) => So(t).fold((() => "skipping"), (r => "br" === n || (e => Ft(e) && ar(e) === kr)(t) ? "valid" : (e => zt(e) && ao(e, Na()))(t) ? "existing" : nu(t.dom) ? "caret" : U(Cm, (e => fo(t, e))) ? "valid-block" : $u(e, o, n) && $u(e, Ht(r), o) ? "valid" : "invalid-child")))(e, t, "span", Ht(t))) {
                                    case "invalid-child":
                                        {
                                            c();
                                            const e = Mo(t);d(e),
                                            c();
                                            break
                                        }
                                    case "valid-block":
                                        c(), Sm(t, o, s, n, r, !0);
                                        break;
                                    case "valid":
                                        {
                                            const e = l.get().getOrThunk((() => {
                                                const e = Wa(i);
                                                return a.push(e), l.set(e), e
                                            }));
                                            ((e, t) => {
                                                Jo(e, t), tn(t, e)
                                            })(t, e);
                                            break
                                        }
                                }
                            };
                        return xm(e.dom, t, (e => {
                            c(), (e => {
                                const t = j(e, go);
                                d(t)
                            })(e)
                        })), a
                    },
                    Om = e => {
                        const t = (() => {
                            const e = {};
                            return {
                                register: (t, o) => {
                                    e[t] = {
                                        name: t,
                                        settings: o
                                    }
                                },
                                lookup: t => Ce(e, t).map((e => e.settings)),
                                getNames: () => me(e)
                            }
                        })();
                        ((e, t) => {
                            const o = Ra(),
                                n = e => I.from(e.attr(o)).bind(t.lookup),
                                r = e => {
                                    var t, o;
                                    e.attr(Da(), null), e.attr(Ra(), null), e.attr(Ba(), null);
                                    const n = I.from(e.attr(Ha())).map((e => e.split(","))).getOr([]),
                                        r = I.from(e.attr(La())).map((e => e.split(","))).getOr([]);
                                    W(n, (t => e.attr(t, null)));
                                    const s = null !== (o = null === (t = e.attr("class")) || void 0 === t ? void 0 : t.split(" ")) && void 0 !== o ? o : [],
                                        a = re(s, [Na()].concat(r));
                                    e.attr("class", a.length > 0 ? a.join(" ") : null), e.attr(La(), null), e.attr(Ha(), null)
                                };
                            e.serializer.addTempAttr(Ba()), e.serializer.addAttributeFilter(o, (e => {
                                for (const t of e) n(t).each((e => {
                                    !1 === e.persistent && ("span" === t.name ? t.unwrap() : r(t))
                                }))
                            }))
                        })(e, t);
                        const o = ((e, t) => {
                                const o = xa({}),
                                    n = () => ({
                                        listeners: [],
                                        previous: Ea()
                                    }),
                                    r = (e, t) => {
                                        s(e, (e => (t(e), e)))
                                    },
                                    s = (e, t) => {
                                        const r = o.get(),
                                            s = t(Ce(r, e).getOrThunk(n));
                                        r[e] = s, o.set(r)
                                    },
                                    a = (t, o) => {
                                        W(Fa(e, t), (e => {
                                            o ? Wt(e, Ba(), "true") : Yt(e, Ba())
                                        }))
                                    },
                                    i = Ma((() => {
                                        const o = ae(t.getNames());
                                        W(o, (t => {
                                            s(t, (o => {
                                                const n = o.previous.get();
                                                return Pa(e, I.some(t)).fold((() => {
                                                    n.each((e => {
                                                        (e => {
                                                            r(e, (t => {
                                                                W(t.listeners, (t => t(!1, e)))
                                                            }))
                                                        })(t), o.previous.clear(), a(e, !1)
                                                    }))
                                                }), (({
                                                    uid: e,
                                                    name: t,
                                                    elements: s
                                                }) => {
                                                    Dt(n, e) || (n.each((e => a(e, !1))), ((e, t, o) => {
                                                        r(e, (n => {
                                                            W(n.listeners, (n => n(!0, e, {
                                                                uid: t,
                                                                nodes: j(o, (e => e.dom))
                                                            })))
                                                        }))
                                                    })(t, e, s), o.previous.set(e), a(e, !0))
                                                })), {
                                                    previous: o.previous,
                                                    listeners: o.listeners
                                                }
                                            }))
                                        }))
                                    }), 30);
                                return e.on("remove", (() => {
                                    i.cancel()
                                })), e.on("NodeChange", (() => {
                                    i.throttle()
                                })), {
                                    addListener: (e, t) => {
                                        s(e, (e => ({
                                            previous: e.previous,
                                            listeners: e.listeners.concat([t])
                                        })))
                                    }
                                }
                            })(e, t),
                            n = Ut("span"),
                            r = e => {
                                W(e, (e => {
                                    n(e) ? sn(e) : (e => {
                                        so(e, Na()), Yt(e, `${Da()}`), Yt(e, `${Ra()}`), Yt(e, `${Ba()}`);
                                        const t = Gt(e, `${Ha()}`).map((e => e.split(","))).getOr([]),
                                            o = Gt(e, `${La()}`).map((e => e.split(","))).getOr([]);
                                        var n;
                                        W(t, (t => Yt(e, t))), n = e, W(o, (e => {
                                            so(n, e)
                                        })), Yt(e, `${La()}`), Yt(e, `${Ha()}`)
                                    })(e)
                                }))
                            };
                        return {
                            register: (e, o) => {
                                t.register(e, o)
                            },
                            annotate: (o, n) => {
                                t.lookup(o).each((t => {
                                    ((e, t, o, n) => {
                                        e.undoManager.transact((() => {
                                            const r = e.selection,
                                                s = r.getRng(),
                                                a = Mu(e).length > 0,
                                                i = Ua("mce-annotation");
                                            if (s.collapsed && !a && ((e, t) => {
                                                    const o = wm(e.dom, t, [{
                                                        inline: "span"
                                                    }]);
                                                    t.setStart(o.startContainer, o.startOffset), t.setEnd(o.endContainer, o.endOffset), e.selection.setRng(t)
                                                })(e, s), r.getRng().collapsed && !a) {
                                                const s = km(e.getDoc(), i, n, t, o.decorate);
                                                cn(s, or), r.getRng().insertNode(s.dom), r.select(s.dom)
                                            } else Pu(r, !1, (() => {
                                                Iu(e, (r => {
                                                    _m(e, r, i, t, o.decorate, n)
                                                }))
                                            }))
                                        }))
                                    })(e, o, t, n)
                                }))
                            },
                            annotationChanged: (e, t) => {
                                o.addListener(e, t)
                            },
                            remove: t => {
                                const o = e.selection.getBookmark();
                                Pa(e, I.some(t)).each((({
                                    elements: e
                                }) => {
                                    r(e)
                                })), e.selection.moveToBookmark(o)
                            },
                            removeAll: t => {
                                const o = e.selection.getBookmark();
                                he(Va(e, t), ((e, t) => {
                                    r(e)
                                })), e.selection.moveToBookmark(o)
                            },
                            getAll: t => {
                                const o = Va(e, t);
                                return pe(o, (e => j(e, (e => e.dom))))
                            }
                        }
                    },
                    Tm = e => ({
                        getBookmark: N(hu, e),
                        moveToBookmark: N(pu, e)
                    });
                Tm.isBookmarkNode = fu;
                const Em = (e, t, o) => !o.collapsed && U(o.getClientRects(), (o => ((e, t, o) => t >= e.left && t <= e.right && o >= e.top && o <= e.bottom)(o, e, t))),
                    Am = (e, t, o) => {
                        e.dispatch(t, o)
                    },
                    Mm = (e, t, o, n) => {
                        e.dispatch("FormatApply", {
                            format: t,
                            node: o,
                            vars: n
                        })
                    },
                    Nm = (e, t, o, n) => {
                        e.dispatch("FormatRemove", {
                            format: t,
                            node: o,
                            vars: n
                        })
                    },
                    Rm = (e, t) => e.dispatch("SetContent", t),
                    Dm = (e, t) => e.dispatch("GetContent", t),
                    Bm = (e, t) => e.dispatch("PastePlainTextToggle", {
                        state: t
                    }),
                    Lm = {
                        BACKSPACE: 8,
                        DELETE: 46,
                        DOWN: 40,
                        ENTER: 13,
                        ESC: 27,
                        LEFT: 37,
                        RIGHT: 39,
                        SPACEBAR: 32,
                        TAB: 9,
                        UP: 38,
                        PAGE_UP: 33,
                        PAGE_DOWN: 34,
                        END: 35,
                        HOME: 36,
                        modifierPressed: e => e.shiftKey || e.ctrlKey || e.altKey || Lm.metaKeyPressed(e),
                        metaKeyPressed: e => Et.os.isMacOS() || Et.os.isiOS() ? e.metaKey : e.ctrlKey && !e.altKey
                    },
                    Hm = "data-mce-selected",
                    Im = Math.abs,
                    Pm = Math.round,
                    zm = {
                        nw: [0, 0, -1, -1],
                        ne: [1, 0, 1, -1],
                        se: [1, 1, 1, 1],
                        sw: [0, 1, -1, 1]
                    },
                    Fm = (e, t) => {
                        const o = t.dom,
                            n = t.getDoc(),
                            r = document,
                            s = t.getBody();
                        let a, i, l, c, d, u, m, g, h, p, f, v, b, y, w;
                        const C = e => x(e) && (Gn(e) || o.is(e, "figure.image")),
                            S = e => Qn(e) || o.hasClass(e, "mce-preview-object"),
                            k = e => {
                                const o = e.target;
                                ((e, t) => {
                                    if ((e => "longpress" === e.type || 0 === e.type.indexOf("touch"))(e)) {
                                        const o = e.touches[0];
                                        return C(e.target) && !Em(o.clientX, o.clientY, t)
                                    }
                                    return C(e.target) && !Em(e.clientX, e.clientY, t)
                                })(e, t.selection.getRng()) && !e.isDefaultPrevented() && t.selection.select(o)
                            },
                            _ = e => o.hasClass(e, "mce-preview-object") && x(e.firstElementChild) ? [e, e.firstElementChild] : o.is(e, "figure.image") ? [e.querySelector("img")] : [e],
                            O = e => {
                                const n = Zl(t);
                                return !!n && "false" !== e.getAttribute("data-mce-resize") && e !== t.getBody() && (o.hasClass(e, "mce-preview-object") && x(e.firstElementChild) ? fo(go(e.firstElementChild), n) : fo(go(e), n))
                            },
                            T = (e, n, r) => {
                                if (x(r)) {
                                    const s = _(e);
                                    W(s, (e => {
                                        e.style[n] || !t.schema.isValid(e.nodeName.toLowerCase(), n) ? o.setStyle(e, n, r) : o.setAttrib(e, n, "" + r)
                                    }))
                                }
                            },
                            E = (e, t, o) => {
                                T(e, "width", t), T(e, "height", o)
                            },
                            A = e => {
                                let n, r, d, x, k;
                                n = e.screenX - u, r = e.screenY - m, v = n * c[2] + g, b = r * c[3] + h, v = v < 5 ? 5 : v, b = b < 5 ? 5 : b, d = (C(a) || S(a)) && !1 !== Ul(t) ? !Lm.modifierPressed(e) : Lm.modifierPressed(e), d && (Im(n) > Im(r) ? (b = Pm(v * p), v = Pm(b / p)) : (v = Pm(b / p), b = Pm(v * p))), E(i, v, b), x = c.startPos.x + n, k = c.startPos.y + r, x = x > 0 ? x : 0, k = k > 0 ? k : 0, o.setStyles(l, {
                                    left: x,
                                    top: k,
                                    display: "block"
                                }), l.innerHTML = v + " &times; " + b, c[2] < 0 && i.clientWidth <= v && o.setStyle(i, "left", void 0 + (g - v)), c[3] < 0 && i.clientHeight <= b && o.setStyle(i, "top", void 0 + (h - b)), n = s.scrollWidth - y, r = s.scrollHeight - w, n + r !== 0 && o.setStyles(l, {
                                    left: x - n,
                                    top: k - r
                                }), f || (((e, t, o, n, r) => {
                                    e.dispatch("ObjectResizeStart", {
                                        target: t,
                                        width: o,
                                        height: n,
                                        origin: r
                                    })
                                })(t, a, g, h, "corner-" + c.name), f = !0)
                            },
                            M = () => {
                                const e = f;
                                f = !1, e && (T(a, "width", v), T(a, "height", b)), o.unbind(n, "mousemove", A), o.unbind(n, "mouseup", M), r !== n && (o.unbind(r, "mousemove", A), o.unbind(r, "mouseup", M)), o.remove(i), o.remove(l), o.remove(d), N(a), e && (((e, t, o, n, r) => {
                                    e.dispatch("ObjectResized", {
                                        target: t,
                                        width: o,
                                        height: n,
                                        origin: r
                                    })
                                })(t, a, v, b, "corner-" + c.name), o.setAttrib(a, "style", o.getAttrib(a, "style"))), t.nodeChanged()
                            },
                            N = e => {
                                H();
                                const f = o.getPos(e, s),
                                    x = f.x,
                                    C = f.y,
                                    k = e.getBoundingClientRect(),
                                    T = k.width || k.right - k.left,
                                    N = k.height || k.bottom - k.top;
                                a !== e && (D(), a = e, v = b = 0);
                                const R = t.dispatch("ObjectSelected", {
                                    target: e
                                });
                                O(e) && !R.isDefaultPrevented() ? he(zm, ((e, t) => {
                                    let f = o.get("mceResizeHandle" + t);
                                    f && o.remove(f), f = o.add(s, "div", {
                                        id: "mceResizeHandle" + t,
                                        "data-mce-bogus": "all",
                                        class: "mce-resizehandle",
                                        unselectable: !0,
                                        style: "cursor:" + t + "-resize; margin:0; padding:0"
                                    }), o.bind(f, "mousedown", (f => {
                                        f.stopImmediatePropagation(), f.preventDefault(), (f => {
                                            const v = _(a)[0];
                                            var b;
                                            u = f.screenX, m = f.screenY, g = v.clientWidth, h = v.clientHeight, p = h / g, c = e, c.name = t, c.startPos = {
                                                x: T * e[0] + x,
                                                y: N * e[1] + C
                                            }, y = s.scrollWidth, w = s.scrollHeight, d = o.add(s, "div", {
                                                class: "mce-resize-backdrop",
                                                "data-mce-bogus": "all"
                                            }), o.setStyles(d, {
                                                position: "fixed",
                                                left: "0",
                                                top: "0",
                                                width: "100%",
                                                height: "100%"
                                            }), i = S(b = a) ? o.create("img", {
                                                src: Et.transparentSrc
                                            }) : b.cloneNode(!0), o.addClass(i, "mce-clonedresizable"), o.setAttrib(i, "data-mce-bogus", "all"), i.contentEditable = "false", o.setStyles(i, {
                                                left: x,
                                                top: C,
                                                margin: 0
                                            }), E(i, T, N), i.removeAttribute(Hm), s.appendChild(i), o.bind(n, "mousemove", A), o.bind(n, "mouseup", M), r !== n && (o.bind(r, "mousemove", A), o.bind(r, "mouseup", M)), l = o.add(s, "div", {
                                                class: "mce-resize-helper",
                                                "data-mce-bogus": "all"
                                            }, g + " &times; " + h)
                                        })(f)
                                    })), e.elm = f, o.setStyles(f, {
                                        left: T * e[0] + x - f.offsetWidth / 2,
                                        top: N * e[1] + C - f.offsetHeight / 2
                                    })
                                })) : D(!1)
                            },
                            R = Aa(N, 0),
                            D = (e = !0) => {
                                R.cancel(), H(), a && e && a.removeAttribute(Hm), he(zm, ((e, t) => {
                                    const n = o.get("mceResizeHandle" + t);
                                    n && (o.unbind(n), o.remove(n))
                                }))
                            },
                            B = (e, t) => o.isChildOf(e, t),
                            L = n => {
                                if (f || t.removed || t.composing) return;
                                const r = "mousedown" === n.type ? n.target : e.getNode(),
                                    a = Tn(go(r), "table,img,figure.image,hr,video,span.mce-preview-object").map((e => e.dom)).getOrUndefined(),
                                    i = x(a) ? o.getAttrib(a, Hm, "1") : "1";
                                if (W(o.select(`img[${Hm}],hr[${Hm}]`), (e => {
                                        e.removeAttribute(Hm)
                                    })), x(a) && B(a, s)) {
                                    I();
                                    const t = e.getStart(!0);
                                    if (B(t, a) && B(e.getEnd(!0), a)) return o.setAttrib(a, Hm, i), void R.throttle(a)
                                }
                                D()
                            },
                            H = () => {
                                he(zm, (e => {
                                    e.elm && (o.unbind(e.elm), delete e.elm)
                                }))
                            },
                            I = () => {
                                try {
                                    t.getDoc().execCommand("enableObjectResizing", !1, "false")
                                } catch (e) {}
                            };
                        return t.on("init", (() => {
                            I(), t.on("NodeChange ResizeEditor ResizeWindow ResizeContent drop", L), t.on("keyup compositionend", (e => {
                                a && "TABLE" === a.nodeName && L(e)
                            })), t.on("hide blur", D), t.on("contextmenu longpress", k, !0)
                        })), t.on("remove", H), {
                            isResizable: O,
                            showResizeRect: N,
                            hideResizeRect: D,
                            updateResizeRect: L,
                            destroy: () => {
                                R.cancel(), a = i = d = null
                            }
                        }
                    },
                    Vm = (e, t, o) => {
                        const n = e.document.createRange();
                        var r;
                        return r = n, t.fold((e => {
                            r.setStartBefore(e.dom)
                        }), ((e, t) => {
                            r.setStart(e.dom, t)
                        }), (e => {
                            r.setStartAfter(e.dom)
                        })), ((e, t) => {
                            t.fold((t => {
                                e.setEndBefore(t.dom)
                            }), ((t, o) => {
                                e.setEnd(t.dom, o)
                            }), (t => {
                                e.setEndAfter(t.dom)
                            }))
                        })(n, o), n
                    },
                    Zm = (e, t, o, n, r) => {
                        const s = e.document.createRange();
                        return s.setStart(t.dom, o), s.setEnd(n.dom, r), s
                    },
                    Um = Gi([{
                        ltr: ["start", "soffset", "finish", "foffset"]
                    }, {
                        rtl: ["start", "soffset", "finish", "foffset"]
                    }]),
                    jm = (e, t, o) => t(go(o.startContainer), o.startOffset, go(o.endContainer), o.endOffset);
                Um.ltr, Um.rtl;
                const Wm = (e, t, o, n) => ({
                        start: e,
                        soffset: t,
                        finish: o,
                        foffset: n
                    }),
                    $m = document.caretPositionFromPoint ? (e, t, o) => {
                        var n, r;
                        return I.from(null === (r = (n = e.dom).caretPositionFromPoint) || void 0 === r ? void 0 : r.call(n, t, o)).bind((t => {
                            if (null === t.offsetNode) return I.none();
                            const o = e.dom.createRange();
                            return o.setStart(t.offsetNode, t.offset), o.collapse(), I.some(o)
                        }))
                    } : document.caretRangeFromPoint ? (e, t, o) => {
                        var n, r;
                        return I.from(null === (r = (n = e.dom).caretRangeFromPoint) || void 0 === r ? void 0 : r.call(n, t, o))
                    } : I.none,
                    qm = Gi([{
                        before: ["element"]
                    }, {
                        on: ["element", "offset"]
                    }, {
                        after: ["element"]
                    }]),
                    Gm = {
                        before: qm.before,
                        on: qm.on,
                        after: qm.after,
                        cata: (e, t, o, n) => e.fold(t, o, n),
                        getStart: e => e.fold(A, A, A)
                    },
                    Km = Gi([{
                        domRange: ["rng"]
                    }, {
                        relative: ["startSitu", "finishSitu"]
                    }, {
                        exact: ["start", "soffset", "finish", "foffset"]
                    }]),
                    Ym = {
                        domRange: Km.domRange,
                        relative: Km.relative,
                        exact: Km.exact,
                        exactFromRange: e => Km.exact(e.start, e.soffset, e.finish, e.foffset),
                        getWin: e => {
                            const t = (e => e.match({
                                domRange: e => go(e.startContainer),
                                relative: (e, t) => Gm.getStart(e),
                                exact: (e, t, o, n) => e
                            }))(e);
                            return Co(t)
                        },
                        range: Wm
                    },
                    Xm = (e, t) => {
                        const o = Ht(e);
                        return "input" === o ? Gm.after(e) : Z(["br", "img"], o) ? 0 === t ? Gm.before(e) : Gm.after(e) : Gm.on(e, t)
                    },
                    Jm = (e, t) => {
                        const o = e.fold(Gm.before, Xm, Gm.after),
                            n = t.fold(Gm.before, Xm, Gm.after);
                        return Ym.relative(o, n)
                    },
                    Qm = (e, t, o, n) => {
                        const r = Xm(e, t),
                            s = Xm(o, n);
                        return Ym.relative(r, s)
                    },
                    eg = (e, t) => {
                        const o = (t || document).createDocumentFragment();
                        return W(e, (e => {
                            o.appendChild(e.dom)
                        })), go(o)
                    },
                    tg = e => {
                        const t = Ym.getWin(e).dom,
                            o = (e, o, n, r) => Zm(t, e, o, n, r),
                            n = (e => e.match({
                                domRange: e => {
                                    const t = go(e.startContainer),
                                        o = go(e.endContainer);
                                    return Qm(t, e.startOffset, o, e.endOffset)
                                },
                                relative: Jm,
                                exact: Qm
                            }))(e);
                        return ((e, t) => {
                            const o = ((e, t) => t.match({
                                domRange: e => ({
                                    ltr: E(e),
                                    rtl: I.none
                                }),
                                relative: (t, o) => ({
                                    ltr: Be((() => Vm(e, t, o))),
                                    rtl: Be((() => I.some(Vm(e, o, t))))
                                }),
                                exact: (t, o, n, r) => ({
                                    ltr: Be((() => Zm(e, t, o, n, r))),
                                    rtl: Be((() => I.some(Zm(e, n, r, t, o))))
                                })
                            }))(e, t);
                            return ((e, t) => {
                                const o = t.ltr();
                                return o.collapsed ? t.rtl().filter((e => !1 === e.collapsed)).map((e => Um.rtl(go(e.endContainer), e.endOffset, go(e.startContainer), e.startOffset))).getOrThunk((() => jm(0, Um.ltr, o))) : jm(0, Um.ltr, o)
                            })(0, o)
                        })(t, n).match({
                            ltr: o,
                            rtl: o
                        })
                    },
                    og = (e, t, o) => ((e, t, o) => ((e, t, o) => {
                        const n = go(e.document);
                        return $m(n, t, o).map((e => Wm(go(e.startContainer), e.startOffset, go(e.endContainer), e.endOffset)))
                    })(e, t, o))(Co(go(o)).dom, e, t).map((e => {
                        const t = o.createRange();
                        return t.setStart(e.start.dom, e.soffset), t.setEnd(e.finish.dom, e.foffset), t
                    })).getOrUndefined(),
                    ng = (e, t) => x(e) && x(t) && e.startContainer === t.startContainer && e.startOffset === t.startOffset && e.endContainer === t.endContainer && e.endOffset === t.endOffset,
                    rg = (e, t, o) => null !== ((e, t, o) => {
                        let n = e;
                        for (; n && n !== t;) {
                            if (o(n)) return n;
                            n = n.parentNode
                        }
                        return null
                    })(e, t, o),
                    sg = (e, t, o) => rg(e, t, (e => e.nodeName === o)),
                    ag = (e, t) => Nr(e) && !rg(e, t, nu),
                    ig = (e, t, o) => {
                        const n = t.parentNode;
                        if (n) {
                            const r = new An(t, e.getParent(n, e.isBlock) || e.getRoot());
                            let s;
                            for (; s = r[o ? "prev" : "next"]();)
                                if (qn(s)) return !0
                        }
                        return !1
                    },
                    lg = (e, t, o, n, r) => {
                        const s = e.getRoot(),
                            a = e.schema.getNonEmptyElements(),
                            i = r.parentNode;
                        let l, c;
                        if (!i) return I.none();
                        const d = e.getParent(i, e.isBlock) || s;
                        if (n && qn(r) && t && e.isEmpty(d)) return I.some(Si(i, e.nodeIndex(r)));
                        const u = new An(r, d);
                        for (; c = u[n ? "prev" : "next"]();) {
                            if ("false" === e.getContentEditableParent(c) || ag(c, s)) return I.none();
                            if (Vn(c) && c.data.length > 0) return sg(c, s, "A") ? I.none() : I.some(Si(c, n ? c.data.length : 0));
                            if (e.isBlock(c) || a[c.nodeName.toLowerCase()]) return I.none();
                            l = c
                        }
                        return jn(l) ? I.none() : o && l ? I.some(Si(l, 0)) : I.none()
                    },
                    cg = (e, t, o, n) => {
                        const r = e.getRoot();
                        let s, a = !1,
                            i = o ? n.startContainer : n.endContainer,
                            l = o ? n.startOffset : n.endOffset;
                        const c = Rn(i) && l === i.childNodes.length,
                            d = e.schema.getNonEmptyElements();
                        let u = o;
                        if (Nr(i)) return I.none();
                        if (Rn(i) && l > i.childNodes.length - 1 && (u = !1), Wn(i) && (i = r, l = 0), i === r) {
                            if (u && (s = i.childNodes[l > 0 ? l - 1 : 0], s)) {
                                if (Nr(s)) return I.none();
                                if (d[s.nodeName] || Pn(s)) return I.none()
                            }
                            if (i.hasChildNodes()) {
                                if (l = Math.min(!u && l > 0 ? l - 1 : l, i.childNodes.length - 1), i = i.childNodes[l], l = Vn(i) && c ? i.data.length : 0, !t && i === r.lastChild && Pn(i)) return I.none();
                                if (((e, t) => {
                                        let o = t;
                                        for (; o && o !== e;) {
                                            if (Yn(o)) return !0;
                                            o = o.parentNode
                                        }
                                        return !1
                                    })(r, i) || Nr(i)) return I.none();
                                if (i.hasChildNodes() && !Pn(i)) {
                                    s = i;
                                    const t = new An(i, r);
                                    do {
                                        if (Yn(s) || Nr(s)) {
                                            a = !1;
                                            break
                                        }
                                        if (Vn(s) && s.data.length > 0) {
                                            l = u ? 0 : s.data.length, i = s, a = !0;
                                            break
                                        }
                                        if (d[s.nodeName.toLowerCase()] && !Jn(s)) {
                                            l = e.nodeIndex(s), i = s.parentNode, u || l++, a = !0;
                                            break
                                        }
                                    } while (s = u ? t.next() : t.prev())
                                }
                            }
                        }
                        return t && (Vn(i) && 0 === l && lg(e, c, t, !0, i).each((e => {
                            i = e.container(), l = e.offset(), a = !0
                        })), Rn(i) && (s = i.childNodes[l], s || (s = i.childNodes[l - 1]), !s || !qn(s) || ((e, t) => {
                            var o;
                            return "A" === (null === (o = e.previousSibling) || void 0 === o ? void 0 : o.nodeName)
                        })(s) || ig(e, s, !1) || ig(e, s, !0) || lg(e, c, t, !0, s).each((e => {
                            i = e.container(), l = e.offset(), a = !0
                        })))), u && !t && Vn(i) && l === i.data.length && lg(e, c, t, !1, i).each((e => {
                            i = e.container(), l = e.offset(), a = !0
                        })), a && i ? I.some(Si(i, l)) : I.none()
                    },
                    dg = (e, t) => {
                        const o = t.collapsed,
                            n = t.cloneRange(),
                            r = Si.fromRangeStart(t);
                        return cg(e, o, !0, n).each((e => {
                            o && Si.isAbove(r, e) || n.setStart(e.container(), e.offset())
                        })), o || cg(e, o, !1, n).each((e => {
                            n.setEnd(e.container(), e.offset())
                        })), o && n.collapse(!0), ng(t, n) ? I.none() : I.some(n)
                    },
                    ug = (e, t) => e.splitText(t),
                    mg = e => {
                        let t = e.startContainer,
                            o = e.startOffset,
                            n = e.endContainer,
                            r = e.endOffset;
                        if (t === n && Vn(t)) {
                            if (o > 0 && o < t.data.length)
                                if (n = ug(t, o), t = n.previousSibling, r > o) {
                                    r -= o;
                                    const e = ug(n, r).previousSibling;
                                    t = n = e, r = e.data.length, o = 0
                                } else r = 0
                        } else if (Vn(t) && o > 0 && o < t.data.length && (t = ug(t, o), o = 0), Vn(n) && r > 0 && r < n.data.length) {
                            const e = ug(n, r).previousSibling;
                            n = e, r = e.data.length
                        }
                        return {
                            startContainer: t,
                            startOffset: o,
                            endContainer: n,
                            endOffset: r
                        }
                    },
                    gg = e => ({
                        walk: (t, o) => xm(e, t, o),
                        split: mg,
                        expand: (t, o = {
                            type: "word"
                        }) => {
                            if ("word" === o.type) {
                                const o = wm(e, t, [{
                                        inline: "span"
                                    }]),
                                    n = e.createRng();
                                return n.setStart(o.startContainer, o.startOffset), n.setEnd(o.endContainer, o.endOffset), n
                            }
                            return t
                        },
                        normalize: t => dg(e, t).fold(L, (e => (t.setStart(e.startContainer, e.startOffset), t.setEnd(e.endContainer, e.endOffset), !0)))
                    });
                gg.compareRanges = ng, gg.getCaretRangeFromPoint = og, gg.getSelectedNode = oi, gg.getNode = ni;
                const hg = ((e, t) => {
                        const o = t => {
                                const o = (e => {
                                    const t = e.dom;
                                    return Uo(e) ? t.getBoundingClientRect().height : t.offsetHeight
                                })(t);
                                if (o <= 0 || null === o) {
                                    const o = qo(t, e);
                                    return parseFloat(o) || 0
                                }
                                return o
                            },
                            n = (e, t) => Y(t, ((t, o) => {
                                const n = qo(e, o),
                                    r = void 0 === n ? 0 : parseInt(n, 10);
                                return isNaN(r) ? t : t + r
                            }), 0);
                        return {
                            set: (t, o) => {
                                if (!S(o) && !o.match(/^[0-9]+$/)) throw new Error(e + ".set accepts only positive integer values. Value was " + o);
                                const n = t.dom;
                                io(n) && (n.style[e] = o + "px")
                            },
                            get: o,
                            getOuter: o,
                            aggregate: n,
                            max: (e, t, o) => {
                                const r = n(e, o);
                                return t > r ? t - r : 0
                            }
                        }
                    })("height"),
                    pg = () => go(document),
                    fg = (e, t) => e.view(t).fold(E([]), (t => {
                        const o = e.owner(t),
                            n = fg(e, o);
                        return [t].concat(n)
                    }));
                var vg = Object.freeze({
                    __proto__: null,
                    view: e => {
                        var t;
                        return (e.dom === document ? I.none() : I.from(null === (t = e.dom.defaultView) || void 0 === t ? void 0 : t.frameElement)).map(go)
                    },
                    owner: e => xo(e)
                });
                const bg = e => "textarea" === Ht(e),
                    yg = (e, t) => {
                        const o = (e => {
                                const t = e.dom.ownerDocument,
                                    o = t.body,
                                    n = t.defaultView,
                                    r = t.documentElement;
                                if (o === e.dom) return gn(o.offsetLeft, o.offsetTop);
                                const s = hn(null == n ? void 0 : n.pageYOffset, r.scrollTop),
                                    a = hn(null == n ? void 0 : n.pageXOffset, r.scrollLeft),
                                    i = hn(r.clientTop, o.clientTop),
                                    l = hn(r.clientLeft, o.clientLeft);
                                return pn(e).translate(a - l, s - i)
                            })(e),
                            n = (e => hg.get(e))(e);
                        return {
                            element: e,
                            bottom: o.top + n,
                            height: n,
                            pos: o,
                            cleanup: t
                        }
                    },
                    wg = (e, t, o, n) => {
                        kg(e, ((r, s) => Cg(e, t, o, n)), o)
                    },
                    xg = (e, t, o, n, r) => {
                        const s = {
                            elm: n.element.dom,
                            alignToTop: r
                        };
                        ((e, t) => e.dispatch("ScrollIntoView", t).isDefaultPrevented())(e, s) || (o(t, fn(t).top, n, r), ((e, t) => {
                            e.dispatch("AfterScrollIntoView", t)
                        })(e, s))
                    },
                    Cg = (e, t, o, n) => {
                        const r = go(e.getBody()),
                            s = go(e.getDoc());
                        r.dom.offsetWidth;
                        const a = ((e, t) => {
                            const o = ((e, t) => {
                                    const o = Mo(e);
                                    if (0 === o.length || bg(e)) return {
                                        element: e,
                                        offset: t
                                    };
                                    if (t < o.length && !bg(o[t])) return {
                                        element: o[t],
                                        offset: 0
                                    }; {
                                        const n = o[o.length - 1];
                                        return bg(n) ? {
                                            element: e,
                                            offset: t
                                        } : "img" === Ht(n) ? {
                                            element: n,
                                            offset: 1
                                        } : Ft(n) ? {
                                            element: n,
                                            offset: ar(n).length
                                        } : {
                                            element: n,
                                            offset: Mo(n).length
                                        }
                                    }
                                })(e, t),
                                n = co('<span data-mce-bogus="all" style="display: inline-block;">\ufeff</span>');
                            return Jo(o.element, n), yg(n, (() => rn(n)))
                        })(go(o.startContainer), o.startOffset);
                        xg(e, s, t, a, n), a.cleanup()
                    },
                    Sg = (e, t, o, n) => {
                        const r = go(e.getDoc());
                        xg(e, r, o, (e => yg(go(e), _))(t), n)
                    },
                    kg = (e, t, o) => {
                        const n = o.startContainer,
                            r = o.startOffset,
                            s = o.endContainer,
                            a = o.endOffset;
                        t(go(n), go(s));
                        const i = e.dom.createRng();
                        i.setStart(n, r), i.setEnd(s, a), e.selection.setRng(o)
                    },
                    _g = (e, t, o, n) => {
                        const r = e.pos;
                        if (o) vn(r.left, r.top, n);
                        else {
                            const o = r.top - t + e.height;
                            vn(r.left, o, n)
                        }
                    },
                    Og = (e, t, o, n, r) => {
                        const s = o + t,
                            a = n.pos.top,
                            i = n.bottom,
                            l = i - a >= o;
                        a < t ? _g(n, o, !1 !== r, e) : a > s ? _g(n, o, l ? !1 !== r : !0 === r, e) : i > s && !l && _g(n, o, !0 === r, e)
                    },
                    Tg = (e, t, o, n) => {
                        const r = Co(e).dom.innerHeight;
                        Og(e, t, r, o, n)
                    },
                    Eg = (e, t, o, n) => {
                        const r = Co(e).dom.innerHeight;
                        Og(e, t, r, o, n);
                        const s = (e => {
                                const t = pg(),
                                    o = fn(t),
                                    n = ((e, t) => {
                                        const o = t.owner(e);
                                        return fg(t, o)
                                    })(e, vg),
                                    r = pn(e),
                                    s = K(n, ((e, t) => {
                                        const o = pn(t);
                                        return {
                                            left: e.left + o.left,
                                            top: e.top + o.top
                                        }
                                    }), {
                                        left: 0,
                                        top: 0
                                    });
                                return gn(s.left + r.left + o.left, s.top + r.top + o.top)
                            })(o.element),
                            a = wn(window);
                        s.top < a.y ? bn(o.element, !1 !== n) : s.top > a.bottom && bn(o.element, !0 === n)
                    },
                    Ag = (e, t, o) => wg(e, Tg, t, o),
                    Mg = (e, t, o) => Sg(e, t, Tg, o),
                    Ng = (e, t, o) => wg(e, Eg, t, o),
                    Rg = (e, t, o) => Sg(e, t, Eg, o),
                    Dg = (e, t, o) => {
                        (e.inline ? Ag : Ng)(e, t, o)
                    },
                    Bg = e => e.dom.focus(),
                    Lg = e => {
                        const t = Po(e).dom;
                        return e.dom === t.activeElement
                    },
                    Hg = (e = pg()) => I.from(e.dom.activeElement).map(go),
                    Ig = (e, t) => {
                        const o = Ft(t) ? ar(t).length : Mo(t).length + 1;
                        return e > o ? o : e < 0 ? 0 : e
                    },
                    Pg = e => Ym.range(e.start, Ig(e.soffset, e.start), e.finish, Ig(e.foffset, e.finish)),
                    zg = (e, t) => !Nn(t.dom) && (yo(e, t) || bo(e, t)),
                    Fg = e => t => zg(e, t.start) && zg(e, t.finish),
                    Vg = e => Ym.range(go(e.startContainer), e.startOffset, go(e.endContainer), e.endOffset),
                    Zg = e => {
                        const t = document.createRange();
                        try {
                            return t.setStart(e.start.dom, e.soffset), t.setEnd(e.finish.dom, e.foffset), I.some(t)
                        } catch (e) {
                            return I.none()
                        }
                    },
                    Ug = e => {
                        const t = (e => e.inline || Et.browser.isFirefox())(e) ? (o = go(e.getBody()), (e => {
                            const t = e.getSelection();
                            return (t && 0 !== t.rangeCount ? I.from(t.getRangeAt(0)) : I.none()).map(Vg)
                        })(Co(o).dom).filter(Fg(o))) : I.none();
                        var o;
                        e.bookmark = t.isSome() ? t : e.bookmark
                    },
                    jg = e => (e.bookmark ? e.bookmark : I.none()).bind((t => {
                        return o = go(e.getBody()), n = t, I.from(n).filter(Fg(o)).map(Pg);
                        var o, n
                    })).bind(Zg),
                    Wg = {
                        isEditorUIElement: e => {
                            const t = e.className.toString();
                            return -1 !== t.indexOf("tox-") || -1 !== t.indexOf("mce-")
                        }
                    },
                    $g = {
                        setEditorTimeout: (e, t, o) => ((e, t) => (S(t) || (t = 0), setTimeout(e, t)))((() => {
                            e.removed || t()
                        }), o),
                        setEditorInterval: (e, t, o) => {
                            const n = ((e, t) => (S(t) || (t = 0), setInterval(e, t)))((() => {
                                e.removed ? clearInterval(n) : t()
                            }), o);
                            return n
                        }
                    };
                let qg;
                const Gg = ba.DOM,
                    Kg = (e, t) => {
                        const o = oc(e),
                            n = Gg.getParent(t, (t => (e => Rn(e) && Wg.isEditorUIElement(e))(t) || !!o && e.dom.is(t, o)));
                        return null !== n
                    },
                    Yg = (e, t) => {
                        const o = t.editor;
                        (e => {
                            const t = Aa((() => {
                                Ug(e)
                            }), 0);
                            e.on("init", (() => {
                                e.inline && ((e, t) => {
                                    const o = () => {
                                        t.throttle()
                                    };
                                    ba.DOM.bind(document, "mouseup", o), e.on("remove", (() => {
                                        ba.DOM.unbind(document, "mouseup", o)
                                    }))
                                })(e, t), ((e, t) => {
                                    ((e, t) => {
                                        e.on("mouseup touchend", (e => {
                                            t.throttle()
                                        }))
                                    })(e, t), e.on("keyup NodeChange AfterSetSelectionRange", (t => {
                                        (e => "nodechange" === e.type && e.selectionChange)(t) || Ug(e)
                                    }))
                                })(e, t)
                            })), e.on("remove", (() => {
                                t.cancel()
                            }))
                        })(o), o.on("focusin", (() => {
                            const t = e.focusedEditor;
                            t !== o && (t && t.dispatch("blur", {
                                focusedEditor: o
                            }), e.setActive(o), e.focusedEditor = o, o.dispatch("focus", {
                                blurredEditor: t
                            }), o.focus(!0))
                        })), o.on("focusout", (() => {
                            $g.setEditorTimeout(o, (() => {
                                const t = e.focusedEditor;
                                Kg(o, (e => {
                                    try {
                                        const t = Po(go(e.getElement()));
                                        return Hg(t).fold((() => document.body), (e => e.dom))
                                    } catch (e) {
                                        return document.body
                                    }
                                })(o)) || t !== o || (o.dispatch("blur", {
                                    focusedEditor: null
                                }), e.focusedEditor = null)
                            }))
                        })), qg || (qg = t => {
                            const o = e.activeEditor;
                            o && Vo(t).each((t => {
                                const n = t;
                                n.ownerDocument === document && (n === document.body || Kg(o, n) || e.focusedEditor !== o || (o.dispatch("blur", {
                                    focusedEditor: null
                                }), e.focusedEditor = null))
                            }))
                        }, Gg.bind(document, "focusin", qg))
                    },
                    Xg = (e, t) => {
                        e.focusedEditor === t.editor && (e.focusedEditor = null), !e.activeEditor && qg && (Gg.unbind(document, "focusin", qg), qg = null)
                    },
                    Jg = (e, t) => {
                        ((e, t) => (e => e.collapsed ? I.from(ni(e.startContainer, e.startOffset)).map(go) : I.none())(t).bind((t => fr(t) ? I.some(t) : yo(e, t) ? I.none() : I.some(e))))(go(e.getBody()), t).bind((e => eu(e.dom))).fold((() => {
                            e.selection.normalize()
                        }), (t => e.selection.setRng(t.toRange())))
                    },
                    Qg = e => {
                        if (e.setActive) try {
                            e.setActive()
                        } catch (t) {
                            e.focus()
                        } else e.focus()
                    },
                    eh = e => e.inline ? (e => {
                        const t = e.getBody();
                        return t && (o = go(t), Lg(o) || (n = o, Hg(Po(n)).filter((e => n.dom.contains(e.dom)))).isSome());
                        var o, n
                    })(e) : (e => x(e.iframeElement) && Lg(go(e.iframeElement)))(e),
                    th = e => e.editorManager.setActive(e),
                    oh = (e, t, o, n, r) => {
                        const s = o ? t.startContainer : t.endContainer,
                            a = o ? t.startOffset : t.endOffset;
                        return I.from(s).map(go).map((e => n && t.collapsed ? e : No(e, r(e, a)).getOr(e))).bind((e => zt(e) ? I.some(e) : So(e).filter(zt))).map((e => e.dom)).getOr(e)
                    },
                    nh = (e, t, o = !1) => oh(e, t, !0, o, ((e, t) => Math.min(Bo(e), t))),
                    rh = (e, t, o = !1) => oh(e, t, !1, o, ((e, t) => t > 0 ? t - 1 : t)),
                    sh = (e, t) => {
                        const o = e;
                        for (; e && Vn(e) && 0 === e.length;) e = t ? e.nextSibling : e.previousSibling;
                        return e || o
                    },
                    ah = (e, t) => j(t, (t => {
                        const o = e.dispatch("GetSelectionRange", {
                            range: t
                        });
                        return o.range !== t ? o.range : t
                    })),
                    ih = ["img", "br"],
                    lh = e => {
                        const t = ir(e).filter((e => 0 !== e.trim().length || e.indexOf(or) > -1)).isSome();
                        return t || Z(ih, Ht(e))
                    },
                    ch = "[data-mce-autocompleter]",
                    dh = (e, t) => {
                        if (uh(go(e.getBody())).isNone()) {
                            const n = co('<span data-mce-autocompleter="1" data-mce-bogus="1"></span>', e.getDoc());
                            tn(n, go(t.extractContents())), t.insertNode(n.dom), So(n).each((e => e.dom.normalize())), (o = n, ((e, t) => {
                                const o = e => {
                                    const n = Mo(e);
                                    for (let e = n.length - 1; e >= 0; e--) {
                                        const r = n[e];
                                        if (t(r)) return I.some(r);
                                        const s = o(r);
                                        if (s.isSome()) return s
                                    }
                                    return I.none()
                                };
                                return o(e)
                            })(o, lh)).map((t => {
                                e.selection.setCursorLocation(t.dom, (e => "img" === Ht(e) ? 1 : ir(e).fold((() => Mo(e).length), (e => e.length)))(t))
                            }))
                        }
                        var o
                    },
                    uh = e => On(e, ch),
                    mh = {
                        "#text": 3,
                        "#comment": 8,
                        "#cdata": 4,
                        "#pi": 7,
                        "#doctype": 10,
                        "#document-fragment": 11
                    },
                    gh = (e, t, o) => {
                        const n = o ? "lastChild" : "firstChild",
                            r = o ? "prev" : "next";
                        if (e[n]) return e[n];
                        if (e !== t) {
                            let o = e[r];
                            if (o) return o;
                            for (let n = e.parent; n && n !== t; n = n.parent)
                                if (o = n[r], o) return o
                        }
                    },
                    hh = e => {
                        var t;
                        const o = null !== (t = e.value) && void 0 !== t ? t : "";
                        if (!Xr(o)) return !1;
                        const n = e.parent;
                        return !n || "span" === n.name && !n.attr("style") || !/^[ ]+$/.test(o)
                    },
                    ph = e => {
                        const t = "a" === e.name && !e.attr("href") && e.attr("id");
                        return e.attr("name") || e.attr("id") && !e.firstChild || e.attr("data-mce-bookmark") || t
                    };
                class fh {
                    constructor(e, t) {
                        this.name = e, this.type = t, 1 === t && (this.attributes = [], this.attributes.map = {})
                    }
                    static create(e, t) {
                        const o = new fh(e, mh[e] || 1);
                        return t && he(t, ((e, t) => {
                            o.attr(t, e)
                        })), o
                    }
                    replace(e) {
                        const t = this;
                        return e.parent && e.remove(), t.insert(e, t), t.remove(), t
                    }
                    attr(e, t) {
                        const o = this;
                        if (!g(e)) return x(e) && he(e, ((e, t) => {
                            o.attr(t, e)
                        })), o;
                        const n = o.attributes;
                        if (n) {
                            if (void 0 !== t) {
                                if (null === t) {
                                    if (e in n.map) {
                                        delete n.map[e];
                                        let t = n.length;
                                        for (; t--;)
                                            if (n[t].name === e) return n.splice(t, 1), o
                                    }
                                    return o
                                }
                                if (e in n.map) {
                                    let o = n.length;
                                    for (; o--;)
                                        if (n[o].name === e) {
                                            n[o].value = t;
                                            break
                                        }
                                } else n.push({
                                    name: e,
                                    value: t
                                });
                                return n.map[e] = t, o
                            }
                            return n.map[e]
                        }
                    }
                    clone() {
                        const e = this,
                            t = new fh(e.name, e.type),
                            o = e.attributes;
                        if (o) {
                            const e = [];
                            e.map = {};
                            for (let t = 0, n = o.length; t < n; t++) {
                                const n = o[t];
                                "id" !== n.name && (e[e.length] = {
                                    name: n.name,
                                    value: n.value
                                }, e.map[n.name] = n.value)
                            }
                            t.attributes = e
                        }
                        return t.value = e.value, t
                    }
                    wrap(e) {
                        const t = this;
                        return t.parent && (t.parent.insert(e, t), e.append(t)), t
                    }
                    unwrap() {
                        const e = this;
                        for (let t = e.firstChild; t;) {
                            const o = t.next;
                            e.insert(t, e, !0), t = o
                        }
                        e.remove()
                    }
                    remove() {
                        const e = this,
                            t = e.parent,
                            o = e.next,
                            n = e.prev;
                        return t && (t.firstChild === e ? (t.firstChild = o, o && (o.prev = null)) : n && (n.next = o), t.lastChild === e ? (t.lastChild = n, n && (n.next = null)) : o && (o.prev = n), e.parent = e.next = e.prev = null), e
                    }
                    append(e) {
                        const t = this;
                        e.parent && e.remove();
                        const o = t.lastChild;
                        return o ? (o.next = e, e.prev = o, t.lastChild = e) : t.lastChild = t.firstChild = e, e.parent = t, e
                    }
                    insert(e, t, o) {
                        e.parent && e.remove();
                        const n = t.parent || this;
                        return o ? (t === n.firstChild ? n.firstChild = e : t.prev && (t.prev.next = e), e.prev = t.prev, e.next = t, t.prev = e) : (t === n.lastChild ? n.lastChild = e : t.next && (t.next.prev = e), e.next = t.next, e.prev = t, t.next = e), e.parent = n, e
                    }
                    getAll(e) {
                        const t = this,
                            o = [];
                        for (let n = t.firstChild; n; n = gh(n, t)) n.name === e && o.push(n);
                        return o
                    }
                    children() {
                        const e = [];
                        for (let t = this.firstChild; t; t = t.next) e.push(t);
                        return e
                    }
                    empty() {
                        const e = this;
                        if (e.firstChild) {
                            const t = [];
                            for (let o = e.firstChild; o; o = gh(o, e)) t.push(o);
                            let o = t.length;
                            for (; o--;) {
                                const e = t[o];
                                e.parent = e.firstChild = e.lastChild = e.next = e.prev = null
                            }
                        }
                        return e.firstChild = e.lastChild = null, e
                    }
                    isEmpty(e, t = {}, o) {
                        var n;
                        const r = this;
                        let s = r.firstChild;
                        if (ph(r)) return !1;
                        if (s)
                            do {
                                if (1 === s.type) {
                                    if (s.attr("data-mce-bogus")) continue;
                                    if (e[s.name]) return !1;
                                    if (ph(s)) return !1
                                }
                                if (8 === s.type) return !1;
                                if (3 === s.type && !hh(s)) return !1;
                                if (3 === s.type && s.parent && t[s.parent.name] && Xr(null !== (n = s.value) && void 0 !== n ? n : "")) return !1;
                                if (o && o(s)) return !1
                            } while (s = gh(s, r));
                        return !0
                    }
                    walk(e) {
                        return gh(this, null, e)
                    }
                }
                const vh = (e, t, o = 0) => {
                        const n = e.toLowerCase();
                        if (-1 !== n.indexOf("[if ", o) && ((e, t) => /^\s*\[if [\w\W]+\]>.*<!\[endif\](--!?)?>/.test(e.substr(t)))(n, o)) {
                            const e = n.indexOf("[endif]", o);
                            return n.indexOf(">", e)
                        }
                        if (t) {
                            const e = n.indexOf(">", o);
                            return -1 !== e ? e : n.length
                        } {
                            const t = /--!?>/g;
                            t.lastIndex = o;
                            const r = t.exec(e);
                            return r ? r.index + r[0].length : n.length
                        }
                    },
                    bh = (e, t, o) => {
                        const n = /<([!?\/])?([A-Za-z0-9\-_:.]+)/g,
                            r = /(?:\s(?:[^'">]+(?:"[^"]*"|'[^']*'))*[^"'>]*(?:"[^">]*|'[^'>]*)?|\s*|\/)>/g,
                            s = e.getVoidElements();
                        let a = 1,
                            i = o;
                        for (; 0 !== a;)
                            for (n.lastIndex = i;;) {
                                const e = n.exec(t);
                                if (null === e) return i;
                                if ("!" === e[1]) {
                                    i = Ve(e[2], "--") ? vh(t, !1, e.index + "!--".length) : vh(t, !0, e.index + 1);
                                    break
                                } {
                                    r.lastIndex = n.lastIndex;
                                    const o = r.exec(t);
                                    if (v(o) || o.index !== n.lastIndex) continue;
                                    "/" === e[1] ? a -= 1 : Se(s, e[2]) || (a += 1), i = n.lastIndex + o[0].length;
                                    break
                                }
                            }
                        return i
                    },
                    yh = (e, t) => {
                        const o = /<(\w+) [^>]*data-mce-bogus="all"[^>]*>/g,
                            n = e.schema;
                        let r = ((e, t) => {
                            const o = new RegExp(["\\s?(" + e.join("|") + ')="[^"]+"'].join("|"), "gi");
                            return t.replace(o, "")
                        })(e.getTempAttrs(), t);
                        const s = n.getVoidElements();
                        let a;
                        for (; a = o.exec(r);) {
                            const e = o.lastIndex,
                                t = a[0].length;
                            let i;
                            i = s[a[1]] ? e : bh(n, r, e), r = r.substring(0, e - t) + r.substring(i), o.lastIndex = e - t
                        }
                        return Or(r)
                    },
                    wh = yh,
                    xh = e => {
                        const t = rr(e, "[data-mce-bogus]");
                        W(t, (e => {
                            "all" === qt(e, "data-mce-bogus") ? rn(e) : mr(e) ? (Jo(e, mo(tr)), rn(e)) : sn(e)
                        }))
                    },
                    Ch = e => {
                        const t = rr(e, "input");
                        W(t, (e => {
                            Yt(e, "name")
                        }))
                    },
                    Sh = (e, t, o) => {
                        let n;
                        return n = "raw" === t.format ? Rt.trim(wh(e.serializer, o.innerHTML)) : "text" === t.format ? ((e, t) => {
                            const o = e.getDoc(),
                                n = Po(go(e.getBody())),
                                r = uo("div", o);
                            Wt(r, "data-mce-bogus", "all"), $o(r, {
                                position: "fixed",
                                left: "-9999999px",
                                top: "0"
                            }), cn(r, t.innerHTML), xh(r), Ch(r);
                            const s = (e => Lo(e) ? e : go(xo(e).dom.body))(n);
                            tn(s, r);
                            const a = Or(r.dom.innerText);
                            return rn(r), a
                        })(e, o) : "tree" === t.format ? e.serializer.serialize(o, t) : ((e, t) => {
                            const o = pl(e),
                                n = new RegExp(`^(<${o}[^>]*>(&nbsp;|&#160;|\\s||<br \\/>|)<\\/${o}>[\r\n]*|<br \\/>[\r\n]*)$`);
                            return t.replace(n, "")
                        })(e, e.serializer.serialize(o, t)), "text" !== t.format && !br(go(o)) && g(n) ? Rt.trim(n) : n
                    },
                    kh = Rt.makeMap,
                    _h = e => {
                        const t = [],
                            o = (e = e || {}).indent,
                            n = kh(e.indent_before || ""),
                            r = kh(e.indent_after || ""),
                            s = zs.getEncodeFunc(e.entity_encoding || "raw", e.entities),
                            a = "xhtml" !== e.element_format;
                        return {
                            start: (e, i, l) => {
                                if (o && n[e] && t.length > 0) {
                                    const e = t[t.length - 1];
                                    e.length > 0 && "\n" !== e && t.push("\n")
                                }
                                if (t.push("<", e), i)
                                    for (let e = 0, o = i.length; e < o; e++) {
                                        const o = i[e];
                                        t.push(" ", o.name, '="', s(o.value, !0), '"')
                                    }
                                if (t[t.length] = !l || a ? ">" : " />", l && o && r[e] && t.length > 0) {
                                    const e = t[t.length - 1];
                                    e.length > 0 && "\n" !== e && t.push("\n")
                                }
                            },
                            end: e => {
                                let n;
                                t.push("</", e, ">"), o && r[e] && t.length > 0 && (n = t[t.length - 1], n.length > 0 && "\n" !== n && t.push("\n"))
                            },
                            text: (e, o) => {
                                e.length > 0 && (t[t.length] = o ? e : s(e))
                            },
                            cdata: e => {
                                t.push("<![CDATA[", e, "]]>")
                            },
                            comment: e => {
                                t.push("\x3c!--", e, "--\x3e")
                            },
                            pi: (e, n) => {
                                n ? t.push("<?", e, " ", s(n), "?>") : t.push("<?", e, "?>"), o && t.push("\n")
                            },
                            doctype: e => {
                                t.push("<!DOCTYPE", e, ">", o ? "\n" : "")
                            },
                            reset: () => {
                                t.length = 0
                            },
                            getContent: () => t.join("").replace(/\n$/, "")
                        }
                    },
                    Oh = (e = {}, t = Js()) => {
                        const o = _h(e);
                        return e.validate = !("validate" in e) || e.validate, {
                            serialize: n => {
                                const r = e.validate,
                                    s = {
                                        3: e => {
                                            var t;
                                            o.text(null !== (t = e.value) && void 0 !== t ? t : "", e.raw)
                                        },
                                        8: e => {
                                            var t;
                                            o.comment(null !== (t = e.value) && void 0 !== t ? t : "")
                                        },
                                        7: e => {
                                            o.pi(e.name, e.value)
                                        },
                                        10: e => {
                                            var t;
                                            o.doctype(null !== (t = e.value) && void 0 !== t ? t : "")
                                        },
                                        4: e => {
                                            var t;
                                            o.cdata(null !== (t = e.value) && void 0 !== t ? t : "")
                                        },
                                        11: e => {
                                            let t = e;
                                            if (t = t.firstChild)
                                                do {
                                                    a(t)
                                                } while (t = t.next)
                                        }
                                    };
                                o.reset();
                                const a = e => {
                                    var n;
                                    const i = s[e.type];
                                    if (i) i(e);
                                    else {
                                        const s = e.name,
                                            i = s in t.getVoidElements();
                                        let l = e.attributes;
                                        if (r && l && l.length > 1) {
                                            const o = [];
                                            o.map = {};
                                            const n = t.getElementRule(e.name);
                                            if (n) {
                                                for (let e = 0, t = n.attributesOrder.length; e < t; e++) {
                                                    const t = n.attributesOrder[e];
                                                    if (t in l.map) {
                                                        const e = l.map[t];
                                                        o.map[t] = e, o.push({
                                                            name: t,
                                                            value: e
                                                        })
                                                    }
                                                }
                                                for (let e = 0, t = l.length; e < t; e++) {
                                                    const t = l[e].name;
                                                    if (!(t in o.map)) {
                                                        const e = l.map[t];
                                                        o.map[t] = e, o.push({
                                                            name: t,
                                                            value: e
                                                        })
                                                    }
                                                }
                                                l = o
                                            }
                                        }
                                        if (o.start(s, l, i), !i) {
                                            let t = e.firstChild;
                                            if (t) {
                                                "pre" !== s && "textarea" !== s || 3 !== t.type || "\n" !== (null === (n = t.value) || void 0 === n ? void 0 : n[0]) || o.text("\n", !0);
                                                do {
                                                    a(t)
                                                } while (t = t.next)
                                            }
                                            o.end(s)
                                        }
                                    }
                                };
                                return 1 !== n.type || e.inner ? 3 === n.type ? s[3](n) : s[11](n) : a(n), o.getContent()
                            }
                        }
                    },
                    Th = new Set;
                W(["margin", "margin-left", "margin-right", "margin-top", "margin-bottom", "padding", "padding-left", "padding-right", "padding-top", "padding-bottom", "border", "border-width", "border-style", "border-color", "background", "background-attachment", "background-clip", "background-color", "background-image", "background-origin", "background-position", "background-repeat", "background-size", "float", "position", "left", "right", "top", "bottom", "z-index", "display", "transform", "width", "max-width", "min-width", "height", "max-height", "min-height", "overflow", "overflow-x", "overflow-y", "text-overflow", "vertical-align", "transition", "transition-delay", "transition-duration", "transition-property", "transition-timing-function"], (e => {
                    Th.add(e)
                }));
                const Eh = ["font", "text-decoration", "text-emphasis"],
                    Ah = (e, t) => me(e.parseStyle(e.getAttrib(t, "style"))),
                    Mh = (e, t, o) => {
                        const n = Ah(e, t),
                            r = Ah(e, o),
                            s = n => {
                                var r, s;
                                const a = null !== (r = e.getStyle(t, n)) && void 0 !== r ? r : "",
                                    i = null !== (s = e.getStyle(o, n)) && void 0 !== s ? s : "";
                                return qe(a) && qe(i) && a !== i
                            };
                        return U(n, (e => {
                            const t = t => U(t, (t => t === e));
                            if (!t(r) && t(Eh)) {
                                const e = G(r, (e => U(Eh, (t => Ve(e, t)))));
                                return U(e, s)
                            }
                            return s(e)
                        }))
                    },
                    Nh = (e, t, o) => I.from(o.container()).filter(Vn).exists((n => {
                        const r = e ? 0 : -1;
                        return t(n.data.charAt(o.offset() + r))
                    })),
                    Rh = N(Nh, !0, yu),
                    Dh = N(Nh, !1, yu),
                    Bh = e => {
                        const t = e.container();
                        return Vn(t) && (0 === t.data.length || _r(t.data) && Tm.isBookmarkNode(t.parentNode))
                    },
                    Lh = (e, t) => o => xd(e ? 0 : -1, o).filter(t).isSome(),
                    Hh = e => Gn(e) && "block" === qo(go(e), "display"),
                    Ih = e => Yn(e) && !(e => Rn(e) && "all" === e.getAttribute("data-mce-bogus"))(e),
                    Ph = Lh(!0, Hh),
                    zh = Lh(!1, Hh),
                    Fh = Lh(!0, Qn),
                    Vh = Lh(!1, Qn),
                    Zh = Lh(!0, Pn),
                    Uh = Lh(!1, Pn),
                    jh = Lh(!0, Ih),
                    Wh = Lh(!1, Ih),
                    $h = (e, t) => ((e, t, o) => yo(t, e) ? _o(e, (e => o(e) || bo(e, t))).slice(0, -1) : [])(e, t, L),
                    qh = (e, t) => [e].concat($h(e, t)),
                    Gh = (e, t, o) => Yd(e, t, o, Bh),
                    Kh = (e, t) => J(qh(go(t.container()), e), dr),
                    Yh = (e, t, o) => Gh(e, t.dom, o).forall((e => Kh(t, o).fold((() => !wd(e, o, t.dom)), (n => !wd(e, o, t.dom) && yo(n, go(e.container())))))),
                    Xh = (e, t, o) => Kh(t, o).fold((() => Gh(e, t.dom, o).forall((e => !wd(e, o, t.dom)))), (t => Gh(e, t.dom, o).isNone())),
                    Jh = N(Xh, !1),
                    Qh = N(Xh, !0),
                    ep = N(Yh, !1),
                    tp = N(Yh, !0),
                    op = e => Md(e).exists(mr),
                    np = (e, t, o) => {
                        const n = G(qh(go(o.container()), t), dr),
                            r = le(n).getOr(t);
                        return Gd(e, r.dom, o).filter(op)
                    },
                    rp = (e, t) => Md(t).exists(mr) || np(!0, e, t).isSome(),
                    sp = (e, t) => (e => I.from(e.getNode(!0)).map(go))(t).exists(mr) || np(!1, e, t).isSome(),
                    ap = N(np, !1),
                    ip = N(np, !0),
                    lp = e => Si.isTextPosition(e) && !e.isAtStart() && !e.isAtEnd(),
                    cp = (e, t) => {
                        const o = G(qh(go(t.container()), e), dr);
                        return le(o).getOr(e)
                    },
                    dp = (e, t) => lp(t) ? Dh(t) : Dh(t) || Qd(cp(e, t).dom, t).exists(Dh),
                    up = (e, t) => lp(t) ? Rh(t) : Rh(t) || Jd(cp(e, t).dom, t).exists(Rh),
                    mp = e => Md(e).bind((e => kn(e, zt))).exists((e => (e => Z(["pre", "pre-wrap"], e))(qo(e, "white-space")))),
                    gp = (e, t) => o => {
                        return n = new An(o, e)[t](), x(n) && Yn(n) && cd(n);
                        var n
                    },
                    hp = (e, t) => !mp(t) && (Jh(e, t) || ep(e, t) || sp(e, t) || dp(e, t) || ((e, t) => {
                        const o = Qd(e.dom, t).getOr(t),
                            n = gp(e.dom, "prev");
                        return t.isAtStart() && (n(t.container()) || n(o.container()))
                    })(e, t)),
                    pp = (e, t) => !mp(t) && (Qh(e, t) || tp(e, t) || rp(e, t) || up(e, t) || ((e, t) => {
                        const o = Jd(e.dom, t).getOr(t),
                            n = gp(e.dom, "next");
                        return t.isAtEnd() && (n(t.container()) || n(o.container()))
                    })(e, t)),
                    fp = (e, t) => hp(e, t) || pp(e, (e => {
                        const t = e.container(),
                            o = e.offset();
                        return Vn(t) && o < t.data.length ? Si(t, o + 1) : e
                    })(t)),
                    vp = (e, t) => vu(e.charAt(t)),
                    bp = (e, t) => yu(e.charAt(t)),
                    yp = (e, t, o) => {
                        const n = t.data,
                            r = Si(t, 0);
                        return o || !vp(n, 0) || fp(e, r) ? !!(o && bp(n, 0) && hp(e, r)) && (t.data = or + n.slice(1), !0) : (t.data = " " + n.slice(1), !0)
                    },
                    wp = (e, t, o) => {
                        const n = t.data,
                            r = Si(t, n.length - 1);
                        return o || !vp(n, n.length - 1) || fp(e, r) ? !!(o && bp(n, n.length - 1) && pp(e, r)) && (t.data = n.slice(0, -1) + or, !0) : (t.data = n.slice(0, -1) + " ", !0)
                    },
                    xp = (e, t) => {
                        const o = t.container();
                        if (!Vn(o)) return I.none();
                        if ((e => {
                                const t = e.container();
                                return Vn(t) && Fe(t.data, or)
                            })(t)) {
                            const n = yp(e, o, !1) || (e => {
                                const t = e.data,
                                    o = (e => {
                                        const t = e.split("");
                                        return j(t, ((e, o) => vu(e) && o > 0 && o < t.length - 1 && wu(t[o - 1]) && wu(t[o + 1]) ? " " : e)).join("")
                                    })(t);
                                return o !== t && (e.data = o, !0)
                            })(o) || wp(e, o, !1);
                            return Lt(n, t)
                        }
                        if (fp(e, t)) {
                            const n = yp(e, o, !0) || wp(e, o, !0);
                            return Lt(n, t)
                        }
                        return I.none()
                    },
                    Cp = (e, t, o) => {
                        if (0 === o) return;
                        const n = go(e),
                            r = Sn(n, dr).getOr(n),
                            s = e.data.slice(t, t + o),
                            a = t + o >= e.data.length && pp(r, Si(e, e.data.length)),
                            i = 0 === t && hp(r, Si(e, 0));
                        e.replaceData(t, o, Qr(s, 4, i, a))
                    },
                    Sp = (e, t) => {
                        const o = e.data.slice(t),
                            n = o.length - We(o).length;
                        Cp(e, t, n)
                    },
                    kp = (e, t) => {
                        const o = e.data.slice(0, t),
                            n = o.length - $e(o).length;
                        Cp(e, t - n, n)
                    },
                    _p = (e, t, o, n = !0) => {
                        const r = $e(e.data).length,
                            s = n ? e : t,
                            a = n ? t : e;
                        return n ? s.appendData(a.data) : s.insertData(0, a.data), rn(go(a)), o && Sp(s, r), s
                    },
                    Op = (e, t) => ((e, t) => {
                        const o = e.container(),
                            n = e.offset();
                        return !Si.isTextPosition(e) && o === t.parentNode && n > Si.before(t).offset()
                    })(t, e) ? Si(t.container(), t.offset() - 1) : t,
                    Tp = e => {
                        return qr(e.previousSibling) ? I.some((t = e.previousSibling, Vn(t) ? Si(t, t.data.length) : Si.after(t))) : e.previousSibling ? tu(e.previousSibling) : I.none();
                        var t
                    },
                    Ep = e => {
                        return qr(e.nextSibling) ? I.some((t = e.nextSibling, Vn(t) ? Si(t, 0) : Si.before(t))) : e.nextSibling ? eu(e.nextSibling) : I.none();
                        var t
                    },
                    Ap = (e, t, o) => ((e, t, o) => e ? ((e, t) => Ep(t).orThunk((() => Tp(t))).orThunk((() => ((e, t) => Jd(e, Si.after(t)).orThunk((() => Qd(e, Si.before(t)))))(e, t))))(t, o) : ((e, t) => Tp(t).orThunk((() => Ep(t))).orThunk((() => ((e, t) => I.from(t.previousSibling ? t.previousSibling : t.parentNode).bind((t => Qd(e, Si.before(t)))).orThunk((() => Jd(e, Si.after(t)))))(e, t))))(t, o))(e, t, o).map(N(Op, o)),
                    Mp = (e, t, o) => {
                        o.fold((() => {
                            e.focus()
                        }), (o => {
                            e.selection.setRng(o.toRange(), t)
                        }))
                    },
                    Np = (e, t) => t && Se(e.schema.getBlockElements(), Ht(t)),
                    Rp = e => {
                        if (rs(e)) {
                            const t = co('<br data-mce-bogus="1">');
                            return nn(e), tn(e, t), I.some(Si.before(t.dom))
                        }
                        return I.none()
                    },
                    Dp = (e, t, o, n = !0) => {
                        const r = Ap(t, e.getBody(), o.dom),
                            s = Sn(o, N(Np, e), (a = e.getBody(), e => e.dom === a));
                        var a;
                        const i = ((e, t, o) => {
                            const n = Oo(e).filter(Ft),
                                r = To(e).filter(Ft);
                            return rn(e), (s = n, a = r, i = t, l = (e, t, n) => {
                                const r = e.dom,
                                    s = t.dom,
                                    a = r.data.length;
                                return _p(r, s, o), n.container() === s ? Si(r, a) : n
                            }, s.isSome() && a.isSome() && i.isSome() ? I.some(l(s.getOrDie(), a.getOrDie(), i.getOrDie())) : I.none()).orThunk((() => (o && (n.each((e => kp(e.dom, e.dom.length))), r.each((e => Sp(e.dom, 0)))), t)));
                            var s, a, i, l
                        })(o, r, ((e, t) => Se(e.schema.getTextInlineElements(), Ht(t)))(e, o));
                        e.dom.isEmpty(e.getBody()) ? (e.setContent(""), e.selection.setCursorLocation()) : s.bind(Rp).fold((() => {
                            n && Mp(e, t, i)
                        }), (o => {
                            n && Mp(e, t, I.some(o))
                        }))
                    },
                    Bp = /[\u0591-\u07FF\uFB1D-\uFDFF\uFE70-\uFEFC]/,
                    Lp = (e, t) => fo(go(t), Vl(e)) && !fs(e.schema, t),
                    Hp = (e, t, o) => {
                        const n = ((e, t, o) => G(ba.DOM.getParents(o.container(), "*", t), e))(e, t, o);
                        return I.from(n[n.length - 1])
                    },
                    Ip = (e, t) => {
                        const o = t.container(),
                            n = t.offset();
                        return e ? Mr(o) ? Vn(o.nextSibling) ? Si(o.nextSibling, 0) : Si.after(o) : Dr(t) ? Si(o, n + 1) : t : Mr(o) ? Vn(o.previousSibling) ? Si(o.previousSibling, o.previousSibling.data.length) : Si.before(o) : Br(t) ? Si(o, n - 1) : t
                    },
                    Pp = N(Ip, !0),
                    zp = N(Ip, !1),
                    Fp = (e, t) => {
                        const o = e => e.stopImmediatePropagation();
                        e.on("beforeinput input", o, !0), e.getDoc().execCommand(t), e.off("beforeinput input", o)
                    },
                    Vp = e => Fp(e, "Delete"),
                    Zp = e => gr(e) || pr(e),
                    Up = (e, t) => yo(e, t) ? kn(t, Zp, (e => t => Dt(So(t), e, bo))(e)) : I.none(),
                    jp = (e, t = !0) => {
                        e.dom.isEmpty(e.getBody()) && e.setContent("", {
                            no_selection: !t
                        })
                    },
                    Wp = e => {
                        var t;
                        return (8 === It(t = e) || "#comment" === Ht(t) ? Oo(e) : Do(e)).bind(Wp).orThunk((() => I.some(e)))
                    },
                    $p = (e, t, o, n = !0) => {
                        var r;
                        t.deleteContents();
                        const s = Wp(o).getOr(o),
                            a = go(null !== (r = e.dom.getParent(s.dom, e.dom.isBlock)) && void 0 !== r ? r : o.dom);
                        if (a.dom === e.getBody() ? jp(e, n) : rs(a) && (Cr(a), n && e.selection.setCursorLocation(a.dom, 0)), !bo(o, a)) {
                            const e = Dt(So(a), o) ? [] : So(i = a).map(Mo).map((e => G(e, (e => !bo(i, e))))).getOr([]);
                            W(e.concat(Mo(o)), (e => {
                                bo(e, a) || yo(e, a) || !rs(e) || rn(e)
                            }))
                        }
                        var i
                    },
                    qp = e => rr(e, "td,th"),
                    Gp = (e, t) => ({
                        start: e,
                        end: t
                    }),
                    Kp = Gi([{
                        singleCellTable: ["rng", "cell"]
                    }, {
                        fullTable: ["table"]
                    }, {
                        partialTable: ["cells", "outsideDetails"]
                    }, {
                        multiTable: ["startTableCells", "endTableCells", "betweenRng"]
                    }]),
                    Yp = (e, t) => Tn(go(e), "td,th", t),
                    Xp = e => !bo(e.start, e.end),
                    Jp = (e, t) => Nu(e.start, t).bind((o => Nu(e.end, t).bind((e => Lt(bo(o, e), o))))),
                    Qp = e => t => Jp(t, e).map((e => ((e, t, o) => ({
                        rng: e,
                        table: t,
                        cells: o
                    }))(t, e, qp(e)))),
                    ef = (e, t, o, n) => {
                        if (o.collapsed || !e.forall(Xp)) return I.none();
                        if (t.isSameTable) {
                            const t = e.bind(Qp(n));
                            return I.some({
                                start: t,
                                end: t
                            })
                        } {
                            const e = Yp(o.startContainer, n),
                                t = Yp(o.endContainer, n),
                                r = e.bind((e => t => Nu(t, e).bind((e => ce(qp(e)).map((e => Gp(t, e))))))(n)).bind(Qp(n)),
                                s = t.bind((e => t => Nu(t, e).bind((e => le(qp(e)).map((e => Gp(e, t))))))(n)).bind(Qp(n));
                            return I.some({
                                start: r,
                                end: s
                            })
                        }
                    },
                    tf = (e, t) => Q(e, (e => bo(e, t))),
                    of = e => Bt(tf(e.cells, e.rng.start), tf(e.cells, e.rng.end), ((t, o) => e.cells.slice(t, o + 1))),
                    nf = (e, t) => {
                        const {
                            startTable: o,
                            endTable: n
                        } = t, r = e.cloneRange();
                        return o.each((e => r.setStartAfter(e.dom))), n.each((e => r.setEndBefore(e.dom))), r
                    },
                    rf = (e, t) => {
                        const o = (e => t => bo(e, t))(e),
                            n = ((e, t) => {
                                const o = Yp(e.startContainer, t),
                                    n = Yp(e.endContainer, t);
                                return Bt(o, n, Gp)
                            })(t, o),
                            r = ((e, t) => {
                                const o = e => Nu(go(e), t),
                                    n = o(e.startContainer),
                                    r = o(e.endContainer),
                                    s = n.isSome(),
                                    a = r.isSome(),
                                    i = Bt(n, r, bo).getOr(!1);
                                return {
                                    startTable: n,
                                    endTable: r,
                                    isStartInTable: s,
                                    isEndInTable: a,
                                    isSameTable: i,
                                    isMultiTable: !i && s && a
                                }
                            })(t, o);
                        return ((e, t, o) => e.exists((e => ((e, t) => !Xp(e) && Jp(e, t).exists((e => {
                            const t = e.dom.rows;
                            return 1 === t.length && 1 === t[0].cells.length
                        })))(e, o) && Bu(e.start, t))))(n, t, o) ? n.map((e => Kp.singleCellTable(t, e.start))) : r.isMultiTable ? ((e, t, o, n) => ef(e, t, o, n).bind((({
                            start: e,
                            end: n
                        }) => {
                            const r = e.bind( of ).getOr([]),
                                s = n.bind( of ).getOr([]);
                            if (r.length > 0 && s.length > 0) {
                                const e = nf(o, t);
                                return I.some(Kp.multiTable(r, s, e))
                            }
                            return I.none()
                        })))(n, r, t, o) : ((e, t, o, n) => ef(e, t, o, n).bind((({
                            start: e,
                            end: t
                        }) => e.or(t))).bind((e => {
                            const {
                                isSameTable: n
                            } = t, r = of (e).getOr([]);
                            if (n && e.cells.length === r.length) return I.some(Kp.fullTable(e.table));
                            if (r.length > 0) {
                                if (n) return I.some(Kp.partialTable(r, I.none())); {
                                    const e = nf(o, t);
                                    return I.some(Kp.partialTable(r, I.some({ ...t,
                                        rng: e
                                    })))
                                }
                            }
                            return I.none()
                        })))(n, r, t, o)
                    },
                    sf = e => W(e, (e => {
                        Yt(e, "contenteditable"), Cr(e)
                    })),
                    af = (e, t, o, n) => {
                        const r = o.cloneRange();
                        n ? (r.setStart(o.startContainer, o.startOffset), r.setEndAfter(t.dom.lastChild)) : (r.setStartBefore(t.dom.firstChild), r.setEnd(o.endContainer, o.endOffset)), uf(e, r, t, !1).each((e => e()))
                    },
                    lf = e => {
                        const t = Mu(e),
                            o = go(e.selection.getNode());
                        Xn(o.dom) && rs(o) ? e.selection.setCursorLocation(o.dom, 0) : e.selection.collapse(!0), t.length > 1 && U(t, (e => bo(e, o))) && Wt(o, "data-mce-selected", "1")
                    },
                    cf = (e, t, o) => I.some((() => {
                        const n = e.selection.getRng(),
                            r = o.bind((({
                                rng: o,
                                isStartInTable: r
                            }) => {
                                const s = ((e, t) => I.from(e.dom.getParent(t, e.dom.isBlock)).map(go))(e, r ? o.endContainer : o.startContainer);
                                o.deleteContents(), ((e, t, o) => {
                                    o.each((o => {
                                        t ? rn(o) : (Cr(o), e.selection.setCursorLocation(o.dom, 0))
                                    }))
                                })(e, r, s.filter(rs));
                                const a = r ? t[0] : t[t.length - 1];
                                return af(e, a, n, r), rs(a) ? I.none() : I.some(r ? t.slice(1) : t.slice(0, -1))
                            })).getOr(t);
                        sf(r), lf(e)
                    })),
                    df = (e, t, o, n) => I.some((() => {
                        const r = e.selection.getRng(),
                            s = t[0],
                            a = o[o.length - 1];
                        af(e, s, r, !0), af(e, a, r, !1);
                        const i = rs(s) ? t : t.slice(1),
                            l = rs(a) ? o : o.slice(0, -1);
                        sf(i.concat(l)), n.deleteContents(), lf(e)
                    })),
                    uf = (e, t, o, n = !0) => I.some((() => {
                        $p(e, t, o, n)
                    })),
                    mf = (e, t) => I.some((() => Dp(e, !1, t))),
                    gf = (e, t) => J(qh(t, e), vr),
                    hf = (e, t) => J(qh(t, e), Ut("caption")),
                    pf = (e, t) => I.some((() => {
                        Cr(t), e.selection.setCursorLocation(t.dom, 0)
                    })),
                    ff = (e, t) => e ? Zh(t) : Uh(t),
                    vf = (e, t, o) => {
                        const n = go(e.getBody());
                        return hf(n, o).fold((() => ((e, t, o, n) => {
                            const r = Si.fromRangeStart(e.selection.getRng());
                            return gf(o, n).bind((n => rs(n) ? pf(e, n) : ((e, t, o, n, r) => Kd(o, e.getBody(), r).bind((e => gf(t, go(e.getNode())).bind((e => bo(e, n) ? I.none() : I.some(_))))))(e, o, t, n, r)))
                        })(e, t, n, o).orThunk((() => Lt(((e, t) => {
                            const o = Si.fromRangeStart(e.selection.getRng());
                            return ff(t, o) || Gd(t, e.getBody(), o).exists((e => ff(t, e)))
                        })(e, t), _)))), (o => ((e, t, o, n) => {
                            const r = Si.fromRangeStart(e.selection.getRng());
                            return rs(n) ? pf(e, n) : ((e, t, o, n, r) => Kd(o, e.getBody(), r).fold((() => I.some(_)), (s => ((e, t, o, n) => eu(e.dom).bind((r => tu(e.dom).map((e => t ? o.isEqual(r) && n.isEqual(e) : o.isEqual(e) && n.isEqual(r))))).getOr(!0))(n, o, r, s) ? ((e, t) => pf(e, t))(e, n) : ((e, t, o) => hf(e, go(o.getNode())).fold((() => I.some(_)), (e => Lt(!bo(e, t), _))))(t, n, s))))(e, o, t, n, r)
                        })(e, t, n, o)))
                    },
                    bf = (e, t) => {
                        const o = go(e.selection.getStart(!0)),
                            n = Mu(e);
                        return e.selection.isCollapsed() && 0 === n.length ? vf(e, t, o) : ((e, t, o) => {
                            const n = go(e.getBody()),
                                r = e.selection.getRng();
                            return 0 !== o.length ? cf(e, o, I.none()) : ((e, t, o, n) => hf(t, n).fold((() => ((e, t, o) => rf(t, o).bind((t => t.fold(N(uf, e), N(mf, e), N(cf, e), N(df, e)))))(e, t, o)), (t => ((e, t) => pf(e, t))(e, t))))(e, n, r, t)
                        })(e, o, n)
                    },
                    yf = (e, t) => {
                        let o = t;
                        for (; o && o !== e;) {
                            if (Kn(o) || Yn(o)) return o;
                            o = o.parentNode
                        }
                        return null
                    },
                    wf = ["data-ephox-", "data-mce-", "data-alloy-", "data-snooker-", "_"],
                    xf = Rt.each,
                    Cf = e => {
                        const t = e.dom,
                            o = new Set(e.serializer.getTempAttrs()),
                            n = e => U(wf, (t => Ve(e, t))) || o.has(e);
                        return {
                            compare: (e, o) => {
                                if (e.nodeName !== o.nodeName || e.nodeType !== o.nodeType) return !1;
                                const r = e => {
                                        const o = {};
                                        return xf(t.getAttribs(e), (r => {
                                            const s = r.nodeName.toLowerCase();
                                            "style" === s || n(s) || (o[s] = t.getAttrib(e, s))
                                        })), o
                                    },
                                    s = (e, t) => {
                                        for (const o in e)
                                            if (Se(e, o)) {
                                                const n = t[o];
                                                if (y(n)) return !1;
                                                if (e[o] !== n) return !1;
                                                delete t[o]
                                            }
                                        for (const e in t)
                                            if (Se(t, e)) return !1;
                                        return !0
                                    };
                                if (Rn(e) && Rn(o)) {
                                    if (!s(r(e), r(o))) return !1;
                                    if (!s(t.parseStyle(t.getAttrib(e, "style")), t.parseStyle(t.getAttrib(o, "style")))) return !1
                                }
                                return !fu(e) && !fu(o)
                            },
                            isAttributeInternal: n
                        }
                    },
                    Sf = (e, t, o, n) => {
                        const r = o.name;
                        for (let t = 0, s = e.length; t < s; t++) {
                            const s = e[t];
                            if (s.name === r) {
                                const e = n.nodes[r];
                                e ? e.nodes.push(o) : n.nodes[r] = {
                                    filter: s,
                                    nodes: [o]
                                }
                            }
                        }
                        if (o.attributes)
                            for (let e = 0, r = t.length; e < r; e++) {
                                const r = t[e],
                                    s = r.name;
                                if (s in o.attributes.map) {
                                    const e = n.attributes[s];
                                    e ? e.nodes.push(o) : n.attributes[s] = {
                                        filter: r,
                                        nodes: [o]
                                    }
                                }
                            }
                    },
                    kf = (e, t) => {
                        const o = (e, o) => {
                            he(e, (e => {
                                const n = de(e.nodes);
                                W(e.filter.callbacks, (r => {
                                    for (let t = n.length - 1; t >= 0; t--) {
                                        const r = n[t];
                                        (o ? void 0 !== r.attr(e.filter.name) : r.name === e.filter.name) && !w(r.parent) || n.splice(t, 1)
                                    }
                                    n.length > 0 && r(n, e.filter.name, t)
                                }))
                            }))
                        };
                        o(e.nodes, !1), o(e.attributes, !0)
                    },
                    _f = (e, t, o, n = {}) => {
                        const r = ((e, t, o) => {
                            const n = {
                                nodes: {},
                                attributes: {}
                            };
                            return o.firstChild && ((o, r) => {
                                let s = o;
                                for (; s = s.walk();) Sf(e, t, s, n)
                            })(o), n
                        })(e, t, o);
                        kf(r, n)
                    },
                    Of = (e, t, o) => {
                        if (e.insert && t(o)) {
                            const e = new fh("br", 1);
                            e.attr("data-mce-bogus", "1"), o.empty().append(e)
                        } else o.empty().append(new fh("#text", 3)).value = or
                    },
                    Tf = (e, t) => {
                        const o = null == e ? void 0 : e.firstChild;
                        return x(o) && o === e.lastChild && o.name === t
                    },
                    Ef = (e, t, o, n) => n.isEmpty(t, o, (t => ((e, t) => {
                        const o = e.getElementRule(t.name);
                        return !0 === (null == o ? void 0 : o.paddEmpty)
                    })(e, t))),
                    Af = (e, t, o = e.parent) => {
                        if (t.getSpecialElements()[e.name]) e.empty().remove();
                        else {
                            const n = e.children();
                            for (const e of n) o && !t.isValidChild(o.name, e.name) && Af(e, t, o);
                            e.unwrap()
                        }
                    },
                    Mf = (e, t, o = _) => {
                        const n = t.getTextBlockElements(),
                            r = t.getNonEmptyElements(),
                            s = t.getWhitespaceElements(),
                            a = Rt.makeMap("tr,td,th,tbody,thead,tfoot,table"),
                            i = new Set;
                        for (let l = 0; l < e.length; l++) {
                            const c = e[l];
                            let d, u, m;
                            if (!c.parent || i.has(c)) continue;
                            if (n[c.name] && "li" === c.parent.name) {
                                let e = c.next;
                                for (; e && n[e.name];) e.name = "li", i.add(e), c.parent.insert(e, c.parent), e = e.next;
                                c.unwrap();
                                continue
                            }
                            const g = [c];
                            for (d = c.parent; d && !t.isValidChild(d.name, c.name) && !a[d.name]; d = d.parent) g.push(d);
                            if (d && g.length > 1)
                                if (t.isValidChild(d.name, c.name)) {
                                    g.reverse(), u = g[0].clone(), o(u);
                                    let e = u;
                                    for (let n = 0; n < g.length - 1; n++) {
                                        t.isValidChild(e.name, g[n].name) ? (m = g[n].clone(), o(m), e.append(m)) : m = e;
                                        for (let e = g[n].firstChild; e && e !== g[n + 1];) {
                                            const t = e.next;
                                            m.append(e), e = t
                                        }
                                        e = m
                                    }
                                    Ef(t, r, s, u) ? d.insert(c, g[0], !0) : (d.insert(u, g[0], !0), d.insert(c, u)), d = g[0], (Ef(t, r, s, d) || Tf(d, "br")) && d.empty().remove()
                                } else Af(c, t);
                            else if (c.parent) {
                                if ("li" === c.name) {
                                    let e = c.prev;
                                    if (e && ("ul" === e.name || "ol" === e.name)) {
                                        e.append(c);
                                        continue
                                    }
                                    if (e = c.next, e && ("ul" === e.name || "ol" === e.name) && e.firstChild) {
                                        e.insert(c, e.firstChild, !0);
                                        continue
                                    }
                                    const t = new fh("ul", 1);
                                    o(t), c.wrap(t);
                                    continue
                                }
                                if (t.isValidChild(c.parent.name, "div") && t.isValidChild("div", c.name)) {
                                    const e = new fh("div", 1);
                                    o(e), c.wrap(e)
                                } else Af(c, t)
                            }
                        }
                    },
                    Nf = (e, t, o = t.parent) => !(!o || !e.children[t.name] || e.isValidChild(o.name, t.name)) || !(!o || "a" !== t.name || !((e, t) => {
                        let o = e;
                        for (; o;) {
                            if ("a" === o.name) return !0;
                            o = o.parent
                        }
                        return !1
                    })(o)),
                    Rf = e => e.collapsed ? e : (e => {
                        const t = Si.fromRangeStart(e),
                            o = Si.fromRangeEnd(e),
                            n = e.commonAncestorContainer;
                        return Gd(!1, n, o).map((r => !wd(t, o, n) && wd(t, r, n) ? ((e, t, o, n) => {
                            const r = document.createRange();
                            return r.setStart(e, t), r.setEnd(o, n), r
                        })(t.container(), t.offset(), r.container(), r.offset()) : e)).getOr(e)
                    })(e),
                    Df = (e, t) => {
                        let o = t.firstChild,
                            n = t.lastChild;
                        return o && "meta" === o.name && (o = o.next), n && "mce_marker" === n.attr("id") && (n = n.prev), ((e, t) => {
                            const o = e.getNonEmptyElements();
                            return x(t) && (t.isEmpty(o) || ((e, t) => e.getBlockElements()[t.name] && (e => x(e.firstChild) && e.firstChild === e.lastChild)(t) && (e => "br" === e.name || e.value === or)(t.firstChild))(e, t))
                        })(e, n) && (n = null == n ? void 0 : n.prev), !(!o || o !== n || "ul" !== o.name && "ol" !== o.name)
                    },
                    Bf = e => {
                        return e.length > 0 && (!(o = e[e.length - 1]).firstChild || x(null == (t = o) ? void 0 : t.firstChild) && t.firstChild === t.lastChild && (e => e.data === or || qn(e))(t.firstChild)) ? e.slice(0, -1) : e;
                        var t, o
                    },
                    Lf = (e, t) => {
                        const o = e.getParent(t, e.isBlock);
                        return o && "LI" === o.nodeName ? o : null
                    },
                    Hf = (e, t) => {
                        const o = Si.after(e),
                            n = jd(t).prev(o);
                        return n ? n.toRange() : null
                    },
                    If = (e, t, o, n) => {
                        const r = ((e, t, o) => {
                                const n = t.serialize(o);
                                return (e => {
                                    var t, o;
                                    const n = e.firstChild,
                                        r = e.lastChild;
                                    return n && "META" === n.nodeName && (null === (t = n.parentNode) || void 0 === t || t.removeChild(n)), r && "mce_marker" === r.id && (null === (o = r.parentNode) || void 0 === o || o.removeChild(r)), e
                                })(e.createFragment(n))
                            })(t, e, n),
                            s = Lf(t, o.startContainer),
                            a = Bf((i = r.firstChild, G(null !== (l = null == i ? void 0 : i.childNodes) && void 0 !== l ? l : [], (e => "LI" === e.nodeName))));
                        var i, l;
                        const c = t.getRoot(),
                            d = e => {
                                const n = Si.fromRangeStart(o),
                                    r = jd(t.getRoot()),
                                    a = 1 === e ? r.prev(n) : r.next(n),
                                    i = null == a ? void 0 : a.getNode();
                                return !i || Lf(t, i) !== s
                            };
                        return s ? d(1) ? ((e, t, o) => {
                            const n = e.parentNode;
                            return n && Rt.each(t, (t => {
                                n.insertBefore(t, e)
                            })), ((e, t) => {
                                const o = Si.before(e),
                                    n = jd(t).next(o);
                                return n ? n.toRange() : null
                            })(e, o)
                        })(s, a, c) : d(2) ? ((e, t, o, n) => (n.insertAfter(t.reverse(), e), Hf(t[0], o)))(s, a, c, t) : ((e, t, o, n) => {
                            const r = ((e, t) => {
                                    const o = t.cloneRange(),
                                        n = t.cloneRange();
                                    return o.setStartBefore(e), n.setEndAfter(e), [o.cloneContents(), n.cloneContents()]
                                })(e, n),
                                s = e.parentNode;
                            return s && (s.insertBefore(r[0], e), Rt.each(t, (t => {
                                s.insertBefore(t, e)
                            })), s.insertBefore(r[1], e), s.removeChild(e)), Hf(t[t.length - 1], o)
                        })(s, a, c, o) : null
                    },
                    Pf = ["pre"],
                    zf = Xn,
                    Ff = (e, t, o) => {
                        var n, r;
                        const s = e.selection,
                            a = e.dom,
                            i = e.parser,
                            l = o.merge,
                            c = Oh({
                                validate: !0
                            }, e.schema),
                            d = '<span id="mce_marker" data-mce-type="bookmark">&#xFEFF;</span>'; - 1 === t.indexOf("{$caret}") && (t += "{$caret}"), t = t.replace(/\{\$caret\}/, d);
                        let u = s.getRng();
                        const m = u.startContainer,
                            g = e.getBody();
                        m === g && s.isCollapsed() && a.isBlock(g.firstChild) && ((e, t) => x(t) && !e.schema.getVoidElements()[t.nodeName])(e, g.firstChild) && a.isEmpty(g.firstChild) && (u = a.createRng(), u.setStart(g.firstChild, 0), u.setEnd(g.firstChild, 0), s.setRng(u)), s.isCollapsed() || (e => {
                            const t = e.dom,
                                o = Rf(e.selection.getRng());
                            e.selection.setRng(o);
                            const n = t.getParent(o.startContainer, zf);
                            ((e, t, o) => !!x(o) && o === e.getParent(t.endContainer, zf) && Bu(go(o), t))(t, o, n) ? uf(e, o, go(n)): o.startContainer === o.endContainer && o.endOffset - o.startOffset == 1 && Vn(o.startContainer.childNodes[o.startOffset]) ? o.deleteContents() : e.getDoc().execCommand("Delete", !1)
                        })(e);
                        const h = s.getNode(),
                            p = {
                                context: h.nodeName.toLowerCase(),
                                data: o.data,
                                insert: !0
                            },
                            f = i.parse(t, p);
                        if (!0 === o.paste && Df(e.schema, f) && ((e, t) => !!Lf(e, t))(a, h)) return u = If(c, a, s.getRng(), f), u && s.setRng(u), t;
                        !0 === o.paste && ((e, t, o, n) => {
                            var r;
                            const s = t.firstChild,
                                a = t.lastChild,
                                i = s === ("bookmark" === a.attr("data-mce-type") ? a.prev : a),
                                l = Z(Pf, s.name);
                            if (i && l) {
                                const t = "false" !== s.attr("contenteditable"),
                                    a = (null === (r = e.getParent(o, e.isBlock)) || void 0 === r ? void 0 : r.nodeName.toLowerCase()) === s.name,
                                    i = I.from(yf(n, o)).forall(Kn);
                                return t && a && i
                            }
                            return !1
                        })(a, f, h, e.getBody()) && (null === (n = f.firstChild) || void 0 === n || n.unwrap()), (e => {
                            let t = e;
                            for (; t = t.walk();) 1 === t.type && t.attr("data-mce-fragment", "1")
                        })(f);
                        let v = f.lastChild;
                        if (v && "mce_marker" === v.attr("id")) {
                            const t = v;
                            for (v = v.prev; v; v = v.walk(!0))
                                if (3 === v.type || !a.isBlock(v.name)) {
                                    v.parent && e.schema.isValidChild(v.parent.name, "span") && v.parent.insert(t, v, "br" === v.name);
                                    break
                                }
                        }
                        if (e._selectionOverrides.showBlockCaretContainer(h), p.invalid) {
                            e.selection.setContent(d);
                            let o, n = s.getNode();
                            const l = e.getBody();
                            for (Wn(n) ? n = o = l : o = n; o && o !== l;) n = o, o = o.parentNode;
                            t = n === l ? l.innerHTML : a.getOuterHTML(n);
                            const u = i.parse(t);
                            for (let e = u; e; e = e.walk())
                                if ("mce_marker" === e.attr("id")) {
                                    e.replace(f);
                                    break
                                }
                            const m = f.children(),
                                g = null !== (r = f.parent) && void 0 !== r ? r : u;
                            f.unwrap();
                            const h = G(m, (t => Nf(e.schema, t, g)));
                            Mf(h, e.schema), _f(i.getNodeFilters(), i.getAttributeFilters(), u), t = c.serialize(u), n === l ? a.setHTML(l, t) : a.setOuterHTML(n, t)
                        } else t = c.serialize(f), ((e, t, o) => {
                            var n;
                            if ("all" === o.getAttribute("data-mce-bogus")) null === (n = o.parentNode) || void 0 === n || n.insertBefore(e.dom.createFragment(t), o);
                            else {
                                const n = o.firstChild,
                                    r = o.lastChild;
                                !n || n === r && "BR" === n.nodeName ? e.dom.setHTML(o, t) : e.selection.setContent(t, {
                                    no_events: !0
                                })
                            }
                        })(e, t, h);
                        var b;
                        return ((e, t) => {
                            const o = e.schema.getTextInlineElements(),
                                n = e.dom;
                            if (t) {
                                const t = e.getBody(),
                                    r = Cf(e);
                                Rt.each(n.select("*[data-mce-fragment]"), (e => {
                                    if (x(o[e.nodeName.toLowerCase()]) && ((e, t) => oe(Ah(e, t), (e => !(e => Th.has(e))(e))))(n, e))
                                        for (let o = e.parentElement; x(o) && o !== t && !Mh(n, e, o); o = o.parentElement)
                                            if (r.compare(o, e)) {
                                                n.remove(e, !0);
                                                break
                                            }
                                }))
                            }
                        })(e, l), ((e, t) => {
                            var o, n, r;
                            let s;
                            const a = e.dom,
                                i = e.selection;
                            if (!t) return;
                            i.scrollIntoView(t);
                            const l = yf(e.getBody(), t);
                            if (l && "false" === a.getContentEditable(l)) return a.remove(t), void i.select(l);
                            let c = a.createRng();
                            const d = t.previousSibling;
                            if (Vn(d)) {
                                c.setStart(d, null !== (n = null === (o = d.nodeValue) || void 0 === o ? void 0 : o.length) && void 0 !== n ? n : 0);
                                const e = t.nextSibling;
                                Vn(e) && (d.appendData(e.data), null === (r = e.parentNode) || void 0 === r || r.removeChild(e))
                            } else c.setStartBefore(t), c.setEndBefore(t);
                            const u = a.getParent(t, a.isBlock);
                            a.remove(t), u && a.isEmpty(u) && (nn(go(u)), c.setStart(u, 0), c.setEnd(u, 0), zf(u) || (e => !!e.getAttribute("data-mce-fragment"))(u) || !(s = (t => {
                                let o = Si.fromRangeStart(t);
                                return o = jd(e.getBody()).next(o), null == o ? void 0 : o.toRange()
                            })(c)) ? a.add(u, a.create("br", {
                                "data-mce-bogus": "1"
                            })) : (c = s, a.remove(u))), i.setRng(c)
                        })(e, a.get("mce_marker")), b = e.getBody(), Rt.each(b.getElementsByTagName("*"), (e => {
                            e.removeAttribute("data-mce-fragment")
                        })), ((e, t) => {
                            I.from(e.getParent(t, "td,th")).map(go).each(Sr)
                        })(a, s.getStart()), ((e, t, o) => {
                            const n = _o(go(o), (e => bo(e, go(t))));
                            ie(n, n.length - 2).filter(zt).fold((() => us(e, t)), (t => us(e, t.dom)))
                        })(e.schema, e.getBody(), s.getStart()), t
                    },
                    Vf = e => e instanceof fh,
                    Zf = (e, t, o) => {
                        e.dom.setHTML(e.getBody(), t), !0 !== o && (e => {
                            eh(e) && eu(e.getBody()).each((t => {
                                const o = t.getNode(),
                                    n = Pn(o) ? eu(o).getOr(t) : t;
                                e.selection.setRng(n.toRange())
                            }))
                        })(e)
                    },
                    Uf = (e, t) => ((e, t) => {
                        const o = e.dom;
                        return o.parentNode ? ((e, t) => J(e.dom.childNodes, (e => t(go(e)))).map(go))(go(o.parentNode), (o => !bo(e, o) && t(o))) : I.none()
                    })(e, t).isSome(),
                    jf = e => C(e) ? e : L,
                    Wf = (e, t, o) => {
                        const n = t(e),
                            r = jf(o);
                        return n.orThunk((() => r(e) ? I.none() : ((e, t, o) => {
                            let n = e.dom;
                            const r = jf(o);
                            for (; n.parentNode;) {
                                n = n.parentNode;
                                const e = go(n),
                                    o = t(e);
                                if (o.isSome()) return o;
                                if (r(e)) break
                            }
                            return I.none()
                        })(e, t, r)))
                    },
                    $f = Yu,
                    qf = (e, t, o) => {
                        const n = e.formatter.get(o);
                        if (n)
                            for (let o = 0; o < n.length; o++) {
                                const r = n[o];
                                if (nm(r) && !1 === r.inherit && e.dom.is(t, r.selector)) return !0
                            }
                        return !1
                    },
                    Gf = (e, t, o, n, r) => {
                        const s = e.dom.getRoot();
                        if (t === s) return !1;
                        const a = e.dom.getParent(t, (t => !!qf(e, t, o) || t.parentNode === s || !!Xf(e, t, o, n, !0)));
                        return !!Xf(e, a, o, n, r)
                    },
                    Kf = (e, t, o) => !(!rm(o) || !$f(t, o.inline)) || !(!om(o) || !$f(t, o.block)) || !!nm(o) && Rn(t) && e.is(t, o.selector),
                    Yf = (e, t, o, n, r, s) => {
                        const a = o[n],
                            i = "attributes" === n;
                        if (C(o.onmatch)) return o.onmatch(t, o, n);
                        if (a)
                            if (Oe(a)) {
                                for (let o = 0; o < a.length; o++)
                                    if (i ? e.getAttrib(t, a[o]) : Ju(e, t, a[o])) return !0
                            } else
                                for (const n in a)
                                    if (Se(a, n)) {
                                        const l = i ? e.getAttrib(t, n) : Ju(e, t, n),
                                            c = Ku(a[n], s),
                                            d = w(l) || Ge(l);
                                        if (d && w(c)) continue;
                                        if (r && d && !o.exact) return !1;
                                        if ((!r || o.exact) && !$f(l, Xu(c, n))) return !1
                                    }
                        return !0
                    },
                    Xf = (e, t, o, n, r) => {
                        const s = e.formatter.get(o),
                            a = e.dom;
                        if (s && Rn(t))
                            for (let o = 0; o < s.length; o++) {
                                const i = s[o];
                                if (Kf(e.dom, t, i) && Yf(a, t, i, "attributes", r, n) && Yf(a, t, i, "styles", r, n)) {
                                    const o = i.classes;
                                    if (o)
                                        for (let r = 0; r < o.length; r++)
                                            if (!e.dom.hasClass(t, Ku(o[r], n))) return;
                                    return i
                                }
                            }
                    },
                    Jf = (e, t, o, n, r) => {
                        if (n) return Gf(e, n, t, o, r);
                        if (n = e.selection.getNode(), Gf(e, n, t, o, r)) return !0;
                        const s = e.selection.getStart();
                        return !(s === n || !Gf(e, s, t, o, r))
                    },
                    Qf = kr,
                    ev = e => (e => {
                        const t = [];
                        let o = e;
                        for (; o;) {
                            if (Vn(o) && o.data !== Qf || o.childNodes.length > 1) return [];
                            Rn(o) && t.push(o), o = o.firstChild
                        }
                        return t
                    })(e).length > 0,
                    tv = e => {
                        if (e) {
                            const t = new An(e, e);
                            for (let e = t.current(); e; e = t.next())
                                if (Vn(e)) return e
                        }
                        return null
                    },
                    ov = e => {
                        const t = uo("span");
                        return $t(t, {
                            id: ou,
                            "data-mce-bogus": "1",
                            "data-mce-type": "format-caret"
                        }), e && tn(t, mo(Qf)), t
                    },
                    nv = (e, t, o = !0) => {
                        const n = e.dom,
                            r = e.selection;
                        if (ev(t)) Dp(e, !1, go(t), o);
                        else {
                            const e = r.getRng(),
                                o = n.getParent(t, n.isBlock),
                                s = e.startContainer,
                                a = e.startOffset,
                                i = e.endContainer,
                                l = e.endOffset,
                                c = (e => {
                                    const t = tv(e);
                                    return t && t.data.charAt(0) === Qf && t.deleteData(0, 1), t
                                })(t);
                            n.remove(t, !0), s === c && a > 0 && e.setStart(c, a - 1), i === c && l > 0 && e.setEnd(c, l - 1), o && n.isEmpty(o) && Cr(go(o)), r.setRng(e)
                        }
                    },
                    rv = (e, t, o = !0) => {
                        const n = e.dom,
                            r = e.selection;
                        if (t) nv(e, t, o);
                        else if (!(t = ru(e.getBody(), r.getStart())))
                            for (; t = n.get(ou);) nv(e, t, !1)
                    },
                    sv = (e, t) => (e.appendChild(t), t),
                    av = (e, t) => {
                        var o;
                        const n = K(e, ((e, t) => sv(e, t.cloneNode(!1))), t),
                            r = null !== (o = n.ownerDocument) && void 0 !== o ? o : document;
                        return sv(n, r.createTextNode(Qf))
                    },
                    iv = (e, t, o, n) => {
                        const r = e.dom,
                            i = e.selection;
                        let l = !1;
                        const c = e.formatter.get(t);
                        if (!c) return;
                        const d = i.getRng(),
                            u = d.startContainer,
                            m = d.startOffset;
                        let g = u;
                        Vn(u) && (m !== u.data.length && (l = !0), g = g.parentNode);
                        const h = [];
                        let p;
                        for (; g;) {
                            if (Xf(e, g, t, o, n)) {
                                p = g;
                                break
                            }
                            g.nextSibling && (l = !0), h.push(g), g = g.parentNode
                        }
                        if (p)
                            if (l) {
                                const s = i.getBookmark();
                                d.collapse(!0);
                                let a = wm(r, d, c, !0);
                                a = mg(a), e.formatter.remove(t, o, a, n), i.moveToBookmark(s)
                            } else {
                                const l = ru(e.getBody(), p),
                                    c = ov(!1).dom;
                                ((e, t, o) => {
                                    var n, r;
                                    const s = e.dom,
                                        a = s.getParent(o, N(Wu, e.schema));
                                    a && s.isEmpty(a) ? null === (n = o.parentNode) || void 0 === n || n.replaceChild(t, o) : ((e => {
                                        const t = rr(e, "br"),
                                            o = G((e => {
                                                const t = [];
                                                let o = e.dom;
                                                for (; o;) t.push(go(o)), o = o.lastChild;
                                                return t
                                            })(e).slice(-1), mr);
                                        t.length === o.length && W(o, rn)
                                    })(go(o)), s.isEmpty(o) ? null === (r = o.parentNode) || void 0 === r || r.replaceChild(t, o) : s.insertAfter(t, o))
                                })(e, c, null != l ? l : p);
                                const d = ((e, t, o, n, r, i) => {
                                        const l = e.formatter,
                                            c = e.dom,
                                            d = G(me(l.get()), (e => e !== n && !Fe(e, "removeformat"))),
                                            u = ((e, t, o) => Y(o, ((o, n) => {
                                                const r = ((e, t) => tm(e, t, (e => {
                                                    const t = e => C(e) || e.length > 1 && "%" === e.charAt(0);
                                                    return U(["styles", "attributes"], (o => Ce(e, o).exists((e => {
                                                        const o = f(e) ? e : xe(e);
                                                        return U(o, t)
                                                    }))))
                                                })))(e, n);
                                                return e.formatter.matchNode(t, n, {}, r) ? o.concat([n]) : o
                                            }), []))(e, o, d);
                                        if (G(u, (t => !((e, t, o) => {
                                                const n = ["inline", "block", "selector", "attributes", "styles", "classes"],
                                                    r = e => ye(e, ((e, t) => U(n, (e => e === t))));
                                                return tm(e, t, (t => {
                                                    const n = r(t);
                                                    return tm(e, o, (e => {
                                                        const t = r(e);
                                                        return ((e, t, o = a) => s(o).eq(e, t))(n, t)
                                                    }))
                                                }))
                                            })(e, t, n))).length > 0) {
                                            const e = o.cloneNode(!1);
                                            return c.add(t, e), l.remove(n, r, e, i), c.remove(e), I.some(e)
                                        }
                                        return I.none()
                                    })(e, c, p, t, o, n),
                                    u = av(h.concat(d.toArray()), c);
                                l && nv(e, l, !1), i.setCursorLocation(u, 1), r.isEmpty(p) && r.remove(p)
                            }
                    },
                    lv = (e, t) => {
                        const o = e.schema.getTextInlineElements();
                        return Se(o, Ht(t)) && !nu(t.dom) && !In(t.dom)
                    },
                    cv = {},
                    dv = Bn(["pre"]);
                ((e, t) => {
                    cv[e] || (cv[e] = []), cv[e].push((e => {
                        if (!e.selection.getRng().collapsed) {
                            const t = e.selection.getSelectedBlocks(),
                                o = G(G(t, dv), (e => t => {
                                    const o = t.previousSibling;
                                    return dv(o) && Z(e, o)
                                })(t));
                            W(o, (e => {
                                ((e, t) => {
                                    const o = go(t),
                                        n = xo(o).dom;
                                    rn(o), on(go(e), [uo("br", n), uo("br", n), ...Mo(o)])
                                })(e.previousSibling, e)
                            }))
                        }
                    }))
                })("pre");
                const uv = ["fontWeight", "fontStyle", "color", "fontSize", "fontFamily"],
                    mv = (e, t) => {
                        const o = e.get(t);
                        return f(o) ? J(o, (e => rm(e) && "span" === e.inline && (e => h(e.styles) && U(me(e.styles), (e => Z(uv, e))))(e))) : I.none()
                    },
                    gv = (e, t) => Qd(t, Si.fromRangeStart(e)).isNone(),
                    hv = (e, t) => !1 === Jd(t, Si.fromRangeEnd(e)).exists((e => !qn(e.getNode()) || Jd(t, e).isSome())),
                    pv = e => t => er(t) && "false" !== e.getContentEditableParent(t),
                    fv = e => G(e.getSelectedBlocks(), pv(e.dom)),
                    vv = Rt.each,
                    bv = e => Rn(e) && !fu(e) && !nu(e) && !In(e),
                    yv = (e, t) => {
                        for (let o = e; o; o = o[t]) {
                            if (Vn(o) && qe(o.data)) return e;
                            if (Rn(o) && !fu(o)) return o
                        }
                        return e
                    },
                    wv = (e, t, o) => {
                        const n = Cf(e),
                            r = Rn(t) && Vu(t),
                            s = Rn(o) && Vu(o);
                        if (r && s) {
                            const r = yv(t, "previousSibling"),
                                s = yv(o, "nextSibling");
                            if (n.compare(r, s)) {
                                for (let e = r.nextSibling; e && e !== s;) {
                                    const t = e;
                                    e = e.nextSibling, r.appendChild(t)
                                }
                                return e.dom.remove(s), Rt.each(Rt.grep(s.childNodes), (e => {
                                    r.appendChild(e)
                                })), r
                            }
                        }
                        return o
                    },
                    xv = (e, t, o, n) => {
                        var r;
                        if (n && !1 !== t.merge_siblings) {
                            const t = null !== (r = wv(e, ju(n), n)) && void 0 !== r ? r : n;
                            wv(e, t, ju(t, !0))
                        }
                    },
                    Cv = (e, t, o) => {
                        vv(e.childNodes, (e => {
                            bv(e) && (t(e) && o(e), e.hasChildNodes() && Cv(e, t, o))
                        }))
                    },
                    Sv = (e, t) => o => !(!o || !Ju(e, o, t)),
                    kv = (e, t, o) => n => {
                        e.setStyle(n, t, o), "" === n.getAttribute("style") && n.removeAttribute("style"), ((e, t) => {
                            "SPAN" === t.nodeName && 0 === e.getAttribs(t).length && e.remove(t, !0)
                        })(e, n)
                    },
                    _v = Gi([{
                        keep: []
                    }, {
                        rename: ["name"]
                    }, {
                        removed: []
                    }]),
                    Ov = /^(src|href|style)$/,
                    Tv = Rt.each,
                    Ev = Yu,
                    Av = (e, t, o) => e.isChildOf(t, o) && t !== o && !e.isBlock(o),
                    Mv = (e, t, o) => {
                        let n = t[o ? "startContainer" : "endContainer"],
                            r = t[o ? "startOffset" : "endOffset"];
                        if (Rn(n)) {
                            const e = n.childNodes.length - 1;
                            !o && r && r--, n = n.childNodes[r > e ? e : r]
                        }
                        return Vn(n) && o && r >= n.data.length && (n = new An(n, e.getBody()).next() || n), Vn(n) && !o && 0 === r && (n = new An(n, e.getBody()).prev() || n), n
                    },
                    Nv = (e, t) => {
                        const o = t ? "firstChild" : "lastChild",
                            n = e[o];
                        return (e => /^(TR|TH|TD)$/.test(e.nodeName))(e) && n ? "TR" === e.nodeName && n[o] || n : e
                    },
                    Rv = (e, t, o, n) => {
                        var r;
                        const s = e.create(o, n);
                        return null === (r = t.parentNode) || void 0 === r || r.insertBefore(s, t), s.appendChild(t), s
                    },
                    Dv = (e, t, o, n, r) => {
                        const s = go(t),
                            a = go(e.create(n, r)),
                            i = o ? Ao(s) : Eo(s);
                        return on(a, i), o ? (Jo(s, a), en(a, s)) : (Qo(s, a), tn(a, s)), a.dom
                    },
                    Bv = (e, t, o) => {
                        const n = t.parentNode;
                        let r;
                        const s = e.dom,
                            a = pl(e);
                        om(o) && n === s.getRoot() && (o.list_block && Ev(t, o.list_block) || W(de(t.childNodes), (t => {
                            $u(e, a, t.nodeName.toLowerCase()) ? r ? r.appendChild(t) : (r = Rv(s, t, a), s.setAttribs(r, fl(e))) : r = null
                        }))), (e => nm(e) && rm(e) && Dt(Ce(e, "mixed"), !0))(o) && !Ev(o.inline, t) || s.remove(t, !0)
                    },
                    Lv = (e, t, o) => S(e) ? {
                        name: t,
                        value: null
                    } : {
                        name: e,
                        value: Ku(t, o)
                    },
                    Hv = (e, t) => {
                        "" === e.getAttrib(t, "style") && (t.removeAttribute("style"), t.removeAttribute("data-mce-style"))
                    },
                    Iv = (e, t, o, n, r) => {
                        let s = !1;
                        Tv(o.styles, ((a, i) => {
                            const {
                                name: l,
                                value: c
                            } = Lv(i, a, n), d = Xu(c, l);
                            (o.remove_similar || v(c) || !Rn(r) || Ev(Ju(e, r, l), d)) && e.setStyle(t, l, ""), s = !0
                        })), s && Hv(e, t)
                    },
                    Pv = (e, t, o, n, r) => {
                        const s = e.dom,
                            a = Cf(e),
                            i = e.schema;
                        if (rm(t) && hs(i, t.inline) && fs(i, n) && n.parentElement === e.getBody()) return Bv(e, n, t), _v.removed();
                        if (!t.ceFalseOverride && n && "false" === s.getContentEditableParent(n)) return _v.keep();
                        if (n && !Kf(s, n, t) && !((e, t) => t.links && "A" === e.nodeName)(n, t)) return _v.keep();
                        const l = n,
                            c = t.preserve_attributes;
                        if (rm(t) && "all" === t.remove && f(c)) {
                            const e = G(s.getAttribs(l), (e => Z(c, e.name.toLowerCase())));
                            if (s.removeAllAttribs(l), W(e, (e => s.setAttrib(l, e.name, e.value))), e.length > 0) return _v.rename("span")
                        }
                        if ("all" !== t.remove) {
                            Iv(s, l, t, o, r), Tv(t.attributes, ((e, n) => {
                                const {
                                    name: a,
                                    value: i
                                } = Lv(n, e, o);
                                if (t.remove_similar || v(i) || !Rn(r) || Ev(s.getAttrib(r, a), i)) {
                                    if ("class" === a) {
                                        const e = s.getAttrib(l, a);
                                        if (e) {
                                            let t = "";
                                            if (W(e.split(/\s+/), (e => {
                                                    /mce\-\w+/.test(e) && (t += (t ? " " : "") + e)
                                                })), t) return void s.setAttrib(l, a, t)
                                        }
                                    }
                                    if (Ov.test(a) && l.removeAttribute("data-mce-" + a), "style" === a && Bn(["li"])(l) && "none" === s.getStyle(l, "list-style-type")) return l.removeAttribute(a), void s.setStyle(l, "list-style-type", "none");
                                    "class" === a && l.removeAttribute("className"), l.removeAttribute(a)
                                }
                            })), Tv(t.classes, (e => {
                                e = Ku(e, o), Rn(r) && !s.hasClass(r, e) || s.removeClass(l, e)
                            }));
                            const e = s.getAttribs(l);
                            for (let t = 0; t < e.length; t++) {
                                const o = e[t].nodeName;
                                if (!a.isAttributeInternal(o)) return _v.keep()
                            }
                        }
                        return "none" !== t.remove ? (Bv(e, l, t), _v.removed()) : _v.keep()
                    },
                    zv = (e, t, o, n, r) => Pv(e, t, o, n, r).fold(L, (t => (e.dom.rename(n, t), !0)), H),
                    Fv = (e, t, o, n) => Pv(e, t, o, n, n).fold(E(n), (t => (e.dom.createFragment().appendChild(n), e.dom.rename(n, t))), E(null)),
                    Vv = (e, t, o, n, r) => {
                        const s = e.formatter.get(t),
                            a = s[0],
                            i = e.dom,
                            l = e.selection,
                            c = n => {
                                const i = ((e, t, o, n, r) => {
                                    let s;
                                    return t.parentNode && W(em(e.dom, t.parentNode).reverse(), (t => {
                                        if (!s && Rn(t) && "_start" !== t.id && "_end" !== t.id) {
                                            const a = Xf(e, t, o, n, r);
                                            a && !1 !== a.split && (s = t)
                                        }
                                    })), s
                                })(e, n, t, o, r);
                                return ((e, t, o, n, r, s, a, i) => {
                                    var l, c;
                                    let d, u;
                                    const m = e.dom;
                                    if (o) {
                                        const s = o.parentNode;
                                        for (let o = n.parentNode; o && o !== s; o = o.parentNode) {
                                            let n = m.clone(o, !1);
                                            for (let o = 0; o < t.length && (n = Fv(e, t[o], i, n), null !== n); o++);
                                            n && (d && n.appendChild(d), u || (u = n), d = n)
                                        }
                                        a.mixed && m.isBlock(o) || (n = null !== (l = m.split(o, n)) && void 0 !== l ? l : n), d && u && (null === (c = r.parentNode) || void 0 === c || c.insertBefore(d, r), u.appendChild(r), rm(a) && xv(e, a, 0, d))
                                    }
                                    return n
                                })(e, s, i, n, n, 0, a, o)
                            },
                            d = t => U(s, (n => zv(e, n, o, t, t))),
                            u = t => {
                                const o = de(t.childNodes),
                                    n = d(t) || U(s, (e => Kf(i, t, e))),
                                    r = t.parentNode;
                                if (!n && x(r) && sm(a) && d(r), a.deep && o.length)
                                    for (let e = 0; e < o.length; e++) u(o[e]);
                                W(["underline", "line-through", "overline"], (o => {
                                    Rn(t) && e.dom.getStyle(t, "text-decoration") === o && t.parentNode && Qu(i, t.parentNode) === o && zv(e, {
                                        deep: !1,
                                        exact: !0,
                                        inline: "span",
                                        styles: {
                                            textDecoration: o
                                        }
                                    }, void 0, t)
                                }))
                            },
                            m = e => {
                                const t = i.get(e ? "_start" : "_end");
                                if (t) {
                                    let o = t[e ? "firstChild" : "lastChild"];
                                    return (e => fu(e) && Rn(e) && ("_start" === e.id || "_end" === e.id))(o) && (o = o[e ? "firstChild" : "lastChild"]), Vn(o) && 0 === o.data.length && (o = e ? t.previousSibling || t.nextSibling : t.nextSibling || t.previousSibling), i.remove(t, !0), o
                                }
                                return null
                            },
                            g = t => {
                                let o, n, r = wm(i, t, s, t.collapsed);
                                if (a.split) {
                                    if (r = mg(r), o = Mv(e, r, !0), n = Mv(e, r), o !== n) {
                                        if (o = Nv(o, !0), n = Nv(n, !1), Av(i, o, n)) {
                                            const e = I.from(o.firstChild).getOr(o);
                                            return c(Dv(i, e, !0, "span", {
                                                id: "_start",
                                                "data-mce-type": "bookmark"
                                            })), void m(!0)
                                        }
                                        if (Av(i, n, o)) {
                                            const e = I.from(n.lastChild).getOr(n);
                                            return c(Dv(i, e, !1, "span", {
                                                id: "_end",
                                                "data-mce-type": "bookmark"
                                            })), void m(!1)
                                        }
                                        o = Rv(i, o, "span", {
                                            id: "_start",
                                            "data-mce-type": "bookmark"
                                        }), n = Rv(i, n, "span", {
                                            id: "_end",
                                            "data-mce-type": "bookmark"
                                        });
                                        const e = i.createRng();
                                        e.setStartAfter(o), e.setEndBefore(n), xm(i, e, (e => {
                                            W(e, (e => {
                                                fu(e) || fu(e.parentNode) || c(e)
                                            }))
                                        })), c(o), c(n), o = m(!0), n = m()
                                    } else o = n = c(o);
                                    r.startContainer = o.parentNode ? o.parentNode : o, r.startOffset = i.nodeIndex(o), r.endContainer = n.parentNode ? n.parentNode : n, r.endOffset = i.nodeIndex(n) + 1
                                }
                                xm(i, r, (e => {
                                    W(e, u)
                                }))
                            };
                        if (n) {
                            if (zu(n)) {
                                const e = i.createRng();
                                e.setStartBefore(n), e.setEndAfter(n), g(e)
                            } else g(n);
                            Nm(e, t, n, o)
                        } else l.isCollapsed() && rm(a) && !Mu(e).length ? iv(e, t, o, r) : (Zu(e, (() => Iu(e, g)), (n => rm(a) && Jf(e, t, o, n))), e.nodeChanged()), ((e, t, o) => {
                            "removeformat" === t ? W(fv(e.selection), (t => {
                                W(uv, (o => e.dom.setStyle(t, o, ""))), Hv(e.dom, t)
                            })) : mv(e.formatter, t).each((t => {
                                W(fv(e.selection), (n => Iv(e.dom, n, t, o, null)))
                            }))
                        })(e, t, o), Nm(e, t, n, o)
                    },
                    Zv = Rt.each,
                    Uv = Rt.each,
                    jv = (e, t, o, n) => {
                        if (Uv(o.styles, ((o, r) => {
                                e.setStyle(t, r, Ku(o, n))
                            })), o.styles) {
                            const o = e.getAttrib(t, "style");
                            o && e.setAttrib(t, "data-mce-style", o)
                        }
                    },
                    Wv = (e, t, o, n) => {
                        const r = e.formatter.get(t),
                            s = r[0],
                            a = !n && e.selection.isCollapsed(),
                            i = e.dom,
                            l = e.selection,
                            c = (e, t = s) => {
                                C(t.onformat) && t.onformat(e, t, o, n), jv(i, e, t, o), Uv(t.attributes, ((t, n) => {
                                    i.setAttrib(e, n, Ku(t, o))
                                })), Uv(t.classes, (t => {
                                    const n = Ku(t, o);
                                    i.hasClass(e, n) || i.addClass(e, n)
                                }))
                            },
                            d = (e, t) => {
                                let o = !1;
                                return Uv(e, (e => !(!nm(e) || ("false" !== i.getContentEditable(t) || e.ceFalseOverride) && (!x(e.collapsed) || e.collapsed === a) && i.is(t, e.selector) && !nu(t) && (c(t, e), o = !0, 1)))), o
                            },
                            u = e => {
                                if (g(e)) {
                                    const t = i.create(e);
                                    return c(t), t
                                }
                                return null
                            },
                            m = (n, a, i) => {
                                const l = [];
                                let m = !0;
                                const g = s.inline || s.block,
                                    h = u(g);
                                xm(n, a, (a => {
                                    let u;
                                    const p = a => {
                                        let f = !1,
                                            v = m,
                                            b = !1;
                                        const y = a.parentNode,
                                            w = y.nodeName.toLowerCase(),
                                            C = n.getContentEditable(a);
                                        x(C) && (v = m, m = "true" === C, f = !0, b = Gu(e, a));
                                        const S = m && !f;
                                        if (qn(a) && !((e, t, o, n) => {
                                                if (ec(e) && rm(t) && o.parentNode) {
                                                    const t = Ys(e.schema),
                                                        r = Uf(go(o), (e => nu(e.dom)));
                                                    return ke(t, n) && rs(go(o.parentNode), !1) && !r
                                                }
                                                return !1
                                            })(e, s, a, w)) return u = null, void(om(s) && n.remove(a));
                                        if ((n => (e => om(e) && !0 === e.wrapper)(s) && Xf(e, n, t, o))(a)) u = null;
                                        else {
                                            if (((t, o, n) => {
                                                    const r = (e => om(e) && !0 !== e.wrapper)(s) && Wu(e.schema, t) && $u(e, o, g);
                                                    return n && r
                                                })(a, w, S)) {
                                                const e = n.rename(a, g);
                                                return c(e), l.push(e), void(u = null)
                                            }
                                            if (nm(s)) {
                                                let e = d(r, a);
                                                if (!e && x(y) && sm(s) && (e = d(r, y)), !rm(s) || e) return void(u = null)
                                            }
                                            x(h) && ((t, o, r, a) => {
                                                const l = t.nodeName.toLowerCase(),
                                                    c = $u(e, g, l) && $u(e, o, g),
                                                    d = !i && Vn(t) && _r(t.data),
                                                    u = nu(t),
                                                    m = !rm(s) || !n.isBlock(t);
                                                return (r || a) && c && !d && !u && m
                                            })(a, w, S, b) ? (u || (u = n.clone(h, !1), y.insertBefore(u, a), l.push(u)), b && f && (m = v), u.appendChild(a)) : (u = null, W(de(a.childNodes), p), f && (m = v), u = null)
                                        }
                                    };
                                    W(a, p)
                                })), !0 === s.links && W(l, (e => {
                                    const t = e => {
                                        "A" === e.nodeName && c(e, s), W(de(e.childNodes), t)
                                    };
                                    t(e)
                                })), W(l, (a => {
                                    const i = (e => {
                                        let t = 0;
                                        return W(e.childNodes, (e => {
                                            (e => x(e) && Vn(e) && 0 === e.length)(e) || fu(e) || t++
                                        })), t
                                    })(a);
                                    !(l.length > 1) && n.isBlock(a) || 0 !== i ? (rm(s) || om(s) && s.wrapper) && (s.exact || 1 !== i || (a = (e => {
                                        const t = J(e.childNodes, Fu).filter((e => "false" !== n.getContentEditable(e) && Kf(n, e, s)));
                                        return t.map((t => {
                                            const o = n.clone(t, !1);
                                            return c(o), n.replace(o, e, !0), n.remove(t, !0), o
                                        })).getOr(e)
                                    })(a)), ((e, t, o, n) => {
                                        Zv(t, (t => {
                                            rm(t) && Zv(e.dom.select(t.inline, n), (n => {
                                                bv(n) && zv(e, t, o, n, t.exact ? n : null)
                                            })), ((e, t, o) => {
                                                if (t.clear_child_styles) {
                                                    const n = t.links ? "*:not(a)" : "*";
                                                    vv(e.select(n, o), (o => {
                                                        bv(o) && Vu(o) && vv(t.styles, ((t, n) => {
                                                            e.setStyle(o, n, "")
                                                        }))
                                                    }))
                                                }
                                            })(e.dom, t, n)
                                        }))
                                    })(e, r, o, a), ((e, t, o, n, r) => {
                                        const s = r.parentNode;
                                        Xf(e, s, o, n) && zv(e, t, n, r) || t.merge_with_parents && s && e.dom.getParent(s, (s => !!Xf(e, s, o, n) && (zv(e, t, n, r), !0)))
                                    })(e, s, t, o, a), ((e, t, o, n) => {
                                        if (t.styles && t.styles.backgroundColor) {
                                            const r = Sv(e, "fontSize");
                                            Cv(n, (e => r(e) && Vu(e)), kv(e, "backgroundColor", Ku(t.styles.backgroundColor, o)))
                                        }
                                    })(n, s, o, a), ((e, t, o, n) => {
                                        const r = t => {
                                            if (Rn(t) && Rn(t.parentNode) && Vu(t)) {
                                                const o = Qu(e, t.parentNode);
                                                e.getStyle(t, "color") && o ? e.setStyle(t, "text-decoration", o) : e.getStyle(t, "text-decoration") === o && e.setStyle(t, "text-decoration", null)
                                            }
                                        };
                                        t.styles && (t.styles.color || t.styles.textDecoration) && (Rt.walk(n, r, "childNodes"), r(n))
                                    })(n, s, 0, a), ((e, t, o, n) => {
                                        if (rm(t) && ("sub" === t.inline || "sup" === t.inline)) {
                                            const o = Sv(e, "fontSize");
                                            Cv(n, (e => o(e) && Vu(e)), kv(e, "fontSize", ""));
                                            const r = G(e.select("sup" === t.inline ? "sub" : "sup", n), Vu);
                                            e.remove(r, !0)
                                        }
                                    })(n, s, 0, a), xv(e, s, 0, a)) : n.remove(a, !0)
                                }))
                            },
                            h = zu(n) ? n : l.getNode();
                        if ("false" === i.getContentEditable(h) && !Gu(e, h)) return d(r, n = h), void Mm(e, t, n, o);
                        if (s) {
                            if (n)
                                if (zu(n)) {
                                    if (!d(r, n)) {
                                        const e = i.createRng();
                                        e.setStartBefore(n), e.setEndAfter(n), m(i, wm(i, e, r), !0)
                                    }
                                } else m(i, n, !0);
                            else a && rm(s) && !Mu(e).length ? ((e, t, o) => {
                                let n;
                                const r = e.selection,
                                    s = e.formatter.get(t);
                                if (!s) return;
                                const a = r.getRng();
                                let i = a.startOffset;
                                const l = a.startContainer.nodeValue;
                                n = ru(e.getBody(), r.getStart());
                                const c = /[^\s\u00a0\u00ad\u200b\ufeff]/;
                                if (l && i > 0 && i < l.length && c.test(l.charAt(i)) && c.test(l.charAt(i - 1))) {
                                    const n = r.getBookmark();
                                    a.collapse(!0);
                                    let i = wm(e.dom, a, s);
                                    i = mg(i), e.formatter.apply(t, o, i), r.moveToBookmark(n)
                                } else {
                                    let s = n ? tv(n) : null;
                                    n && (null == s ? void 0 : s.data) === Qf || (d = e.getDoc(), u = ov(!0).dom, n = d.importNode(u, !0), s = n.firstChild, a.insertNode(n), i = 1), e.formatter.apply(t, o, n), r.setCursorLocation(s, i)
                                }
                                var d, u
                            })(e, t, o) : (l.setRng(Rf(l.getRng())), Zu(e, (() => {
                                Iu(e, ((e, t) => {
                                    const o = t ? e : wm(i, e, r);
                                    m(i, o, !1)
                                }))
                            }), H), e.nodeChanged()), mv(e.formatter, t).each((t => {
                                W((e => G((e => {
                                    const t = e.getSelectedBlocks(),
                                        o = e.getRng();
                                    if (e.isCollapsed()) return [];
                                    if (1 === t.length) return gv(o, t[0]) && hv(o, t[0]) ? t : []; {
                                        const e = le(t).filter((e => gv(o, e))).toArray(),
                                            n = ce(t).filter((e => hv(o, e))).toArray(),
                                            r = t.slice(1, -1);
                                        return e.concat(r).concat(n)
                                    }
                                })(e), pv(e.dom)))(e.selection), (e => jv(i, e, t, o)))
                            }));
                            ((e, t) => {
                                Se(cv, e) && W(cv[e], (e => {
                                    e(t)
                                }))
                            })(t, e)
                        }
                        Mm(e, t, n, o)
                    },
                    $v = e => Se(e, "vars"),
                    qv = e => e.selection.getStart(),
                    Gv = (e, t, o, n, r) => X(t, (t => {
                        const s = e.formatter.matchNode(t, o, null != r ? r : {}, n);
                        return !y(s)
                    }), (t => !!qf(e, t, o) || !n && x(e.formatter.matchNode(t, o, r, !0)))),
                    Kv = (e, t) => {
                        const o = null != t ? t : qv(e);
                        return G(em(e.dom, o), (e => Rn(e) && !In(e)))
                    },
                    Yv = (e, t, o) => {
                        const n = Kv(e, t);
                        he(o, ((o, r) => {
                            const s = o => {
                                const s = Gv(e, n, r, o.similar, $v(o) ? o.vars : void 0),
                                    a = s.isSome();
                                if (o.state.get() !== a) {
                                    o.state.set(a);
                                    const e = s.getOr(t);
                                    $v(o) ? o.callback(a, {
                                        node: e,
                                        format: r,
                                        parents: n
                                    }) : W(o.callbacks, (t => t(a, {
                                        node: e,
                                        format: r,
                                        parents: n
                                    })))
                                }
                            };
                            W([o.withSimilar, o.withoutSimilar], s), W(o.withVars, s)
                        }))
                    };

                function Xv(e) {
                    return Xv = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                        return typeof e
                    } : function(e) {
                        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                    }, Xv(e)
                }

                function Jv(e, t) {
                    return Jv = Object.setPrototypeOf || function(e, t) {
                        return e.__proto__ = t, e
                    }, Jv(e, t)
                }

                function Qv() {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                    if (Reflect.construct.sham) return !1;
                    if ("function" == typeof Proxy) return !0;
                    try {
                        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
                    } catch (e) {
                        return !1
                    }
                }

                function eb(e, t, o) {
                    return eb = Qv() ? Reflect.construct : function(e, t, o) {
                        var n = [null];
                        n.push.apply(n, t);
                        var r = new(Function.bind.apply(e, n));
                        return o && Jv(r, o.prototype), r
                    }, eb.apply(null, arguments)
                }

                function tb(e) {
                    return function(e) {
                        if (Array.isArray(e)) return ob(e)
                    }(e) || function(e) {
                        if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"]) return Array.from(e)
                    }(e) || function(e, t) {
                        if (e) {
                            if ("string" == typeof e) return ob(e, t);
                            var o = Object.prototype.toString.call(e).slice(8, -1);
                            return "Object" === o && e.constructor && (o = e.constructor.name), "Map" === o || "Set" === o ? Array.from(e) : "Arguments" === o || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(o) ? ob(e, t) : void 0
                        }
                    }(e) || function() {
                        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                    }()
                }

                function ob(e, t) {
                    (null == t || t > e.length) && (t = e.length);
                    for (var o = 0, n = new Array(t); o < t; o++) n[o] = e[o];
                    return n
                }
                var nb = Object.hasOwnProperty,
                    rb = Object.setPrototypeOf,
                    sb = Object.isFrozen,
                    ab = Object.getPrototypeOf,
                    ib = Object.getOwnPropertyDescriptor,
                    lb = Object.freeze,
                    cb = Object.seal,
                    db = Object.create,
                    ub = "undefined" != typeof Reflect && Reflect,
                    mb = ub.apply,
                    gb = ub.construct;
                mb || (mb = function(e, t, o) {
                    return e.apply(t, o)
                }), lb || (lb = function(e) {
                    return e
                }), cb || (cb = function(e) {
                    return e
                }), gb || (gb = function(e, t) {
                    return eb(e, tb(t))
                });
                var hb, pb = _b(Array.prototype.forEach),
                    fb = _b(Array.prototype.pop),
                    vb = _b(Array.prototype.push),
                    bb = _b(String.prototype.toLowerCase),
                    yb = _b(String.prototype.match),
                    wb = _b(String.prototype.replace),
                    xb = _b(String.prototype.indexOf),
                    Cb = _b(String.prototype.trim),
                    Sb = _b(RegExp.prototype.test),
                    kb = (hb = TypeError, function() {
                        for (var e = arguments.length, t = new Array(e), o = 0; o < e; o++) t[o] = arguments[o];
                        return gb(hb, t)
                    });

                function _b(e) {
                    return function(t) {
                        for (var o = arguments.length, n = new Array(o > 1 ? o - 1 : 0), r = 1; r < o; r++) n[r - 1] = arguments[r];
                        return mb(e, t, n)
                    }
                }

                function Ob(e, t) {
                    rb && rb(e, null);
                    for (var o = t.length; o--;) {
                        var n = t[o];
                        if ("string" == typeof n) {
                            var r = bb(n);
                            r !== n && (sb(t) || (t[o] = r), n = r)
                        }
                        e[n] = !0
                    }
                    return e
                }

                function Tb(e) {
                    var t, o = db(null);
                    for (t in e) mb(nb, e, [t]) && (o[t] = e[t]);
                    return o
                }

                function Eb(e, t) {
                    for (; null !== e;) {
                        var o = ib(e, t);
                        if (o) {
                            if (o.get) return _b(o.get);
                            if ("function" == typeof o.value) return _b(o.value)
                        }
                        e = ab(e)
                    }
                    return function(e) {
                        return console.warn("fallback value for", e), null
                    }
                }
                var Ab = lb(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]),
                    Mb = lb(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]),
                    Nb = lb(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]),
                    Rb = lb(["animate", "color-profile", "cursor", "discard", "fedropshadow", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]),
                    Db = lb(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover"]),
                    Bb = lb(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]),
                    Lb = lb(["#text"]),
                    Hb = lb(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "xmlns", "slot"]),
                    Ib = lb(["accent-height", "accumulate", "additive", "alignment-baseline", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]),
                    Pb = lb(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]),
                    zb = lb(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]),
                    Fb = cb(/\{\{[\w\W]*|[\w\W]*\}\}/gm),
                    Vb = cb(/<%[\w\W]*|[\w\W]*%>/gm),
                    Zb = cb(/^data-[\-\w.\u00B7-\uFFFF]/),
                    Ub = cb(/^aria-[\-\w]+$/),
                    jb = cb(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i),
                    Wb = cb(/^(?:\w+script|data):/i),
                    $b = cb(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g),
                    qb = cb(/^html$/i),
                    Gb = function() {
                        return "undefined" == typeof window ? null : window
                    },
                    Kb = function(e, t) {
                        if ("object" !== Xv(e) || "function" != typeof e.createPolicy) return null;
                        var o = null,
                            n = "data-tt-policy-suffix";
                        t.currentScript && t.currentScript.hasAttribute(n) && (o = t.currentScript.getAttribute(n));
                        var r = "dompurify" + (o ? "#" + o : "");
                        try {
                            return e.createPolicy(r, {
                                createHTML: function(e) {
                                    return e
                                }
                            })
                        } catch (e) {
                            return console.warn("TrustedTypes policy " + r + " could not be created."), null
                        }
                    },
                    Yb = function e() {
                        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Gb(),
                            o = function(t) {
                                return e(t)
                            };
                        if (o.version = "2.3.8", o.removed = [], !t || !t.document || 9 !== t.document.nodeType) return o.isSupported = !1, o;
                        var n = t.document,
                            r = t.document,
                            s = t.DocumentFragment,
                            a = t.HTMLTemplateElement,
                            i = t.Node,
                            l = t.Element,
                            c = t.NodeFilter,
                            d = t.NamedNodeMap,
                            u = void 0 === d ? t.NamedNodeMap || t.MozNamedAttrMap : d,
                            m = t.HTMLFormElement,
                            g = t.DOMParser,
                            h = t.trustedTypes,
                            p = l.prototype,
                            f = Eb(p, "cloneNode"),
                            v = Eb(p, "nextSibling"),
                            b = Eb(p, "childNodes"),
                            y = Eb(p, "parentNode");
                        if ("function" == typeof a) {
                            var w = r.createElement("template");
                            w.content && w.content.ownerDocument && (r = w.content.ownerDocument)
                        }
                        var x = Kb(h, n),
                            C = x ? x.createHTML("") : "",
                            S = r,
                            k = S.implementation,
                            _ = S.createNodeIterator,
                            O = S.createDocumentFragment,
                            T = S.getElementsByTagName,
                            E = n.importNode,
                            A = {};
                        try {
                            A = Tb(r).documentMode ? r.documentMode : {}
                        } catch (e) {}
                        var M = {};
                        o.isSupported = "function" == typeof y && k && void 0 !== k.createHTMLDocument && 9 !== A;
                        var N, R, D = Fb,
                            B = Vb,
                            L = Zb,
                            H = Ub,
                            I = Wb,
                            P = $b,
                            z = jb,
                            F = null,
                            V = Ob({}, [].concat(tb(Ab), tb(Mb), tb(Nb), tb(Db), tb(Lb))),
                            Z = null,
                            U = Ob({}, [].concat(tb(Hb), tb(Ib), tb(Pb), tb(zb))),
                            j = Object.seal(Object.create(null, {
                                tagNameCheck: {
                                    writable: !0,
                                    configurable: !1,
                                    enumerable: !0,
                                    value: null
                                },
                                attributeNameCheck: {
                                    writable: !0,
                                    configurable: !1,
                                    enumerable: !0,
                                    value: null
                                },
                                allowCustomizedBuiltInElements: {
                                    writable: !0,
                                    configurable: !1,
                                    enumerable: !0,
                                    value: !1
                                }
                            })),
                            W = null,
                            $ = null,
                            q = !0,
                            G = !0,
                            K = !1,
                            Y = !1,
                            X = !1,
                            J = !1,
                            Q = !1,
                            ee = !1,
                            te = !1,
                            oe = !1,
                            ne = !0,
                            re = !0,
                            se = !1,
                            ae = {},
                            ie = null,
                            le = Ob({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]),
                            ce = null,
                            de = Ob({}, ["audio", "video", "img", "source", "image", "track"]),
                            ue = null,
                            me = Ob({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]),
                            ge = "http://www.w3.org/1998/Math/MathML",
                            he = "http://www.w3.org/2000/svg",
                            pe = "http://www.w3.org/1999/xhtml",
                            fe = pe,
                            ve = !1,
                            be = ["application/xhtml+xml", "text/html"],
                            ye = "text/html",
                            we = null,
                            xe = r.createElement("form"),
                            Ce = function(e) {
                                return e instanceof RegExp || e instanceof Function
                            },
                            Se = function(e) {
                                we && we === e || (e && "object" === Xv(e) || (e = {}), e = Tb(e), F = "ALLOWED_TAGS" in e ? Ob({}, e.ALLOWED_TAGS) : V, Z = "ALLOWED_ATTR" in e ? Ob({}, e.ALLOWED_ATTR) : U, ue = "ADD_URI_SAFE_ATTR" in e ? Ob(Tb(me), e.ADD_URI_SAFE_ATTR) : me, ce = "ADD_DATA_URI_TAGS" in e ? Ob(Tb(de), e.ADD_DATA_URI_TAGS) : de, ie = "FORBID_CONTENTS" in e ? Ob({}, e.FORBID_CONTENTS) : le, W = "FORBID_TAGS" in e ? Ob({}, e.FORBID_TAGS) : {}, $ = "FORBID_ATTR" in e ? Ob({}, e.FORBID_ATTR) : {}, ae = "USE_PROFILES" in e && e.USE_PROFILES, q = !1 !== e.ALLOW_ARIA_ATTR, G = !1 !== e.ALLOW_DATA_ATTR, K = e.ALLOW_UNKNOWN_PROTOCOLS || !1, Y = e.SAFE_FOR_TEMPLATES || !1, X = e.WHOLE_DOCUMENT || !1, ee = e.RETURN_DOM || !1, te = e.RETURN_DOM_FRAGMENT || !1, oe = e.RETURN_TRUSTED_TYPE || !1, Q = e.FORCE_BODY || !1, ne = !1 !== e.SANITIZE_DOM, re = !1 !== e.KEEP_CONTENT, se = e.IN_PLACE || !1, z = e.ALLOWED_URI_REGEXP || z, fe = e.NAMESPACE || pe, e.CUSTOM_ELEMENT_HANDLING && Ce(e.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (j.tagNameCheck = e.CUSTOM_ELEMENT_HANDLING.tagNameCheck), e.CUSTOM_ELEMENT_HANDLING && Ce(e.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (j.attributeNameCheck = e.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), e.CUSTOM_ELEMENT_HANDLING && "boolean" == typeof e.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (j.allowCustomizedBuiltInElements = e.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), N = N = -1 === be.indexOf(e.PARSER_MEDIA_TYPE) ? ye : e.PARSER_MEDIA_TYPE, R = "application/xhtml+xml" === N ? function(e) {
                                    return e
                                } : bb, Y && (G = !1), te && (ee = !0), ae && (F = Ob({}, tb(Lb)), Z = [], !0 === ae.html && (Ob(F, Ab), Ob(Z, Hb)), !0 === ae.svg && (Ob(F, Mb), Ob(Z, Ib), Ob(Z, zb)), !0 === ae.svgFilters && (Ob(F, Nb), Ob(Z, Ib), Ob(Z, zb)), !0 === ae.mathMl && (Ob(F, Db), Ob(Z, Pb), Ob(Z, zb))), e.ADD_TAGS && (F === V && (F = Tb(F)), Ob(F, e.ADD_TAGS)), e.ADD_ATTR && (Z === U && (Z = Tb(Z)), Ob(Z, e.ADD_ATTR)), e.ADD_URI_SAFE_ATTR && Ob(ue, e.ADD_URI_SAFE_ATTR), e.FORBID_CONTENTS && (ie === le && (ie = Tb(ie)), Ob(ie, e.FORBID_CONTENTS)), re && (F["#text"] = !0), X && Ob(F, ["html", "head", "body"]), F.table && (Ob(F, ["tbody"]), delete W.tbody), lb && lb(e), we = e)
                            },
                            ke = Ob({}, ["mi", "mo", "mn", "ms", "mtext"]),
                            _e = Ob({}, ["foreignobject", "desc", "title", "annotation-xml"]),
                            Oe = Ob({}, ["title", "style", "font", "a", "script"]),
                            Te = Ob({}, Mb);
                        Ob(Te, Nb), Ob(Te, Rb);
                        var Ee = Ob({}, Db);
                        Ob(Ee, Bb);
                        var Ae = function(e) {
                                var t = y(e);
                                t && t.tagName || (t = {
                                    namespaceURI: pe,
                                    tagName: "template"
                                });
                                var o = bb(e.tagName),
                                    n = bb(t.tagName);
                                return e.namespaceURI === he ? t.namespaceURI === pe ? "svg" === o : t.namespaceURI === ge ? "svg" === o && ("annotation-xml" === n || ke[n]) : Boolean(Te[o]) : e.namespaceURI === ge ? t.namespaceURI === pe ? "math" === o : t.namespaceURI === he ? "math" === o && _e[n] : Boolean(Ee[o]) : e.namespaceURI === pe && !(t.namespaceURI === he && !_e[n]) && !(t.namespaceURI === ge && !ke[n]) && !Ee[o] && (Oe[o] || !Te[o])
                            },
                            Me = function(e) {
                                vb(o.removed, {
                                    element: e
                                });
                                try {
                                    e.parentNode.removeChild(e)
                                } catch (t) {
                                    try {
                                        e.outerHTML = C
                                    } catch (t) {
                                        e.remove()
                                    }
                                }
                            },
                            Ne = function(e, t) {
                                try {
                                    vb(o.removed, {
                                        attribute: t.getAttributeNode(e),
                                        from: t
                                    })
                                } catch (e) {
                                    vb(o.removed, {
                                        attribute: null,
                                        from: t
                                    })
                                }
                                if (t.removeAttribute(e), "is" === e && !Z[e])
                                    if (ee || te) try {
                                        Me(t)
                                    } catch (e) {} else try {
                                        t.setAttribute(e, "")
                                    } catch (e) {}
                            },
                            Re = function(e) {
                                var t, o;
                                if (Q) e = "<remove></remove>" + e;
                                else {
                                    var n = yb(e, /^[\r\n\t ]+/);
                                    o = n && n[0]
                                }
                                "application/xhtml+xml" === N && (e = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + e + "</body></html>");
                                var s = x ? x.createHTML(e) : e;
                                if (fe === pe) try {
                                    t = (new g).parseFromString(s, N)
                                } catch (e) {}
                                if (!t || !t.documentElement) {
                                    t = k.createDocument(fe, "template", null);
                                    try {
                                        t.documentElement.innerHTML = ve ? "" : s
                                    } catch (e) {}
                                }
                                var a = t.body || t.documentElement;
                                return e && o && a.insertBefore(r.createTextNode(o), a.childNodes[0] || null), fe === pe ? T.call(t, X ? "html" : "body")[0] : X ? t.documentElement : a
                            },
                            De = function(e) {
                                return _.call(e.ownerDocument || e, e, c.SHOW_ELEMENT | c.SHOW_COMMENT | c.SHOW_TEXT, null, !1)
                            },
                            Be = function(e) {
                                return e instanceof m && ("string" != typeof e.nodeName || "string" != typeof e.textContent || "function" != typeof e.removeChild || !(e.attributes instanceof u) || "function" != typeof e.removeAttribute || "function" != typeof e.setAttribute || "string" != typeof e.namespaceURI || "function" != typeof e.insertBefore)
                            },
                            Le = function(e) {
                                return "object" === Xv(i) ? e instanceof i : e && "object" === Xv(e) && "number" == typeof e.nodeType && "string" == typeof e.nodeName
                            },
                            He = function(e, t, n) {
                                M[e] && pb(M[e], (function(e) {
                                    e.call(o, t, n, we)
                                }))
                            },
                            Ie = function(e) {
                                var t;
                                if (He("beforeSanitizeElements", e, null), Be(e)) return Me(e), !0;
                                if (Sb(/[\u0080-\uFFFF]/, e.nodeName)) return Me(e), !0;
                                var n = R(e.nodeName);
                                if (He("uponSanitizeElement", e, {
                                        tagName: n,
                                        allowedTags: F
                                    }), e.hasChildNodes() && !Le(e.firstElementChild) && (!Le(e.content) || !Le(e.content.firstElementChild)) && Sb(/<[/\w]/g, e.innerHTML) && Sb(/<[/\w]/g, e.textContent)) return Me(e), !0;
                                if ("select" === n && Sb(/<template/i, e.innerHTML)) return Me(e), !0;
                                if (!F[n] || W[n]) {
                                    if (!W[n] && ze(n)) {
                                        if (j.tagNameCheck instanceof RegExp && Sb(j.tagNameCheck, n)) return !1;
                                        if (j.tagNameCheck instanceof Function && j.tagNameCheck(n)) return !1
                                    }
                                    if (re && !ie[n]) {
                                        var r = y(e) || e.parentNode,
                                            s = b(e) || e.childNodes;
                                        if (s && r)
                                            for (var a = s.length - 1; a >= 0; --a) r.insertBefore(f(s[a], !0), v(e))
                                    }
                                    return Me(e), !0
                                }
                                return e instanceof l && !Ae(e) ? (Me(e), !0) : "noscript" !== n && "noembed" !== n || !Sb(/<\/no(script|embed)/i, e.innerHTML) ? (Y && 3 === e.nodeType && (t = e.textContent, t = wb(t, D, " "), t = wb(t, B, " "), e.textContent !== t && (vb(o.removed, {
                                    element: e.cloneNode()
                                }), e.textContent = t)), He("afterSanitizeElements", e, null), !1) : (Me(e), !0)
                            },
                            Pe = function(e, t, o) {
                                if (ne && ("id" === t || "name" === t) && (o in r || o in xe)) return !1;
                                if (G && !$[t] && Sb(L, t));
                                else if (q && Sb(H, t));
                                else if (!Z[t] || $[t]) {
                                    if (!(ze(e) && (j.tagNameCheck instanceof RegExp && Sb(j.tagNameCheck, e) || j.tagNameCheck instanceof Function && j.tagNameCheck(e)) && (j.attributeNameCheck instanceof RegExp && Sb(j.attributeNameCheck, t) || j.attributeNameCheck instanceof Function && j.attributeNameCheck(t)) || "is" === t && j.allowCustomizedBuiltInElements && (j.tagNameCheck instanceof RegExp && Sb(j.tagNameCheck, o) || j.tagNameCheck instanceof Function && j.tagNameCheck(o)))) return !1
                                } else if (ue[t]);
                                else if (Sb(z, wb(o, P, "")));
                                else if ("src" !== t && "xlink:href" !== t && "href" !== t || "script" === e || 0 !== xb(o, "data:") || !ce[e])
                                    if (K && !Sb(I, wb(o, P, "")));
                                    else if (o) return !1;
                                return !0
                            },
                            ze = function(e) {
                                return e.indexOf("-") > 0
                            },
                            Fe = function(e) {
                                var t, o, n, r;
                                He("beforeSanitizeAttributes", e, null);
                                var s = e.attributes;
                                if (s) {
                                    var a = {
                                        attrName: "",
                                        attrValue: "",
                                        keepAttr: !0,
                                        allowedAttributes: Z
                                    };
                                    for (r = s.length; r--;) {
                                        var i = t = s[r],
                                            l = i.name,
                                            c = i.namespaceURI;
                                        o = "value" === l ? t.value : Cb(t.value), n = R(l);
                                        var d = o;
                                        if (a.attrName = n, a.attrValue = o, a.keepAttr = !0, a.forceKeepAttr = void 0, He("uponSanitizeAttribute", e, a), o = a.attrValue, !a.forceKeepAttr)
                                            if (a.keepAttr)
                                                if (Sb(/\/>/i, o)) Ne(l, e);
                                                else {
                                                    Y && (o = wb(o, D, " "), o = wb(o, B, " "));
                                                    var u = R(e.nodeName);
                                                    if (Pe(u, n, o)) {
                                                        if (o !== d) try {
                                                            c ? e.setAttributeNS(c, l, o) : e.setAttribute(l, o)
                                                        } catch (t) {
                                                            Ne(l, e)
                                                        }
                                                    } else Ne(l, e)
                                                }
                                        else Ne(l, e)
                                    }
                                    He("afterSanitizeAttributes", e, null)
                                }
                            },
                            Ve = function e(t) {
                                var o, n = De(t);
                                for (He("beforeSanitizeShadowDOM", t, null); o = n.nextNode();) He("uponSanitizeShadowNode", o, null), Ie(o) || (o.content instanceof s && e(o.content), Fe(o));
                                He("afterSanitizeShadowDOM", t, null)
                            };
                        return o.sanitize = function(e, r) {
                            var a, l, c, d, u;
                            if ((ve = !e) && (e = "\x3c!--\x3e"), "string" != typeof e && !Le(e)) {
                                if ("function" != typeof e.toString) throw kb("toString is not a function");
                                if ("string" != typeof(e = e.toString())) throw kb("dirty is not a string, aborting")
                            }
                            if (!o.isSupported) {
                                if ("object" === Xv(t.toStaticHTML) || "function" == typeof t.toStaticHTML) {
                                    if ("string" == typeof e) return t.toStaticHTML(e);
                                    if (Le(e)) return t.toStaticHTML(e.outerHTML)
                                }
                                return e
                            }
                            if (J || Se(r), o.removed = [], "string" == typeof e && (se = !1), se) {
                                if (e.nodeName) {
                                    var m = R(e.nodeName);
                                    if (!F[m] || W[m]) throw kb("root node is forbidden and cannot be sanitized in-place")
                                }
                            } else if (e instanceof i) 1 === (l = (a = Re("\x3c!----\x3e")).ownerDocument.importNode(e, !0)).nodeType && "BODY" === l.nodeName || "HTML" === l.nodeName ? a = l : a.appendChild(l);
                            else {
                                if (!ee && !Y && !X && -1 === e.indexOf("<")) return x && oe ? x.createHTML(e) : e;
                                if (!(a = Re(e))) return ee ? null : oe ? C : ""
                            }
                            a && Q && Me(a.firstChild);
                            for (var g = De(se ? e : a); c = g.nextNode();) 3 === c.nodeType && c === d || Ie(c) || (c.content instanceof s && Ve(c.content), Fe(c), d = c);
                            if (d = null, se) return e;
                            if (ee) {
                                if (te)
                                    for (u = O.call(a.ownerDocument); a.firstChild;) u.appendChild(a.firstChild);
                                else u = a;
                                return Z.shadowroot && (u = E.call(n, u, !0)), u
                            }
                            var h = X ? a.outerHTML : a.innerHTML;
                            return X && F["!doctype"] && a.ownerDocument && a.ownerDocument.doctype && a.ownerDocument.doctype.name && Sb(qb, a.ownerDocument.doctype.name) && (h = "<!DOCTYPE " + a.ownerDocument.doctype.name + ">\n" + h), Y && (h = wb(h, D, " "), h = wb(h, B, " ")), x && oe ? x.createHTML(h) : h
                        }, o.setConfig = function(e) {
                            Se(e), J = !0
                        }, o.clearConfig = function() {
                            we = null, J = !1
                        }, o.isValidAttribute = function(e, t, o) {
                            we || Se({});
                            var n = R(e),
                                r = R(t);
                            return Pe(n, r, o)
                        }, o.addHook = function(e, t) {
                            "function" == typeof t && (M[e] = M[e] || [], vb(M[e], t))
                        }, o.removeHook = function(e) {
                            if (M[e]) return fb(M[e])
                        }, o.removeHooks = function(e) {
                            M[e] && (M[e] = [])
                        }, o.removeAllHooks = function() {
                            M = {}
                        }, o
                    }();
                const Xb = Rt.explode,
                    Jb = () => {
                        const e = {};
                        return {
                            addFilter: (t, o) => {
                                W(Xb(t), (t => {
                                    Se(e, t) || (e[t] = {
                                        name: t,
                                        callbacks: []
                                    }), e[t].callbacks.push(o)
                                }))
                            },
                            getFilters: () => xe(e),
                            removeFilter: (t, o) => {
                                W(Xb(t), (t => {
                                    if (Se(e, t))
                                        if (x(o)) {
                                            const n = e[t],
                                                r = G(n.callbacks, (e => e !== o));
                                            r.length > 0 ? n.callbacks = r : delete e[t]
                                        } else delete e[t]
                                }))
                            }
                        }
                    },
                    Qb = (e, t, o) => {
                        var n;
                        const r = Qs();
                        t.convert_fonts_to_spans && ((e, t, o) => {
                            e.addNodeFilter("font", (e => {
                                W(e, (e => {
                                    const n = t.parse(e.attr("style")),
                                        r = e.attr("color"),
                                        s = e.attr("face"),
                                        a = e.attr("size");
                                    r && (n.color = r), s && (n["font-family"] = s), a && Ke(a).each((e => {
                                        n["font-size"] = o[e - 1]
                                    })), e.name = "span", e.attr("style", t.serialize(n)), ((e, t) => {
                                        W(["color", "face", "size"], (t => {
                                            e.attr(t, null)
                                        }))
                                    })(e)
                                }))
                            }))
                        })(e, r, Rt.explode(null !== (n = t.font_size_legacy_values) && void 0 !== n ? n : "")), ((e, t, o) => {
                            e.addNodeFilter("strike", (e => {
                                const n = "html4" !== t.type;
                                W(e, (e => {
                                    if (n) e.name = "s";
                                    else {
                                        const t = o.parse(e.attr("style"));
                                        t["text-decoration"] = "line-through", e.name = "span", e.attr("style", o.serialize(t))
                                    }
                                }))
                            }))
                        })(e, o, r)
                    },
                    ey = e => {
                        const [t, ...o] = e.split(","), n = o.join(","), r = /data:([^/]+\/[^;]+)(;.+)?/.exec(t);
                        if (r) {
                            const e = ";base64" === r[2],
                                t = e ? (e => {
                                    const t = /([a-z0-9+\/=\s]+)/i.exec(e);
                                    return t ? t[1] : ""
                                })(n) : decodeURIComponent(n);
                            return I.some({
                                type: r[1],
                                data: t,
                                base64Encoded: e
                            })
                        }
                        return I.none()
                    },
                    ty = (e, t, o = !0) => {
                        let n = t;
                        if (o) try {
                            n = atob(t)
                        } catch (e) {
                            return I.none()
                        }
                        const r = new Uint8Array(n.length);
                        for (let e = 0; e < r.length; e++) r[e] = n.charCodeAt(e);
                        return I.some(new Blob([r], {
                            type: e
                        }))
                    },
                    oy = e => new Promise(((t, o) => {
                        const n = new FileReader;
                        n.onloadend = () => {
                            t(n.result)
                        }, n.onerror = () => {
                            var e;
                            o(null === (e = n.error) || void 0 === e ? void 0 : e.message)
                        }, n.readAsDataURL(e)
                    }));
                let ny = 0;
                const ry = (e, t, o) => ey(e).bind((({
                        data: e,
                        type: n,
                        base64Encoded: r
                    }) => {
                        if (t && !r) return I.none(); {
                            const t = r ? e : btoa(e);
                            return o(t, n)
                        }
                    })),
                    sy = (e, t, o) => {
                        const n = e.create("blobid" + ny++, t, o);
                        return e.add(n), n
                    },
                    ay = (e, t, o = !1) => ry(t, o, ((t, o) => I.from(e.getByData(t, o)).orThunk((() => ty(o, t).map((o => sy(e, o, t))))))),
                    iy = Rt.each,
                    ly = Rt.trim,
                    cy = ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"],
                    dy = {
                        ftp: 21,
                        http: 80,
                        https: 443,
                        mailto: 25
                    },
                    uy = ["img", "video"],
                    my = (e, t, o) => {
                        const n = (e => {
                            try {
                                return decodeURIComponent(e)
                            } catch (t) {
                                return unescape(e)
                            }
                        })(t);
                        return !e.allow_script_urls && (!!/((java|vb)script|mhtml):/i.test(n) || !e.allow_html_data_urls && (/^data:image\//i.test(n) ? ((e, t) => x(e) ? !e : !x(t) || !Z(uy, t))(e.allow_svg_data_urls, o) && /^data:image\/svg\+xml/i.test(n) : /^data:/i.test(n)))
                    };
                class gy {
                    constructor(e, t = {}) {
                        this.path = "", this.directory = "", e = ly(e), this.settings = t;
                        const o = t.base_uri,
                            n = this;
                        if (/^([\w\-]+):([^\/]{2})/i.test(e) || /^\s*#/.test(e)) return void(n.source = e);
                        const r = 0 === e.indexOf("//");
                        if (0 !== e.indexOf("/") || r || (e = (o && o.protocol || "http") + "://mce_host" + e), !/^[\w\-]*:?\/\//.test(e)) {
                            const t = o ? o.path : new gy(document.location.href).directory;
                            if ("" === (null == o ? void 0 : o.protocol)) e = "//mce_host" + n.toAbsPath(t, e);
                            else {
                                const r = /([^#?]*)([#?]?.*)/.exec(e);
                                r && (e = (o && o.protocol || "http") + "://mce_host" + n.toAbsPath(t, r[1]) + r[2])
                            }
                        }
                        e = e.replace(/@@/g, "(mce_at)");
                        const s = /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@\/]*):?([^:@\/]*))?@)?(\[[a-zA-Z0-9:.%]+\]|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/.exec(e);
                        s && iy(cy, ((e, t) => {
                            let o = s[t];
                            o && (o = o.replace(/\(mce_at\)/g, "@@")), n[e] = o
                        })), o && (n.protocol || (n.protocol = o.protocol), n.userInfo || (n.userInfo = o.userInfo), n.port || "mce_host" !== n.host || (n.port = o.port), n.host && "mce_host" !== n.host || (n.host = o.host), n.source = ""), r && (n.protocol = "")
                    }
                    static parseDataUri(e) {
                        let t;
                        const o = decodeURIComponent(e).split(","),
                            n = /data:([^;]+)/.exec(o[0]);
                        return n && (t = n[1]), {
                            type: t,
                            data: o[1]
                        }
                    }
                    static isDomSafe(e, t, o = {}) {
                        if (o.allow_script_urls) return !0; {
                            const n = zs.decode(e).replace(/[\s\u0000-\u001F]+/g, "");
                            return !my(o, n, t)
                        }
                    }
                    static getDocumentBaseUrl(e) {
                        var t;
                        let o;
                        return o = 0 !== e.protocol.indexOf("http") && "file:" !== e.protocol ? null !== (t = e.href) && void 0 !== t ? t : "" : e.protocol + "//" + e.host + e.pathname, /^[^:]+:\/\/\/?[^\/]+\//.test(o) && (o = o.replace(/[\?#].*$/, "").replace(/[\/\\][^\/]+$/, ""), /[\/\\]$/.test(o) || (o += "/")), o
                    }
                    setPath(e) {
                        const t = /^(.*?)\/?(\w+)?$/.exec(e);
                        t && (this.path = t[0], this.directory = t[1], this.file = t[2]), this.source = "", this.getURI()
                    }
                    toRelative(e) {
                        if ("./" === e) return e;
                        const t = new gy(e, {
                            base_uri: this
                        });
                        if ("mce_host" !== t.host && this.host !== t.host && t.host || this.port !== t.port || this.protocol !== t.protocol && "" !== t.protocol) return t.getURI();
                        const o = this.getURI(),
                            n = t.getURI();
                        if (o === n || "/" === o.charAt(o.length - 1) && o.substr(0, o.length - 1) === n) return o;
                        let r = this.toRelPath(this.path, t.path);
                        return t.query && (r += "?" + t.query), t.anchor && (r += "#" + t.anchor), r
                    }
                    toAbsolute(e, t) {
                        const o = new gy(e, {
                            base_uri: this
                        });
                        return o.getURI(t && this.isSameOrigin(o))
                    }
                    isSameOrigin(e) {
                        if (this.host == e.host && this.protocol == e.protocol) {
                            if (this.port == e.port) return !0;
                            const t = this.protocol ? dy[this.protocol] : null;
                            if (t && (this.port || t) == (e.port || t)) return !0
                        }
                        return !1
                    }
                    toRelPath(e, t) {
                        let o, n, r = 0,
                            s = "";
                        const a = e.substring(0, e.lastIndexOf("/")).split("/"),
                            i = t.split("/");
                        if (a.length >= i.length)
                            for (o = 0, n = a.length; o < n; o++)
                                if (o >= i.length || a[o] !== i[o]) {
                                    r = o + 1;
                                    break
                                }
                        if (a.length < i.length)
                            for (o = 0, n = i.length; o < n; o++)
                                if (o >= a.length || a[o] !== i[o]) {
                                    r = o + 1;
                                    break
                                }
                        if (1 === r) return t;
                        for (o = 0, n = a.length - (r - 1); o < n; o++) s += "../";
                        for (o = r - 1, n = i.length; o < n; o++) s += o !== r - 1 ? "/" + i[o] : i[o];
                        return s
                    }
                    toAbsPath(e, t) {
                        let o = 0;
                        const n = /\/$/.test(t) ? "/" : "",
                            r = e.split("/"),
                            s = t.split("/"),
                            a = [];
                        iy(r, (e => {
                            e && a.push(e)
                        }));
                        const i = [];
                        for (let e = s.length - 1; e >= 0; e--) 0 !== s[e].length && "." !== s[e] && (".." !== s[e] ? o > 0 ? o-- : i.push(s[e]) : o++);
                        const l = a.length - o;
                        let c;
                        return c = l <= 0 ? ne(i).join("/") : a.slice(0, l).join("/") + "/" + ne(i).join("/"), 0 !== c.indexOf("/") && (c = "/" + c), n && c.lastIndexOf("/") !== c.length - 1 && (c += n), c
                    }
                    getURI(e = !1) {
                        let t;
                        return this.source && !e || (t = "", e || (this.protocol ? t += this.protocol + "://" : t += "//", this.userInfo && (t += this.userInfo + "@"), this.host && (t += this.host), this.port && (t += ":" + this.port)), this.path && (t += this.path), this.query && (t += "?" + this.query), this.anchor && (t += "#" + this.anchor), this.source = t), this.source
                    }
                }
                const hy = Rt.makeMap,
                    py = Rt.extend,
                    fy = {
                        IN_PLACE: !0,
                        ALLOW_UNKNOWN_PROTOCOLS: !0,
                        ALLOWED_TAGS: ["#comment", "#cdata-section", "body"],
                        ALLOWED_ATTR: []
                    },
                    vy = Rt.makeMap("src,href,data,background,action,formaction,poster,xlink:href"),
                    by = "data-mce-type",
                    yy = (e, t) => {
                        const o = Yb(),
                            n = t.getSpecialElements(),
                            r = e.validate;
                        let s = 0;
                        return o.addHook("uponSanitizeElement", ((o, a) => {
                            var i, l, c;
                            8 === o.nodeType && !e.allow_conditional_comments && /^\[if/i.test(null !== (i = o.nodeValue) && void 0 !== i ? i : "") && (o.nodeValue = " " + o.nodeValue);
                            const d = a.tagName;
                            if (1 !== o.nodeType || "body" === d) return;
                            const u = go(o),
                                m = d.toLowerCase(),
                                h = Kt(u, by),
                                p = qt(u, "data-mce-bogus");
                            if (!h && g(p)) return void("all" === p ? rn(u) : sn(u));
                            const f = t.getElementRule(m);
                            if (!r || f) {
                                if (a.allowedTags[d] = !0, r && f && !h) {
                                    if (W(null !== (l = f.attributesForced) && void 0 !== l ? l : [], (e => {
                                            Wt(u, e.name, "{$uid}" === e.value ? "mce_" + s++ : e.value)
                                        })), W(null !== (c = f.attributesDefault) && void 0 !== c ? c : [], (e => {
                                            Kt(u, e.name) || Wt(u, e.name, "{$uid}" === e.value ? "mce_" + s++ : e.value)
                                        })), f.attributesRequired && !U(f.attributesRequired, (e => Kt(u, e)))) return void sn(u);
                                    if (f.removeEmptyAttrs && (e => {
                                            const t = e.dom.attributes;
                                            return null == t || 0 === t.length
                                        })(u)) return void sn(u);
                                    f.outputName && f.outputName !== m && ((e, t) => {
                                        const o = ((e, t) => {
                                            const o = uo(t),
                                                n = Xt(e);
                                            return $t(o, n), o
                                        })(e, t);
                                        Qo(e, o);
                                        const n = Mo(e);
                                        on(o, n), rn(e)
                                    })(u, f.outputName)
                                }
                            } else Se(n, m) ? rn(u) : sn(u)
                        })), o.addHook("uponSanitizeAttribute", ((o, n) => {
                            const s = o.tagName.toLowerCase(),
                                {
                                    attrName: a,
                                    attrValue: i
                                } = n;
                            n.keepAttr = !r || t.isValid(s, a) || Ve(a, "data-") || Ve(a, "aria-"), a in vy && my(e, i, s) && (n.keepAttr = !1), n.keepAttr ? (n.allowedAttributes[a] = !0, a in t.getBoolAttrs() && (n.attrValue = a), e.allow_svg_data_urls && Ve(i, "data:image/svg+xml") && (n.forceKeepAttr = !0)) : !o.hasAttribute(by) || "id" !== a && "class" !== a && "style" !== a || (n.forceKeepAttr = !0)
                        })), o
                    },
                    wy = (e, t, o) => {
                        const n = e.name,
                            r = n in o && "title" !== n && "textarea" !== n,
                            s = t.childNodes;
                        for (let t = 0, n = s.length; t < n; t++) {
                            const n = s[t],
                                a = new fh(n.nodeName.toLowerCase(), n.nodeType);
                            if (Rn(n)) {
                                const e = n.attributes;
                                for (let t = 0, o = e.length; t < o; t++) {
                                    const o = e[t];
                                    a.attr(o.name, o.value)
                                }
                            } else Vn(n) ? (a.value = n.data, r && (a.raw = !0)) : (jn(n) || Zn(n) || Un(n)) && (a.value = n.data);
                            wy(a, n, o), e.append(a)
                        }
                    },
                    xy = (e = {}, t = Js()) => {
                        const o = Jb(),
                            n = Jb(),
                            r = {
                                validate: !0,
                                root_name: "body",
                                ...e
                            },
                            s = new DOMParser,
                            a = yy(r, t),
                            i = o.addFilter,
                            l = o.getFilters,
                            c = o.removeFilter,
                            d = n.addFilter,
                            u = n.getFilters,
                            m = n.removeFilter,
                            h = (e, o) => {
                                const n = g(o.attr(by)),
                                    r = 1 === o.type && !Se(e, o.name) && !((e, t) => 1 === t.type && hs(e, t.name) && g(t.attr(ss)))(t, o);
                                return 3 === o.type || r && !n
                            },
                            p = {
                                schema: t,
                                addAttributeFilter: d,
                                getAttributeFilters: u,
                                removeAttributeFilter: m,
                                addNodeFilter: i,
                                getNodeFilters: l,
                                removeNodeFilter: c,
                                parse: (e, o = {}) => {
                                    var n;
                                    const i = r.validate,
                                        c = null !== (n = o.context) && void 0 !== n ? n : r.root_name,
                                        d = ((e, o, n = "html") => {
                                            const i = "xhtml" === n ? "application/xhtml+xml" : "text/html",
                                                l = Se(t.getSpecialElements(), o.toLowerCase()),
                                                c = l ? `<${o}>${e}</${o}>` : e,
                                                d = "xhtml" === n ? `<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>${c}</body></html>` : `<body>${c}</body>`,
                                                u = s.parseFromString(d, i).body;
                                            return a.sanitize(u, ((e, t) => {
                                                const o = { ...fy
                                                };
                                                return o.PARSER_MEDIA_TYPE = t, e.allow_script_urls ? o.ALLOWED_URI_REGEXP = /.*/ : e.allow_html_data_urls && (o.ALLOWED_URI_REGEXP = /^(?!(\w+script|mhtml):)/i), o
                                            })(r, i)), a.removed = [], l ? u.firstChild : u
                                        })(e, c, o.format);
                                    us(t, d);
                                    const m = new fh(c, 11);
                                    wy(m, d, t.getSpecialElements()), d.innerHTML = "";
                                    const [g, p] = ((e, t, o, n) => {
                                        const r = o.validate,
                                            s = t.getNonEmptyElements(),
                                            a = t.getWhitespaceElements(),
                                            i = py(hy("script,style,head,html,body,title,meta,param"), t.getBlockElements()),
                                            l = Ys(t),
                                            c = /[ \t\r\n]+/g,
                                            d = /^[ \t\r\n]+/,
                                            u = /[ \t\r\n]+$/,
                                            m = e => {
                                                let t = e.parent;
                                                for (; x(t);) {
                                                    if (t.name in a) return !0;
                                                    t = t.parent
                                                }
                                                return !1
                                            },
                                            g = e => e.name in i && !vs(t, e),
                                            h = (t, o) => {
                                                const r = o ? t.prev : t.next;
                                                return !x(r) && !w(t.parent) && g(t.parent) && (t.parent !== e || !0 === n.isRootContent)
                                            };
                                        return [e => {
                                            var t;
                                            if (3 === e.type && !m(e)) {
                                                let o = null !== (t = e.value) && void 0 !== t ? t : "";
                                                o = o.replace(c, " "), (((e, t) => x(e) && (t(e) || "br" === e.name))(e.prev, g) || h(e, !0)) && (o = o.replace(d, "")), 0 === o.length ? e.remove() : e.value = o
                                            }
                                        }, e => {
                                            var o;
                                            if (1 === e.type) {
                                                const o = t.getElementRule(e.name);
                                                if (r && o) {
                                                    const r = Ef(t, s, a, e);
                                                    o.paddInEmptyBlock && r && (e => {
                                                        let o = e;
                                                        for (; x(o);) {
                                                            if (o.name in l) return Ef(t, s, a, o);
                                                            o = o.parent
                                                        }
                                                        return !1
                                                    })(e) ? Of(n, g, e) : o.removeEmpty && r ? g(e) ? e.remove() : e.unwrap() : o.paddEmpty && (r || (e => {
                                                        var t;
                                                        return Tf(e, "#text") && (null === (t = null == e ? void 0 : e.firstChild) || void 0 === t ? void 0 : t.value) === or
                                                    })(e)) && Of(n, g, e)
                                                }
                                            } else if (3 === e.type && !m(e)) {
                                                let t = null !== (o = e.value) && void 0 !== o ? o : "";
                                                (e.next && g(e.next) || h(e, !1)) && (t = t.replace(u, "")), 0 === t.length ? e.remove() : e.value = t
                                            }
                                        }]
                                    })(m, t, r, o), f = [], v = i ? e => ((e, o) => {
                                        Nf(t, e) && o.push(e)
                                    })(e, f) : _, b = {
                                        nodes: {},
                                        attributes: {}
                                    }, y = e => Sf(l(), u(), e, b);
                                    if (((e, t, o) => {
                                            const n = [];
                                            for (let o = e, r = o; o; r = o, o = o.walk()) {
                                                const s = o;
                                                W(t, (e => e(s))), w(s.parent) && s !== e ? o = r : n.push(s)
                                            }
                                            for (let e = n.length - 1; e >= 0; e--) {
                                                const t = n[e];
                                                W(o, (e => e(t)))
                                            }
                                        })(m, [g, y], [p, v]), f.reverse(), i && f.length > 0)
                                        if (o.context) {
                                            const {
                                                pass: e,
                                                fail: n
                                            } = q(f, (e => e.parent === m));
                                            Mf(n, t, y), o.invalid = e.length > 0
                                        } else Mf(f, t, y);
                                    const C = ((e, t) => {
                                        var o;
                                        const n = null !== (o = t.forced_root_block) && void 0 !== o ? o : e.forced_root_block;
                                        return !1 === n ? "" : !0 === n ? "p" : n
                                    })(r, o);
                                    return C && ("body" === m.name || o.isRootContent) && ((e, o) => {
                                        const n = py(hy("script,style,head,html,body,title,meta,param"), t.getBlockElements()),
                                            s = /^[ \t\r\n]+/,
                                            a = /[ \t\r\n]+$/;
                                        let i = e.firstChild,
                                            l = null;
                                        const c = e => {
                                            var t, o;
                                            e && (i = e.firstChild, i && 3 === i.type && (i.value = null === (t = i.value) || void 0 === t ? void 0 : t.replace(s, "")), i = e.lastChild, i && 3 === i.type && (i.value = null === (o = i.value) || void 0 === o ? void 0 : o.replace(a, "")))
                                        };
                                        if (t.isValidChild(e.name, o.toLowerCase())) {
                                            for (; i;) {
                                                const t = i.next;
                                                h(n, i) ? (l || (l = new fh(o, 1), l.attr(r.forced_root_block_attrs), e.insert(l, i)), l.append(i)) : (c(l), l = null), i = t
                                            }
                                            c(l)
                                        }
                                    })(m, C), o.invalid || kf(b, o), m
                                }
                            };
                        return ((e, t) => {
                            const o = e.schema;
                            t.remove_trailing_brs && e.addNodeFilter("br", ((e, t, n) => {
                                const r = Rt.extend({}, o.getBlockElements()),
                                    s = o.getNonEmptyElements(),
                                    a = o.getWhitespaceElements();
                                r.body = 1;
                                const i = e => e.name in r && vs(o, e);
                                for (let t = 0, l = e.length; t < l; t++) {
                                    let l = e[t],
                                        c = l.parent;
                                    if (c && r[c.name] && l === c.lastChild) {
                                        let e = l.prev;
                                        for (; e;) {
                                            const t = e.name;
                                            if ("span" !== t || "bookmark" !== e.attr("data-mce-type")) {
                                                "br" === t && (l = null);
                                                break
                                            }
                                            e = e.prev
                                        }
                                        if (l && (l.remove(), Ef(o, s, a, c))) {
                                            const e = o.getElementRule(c.name);
                                            e && (e.removeEmpty ? c.remove() : e.paddEmpty && Of(n, i, c))
                                        }
                                    } else {
                                        let e = l;
                                        for (; c && c.firstChild === e && c.lastChild === e && (e = c, !r[c.name]);) c = c.parent;
                                        if (e === c) {
                                            const e = new fh("#text", 3);
                                            e.value = or, l.replace(e)
                                        }
                                    }
                                }
                            })), e.addAttributeFilter("href", (e => {
                                let o = e.length;
                                const n = e => {
                                    const t = e ? Rt.trim(e) : "";
                                    return /\b(noopener)\b/g.test(t) ? t : (e => e.split(" ").filter((e => e.length > 0)).concat(["noopener"]).sort().join(" "))(t)
                                };
                                if (!t.allow_unsafe_link_target)
                                    for (; o--;) {
                                        const t = e[o];
                                        "a" === t.name && "_blank" === t.attr("target") && t.attr("rel", n(t.attr("rel")))
                                    }
                            })), t.allow_html_in_named_anchor || e.addAttributeFilter("id,name", (e => {
                                let t, o, n, r, s = e.length;
                                for (; s--;)
                                    if (r = e[s], "a" === r.name && r.firstChild && !r.attr("href"))
                                        for (n = r.parent, t = r.lastChild; t && n;) o = t.prev, n.insert(t, r), t = o
                            })), t.fix_list_elements && e.addNodeFilter("ul,ol", (e => {
                                let t, o, n = e.length;
                                for (; n--;)
                                    if (t = e[n], o = t.parent, o && ("ul" === o.name || "ol" === o.name))
                                        if (t.prev && "li" === t.prev.name) t.prev.append(t);
                                        else {
                                            const e = new fh("li", 1);
                                            e.attr("style", "list-style-type: none"), t.wrap(e)
                                        }
                            }));
                            const n = o.getValidClasses();
                            t.validate && n && e.addAttributeFilter("class", (e => {
                                var t;
                                let o = e.length;
                                for (; o--;) {
                                    const r = e[o],
                                        s = null !== (t = r.attr("class")) && void 0 !== t ? t : "",
                                        a = Rt.explode(s, " ");
                                    let i = "";
                                    for (let e = 0; e < a.length; e++) {
                                        const t = a[e];
                                        let o = !1,
                                            s = n["*"];
                                        s && s[t] && (o = !0), s = n[r.name], !o && s && s[t] && (o = !0), o && (i && (i += " "), i += t)
                                    }
                                    i.length || (i = null), r.attr("class", i)
                                }
                            })), ((e, t) => {
                                const {
                                    blob_cache: o
                                } = t;
                                if (o) {
                                    const t = e => {
                                        const t = e.attr("src");
                                        (e => e.attr("src") === Et.transparentSrc || x(e.attr("data-mce-placeholder")))(e) || (e => x(e.attr("data-mce-bogus")))(e) || w(t) || ay(o, t, !0).each((t => {
                                            e.attr("src", t.blobUri())
                                        }))
                                    };
                                    e.addAttributeFilter("src", (e => W(e, t)))
                                }
                            })(e, t)
                        })(p, r), ((e, t, o) => {
                            t.inline_styles && Qb(e, t, o)
                        })(p, r, t), p
                    },
                    Cy = (e, t) => {
                        const o = (e => Vf(e) ? Oh({
                                validate: !1
                            }).serialize(e) : e)(e),
                            n = t(o);
                        if (n.isDefaultPrevented()) return n;
                        if (Vf(e)) {
                            if (n.content !== o) {
                                const t = xy({
                                    validate: !1,
                                    forced_root_block: !1
                                }).parse(n.content, {
                                    context: e.name
                                });
                                return { ...n,
                                    content: t
                                }
                            }
                            return { ...n,
                                content: e
                            }
                        }
                        return n
                    },
                    Sy = (e, t) => {
                        if (t.no_events) return qi.value(t); {
                            const o = ((e, t) => e.dispatch("BeforeGetContent", t))(e, t);
                            return o.isDefaultPrevented() ? qi.error(Dm(e, {
                                content: "",
                                ...o
                            }).content) : qi.value(o)
                        }
                    },
                    ky = (e, t, o) => o.no_events ? t : Cy(t, (t => Dm(e, { ...o,
                        content: t
                    }))).content,
                    _y = (e, t) => {
                        if (t.no_events) return qi.value(t); {
                            const o = Cy(t.content, (o => ((e, t) => e.dispatch("BeforeSetContent", t))(e, { ...t,
                                content: o
                            })));
                            return o.isDefaultPrevented() ? (Rm(e, o), qi.error(void 0)) : qi.value(o)
                        }
                    },
                    Oy = (e, t, o) => {
                        o.no_events || Rm(e, { ...o,
                            content: t
                        })
                    },
                    Ty = (e, t, o) => ({
                        element: e,
                        width: t,
                        rows: o
                    }),
                    Ey = (e, t) => ({
                        element: e,
                        cells: t
                    }),
                    Ay = (e, t) => ({
                        x: e,
                        y: t
                    }),
                    My = (e, t) => Gt(e, t).bind(Ke).getOr(1),
                    Ny = (e, t, o) => {
                        const n = e.rows;
                        return !!(n[o] ? n[o].cells : [])[t]
                    },
                    Ry = e => Y(e, ((e, t) => t.cells.length > e ? t.cells.length : e), 0),
                    Dy = (e, t) => {
                        const o = e.rows;
                        for (let e = 0; e < o.length; e++) {
                            const n = o[e].cells;
                            for (let o = 0; o < n.length; o++)
                                if (bo(n[o], t)) return I.some(Ay(o, e))
                        }
                        return I.none()
                    },
                    By = (e, t, o, n, r) => {
                        const s = [],
                            a = e.rows;
                        for (let e = o; e <= r; e++) {
                            const o = a[e].cells,
                                r = t < n ? o.slice(t, n + 1) : o.slice(n, t + 1);
                            s.push(Ey(a[e].element, r))
                        }
                        return s
                    },
                    Ly = e => ((e, t) => {
                        const o = Wa(e.element),
                            n = uo("tbody");
                        return on(n, t), tn(o, n), o
                    })(e, (e => j(e.rows, (e => {
                        const t = j(e.cells, (e => {
                                const t = $a(e);
                                return Yt(t, "colspan"), Yt(t, "rowspan"), t
                            })),
                            o = Wa(e.element);
                        return on(o, t), o
                    })))(e)),
                    Hy = (e, t) => {
                        const o = go(t.commonAncestorContainer),
                            n = qh(o, e),
                            r = G(n, wr),
                            s = ((e, t) => J(e, (e => "li" === Ht(e) && Bu(e, t))).fold(E([]), (t => (e => J(e, (e => "ul" === Ht(e) || "ol" === Ht(e))))(e).map((e => {
                                const t = uo(Ht(e)),
                                    o = ye(Yo(e), ((e, t) => Ve(t, "list-style")));
                                return $o(t, o), [uo("li"), t]
                            })).getOr([]))))(n, t),
                            a = r.concat(s.length ? s : (e => pr(e) ? So(e).filter(hr).fold(E([]), (t => [e, t])) : hr(e) ? [e] : [])(o));
                        return j(a, Wa)
                    },
                    Iy = () => eg([]),
                    Py = (e, t) => ((e, t) => _n(t, "table", N(bo, e)))(e, t[0]).bind((e => {
                        const o = t[0],
                            n = t[t.length - 1],
                            r = (e => {
                                const t = Ty(Wa(e), 0, []);
                                return W(rr(e, "tr"), ((e, o) => {
                                    W(rr(e, "td,th"), ((n, r) => {
                                        ((e, t, o, n, r) => {
                                            const s = My(r, "rowspan"),
                                                a = My(r, "colspan"),
                                                i = e.rows;
                                            for (let e = o; e < o + s; e++) {
                                                i[e] || (i[e] = Ey($a(n), []));
                                                for (let n = t; n < t + a; n++) i[e].cells[n] = e === o && n === t ? r : Wa(r)
                                            }
                                        })(t, ((e, t, o) => {
                                            for (; Ny(e, t, o);) t++;
                                            return t
                                        })(t, r, o), o, e, n)
                                    }))
                                })), Ty(t.element, Ry(t.rows), t.rows)
                            })(e);
                        return ((e, t, o) => Dy(e, t).bind((t => Dy(e, o).map((o => ((e, t, o) => {
                            const n = t.x,
                                r = t.y,
                                s = o.x,
                                a = o.y,
                                i = r < a ? By(e, n, r, s, a) : By(e, n, a, s, r);
                            return Ty(e.element, Ry(i), i)
                        })(e, t, o))))))(r, o, n).map((e => eg([Ly(e)])))
                    })).getOrThunk(Iy),
                    zy = (e, t) => {
                        const o = Au(t, e);
                        return o.length > 0 ? Py(e, o) : ((e, t) => t.length > 0 && t[0].collapsed ? Iy() : ((e, t) => ((e, t) => {
                            const o = Y(t, ((e, t) => (tn(t, e), t)), e);
                            return t.length > 0 ? eg([o]) : o
                        })(go(t.cloneContents()), Hy(e, t)))(e, t[0]))(e, t)
                    },
                    Fy = (e, t) => t >= 0 && t < e.length && yu(e.charAt(t)),
                    Vy = e => Or(e.innerText),
                    Zy = e => Rn(e) ? e.outerHTML : Vn(e) ? zs.encodeRaw(e.data, !1) : jn(e) ? "\x3c!--" + e.data + "--\x3e" : "",
                    Uy = (e, t) => (((e, t) => {
                        let o = 0;
                        W(e, (e => {
                            0 === e[0] ? o++ : 1 === e[0] ? (((e, t, o) => {
                                const n = (e => {
                                    let t;
                                    const o = document.createElement("div"),
                                        n = document.createDocumentFragment();
                                    for (e && (o.innerHTML = e); t = o.firstChild;) n.appendChild(t);
                                    return n
                                })(t);
                                if (e.hasChildNodes() && o < e.childNodes.length) {
                                    const t = e.childNodes[o];
                                    e.insertBefore(n, t)
                                } else e.appendChild(n)
                            })(t, e[1], o), o++) : 2 === e[0] && ((e, t) => {
                                if (e.hasChildNodes() && t < e.childNodes.length) {
                                    const o = e.childNodes[t];
                                    e.removeChild(o)
                                }
                            })(t, o)
                        }))
                    })(((e, t) => {
                        const o = e.length + t.length + 2,
                            n = new Array(o),
                            r = new Array(o),
                            s = (o, n, r, a, l) => {
                                const c = i(o, n, r, a);
                                if (null === c || c.start === n && c.diag === n - a || c.end === o && c.diag === o - r) {
                                    let s = o,
                                        i = r;
                                    for (; s < n || i < a;) s < n && i < a && e[s] === t[i] ? (l.push([0, e[s]]), ++s, ++i) : n - o > a - r ? (l.push([2, e[s]]), ++s) : (l.push([1, t[i]]), ++i)
                                } else {
                                    s(o, c.start, r, c.start - c.diag, l);
                                    for (let t = c.start; t < c.end; ++t) l.push([0, e[t]]);
                                    s(c.end, n, c.end - c.diag, a, l)
                                }
                            },
                            a = (o, n, r, s) => {
                                let a = o;
                                for (; a - n < s && a < r && e[a] === t[a - n];) ++a;
                                return ((e, t, o) => ({
                                    start: e,
                                    end: t,
                                    diag: o
                                }))(o, a, n)
                            },
                            i = (o, s, i, l) => {
                                const c = s - o,
                                    d = l - i;
                                if (0 === c || 0 === d) return null;
                                const u = c - d,
                                    m = d + c,
                                    g = (m % 2 == 0 ? m : m + 1) / 2;
                                let h, p, f, v, b;
                                for (n[1 + g] = o, r[1 + g] = s + 1, h = 0; h <= g; ++h) {
                                    for (p = -h; p <= h; p += 2) {
                                        for (f = p + g, p === -h || p !== h && n[f - 1] < n[f + 1] ? n[f] = n[f + 1] : n[f] = n[f - 1] + 1, v = n[f], b = v - o + i - p; v < s && b < l && e[v] === t[b];) n[f] = ++v, ++b;
                                        if (u % 2 != 0 && u - h <= p && p <= u + h && r[f - u] <= n[f]) return a(r[f - u], p + o - i, s, l)
                                    }
                                    for (p = u - h; p <= u + h; p += 2) {
                                        for (f = p + g - u, p === u - h || p !== u + h && r[f + 1] <= r[f - 1] ? r[f] = r[f + 1] - 1 : r[f] = r[f - 1], v = r[f] - 1, b = v - o + i - p; v >= o && b >= i && e[v] === t[b];) r[f] = v--, b--;
                                        if (u % 2 == 0 && -h <= p && p <= h && r[f] <= n[f + u]) return a(r[f], p + o - i, s, l)
                                    }
                                }
                                return null
                            },
                            l = [];
                        return s(0, e.length, 0, t.length, l), l
                    })(j(de(t.childNodes), Zy), e), t), t),
                    jy = Be((() => document.implementation.createHTMLDocument("undo"))),
                    Wy = e => {
                        const t = (o = e.getBody(), G(j(de(o.childNodes), Zy), (e => e.length > 0)));
                        var o;
                        const n = te(t, (t => {
                                const o = yh(e.serializer, t);
                                return o.length > 0 ? [o] : []
                            })),
                            r = n.join("");
                        return (e => -1 !== e.indexOf("</iframe>"))(r) ? (e => ({
                            type: "fragmented",
                            fragments: e,
                            content: "",
                            bookmark: null,
                            beforeBookmark: null
                        }))(n) : (e => ({
                            type: "complete",
                            fragments: null,
                            content: e,
                            bookmark: null,
                            beforeBookmark: null
                        }))(r)
                    },
                    $y = (e, t, o) => {
                        const n = o ? t.beforeBookmark : t.bookmark;
                        "fragmented" === t.type ? Uy(t.fragments, e.getBody()) : e.setContent(t.content, {
                            format: "raw",
                            no_selection: !x(n) || !au(n) || !n.isFakeCaret
                        }), n && (e.selection.moveToBookmark(n), e.selection.scrollIntoView())
                    },
                    qy = e => "fragmented" === e.type ? e.fragments.join("") : e.content,
                    Gy = e => {
                        const t = uo("body", jy());
                        return cn(t, qy(e)), W(rr(t, "*[data-mce-bogus]"), sn), ln(t)
                    },
                    Ky = (e, t) => !(!e || !t) && (!!((e, t) => qy(e) === qy(t))(e, t) || ((e, t) => Gy(e) === Gy(t))(e, t)),
                    Yy = e => 0 === e.get(),
                    Xy = (e, t, o) => {
                        Yy(o) && (e.typing = t)
                    },
                    Jy = (e, t) => {
                        e.typing && (Xy(e, !1, t), e.add())
                    },
                    Qy = e => ({
                        init: {
                            bindEvents: _
                        },
                        undoManager: {
                            beforeChange: (t, o) => ((e, t, o) => {
                                Yy(t) && o.set(ji(e.selection))
                            })(e, t, o),
                            add: (t, o, n, r, s, a) => ((e, t, o, n, r, s, a) => {
                                const i = Wy(e),
                                    l = Rt.extend(s || {}, i);
                                if (!Yy(n) || e.removed) return null;
                                const c = t.data[o.get()];
                                if (e.dispatch("BeforeAddUndo", {
                                        level: l,
                                        lastLevel: c,
                                        originalEvent: a
                                    }).isDefaultPrevented()) return null;
                                if (c && Ky(c, l)) return null;
                                t.data[o.get()] && r.get().each((e => {
                                    t.data[o.get()].beforeBookmark = e
                                }));
                                const d = lc(e);
                                if (d && t.data.length > d) {
                                    for (let e = 0; e < t.data.length - 1; e++) t.data[e] = t.data[e + 1];
                                    t.data.length--, o.set(t.data.length)
                                }
                                l.bookmark = ji(e.selection), o.get() < t.data.length - 1 && (t.data.length = o.get() + 1), t.data.push(l), o.set(t.data.length - 1);
                                const u = {
                                    level: l,
                                    lastLevel: c,
                                    originalEvent: a
                                };
                                return o.get() > 0 ? (e.setDirty(!0), e.dispatch("AddUndo", u), e.dispatch("change", u)) : e.dispatch("AddUndo", u), l
                            })(e, t, o, n, r, s, a),
                            undo: (t, o, n) => ((e, t, o, n) => {
                                let r;
                                return t.typing && (t.add(), t.typing = !1, Xy(t, !1, o)), n.get() > 0 && (n.set(n.get() - 1), r = t.data[n.get()], $y(e, r, !0), e.setDirty(!0), e.dispatch("Undo", {
                                    level: r
                                })), r
                            })(e, t, o, n),
                            redo: (t, o) => ((e, t, o) => {
                                let n;
                                return t.get() < o.length - 1 && (t.set(t.get() + 1), n = o[t.get()], $y(e, n, !1), e.setDirty(!0), e.dispatch("Redo", {
                                    level: n
                                })), n
                            })(e, t, o),
                            clear: (t, o) => ((e, t, o) => {
                                t.data = [], o.set(0), t.typing = !1, e.dispatch("ClearUndos")
                            })(e, t, o),
                            reset: e => (e => {
                                e.clear(), e.add()
                            })(e),
                            hasUndo: (t, o) => ((e, t, o) => o.get() > 0 || t.typing && t.data[0] && !Ky(Wy(e), t.data[0]))(e, t, o),
                            hasRedo: (e, t) => ((e, t) => t.get() < e.data.length - 1 && !e.typing)(e, t),
                            transact: (e, t, o) => ((e, t, o) => (Jy(e, t), e.beforeChange(), e.ignore(o), e.add()))(e, t, o),
                            ignore: (e, t) => ((e, t) => {
                                try {
                                    e.set(e.get() + 1), t()
                                } finally {
                                    e.set(e.get() - 1)
                                }
                            })(e, t),
                            extra: (t, o, n, r) => ((e, t, o, n, r) => {
                                if (t.transact(n)) {
                                    const n = t.data[o.get()].bookmark,
                                        s = t.data[o.get() - 1];
                                    $y(e, s, !0), t.transact(r) && (t.data[o.get() - 1].beforeBookmark = n)
                                }
                            })(e, t, o, n, r)
                        },
                        formatter: {
                            match: (t, o, n, r) => Jf(e, t, o, n, r),
                            matchAll: (t, o) => ((e, t, o) => {
                                const n = [],
                                    r = {},
                                    s = e.selection.getStart();
                                return e.dom.getParent(s, (s => {
                                    for (let a = 0; a < t.length; a++) {
                                        const i = t[a];
                                        !r[i] && Xf(e, s, i, o) && (r[i] = !0, n.push(i))
                                    }
                                }), e.dom.getRoot()), n
                            })(e, t, o),
                            matchNode: (t, o, n, r) => Xf(e, t, o, n, r),
                            canApply: t => ((e, t) => {
                                const o = e.formatter.get(t),
                                    n = e.dom;
                                if (o) {
                                    const t = e.selection.getStart(),
                                        r = em(n, t);
                                    for (let e = o.length - 1; e >= 0; e--) {
                                        const t = o[e];
                                        if (!nm(t)) return !0;
                                        for (let e = r.length - 1; e >= 0; e--)
                                            if (n.is(r[e], t.selector)) return !0
                                    }
                                }
                                return !1
                            })(e, t),
                            closest: t => ((e, t) => {
                                const o = t => bo(t, go(e.getBody()));
                                return I.from(e.selection.getStart(!0)).bind((n => Wf(go(n), (o => ue(t, (t => ((t, o) => Xf(e, t.dom, o) ? I.some(o) : I.none())(o, t)))), o))).getOrNull()
                            })(e, t),
                            apply: (t, o, n) => Wv(e, t, o, n),
                            remove: (t, o, n, r) => Vv(e, t, o, n, r),
                            toggle: (t, o, n) => ((e, t, o, n) => {
                                const r = e.formatter.get(t);
                                r && (!Jf(e, t, o, n) || "toggle" in r[0] && !r[0].toggle ? Wv(e, t, o, n) : Vv(e, t, o, n))
                            })(e, t, o, n),
                            formatChanged: (t, o, n, r, s) => ((e, t, o, n, r, s) => (((e, t, o, n, r, s) => {
                                const a = t.get();
                                W(o.split(","), (t => {
                                    const o = Ce(a, t).getOrThunk((() => {
                                            const e = {
                                                withSimilar: {
                                                    state: xa(!1),
                                                    similar: !0,
                                                    callbacks: []
                                                },
                                                withoutSimilar: {
                                                    state: xa(!1),
                                                    similar: !1,
                                                    callbacks: []
                                                },
                                                withVars: []
                                            };
                                            return a[t] = e, e
                                        })),
                                        i = () => {
                                            const o = Kv(e);
                                            return Gv(e, o, t, r, s).isSome()
                                        };
                                    if (y(s)) {
                                        const e = r ? o.withSimilar : o.withoutSimilar;
                                        e.callbacks.push(n), 1 === e.callbacks.length && e.state.set(i())
                                    } else o.withVars.push({
                                        state: xa(i()),
                                        similar: r,
                                        vars: s,
                                        callback: n
                                    })
                                })), t.set(a)
                            })(e, t, o, n, r, s), {
                                unbind: () => ((e, t, o) => {
                                    const n = e.get();
                                    W(t.split(","), (e => Ce(n, e).each((t => {
                                        n[e] = {
                                            withSimilar: { ...t.withSimilar,
                                                callbacks: G(t.withSimilar.callbacks, (e => e !== o))
                                            },
                                            withoutSimilar: { ...t.withoutSimilar,
                                                callbacks: G(t.withoutSimilar.callbacks, (e => e !== o))
                                            },
                                            withVars: G(t.withVars, (e => e.callback !== o))
                                        }
                                    })))), e.set(n)
                                })(t, o, n)
                            }))(e, t, o, n, r, s)
                        },
                        editor: {
                            getContent: t => ((e, t) => I.from(e.getBody()).fold(E("tree" === t.format ? new fh("body", 11) : ""), (o => Sh(e, t, o))))(e, t),
                            setContent: (t, o) => ((e, t, o) => I.from(e.getBody()).map((n => Vf(t) ? ((e, t, o, n) => {
                                _f(e.parser.getNodeFilters(), e.parser.getAttributeFilters(), o);
                                const r = Oh({
                                        validate: !1
                                    }, e.schema).serialize(o),
                                    s = br(go(t)) ? r : Rt.trim(r);
                                return Zf(e, s, n.no_selection), {
                                    content: o,
                                    html: s
                                }
                            })(e, n, t, o) : ((e, t, o, n) => {
                                if (0 === o.length || /^\s+$/.test(o)) {
                                    const r = '<br data-mce-bogus="1">';
                                    "TABLE" === t.nodeName ? o = "<tr><td>" + r + "</td></tr>" : /^(UL|OL)$/.test(t.nodeName) && (o = "<li>" + r + "</li>");
                                    const s = pl(e);
                                    return e.schema.isValidChild(t.nodeName.toLowerCase(), s.toLowerCase()) ? (o = r, o = e.dom.createHTML(s, fl(e), o)) : o || (o = r), Zf(e, o, n.no_selection), {
                                        content: o,
                                        html: o
                                    }
                                } {
                                    "raw" !== n.format && (o = Oh({
                                        validate: !1
                                    }, e.schema).serialize(e.parser.parse(o, {
                                        isRootContent: !0,
                                        insert: !0
                                    })));
                                    const r = br(go(t)) ? o : Rt.trim(o);
                                    return Zf(e, r, n.no_selection), {
                                        content: r,
                                        html: r
                                    }
                                }
                            })(e, n, t, o))).getOr({
                                content: t,
                                html: Vf(o.content) ? "" : o.content
                            }))(e, t, o),
                            insertContent: (t, o) => Ff(e, t, o),
                            addVisual: t => ((e, t) => {
                                const o = e.dom,
                                    n = x(t) ? t : e.getBody();
                                W(o.select("table,a", n), (t => {
                                    switch (t.nodeName) {
                                        case "TABLE":
                                            const n = fc(e),
                                                r = o.getAttrib(t, "border");
                                            r && "0" !== r || !e.hasVisual ? o.removeClass(t, n) : o.addClass(t, n);
                                            break;
                                        case "A":
                                            if (!o.getAttrib(t, "href")) {
                                                const n = o.getAttrib(t, "name") || t.id,
                                                    r = vc(e);
                                                n && e.hasVisual ? o.addClass(t, r) : o.removeClass(t, r)
                                            }
                                    }
                                })), e.dispatch("VisualAid", {
                                    element: t,
                                    hasVisual: e.hasVisual
                                })
                            })(e, t)
                        },
                        selection: {
                            getContent: (t, o) => ((e, t, o = {}) => {
                                const n = ((e, t) => ({ ...e,
                                    format: t,
                                    get: !0,
                                    selection: !0,
                                    getInner: !0
                                }))(o, t);
                                return Sy(e, n).fold(A, (t => {
                                    const o = ((e, t) => {
                                        if ("text" === t.format) return (e => I.from(e.selection.getRng()).map((t => {
                                            var o;
                                            const n = I.from(e.dom.getParent(t.commonAncestorContainer, e.dom.isBlock)),
                                                r = e.getBody(),
                                                s = (e => e.map((e => e.nodeName)).getOr("div").toLowerCase())(n),
                                                a = go(t.cloneContents());
                                            xh(a), Ch(a);
                                            const i = e.dom.add(r, s, {
                                                    "data-mce-bogus": "all",
                                                    style: "overflow: hidden; opacity: 0;"
                                                }, a.dom),
                                                l = Vy(i),
                                                c = Or(null !== (o = i.textContent) && void 0 !== o ? o : "");
                                            if (e.dom.remove(i), Fy(c, 0) || Fy(c, c.length - 1)) {
                                                const e = n.getOr(r),
                                                    t = Vy(e),
                                                    o = t.indexOf(l);
                                                return -1 === o ? l : (Fy(t, o - 1) ? " " : "") + l + (Fy(t, o + l.length) ? " " : "")
                                            }
                                            return l
                                        })).getOr(""))(e); {
                                            const o = ((e, t) => {
                                                const o = e.selection.getRng(),
                                                    n = e.dom.create("body"),
                                                    r = e.selection.getSel(),
                                                    s = ah(e, Eu(r)),
                                                    a = t.contextual ? zy(go(e.getBody()), s).dom : o.cloneContents();
                                                return a && n.appendChild(a), e.selection.serializer.serialize(n, t)
                                            })(e, t);
                                            return "tree" === t.format ? o : e.selection.isCollapsed() ? "" : o
                                        }
                                    })(e, t);
                                    return ky(e, o, t)
                                }))
                            })(e, t, o)
                        },
                        autocompleter: {
                            addDecoration: t => dh(e, t),
                            removeDecoration: () => ((e, t) => uh(t).each((t => {
                                const o = e.selection.getBookmark();
                                sn(t), e.selection.moveToBookmark(o)
                            })))(e, go(e.getBody()))
                        },
                        raw: {
                            getModel: () => I.none()
                        }
                    }),
                    ew = e => Se(e.plugins, "rtc"),
                    tw = e => e.rtcInstance ? e.rtcInstance : Qy(e),
                    ow = e => {
                        const t = e.rtcInstance;
                        if (t) return t;
                        throw new Error("Failed to get RTC instance not yet initialized.")
                    },
                    nw = e => ow(e).init.bindEvents(),
                    rw = e => 0 === e.dom.length ? (rn(e), I.none()) : I.some(e),
                    sw = (e, t, o, n) => {
                        e.bind((e => ((n ? kp : Sp)(e.dom, n ? e.dom.length : 0), t.filter(Ft).map((t => ((e, t, o, n) => {
                            const r = e.dom,
                                s = t.dom,
                                a = n ? r.length : s.length;
                            n ? (_p(r, s, !1, !n), o.setStart(s, a)) : (_p(s, r, !1, !n), o.setEnd(s, a))
                        })(e, t, o, n)))))).orThunk((() => {
                            const e = ((e, t) => e.filter((e => Tm.isBookmarkNode(e.dom))).bind(t ? To : Oo))(t, n).or(t).filter(Ft);
                            return e.map((e => ((e, t) => {
                                So(e).each((o => {
                                    const n = e.dom;
                                    t && hp(o, Si(n, 0)) ? Sp(n, 0) : !t && pp(o, Si(n, n.length)) && kp(n, n.length)
                                }))
                            })(e, n)))
                        }))
                    },
                    aw = (e, t, o) => {
                        if (Se(e, t)) {
                            const n = G(e[t], (e => e !== o));
                            0 === n.length ? delete e[t] : e[t] = n
                        }
                    };
                const iw = e => !(!e || !e.ownerDocument) && yo(go(e.ownerDocument), go(e)),
                    lw = (e, t, o, n) => {
                        let r, s;
                        const {
                            selectorChangedWithUnbind: a
                        } = ((e, t) => {
                            let o, n;
                            const r = (t, o) => J(o, (o => e.is(o, t))),
                                s = t => e.getParents(t, void 0, e.getRoot());
                            return {
                                selectorChangedWithUnbind: (e, a) => (o || (o = {}, n = {}, t.on("NodeChange", (e => {
                                    const t = e.element,
                                        a = s(t),
                                        i = {};
                                    he(o, ((e, t) => {
                                        r(t, a).each((o => {
                                            n[t] || (W(e, (e => {
                                                e(!0, {
                                                    node: o,
                                                    selector: t,
                                                    parents: a
                                                })
                                            })), n[t] = e), i[t] = e
                                        }))
                                    })), he(n, ((e, o) => {
                                        i[o] || (delete n[o], W(e, (e => {
                                            e(!1, {
                                                node: t,
                                                selector: o,
                                                parents: a
                                            })
                                        })))
                                    }))
                                }))), o[e] || (o[e] = []), o[e].push(a), r(e, s(t.selection.getStart())).each((() => {
                                    n[e] = o[e]
                                })), {
                                    unbind: () => {
                                        aw(o, e, a), aw(n, e, a)
                                    }
                                })
                            }
                        })(e, n), i = (e, t) => ((e, t, o = {}) => {
                            const n = ((e, t) => ({
                                format: "html",
                                ...e,
                                set: !0,
                                selection: !0,
                                content: t
                            }))(o, t);
                            _y(e, n).each((t => {
                                const o = ((e, t) => {
                                        if ("raw" !== t.format) {
                                            const o = e.selection.getRng(),
                                                n = e.dom.getParent(o.commonAncestorContainer, e.dom.isBlock),
                                                r = n ? {
                                                    context: n.nodeName.toLowerCase()
                                                } : {},
                                                s = e.parser.parse(t.content, {
                                                    forced_root_block: !1,
                                                    ...r,
                                                    ...t
                                                });
                                            return Oh({
                                                validate: !1
                                            }, e.schema).serialize(s)
                                        }
                                        return t.content
                                    })(e, t),
                                    n = e.selection.getRng();
                                ((e, t) => {
                                    const o = I.from(t.firstChild).map(go),
                                        n = I.from(t.lastChild).map(go);
                                    e.deleteContents(), e.insertNode(t);
                                    const r = o.bind(Oo).filter(Ft).bind(rw),
                                        s = n.bind(To).filter(Ft).bind(rw);
                                    sw(r, o, e, !0), sw(s, n, e, !1), e.collapse(!1)
                                })(n, n.createContextualFragment(o)), e.selection.setRng(n), Dg(e, n), Oy(e, o, t)
                            }))
                        })(n, e, t), l = e => {
                            const t = d();
                            t.collapse(!!e), u(t)
                        }, c = () => t.getSelection ? t.getSelection() : t.document.selection, d = () => {
                            let o;
                            const a = (e, t, o) => {
                                    try {
                                        return t.compareBoundaryPoints(e, o)
                                    } catch (e) {
                                        return -1
                                    }
                                },
                                i = t.document;
                            if (x(n.bookmark) && !eh(n)) {
                                const e = jg(n);
                                if (e.isSome()) return e.map((e => ah(n, [e])[0])).getOr(i.createRange())
                            }
                            try {
                                const e = c();
                                e && !Nn(e.anchorNode) && (o = e.rangeCount > 0 ? e.getRangeAt(0) : i.createRange(), o = ah(n, [o])[0])
                            } catch (e) {}
                            if (o || (o = i.createRange()), Wn(o.startContainer) && o.collapsed) {
                                const t = e.getRoot();
                                o.setStart(t, 0), o.setEnd(t, 0)
                            }
                            return r && s && (0 === a(o.START_TO_START, o, r) && 0 === a(o.END_TO_END, o, r) ? o = s : (r = null, s = null)), o
                        }, u = (e, t) => {
                            if (!(e => !!e && iw(e.startContainer) && iw(e.endContainer))(e)) return;
                            const o = c();
                            if (e = n.dispatch("SetSelectionRange", {
                                    range: e,
                                    forward: t
                                }).range, o) {
                                s = e;
                                try {
                                    o.removeAllRanges(), o.addRange(e)
                                } catch (e) {}!1 === t && o.extend && (o.collapse(e.endContainer, e.endOffset), o.extend(e.startContainer, e.startOffset)), r = o.rangeCount > 0 ? o.getRangeAt(0) : null
                            }
                            if (!e.collapsed && e.startContainer === e.endContainer && (null == o ? void 0 : o.setBaseAndExtent) && e.endOffset - e.startOffset < 2 && e.startContainer.hasChildNodes()) {
                                const t = e.startContainer.childNodes[e.startOffset];
                                t && "IMG" === t.nodeName && (o.setBaseAndExtent(e.startContainer, e.startOffset, e.endContainer, e.endOffset), o.anchorNode === e.startContainer && o.focusNode === e.endContainer || o.setBaseAndExtent(t, 0, t, 1))
                            }
                            n.dispatch("AfterSetSelectionRange", {
                                range: e,
                                forward: t
                            })
                        }, m = () => {
                            const t = c(),
                                o = null == t ? void 0 : t.anchorNode,
                                n = null == t ? void 0 : t.focusNode;
                            if (!t || !o || !n || Nn(o) || Nn(n)) return !0;
                            const r = e.createRng(),
                                s = e.createRng();
                            try {
                                r.setStart(o, t.anchorOffset), r.collapse(!0), s.setStart(n, t.focusOffset), s.collapse(!0)
                            } catch (e) {
                                return !0
                            }
                            return r.compareBoundaryPoints(r.START_TO_START, s) <= 0
                        }, g = {
                            dom: e,
                            win: t,
                            serializer: o,
                            editor: n,
                            expand: (t = {
                                type: "word"
                            }) => u(gg(e).expand(d(), t)),
                            collapse: l,
                            setCursorLocation: (t, o) => {
                                const r = e.createRng();
                                x(t) && x(o) ? (r.setStart(t, o), r.setEnd(t, o), u(r), l(!1)) : (Lu(e, r, n.getBody(), !0), u(r))
                            },
                            getContent: e => ((e, t = {}) => ((e, t, o) => ow(e).selection.getContent(t, o))(e, t.format ? t.format : "html", t))(n, e),
                            setContent: i,
                            getBookmark: (e, t) => h.getBookmark(e, t),
                            moveToBookmark: e => h.moveToBookmark(e),
                            select: (t, o) => (((e, t, o) => I.from(t).bind((t => I.from(t.parentNode).map((n => {
                                const r = e.nodeIndex(t),
                                    s = e.createRng();
                                return s.setStart(n, r), s.setEnd(n, r + 1), o && (Lu(e, s, t, !0), Lu(e, s, t, !1)), s
                            })))))(e, t, o).each(u), t),
                            isCollapsed: () => {
                                const e = d(),
                                    t = c();
                                return !(!e || e.item) && (e.compareEndPoints ? 0 === e.compareEndPoints("StartToEnd", e) : !t || e.collapsed)
                            },
                            isForward: m,
                            setNode: t => (i(e.getOuterHTML(t)), t),
                            getNode: () => ((e, t) => {
                                if (!t) return e;
                                let o = t.startContainer,
                                    n = t.endContainer;
                                const r = t.startOffset,
                                    s = t.endOffset;
                                let a = t.commonAncestorContainer;
                                t.collapsed || (o === n && s - r < 2 && o.hasChildNodes() && (a = o.childNodes[r]), Vn(o) && Vn(n) && (o = o.length === r ? sh(o.nextSibling, !0) : o.parentNode, n = 0 === s ? sh(n.previousSibling, !1) : n.parentNode, o && o === n && (a = o)));
                                const i = Vn(a) ? a.parentNode : a;
                                return Rn(i) ? i : e
                            })(n.getBody(), d()),
                            getSel: c,
                            setRng: u,
                            getRng: d,
                            getStart: e => nh(n.getBody(), d(), e),
                            getEnd: e => rh(n.getBody(), d(), e),
                            getSelectedBlocks: (t, o) => ((e, t, o, n) => {
                                const r = [],
                                    s = e.getRoot(),
                                    a = e.getParent(o || nh(s, t, t.collapsed), e.isBlock),
                                    i = e.getParent(n || rh(s, t, t.collapsed), e.isBlock);
                                if (a && a !== s && r.push(a), a && i && a !== i) {
                                    let t = a;
                                    const o = new An(a, s);
                                    for (;
                                        (t = o.next()) && t !== i;) e.isBlock(t) && r.push(t)
                                }
                                return i && a !== i && i !== s && r.push(i), r
                            })(e, d(), t, o),
                            normalize: () => {
                                const t = d(),
                                    o = c();
                                if (!(Eu(o).length > 1) && Hu(n)) {
                                    const o = dg(e, t);
                                    return o.each((e => {
                                        u(e, m())
                                    })), o.getOr(t)
                                }
                                return t
                            },
                            selectorChanged: (e, t) => (a(e, t), g),
                            selectorChangedWithUnbind: a,
                            getScrollContainer: () => {
                                let t, o = e.getRoot();
                                for (; o && "BODY" !== o.nodeName;) {
                                    if (o.scrollHeight > o.clientHeight) {
                                        t = o;
                                        break
                                    }
                                    o = o.parentNode
                                }
                                return t
                            },
                            scrollIntoView: (e, t) => {
                                x(e) ? ((e, t, o) => {
                                    (e.inline ? Mg : Rg)(e, t, o)
                                })(n, e, t) : Dg(n, d(), t)
                            },
                            placeCaretAt: (e, t) => u(og(e, t, n.getDoc())),
                            getBoundingClientRect: () => {
                                const e = d();
                                return e.collapsed ? Si.fromRangeStart(e).getClientRects()[0] : e.getBoundingClientRect()
                            },
                            destroy: () => {
                                t = r = s = null, p.destroy()
                            }
                        }, h = Tm(g), p = Fm(g, n);
                        return g.bookmarkManager = h, g.controlSelection = p, g
                    },
                    cw = (e, t, o) => {
                        -1 === Rt.inArray(t, o) && (e.addAttributeFilter(o, ((e, t) => {
                            let o = e.length;
                            for (; o--;) e[o].attr(t, null)
                        })), t.push(o))
                    },
                    dw = (e, t) => {
                        const o = ["data-mce-selected"],
                            n = t && t.dom ? t.dom : ba.DOM,
                            r = t && t.schema ? t.schema : Js(e);
                        e.entity_encoding = e.entity_encoding || "named", e.remove_trailing_brs = !("remove_trailing_brs" in e) || e.remove_trailing_brs;
                        const s = xy(e, r);
                        return ((e, t, o) => {
                            e.addAttributeFilter("data-mce-tabindex", ((e, t) => {
                                let o = e.length;
                                for (; o--;) {
                                    const n = e[o];
                                    n.attr("tabindex", n.attr("data-mce-tabindex")), n.attr(t, null)
                                }
                            })), e.addAttributeFilter("src,href,style", ((e, n) => {
                                const r = "data-mce-" + n,
                                    s = t.url_converter,
                                    a = t.url_converter_scope;
                                let i = e.length;
                                for (; i--;) {
                                    const t = e[i];
                                    let l = t.attr(r);
                                    void 0 !== l ? (t.attr(n, l.length > 0 ? l : null), t.attr(r, null)) : (l = t.attr(n), "style" === n ? l = o.serializeStyle(o.parseStyle(l), t.name) : s && (l = s.call(a, l, n, t.name)), t.attr(n, l.length > 0 ? l : null))
                                }
                            })), e.addAttributeFilter("class", (e => {
                                let t = e.length;
                                for (; t--;) {
                                    const o = e[t];
                                    let n = o.attr("class");
                                    n && (n = n.replace(/(?:^|\s)mce-item-\w+(?!\S)/g, ""), o.attr("class", n.length > 0 ? n : null))
                                }
                            })), e.addAttributeFilter("data-mce-type", ((e, t, o) => {
                                let n = e.length;
                                for (; n--;) {
                                    const t = e[n];
                                    if ("bookmark" === t.attr("data-mce-type") && !o.cleanup) {
                                        const e = I.from(t.firstChild).exists((e => {
                                            var t;
                                            return !_r(null !== (t = e.value) && void 0 !== t ? t : "")
                                        }));
                                        e ? t.unwrap() : t.remove()
                                    }
                                }
                            })), e.addNodeFilter("noscript", (e => {
                                var t;
                                let o = e.length;
                                for (; o--;) {
                                    const n = e[o].firstChild;
                                    n && (n.value = zs.decode(null !== (t = n.value) && void 0 !== t ? t : ""))
                                }
                            })), e.addNodeFilter("script,style", ((e, o) => {
                                var n;
                                const r = e => e.replace(/(<!--\[CDATA\[|\]\]-->)/g, "\n").replace(/^[\r\n]*|[\r\n]*$/g, "").replace(/^\s*((<!--)?(\s*\/\/)?\s*<!\[CDATA\[|(<!--\s*)?\/\*\s*<!\[CDATA\[\s*\*\/|(\/\/)?\s*<!--|\/\*\s*<!--\s*\*\/)\s*[\r\n]*/gi, "").replace(/\s*(\/\*\s*\]\]>\s*\*\/(-->)?|\s*\/\/\s*\]\]>(-->)?|\/\/\s*(-->)?|\]\]>|\/\*\s*-->\s*\*\/|\s*-->\s*)\s*$/g, "");
                                let s = e.length;
                                for (; s--;) {
                                    const a = e[s],
                                        i = a.firstChild,
                                        l = null !== (n = null == i ? void 0 : i.value) && void 0 !== n ? n : "";
                                    if ("script" === o) {
                                        const e = a.attr("type");
                                        e && a.attr("type", "mce-no/type" === e ? null : e.replace(/^mce\-/, "")), "xhtml" === t.element_format && i && l.length > 0 && (i.value = "// <![CDATA[\n" + r(l) + "\n// ]]>")
                                    } else "xhtml" === t.element_format && i && l.length > 0 && (i.value = "\x3c!--\n" + r(l) + "\n--\x3e")
                                }
                            })), e.addNodeFilter("#comment", (e => {
                                let n = e.length;
                                for (; n--;) {
                                    const r = e[n],
                                        s = r.value;
                                    t.preserve_cdata && 0 === (null == s ? void 0 : s.indexOf("[CDATA[")) ? (r.name = "#cdata", r.type = 4, r.value = o.decode(s.replace(/^\[CDATA\[|\]\]$/g, ""))) : 0 === (null == s ? void 0 : s.indexOf("mce:protected ")) && (r.name = "#text", r.type = 3, r.raw = !0, r.value = unescape(s).substr(14))
                                }
                            })), e.addNodeFilter("xml:namespace,input", ((e, t) => {
                                let o = e.length;
                                for (; o--;) {
                                    const n = e[o];
                                    7 === n.type ? n.remove() : 1 === n.type && ("input" !== t || n.attr("type") || n.attr("type", "text"))
                                }
                            })), e.addAttributeFilter("data-mce-type", (t => {
                                W(t, (t => {
                                    "format-caret" === t.attr("data-mce-type") && (t.isEmpty(e.schema.getNonEmptyElements()) ? t.remove() : t.unwrap())
                                }))
                            })), e.addAttributeFilter("data-mce-src,data-mce-href,data-mce-style,data-mce-selected,data-mce-expando,data-mce-block,data-mce-type,data-mce-resize,data-mce-placeholder", ((e, t) => {
                                let o = e.length;
                                for (; o--;) e[o].attr(t, null)
                            }))
                        })(s, e, n), {
                            schema: r,
                            addNodeFilter: s.addNodeFilter,
                            addAttributeFilter: s.addAttributeFilter,
                            serialize: (o, a = {}) => {
                                const i = {
                                        format: "html",
                                        ...a
                                    },
                                    l = ((e, t, o) => ((e, t) => x(e) && e.hasEventListeners("PreProcess") && !t.no_events)(e, o) ? ((e, t, o) => {
                                        let n;
                                        const r = e.dom;
                                        let s = t.cloneNode(!0);
                                        const a = document.implementation;
                                        if (a.createHTMLDocument) {
                                            const e = a.createHTMLDocument("");
                                            Rt.each("BODY" === s.nodeName ? s.childNodes : [s], (t => {
                                                e.body.appendChild(e.importNode(t, !0))
                                            })), s = "BODY" !== s.nodeName ? e.body.firstChild : e.body, n = r.doc, r.doc = e
                                        }
                                        return ((e, t) => {
                                            e.dispatch("PreProcess", t)
                                        })(e, { ...o,
                                            node: s
                                        }), n && (r.doc = n), s
                                    })(e, t, o) : t)(t, o, i),
                                    c = ((e, t, o) => {
                                        const n = Or(o.getInner ? t.innerHTML : e.getOuterHTML(t));
                                        return o.selection || br(go(t)) ? n : Rt.trim(n)
                                    })(n, l, i),
                                    d = ((e, t, o) => {
                                        const n = o.selection ? {
                                                forced_root_block: !1,
                                                ...o
                                            } : o,
                                            r = e.parse(t, n);
                                        return (e => {
                                            const t = e => "br" === (null == e ? void 0 : e.name),
                                                o = e.lastChild;
                                            if (t(o)) {
                                                const e = o.prev;
                                                t(e) && (o.remove(), e.remove())
                                            }
                                        })(r), r
                                    })(s, c, i);
                                return "tree" === i.format ? d : ((e, t, o, n, r) => {
                                    const s = ((e, t, o) => Oh(e, t).serialize(o))(t, o, n);
                                    return ((e, t, o) => {
                                        if (!t.no_events && e) {
                                            const n = ((e, t) => e.dispatch("PostProcess", t))(e, { ...t,
                                                content: o
                                            });
                                            return n.content
                                        }
                                        return o
                                    })(e, r, s)
                                })(t, e, r, d, i)
                            },
                            addRules: r.addValidElements,
                            setRules: r.setValidElements,
                            addTempAttr: N(cw, s, o),
                            getTempAttrs: E(o),
                            getNodeFilters: s.getNodeFilters,
                            getAttributeFilters: s.getAttributeFilters,
                            removeNodeFilter: s.removeNodeFilter,
                            removeAttributeFilter: s.removeAttributeFilter
                        }
                    },
                    uw = (e, t) => {
                        const o = dw(e, t);
                        return {
                            schema: o.schema,
                            addNodeFilter: o.addNodeFilter,
                            addAttributeFilter: o.addAttributeFilter,
                            serialize: o.serialize,
                            addRules: o.addRules,
                            setRules: o.setRules,
                            addTempAttr: o.addTempAttr,
                            getTempAttrs: o.getTempAttrs,
                            getNodeFilters: o.getNodeFilters,
                            getAttributeFilters: o.getAttributeFilters,
                            removeNodeFilter: o.removeNodeFilter,
                            removeAttributeFilter: o.removeAttributeFilter
                        }
                    },
                    mw = (e, t, o = {}) => {
                        const n = ((e, t) => ({
                            format: "html",
                            ...e,
                            set: !0,
                            content: t
                        }))(o, t);
                        return _y(e, n).map((t => {
                            const o = ((e, t, o) => tw(e).editor.setContent(t, o))(e, t.content, t);
                            return Oy(e, o.html, t), o.content
                        })).getOr(t)
                    },
                    gw = "autoresize_on_init,content_editable_state,padd_empty_with_br,block_elements,boolean_attributes,editor_deselector,editor_selector,elements,file_browser_callback_types,filepicker_validator_handler,force_hex_style_colors,force_p_newlines,gecko_spellcheck,images_dataimg_filter,media_scripts,mode,move_caret_before_on_enter_elements,non_empty_elements,self_closing_elements,short_ended_elements,special,spellchecker_select_languages,spellchecker_whitelist,tab_focus,tabfocus_elements,table_responsive_width,text_block_elements,text_inline_elements,toolbar_drawer,types,validate,whitespace_elements,paste_enable_default_filters,paste_filter_drop,paste_word_valid_elements,paste_retain_style_properties,paste_convert_word_fake_lists".split(","),
                    hw = "bbcode,colorpicker,contextmenu,fullpage,legacyoutput,spellchecker,textcolor".split(","),
                    pw = e => {
                        const t = G(gw, (t => Se(e, t))),
                            o = e.forced_root_block;
                        return !1 !== o && "" !== o || t.push("forced_root_block (false only)"), ae(t)
                    },
                    fw = e => {
                        const t = Rt.makeMap(e.plugins, " "),
                            o = G(hw, (e => Se(t, e)));
                        return ae(o)
                    },
                    vw = ba.DOM,
                    bw = e => I.from(e).each((e => e.destroy())),
                    yw = (() => {
                        const e = {};
                        return {
                            add: (t, o) => {
                                e[t] = o
                            },
                            get: t => e[t] ? e[t] : {
                                icons: {}
                            },
                            has: t => Se(e, t)
                        }
                    })(),
                    ww = Oa.ModelManager,
                    xw = (e, t) => t.dom[e],
                    Cw = (e, t) => parseInt(qo(t, e), 10),
                    Sw = N(xw, "clientWidth"),
                    kw = N(xw, "clientHeight"),
                    _w = N(Cw, "margin-top"),
                    Ow = N(Cw, "margin-left"),
                    Tw = e => {
                        const t = [],
                            o = () => {
                                const t = e.theme;
                                return t && t.getNotificationManagerImpl ? t.getNotificationManagerImpl() : (() => {
                                    const e = () => {
                                        throw new Error("Theme did not provide a NotificationManager implementation.")
                                    };
                                    return {
                                        open: e,
                                        close: e,
                                        getArgs: e
                                    }
                                })()
                            },
                            n = () => I.from(t[0]),
                            r = () => {
                                W(t, (e => {
                                    e.reposition()
                                }))
                            },
                            s = e => {
                                Q(t, (t => t === e)).each((e => {
                                    t.splice(e, 1)
                                }))
                            },
                            a = (a, i = !0) => e.removed || !(e => {
                                return (t = e.inline ? e.getBody() : e.getContentAreaContainer(), I.from(t).map(go)).map(Uo).getOr(!1);
                                var t
                            })(e) ? {} : (i && e.dispatch("BeforeOpenNotification", {
                                notification: a
                            }), J(t, (e => {
                                return t = o().getArgs(e), n = a, !(t.type !== n.type || t.text !== n.text || t.progressBar || t.timeout || n.progressBar || n.timeout);
                                var t, n
                            })).getOrThunk((() => {
                                e.editorManager.setActive(e);
                                const i = o().open(a, (() => {
                                    s(i), r(), n().fold((() => e.focus()), (e => Bg(go(e.getEl()))))
                                }));
                                return (e => {
                                    t.push(e)
                                })(i), r(), e.dispatch("OpenNotification", {
                                    notification: { ...i
                                    }
                                }), i
                            }))),
                            i = E(t);
                        return (e => {
                            e.on("SkinLoaded", (() => {
                                const t = $l(e);
                                t && a({
                                    text: t,
                                    type: "warning",
                                    timeout: 0
                                }, !1), r()
                            })), e.on("show ResizeEditor ResizeWindow NodeChange", (() => {
                                requestAnimationFrame(r)
                            })), e.on("remove", (() => {
                                W(t.slice(), (e => {
                                    o().close(e)
                                }))
                            }))
                        })(e), {
                            open: a,
                            close: () => {
                                n().each((e => {
                                    o().close(e), s(e), r()
                                }))
                            },
                            getNotifications: i
                        }
                    },
                    Ew = Oa.PluginManager,
                    Aw = Oa.ThemeManager,
                    Mw = e => {
                        let t = [];
                        const o = () => {
                                const t = e.theme;
                                return t && t.getWindowManagerImpl ? t.getWindowManagerImpl() : (() => {
                                    const e = () => {
                                        throw new Error("Theme did not provide a WindowManager implementation.")
                                    };
                                    return {
                                        open: e,
                                        openUrl: e,
                                        alert: e,
                                        confirm: e,
                                        close: e
                                    }
                                })()
                            },
                            n = (e, t) => (...o) => t ? t.apply(e, o) : void 0,
                            r = o => {
                                (t => {
                                    e.dispatch("CloseWindow", {
                                        dialog: t
                                    })
                                })(o), t = G(t, (e => e !== o)), 0 === t.length && e.focus()
                            },
                            s = o => {
                                e.editorManager.setActive(e), Ug(e), e.ui.show();
                                const n = o();
                                return (o => {
                                    t.push(o), (t => {
                                        e.dispatch("OpenWindow", {
                                            dialog: t
                                        })
                                    })(o)
                                })(n), n
                            };
                        return e.on("remove", (() => {
                            W(t, (e => {
                                o().close(e)
                            }))
                        })), {
                            open: (e, t) => s((() => o().open(e, t, r))),
                            openUrl: e => s((() => o().openUrl(e, r))),
                            alert: (e, t, r) => {
                                const s = o();
                                s.alert(e, n(r || s, t))
                            },
                            confirm: (e, t, r) => {
                                const s = o();
                                s.confirm(e, n(r || s, t))
                            },
                            close: () => {
                                I.from(t[t.length - 1]).each((e => {
                                    o().close(e), r(e)
                                }))
                            }
                        }
                    },
                    Nw = (e, t) => {
                        e.notificationManager.open({
                            type: "error",
                            text: t
                        })
                    },
                    Rw = (e, t) => {
                        e._skinLoaded ? Nw(e, t) : e.on("SkinLoaded", (() => {
                            Nw(e, t)
                        }))
                    },
                    Dw = (e, t, o) => {
                        Am(e, t, {
                            message: o
                        }), console.error(o)
                    },
                    Bw = (e, t, o) => o ? `Failed to load ${e}: ${o} from url ${t}` : `Failed to load ${e} url: ${t}`,
                    Lw = (e, ...t) => {
                        const o = window.console;
                        o && (o.error ? o.error(e, ...t) : o.log(e, ...t))
                    },
                    Hw = (e, t) => {
                        const o = e.editorManager.baseURL + "/skins/content",
                            n = `content${e.editorManager.suffix}.css`;
                        return j(t, (t => (e => /^[a-z0-9\-]+$/i.test(e))(t) && !e.inline ? `${o}/${t}/${n}` : e.documentBaseURI.toAbsolute(t)))
                    },
                    Iw = H,
                    Pw = (e, t) => {
                        const o = {};
                        return {
                            findAll: (n, r = H) => {
                                const s = G((e => e ? de(e.getElementsByTagName("img")) : [])(n), (t => {
                                        const o = t.src;
                                        return !t.hasAttribute("data-mce-bogus") && !t.hasAttribute("data-mce-placeholder") && !(!o || o === Et.transparentSrc) && (Ve(o, "blob:") ? !e.isUploaded(o) && r(t) : !!Ve(o, "data:") && r(t))
                                    })),
                                    a = j(s, (e => {
                                        const n = e.src;
                                        if (Se(o, n)) return o[n].then((t => g(t) ? t : {
                                            image: e,
                                            blobInfo: t.blobInfo
                                        })); {
                                            const r = ((e, t) => {
                                                const o = () => Promise.reject("Invalid data URI");
                                                if (Ve(t, "blob:")) {
                                                    const s = e.getByUri(t);
                                                    return x(s) ? Promise.resolve(s) : (n = t, Ve(n, "blob:") ? (e => fetch(e).then((e => e.ok ? e.blob() : Promise.reject())).catch((() => Promise.reject(`Cannot convert ${e} to Blob. Resource might not exist or is inaccessible.`))))(n) : Ve(n, "data:") ? (r = n, new Promise(((e, t) => {
                                                        ey(r).bind((({
                                                            type: e,
                                                            data: t,
                                                            base64Encoded: o
                                                        }) => ty(e, t, o))).fold((() => t("Invalid data URI")), e)
                                                    }))) : Promise.reject("Unknown URI format")).then((t => oy(t).then((n => ry(n, !1, (o => I.some(sy(e, t, o)))).getOrThunk(o)))))
                                                }
                                                var n, r;
                                                return Ve(t, "data:") ? ay(e, t).fold(o, (e => Promise.resolve(e))) : Promise.reject("Unknown image data format")
                                            })(t, n).then((t => (delete o[n], {
                                                image: e,
                                                blobInfo: t
                                            }))).catch((e => (delete o[n], e)));
                                            return o[n] = r, r
                                        }
                                    }));
                                return Promise.all(a)
                            }
                        }
                    },
                    zw = () => {
                        let e = {};
                        const t = (e, t) => ({
                                status: e,
                                resultUri: t
                            }),
                            o = t => t in e;
                        return {
                            hasBlobUri: o,
                            getResultUri: t => {
                                const o = e[t];
                                return o ? o.resultUri : null
                            },
                            isPending: t => !!o(t) && 1 === e[t].status,
                            isUploaded: t => !!o(t) && 2 === e[t].status,
                            markPending: o => {
                                e[o] = t(1, null)
                            },
                            markUploaded: (o, n) => {
                                e[o] = t(2, n)
                            },
                            removeFailed: t => {
                                delete e[t]
                            },
                            destroy: () => {
                                e = {}
                            }
                        }
                    };
                let Fw = 0;
                const Vw = (e, t) => {
                        const o = {},
                            n = (e, o) => new Promise(((n, r) => {
                                const s = new XMLHttpRequest;
                                s.open("POST", t.url), s.withCredentials = t.credentials, s.upload.onprogress = e => {
                                    o(e.loaded / e.total * 100)
                                }, s.onerror = () => {
                                    r("Image upload failed due to a XHR Transport error. Code: " + s.status)
                                }, s.onload = () => {
                                    if (s.status < 200 || s.status >= 300) return void r("HTTP Error: " + s.status);
                                    const e = JSON.parse(s.responseText);
                                    var o, a;
                                    e && g(e.location) ? n((o = t.basePath, a = e.location, o ? o.replace(/\/$/, "") + "/" + a.replace(/^\//, "") : a)) : r("Invalid JSON: " + s.responseText)
                                };
                                const a = new FormData;
                                a.append("file", e.blob(), e.filename()), s.send(a)
                            })),
                            r = C(t.handler) ? t.handler : n,
                            s = (e, t) => ({
                                url: t,
                                blobInfo: e,
                                status: !0
                            }),
                            a = (e, t) => ({
                                url: "",
                                blobInfo: e,
                                status: !1,
                                error: t
                            }),
                            i = (e, t) => {
                                Rt.each(o[e], (e => {
                                    e(t)
                                })), delete o[e]
                            };
                        return {
                            upload: (l, c) => t.url || r !== n ? ((t, n) => (t = Rt.grep(t, (t => !e.isUploaded(t.blobUri()))), Promise.all(Rt.map(t, (t => e.isPending(t.blobUri()) ? (e => {
                                const t = e.blobUri();
                                return new Promise((e => {
                                    o[t] = o[t] || [], o[t].push(e)
                                }))
                            })(t) : ((t, o, n) => (e.markPending(t.blobUri()), new Promise((r => {
                                let l, c;
                                try {
                                    const d = () => {
                                            l && (l.close(), c = _)
                                        },
                                        u = o => {
                                            d(), e.markUploaded(t.blobUri(), o), i(t.blobUri(), s(t, o)), r(s(t, o))
                                        },
                                        m = o => {
                                            d(), e.removeFailed(t.blobUri()), i(t.blobUri(), a(t, o)), r(a(t, o))
                                        };
                                    c = e => {
                                        e < 0 || e > 100 || I.from(l).orThunk((() => I.from(n).map(D))).each((t => {
                                            l = t, t.progressBar.value(e)
                                        }))
                                    }, o(t, c).then(u, (e => {
                                        m(g(e) ? {
                                            message: e
                                        } : e)
                                    }))
                                } catch (e) {
                                    r(a(t, e))
                                }
                            }))))(t, r, n))))))(l, c) : new Promise((e => {
                                e([])
                            }))
                        }
                    },
                    Zw = e => () => e.notificationManager.open({
                        text: e.translate("Image uploading..."),
                        type: "info",
                        timeout: -1,
                        progressBar: !0
                    }),
                    Uw = (e, t) => Vw(t, {
                        url: Tl(e),
                        basePath: El(e),
                        credentials: Al(e),
                        handler: Ml(e)
                    }),
                    jw = e => {
                        const t = (() => {
                            let e = [];
                            const t = e => {
                                    if (!e.blob || !e.base64) throw new Error("blob and base64 representations of the image are required for BlobInfo to be created");
                                    const t = e.id || "blobid" + Fw++ + (() => {
                                            const e = () => Math.round(4294967295 * Math.random()).toString(36);
                                            return "s" + (new Date).getTime().toString(36) + e() + e() + e()
                                        })(),
                                        o = e.name || t,
                                        n = e.blob;
                                    var r;
                                    return {
                                        id: E(t),
                                        name: E(o),
                                        filename: E(e.filename || o + "." + (r = n.type, {
                                            "image/jpeg": "jpg",
                                            "image/jpg": "jpg",
                                            "image/gif": "gif",
                                            "image/png": "png",
                                            "image/apng": "apng",
                                            "image/avif": "avif",
                                            "image/svg+xml": "svg",
                                            "image/webp": "webp",
                                            "image/bmp": "bmp",
                                            "image/tiff": "tiff"
                                        }[r.toLowerCase()] || "dat")),
                                        blob: E(n),
                                        base64: E(e.base64),
                                        blobUri: E(e.blobUri || URL.createObjectURL(n)),
                                        uri: E(e.uri)
                                    }
                                },
                                o = t => J(e, t).getOrUndefined(),
                                n = e => o((t => t.id() === e));
                            return {
                                create: (e, o, n, r, s) => {
                                    if (g(e)) return t({
                                        id: e,
                                        name: r,
                                        filename: s,
                                        blob: o,
                                        base64: n
                                    });
                                    if (h(e)) return t(e);
                                    throw new Error("Unknown input type")
                                },
                                add: t => {
                                    n(t.id()) || e.push(t)
                                },
                                get: n,
                                getByUri: e => o((t => t.blobUri() === e)),
                                getByData: (e, t) => o((o => o.base64() === e && o.blob().type === t)),
                                findFirst: o,
                                removeByUri: t => {
                                    e = G(e, (e => e.blobUri() !== t || (URL.revokeObjectURL(e.blobUri()), !1)))
                                },
                                destroy: () => {
                                    W(e, (e => {
                                        URL.revokeObjectURL(e.blobUri())
                                    })), e = []
                                }
                            }
                        })();
                        let o, n;
                        const r = zw(),
                            s = [],
                            a = t => o => e.selection ? t(o) : [],
                            i = (e, t, o) => {
                                let n = 0;
                                do {
                                    n = e.indexOf(t, n), -1 !== n && (e = e.substring(0, n) + o + e.substr(n + t.length), n += o.length - t.length + 1)
                                } while (-1 !== n);
                                return e
                            },
                            l = (e, t, o) => {
                                const n = `src="${o}"${o===Et.transparentSrc?' data-mce-placeholder="1"':""}`;
                                return e = i(e, `src="${t}"`, n), i(e, 'data-mce-src="' + t + '"', 'data-mce-src="' + o + '"')
                            },
                            c = (t, o) => {
                                W(e.undoManager.data, (e => {
                                    "fragmented" === e.type ? e.fragments = j(e.fragments, (e => l(e, t, o))) : e.content = l(e.content, t, o)
                                }))
                            },
                            d = () => (o || (o = Uw(e, r)), p().then(a((n => {
                                const r = j(n, (e => e.blobInfo));
                                return o.upload(r, Zw(e)).then(a((o => {
                                    const r = [];
                                    let s = !1;
                                    const a = j(o, ((o, a) => {
                                        const {
                                            blobInfo: i,
                                            image: l
                                        } = n[a];
                                        let d = !1;
                                        return o.status && kl(e) ? (o.url && !Fe(l.src, o.url) && (s = !0), t.removeByUri(l.src), ew(e) || ((t, o) => {
                                            const n = e.convertURL(o, "src");
                                            var r;
                                            c(t.src, o), $t(go(t), {
                                                src: Sl(e) ? (r = o, r + (-1 === r.indexOf("?") ? "?" : "&") + (new Date).getTime()) : o,
                                                "data-mce-src": n
                                            })
                                        })(l, o.url)) : o.error && (o.error.remove && (c(l.src, Et.transparentSrc), r.push(l), d = !0), ((e, t) => {
                                            Rw(e, _a.translate(["Failed to upload image: {0}", t]))
                                        })(e, o.error.message)), {
                                            element: l,
                                            status: o.status,
                                            uploadUri: o.url,
                                            blobInfo: i,
                                            removed: d
                                        }
                                    }));
                                    return r.length > 0 && !ew(e) ? e.undoManager.transact((() => {
                                        W(r, (o => {
                                            e.dom.remove(o), t.removeByUri(o.src)
                                        }))
                                    })) : s && e.undoManager.dispatchChange(), a
                                })))
                            })))),
                            u = () => Cl(e) ? d() : Promise.resolve([]),
                            m = e => oe(s, (t => t(e))),
                            p = () => (n || (n = Pw(r, t)), n.findAll(e.getBody(), m).then(a((t => {
                                const o = G(t, (t => !g(t) || (Rw(e, t), !1)));
                                return ew(e) || W(o, (e => {
                                    c(e.image.src, e.blobInfo.blobUri()), e.image.src = e.blobInfo.blobUri(), e.image.removeAttribute("data-mce-src")
                                })), o
                            })))),
                            f = o => o.replace(/src="(blob:[^"]+)"/g, ((o, n) => {
                                const s = r.getResultUri(n);
                                if (s) return 'src="' + s + '"';
                                let a = t.getByUri(n);
                                return a || (a = Y(e.editorManager.get(), ((e, t) => e || t.editorUpload && t.editorUpload.blobCache.getByUri(n)), void 0)), a ? 'src="data:' + a.blob().type + ";base64," + a.base64() + '"' : o
                            }));
                        return e.on("SetContent", (() => {
                            Cl(e) ? u() : p()
                        })), e.on("RawSaveContent", (e => {
                            e.content = f(e.content)
                        })), e.on("GetContent", (e => {
                            e.source_view || "raw" === e.format || "tree" === e.format || (e.content = f(e.content))
                        })), e.on("PostRender", (() => {
                            e.parser.addNodeFilter("img", (e => {
                                W(e, (e => {
                                    const o = e.attr("src");
                                    if (!o || t.getByUri(o)) return;
                                    const n = r.getResultUri(o);
                                    n && e.attr("src", n)
                                }))
                            }))
                        })), {
                            blobCache: t,
                            addFilter: e => {
                                s.push(e)
                            },
                            uploadImages: d,
                            uploadImagesAuto: u,
                            scanForImages: p,
                            destroy: () => {
                                t.destroy(), r.destroy(), n = o = null
                            }
                        }
                    },
                    Ww = {
                        remove_similar: !0,
                        inherit: !1
                    },
                    $w = {
                        selector: "td,th",
                        ...Ww
                    },
                    qw = {
                        tablecellbackgroundcolor: {
                            styles: {
                                backgroundColor: "%value"
                            },
                            ...$w
                        },
                        tablecellverticalalign: {
                            styles: {
                                "vertical-align": "%value"
                            },
                            ...$w
                        },
                        tablecellbordercolor: {
                            styles: {
                                borderColor: "%value"
                            },
                            ...$w
                        },
                        tablecellclass: {
                            classes: ["%value"],
                            ...$w
                        },
                        tableclass: {
                            selector: "table",
                            classes: ["%value"],
                            ...Ww
                        },
                        tablecellborderstyle: {
                            styles: {
                                borderStyle: "%value"
                            },
                            ...$w
                        },
                        tablecellborderwidth: {
                            styles: {
                                borderWidth: "%value"
                            },
                            ...$w
                        }
                    },
                    Gw = E(qw),
                    Kw = Rt.each,
                    Yw = ba.DOM,
                    Xw = e => x(e) && h(e),
                    Jw = (e, t) => {
                        const o = t && t.schema || Js({}),
                            n = e => {
                                const t = g(e) ? {
                                        name: e,
                                        classes: [],
                                        attrs: {}
                                    } : e,
                                    o = Yw.create(t.name);
                                return ((e, t) => {
                                    t.classes.length > 0 && Yw.addClass(e, t.classes.join(" ")), Yw.setAttribs(e, t.attrs)
                                })(o, t), o
                            },
                            r = (e, t, s) => {
                                let a;
                                const i = t[0],
                                    l = Xw(i) ? i.name : void 0,
                                    c = ((e, t) => {
                                        const n = o.getElementRule(e.nodeName.toLowerCase()),
                                            r = null == n ? void 0 : n.parentsRequired;
                                        return !(!r || !r.length) && (t && Z(r, t) ? t : r[0])
                                    })(e, l);
                                if (c) l === c ? (a = i, t = t.slice(1)) : a = c;
                                else if (i) a = i, t = t.slice(1);
                                else if (!s) return e;
                                const d = a ? n(a) : Yw.create("div");
                                d.appendChild(e), s && Rt.each(s, (t => {
                                    const o = n(t);
                                    d.insertBefore(o, e)
                                }));
                                const u = Xw(a) ? a.siblings : void 0;
                                return r(d, t, u)
                            },
                            s = Yw.create("div");
                        if (e.length > 0) {
                            const t = e[0],
                                o = n(t),
                                a = Xw(t) ? t.siblings : void 0;
                            s.appendChild(r(o, e.slice(1), a))
                        }
                        return s
                    },
                    Qw = e => {
                        let t = "div";
                        const o = {
                            name: t,
                            classes: [],
                            attrs: {},
                            selector: e = Rt.trim(e)
                        };
                        return "*" !== e && (t = e.replace(/(?:([#\.]|::?)([\w\-]+)|(\[)([^\]]+)\]?)/g, ((e, t, n, r, s) => {
                            switch (t) {
                                case "#":
                                    o.attrs.id = n;
                                    break;
                                case ".":
                                    o.classes.push(n);
                                    break;
                                case ":":
                                    -1 !== Rt.inArray("checked disabled enabled read-only required".split(" "), n) && (o.attrs[n] = n)
                            }
                            if ("[" === r) {
                                const e = s.match(/([\w\-]+)(?:\=\"([^\"]+))?/);
                                e && (o.attrs[e[1]] = e[2])
                            }
                            return ""
                        }))), o.name = t || "div", o
                    },
                    ex = (e, t) => {
                        let o = "",
                            n = Ql(e);
                        if ("" === n) return "";
                        const r = e => g(e) ? e.replace(/%(\w+)/g, "") : "",
                            s = (t, o) => Yw.getStyle(null != o ? o : e.getBody(), t, !0);
                        if (g(t)) {
                            const o = e.formatter.get(t);
                            if (!o) return "";
                            t = o[0]
                        }
                        if ("preview" in t) {
                            const e = t.preview;
                            if (!1 === e) return "";
                            n = e || n
                        }
                        let a, i = t.block || t.inline || "span";
                        const l = (c = t.selector, g(c) ? (c = (c = c.split(/\s*,\s*/)[0]).replace(/\s*(~\+|~|\+|>)\s*/g, "$1"), Rt.map(c.split(/(?:>|\s+(?![^\[\]]+\]))/), (e => {
                            const t = Rt.map(e.split(/(?:~\+|~|\+)/), Qw),
                                o = t.pop();
                            return t.length && (o.siblings = t), o
                        })).reverse()) : []);
                        var c;
                        l.length > 0 ? (l[0].name || (l[0].name = i), i = t.selector, a = Jw(l, e)) : a = Jw([i], e);
                        const d = Yw.select(i, a)[0] || a.firstChild;
                        Kw(t.styles, ((e, t) => {
                            const o = r(e);
                            o && Yw.setStyle(d, t, o)
                        })), Kw(t.attributes, ((e, t) => {
                            const o = r(e);
                            o && Yw.setAttrib(d, t, o)
                        })), Kw(t.classes, (e => {
                            const t = r(e);
                            Yw.hasClass(d, t) || Yw.addClass(d, t)
                        })), e.dispatch("PreviewFormats"), Yw.setStyles(a, {
                            position: "absolute",
                            left: -65535
                        }), e.getBody().appendChild(a);
                        const u = s("fontSize"),
                            m = /px$/.test(u) ? parseInt(u, 10) : 0;
                        return Kw(n.split(" "), (e => {
                            let t = s(e, d);
                            if (!("background-color" === e && /transparent|rgba\s*\([^)]+,\s*0\)/.test(t) && (t = s(e), "#ffffff" === Tu(t).toLowerCase()) || "color" === e && "#000000" === Tu(t).toLowerCase())) {
                                if ("font-size" === e && /em|%$/.test(t)) {
                                    if (0 === m) return;
                                    t = parseFloat(t) / (/%$/.test(t) ? 100 : 1) * m + "px"
                                }
                                "border" === e && t && (o += "padding:0 2px;"), o += e + ":" + t + ";"
                            }
                        })), e.dispatch("AfterPreviewFormats"), Yw.remove(a), o
                    },
                    tx = e => {
                        const t = (e => {
                                const t = {},
                                    o = (e, n) => {
                                        e && (g(e) ? (f(n) || (n = [n]), W(n, (e => {
                                            y(e.deep) && (e.deep = !nm(e)), y(e.split) && (e.split = !nm(e) || rm(e)), y(e.remove) && nm(e) && !rm(e) && (e.remove = "none"), nm(e) && rm(e) && (e.mixed = !0, e.block_expand = !0), g(e.classes) && (e.classes = e.classes.split(/\s+/))
                                        })), t[e] = n) : he(e, ((e, t) => {
                                            o(t, e)
                                        })))
                                    };
                                return o((e => {
                                    const t = e.dom,
                                        o = e.schema.type,
                                        n = {
                                            valigntop: [{
                                                selector: "td,th",
                                                styles: {
                                                    verticalAlign: "top"
                                                }
                                            }],
                                            valignmiddle: [{
                                                selector: "td,th",
                                                styles: {
                                                    verticalAlign: "middle"
                                                }
                                            }],
                                            valignbottom: [{
                                                selector: "td,th",
                                                styles: {
                                                    verticalAlign: "bottom"
                                                }
                                            }],
                                            alignleft: [{
                                                selector: "figure.image",
                                                collapsed: !1,
                                                classes: "align-left",
                                                ceFalseOverride: !0,
                                                preview: "font-family font-size"
                                            }, {
                                                selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre",
                                                styles: {
                                                    textAlign: "left"
                                                },
                                                inherit: !1,
                                                preview: !1
                                            }, {
                                                selector: "img,audio,video",
                                                collapsed: !1,
                                                styles: {
                                                    float: "left"
                                                },
                                                preview: "font-family font-size"
                                            }, {
                                                selector: "table",
                                                collapsed: !1,
                                                styles: {
                                                    marginLeft: "0px",
                                                    marginRight: "auto"
                                                },
                                                onformat: e => {
                                                    t.setStyle(e, "float", null)
                                                },
                                                preview: "font-family font-size"
                                            }, {
                                                selector: ".mce-preview-object,[data-ephox-embed-iri]",
                                                ceFalseOverride: !0,
                                                styles: {
                                                    float: "left"
                                                }
                                            }],
                                            aligncenter: [{
                                                selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre",
                                                styles: {
                                                    textAlign: "center"
                                                },
                                                inherit: !1,
                                                preview: "font-family font-size"
                                            }, {
                                                selector: "figure.image",
                                                collapsed: !1,
                                                classes: "align-center",
                                                ceFalseOverride: !0,
                                                preview: "font-family font-size"
                                            }, {
                                                selector: "img,audio,video",
                                                collapsed: !1,
                                                styles: {
                                                    display: "block",
                                                    marginLeft: "auto",
                                                    marginRight: "auto"
                                                },
                                                preview: !1
                                            }, {
                                                selector: "table",
                                                collapsed: !1,
                                                styles: {
                                                    marginLeft: "auto",
                                                    marginRight: "auto"
                                                },
                                                preview: "font-family font-size"
                                            }, {
                                                selector: ".mce-preview-object",
                                                ceFalseOverride: !0,
                                                styles: {
                                                    display: "table",
                                                    marginLeft: "auto",
                                                    marginRight: "auto"
                                                },
                                                preview: !1
                                            }, {
                                                selector: "[data-ephox-embed-iri]",
                                                ceFalseOverride: !0,
                                                styles: {
                                                    marginLeft: "auto",
                                                    marginRight: "auto"
                                                },
                                                preview: !1
                                            }],
                                            alignright: [{
                                                selector: "figure.image",
                                                collapsed: !1,
                                                classes: "align-right",
                                                ceFalseOverride: !0,
                                                preview: "font-family font-size"
                                            }, {
                                                selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre",
                                                styles: {
                                                    textAlign: "right"
                                                },
                                                inherit: !1,
                                                preview: "font-family font-size"
                                            }, {
                                                selector: "img,audio,video",
                                                collapsed: !1,
                                                styles: {
                                                    float: "right"
                                                },
                                                preview: "font-family font-size"
                                            }, {
                                                selector: "table",
                                                collapsed: !1,
                                                styles: {
                                                    marginRight: "0px",
                                                    marginLeft: "auto"
                                                },
                                                onformat: e => {
                                                    t.setStyle(e, "float", null)
                                                },
                                                preview: "font-family font-size"
                                            }, {
                                                selector: ".mce-preview-object,[data-ephox-embed-iri]",
                                                ceFalseOverride: !0,
                                                styles: {
                                                    float: "right"
                                                },
                                                preview: !1
                                            }],
                                            alignjustify: [{
                                                selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre",
                                                styles: {
                                                    textAlign: "justify"
                                                },
                                                inherit: !1,
                                                preview: "font-family font-size"
                                            }],
                                            bold: [{
                                                inline: "strong",
                                                remove: "all",
                                                preserve_attributes: ["class", "style"]
                                            }, {
                                                inline: "span",
                                                styles: {
                                                    fontWeight: "bold"
                                                }
                                            }, {
                                                inline: "b",
                                                remove: "all",
                                                preserve_attributes: ["class", "style"]
                                            }],
                                            italic: [{
                                                inline: "em",
                                                remove: "all",
                                                preserve_attributes: ["class", "style"]
                                            }, {
                                                inline: "span",
                                                styles: {
                                                    fontStyle: "italic"
                                                }
                                            }, {
                                                inline: "i",
                                                remove: "all",
                                                preserve_attributes: ["class", "style"]
                                            }],
                                            underline: [{
                                                inline: "span",
                                                styles: {
                                                    textDecoration: "underline"
                                                },
                                                exact: !0
                                            }, {
                                                inline: "u",
                                                remove: "all",
                                                preserve_attributes: ["class", "style"]
                                            }],
                                            strikethrough: (() => {
                                                const e = {
                                                        inline: "span",
                                                        styles: {
                                                            textDecoration: "line-through"
                                                        },
                                                        exact: !0
                                                    },
                                                    t = {
                                                        inline: "strike",
                                                        remove: "all",
                                                        preserve_attributes: ["class", "style"]
                                                    },
                                                    n = {
                                                        inline: "s",
                                                        remove: "all",
                                                        preserve_attributes: ["class", "style"]
                                                    };
                                                return "html4" !== o ? [n, e, t] : [e, n, t]
                                            })(),
                                            forecolor: {
                                                inline: "span",
                                                styles: {
                                                    color: "%value"
                                                },
                                                links: !0,
                                                remove_similar: !0,
                                                clear_child_styles: !0
                                            },
                                            hilitecolor: {
                                                inline: "span",
                                                styles: {
                                                    backgroundColor: "%value"
                                                },
                                                links: !0,
                                                remove_similar: !0,
                                                clear_child_styles: !0
                                            },
                                            fontname: {
                                                inline: "span",
                                                toggle: !1,
                                                styles: {
                                                    fontFamily: "%value"
                                                },
                                                clear_child_styles: !0
                                            },
                                            fontsize: {
                                                inline: "span",
                                                toggle: !1,
                                                styles: {
                                                    fontSize: "%value"
                                                },
                                                clear_child_styles: !0
                                            },
                                            lineheight: {
                                                selector: "h1,h2,h3,h4,h5,h6,p,li,td,th,div",
                                                styles: {
                                                    lineHeight: "%value"
                                                }
                                            },
                                            fontsize_class: {
                                                inline: "span",
                                                attributes: {
                                                    class: "%value"
                                                }
                                            },
                                            blockquote: {
                                                block: "blockquote",
                                                wrapper: !0,
                                                remove: "all"
                                            },
                                            subscript: {
                                                inline: "sub"
                                            },
                                            superscript: {
                                                inline: "sup"
                                            },
                                            code: {
                                                inline: "code"
                                            },
                                            link: {
                                                inline: "a",
                                                selector: "a",
                                                remove: "all",
                                                split: !0,
                                                deep: !0,
                                                onmatch: (e, t, o) => Rn(e) && e.hasAttribute("href"),
                                                onformat: (e, o, n) => {
                                                    Rt.each(n, ((o, n) => {
                                                        t.setAttrib(e, n, o)
                                                    }))
                                                }
                                            },
                                            lang: {
                                                inline: "span",
                                                clear_child_styles: !0,
                                                remove_similar: !0,
                                                attributes: {
                                                    lang: "%value",
                                                    "data-mce-lang": e => {
                                                        var t;
                                                        return null !== (t = null == e ? void 0 : e.customValue) && void 0 !== t ? t : null
                                                    }
                                                }
                                            },
                                            removeformat: [{
                                                selector: "b,strong,em,i,font,u,strike,s,sub,sup,dfn,code,samp,kbd,var,cite,mark,q,del,ins,small",
                                                remove: "all",
                                                split: !0,
                                                expand: !1,
                                                block_expand: !0,
                                                deep: !0
                                            }, {
                                                selector: "span",
                                                attributes: ["style", "class"],
                                                remove: "empty",
                                                split: !0,
                                                expand: !1,
                                                deep: !0
                                            }, {
                                                selector: "*",
                                                attributes: ["style", "class"],
                                                split: !1,
                                                expand: !1,
                                                deep: !0
                                            }]
                                        };
                                    return Rt.each("p h1 h2 h3 h4 h5 h6 div address pre dt dd samp".split(/\s/), (e => {
                                        n[e] = {
                                            block: e,
                                            remove: "all"
                                        }
                                    })), n
                                })(e)), o(Gw()), o(Jl(e)), {
                                    get: e => x(e) ? t[e] : t,
                                    has: e => Se(t, e),
                                    register: o,
                                    unregister: e => (e && t[e] && delete t[e], t)
                                }
                            })(e),
                            o = xa({});
                        return (e => {
                            e.addShortcut("meta+b", "", "Bold"), e.addShortcut("meta+i", "", "Italic"), e.addShortcut("meta+u", "", "Underline");
                            for (let t = 1; t <= 6; t++) e.addShortcut("access+" + t, "", ["FormatBlock", !1, "h" + t]);
                            e.addShortcut("access+7", "", ["FormatBlock", !1, "p"]), e.addShortcut("access+8", "", ["FormatBlock", !1, "div"]), e.addShortcut("access+9", "", ["FormatBlock", !1, "address"])
                        })(e), (e => {
                            e.on("mouseup keydown", (t => {
                                ((e, t) => {
                                    const o = e.selection,
                                        n = e.getBody();
                                    rv(e, null, !1), 8 !== t && 46 !== t || !o.isCollapsed() || o.getStart().innerHTML !== Qf || rv(e, ru(n, o.getStart())), 37 !== t && 39 !== t || rv(e, ru(n, o.getStart()))
                                })(e, t.keyCode)
                            }))
                        })(e), ew(e) || ((e, t) => {
                            e.set({}), t.on("NodeChange", (o => {
                                Yv(t, o.element, e.get())
                            })), t.on("FormatApply FormatRemove", (o => {
                                const n = I.from(o.node).map((e => zu(e) ? e : e.startContainer)).bind((e => Rn(e) ? I.some(e) : I.from(e.parentElement))).getOrThunk((() => qv(t)));
                                Yv(t, n, e.get())
                            }))
                        })(o, e), {
                            get: t.get,
                            has: t.has,
                            register: t.register,
                            unregister: t.unregister,
                            apply: (t, o, n) => {
                                ((e, t, o, n) => {
                                    ow(e).formatter.apply(t, o, n)
                                })(e, t, o, n)
                            },
                            remove: (t, o, n, r) => {
                                ((e, t, o, n, r) => {
                                    ow(e).formatter.remove(t, o, n, r)
                                })(e, t, o, n, r)
                            },
                            toggle: (t, o, n) => {
                                ((e, t, o, n) => {
                                    ow(e).formatter.toggle(t, o, n)
                                })(e, t, o, n)
                            },
                            match: (t, o, n, r) => ((e, t, o, n, r) => ow(e).formatter.match(t, o, n, r))(e, t, o, n, r),
                            closest: t => ((e, t) => ow(e).formatter.closest(t))(e, t),
                            matchAll: (t, o) => ((e, t, o) => ow(e).formatter.matchAll(t, o))(e, t, o),
                            matchNode: (t, o, n, r) => ((e, t, o, n, r) => ow(e).formatter.matchNode(t, o, n, r))(e, t, o, n, r),
                            canApply: t => ((e, t) => ow(e).formatter.canApply(t))(e, t),
                            formatChanged: (t, n, r, s) => ((e, t, o, n, r, s) => ow(e).formatter.formatChanged(t, o, n, r, s))(e, o, t, n, r, s),
                            getCssText: N(ex, e)
                        }
                    },
                    ox = e => {
                        switch (e.toLowerCase()) {
                            case "undo":
                            case "redo":
                            case "mcefocus":
                                return !0;
                            default:
                                return !1
                        }
                    },
                    nx = e => {
                        const t = Ea(),
                            o = xa(0),
                            n = xa(0),
                            r = {
                                data: [],
                                typing: !1,
                                beforeChange: () => {
                                    ((e, t, o) => {
                                        ow(e).undoManager.beforeChange(t, o)
                                    })(e, o, t)
                                },
                                add: (s, a) => ((e, t, o, n, r, s, a) => ow(e).undoManager.add(t, o, n, r, s, a))(e, r, n, o, t, s, a),
                                dispatchChange: () => {
                                    e.setDirty(!0);
                                    const t = Wy(e);
                                    t.bookmark = ji(e.selection), e.dispatch("change", {
                                        level: t,
                                        lastLevel: ie(r.data, n.get()).getOrUndefined()
                                    })
                                },
                                undo: () => ((e, t, o, n) => ow(e).undoManager.undo(t, o, n))(e, r, o, n),
                                redo: () => ((e, t, o) => ow(e).undoManager.redo(t, o))(e, n, r.data),
                                clear: () => {
                                    ((e, t, o) => {
                                        ow(e).undoManager.clear(t, o)
                                    })(e, r, n)
                                },
                                reset: () => {
                                    ((e, t) => {
                                        ow(e).undoManager.reset(t)
                                    })(e, r)
                                },
                                hasUndo: () => ((e, t, o) => ow(e).undoManager.hasUndo(t, o))(e, r, n),
                                hasRedo: () => ((e, t, o) => ow(e).undoManager.hasRedo(t, o))(e, r, n),
                                transact: t => ((e, t, o, n) => ow(e).undoManager.transact(t, o, n))(e, r, o, t),
                                ignore: t => {
                                    ((e, t, o) => {
                                        ow(e).undoManager.ignore(t, o)
                                    })(e, o, t)
                                },
                                extra: (t, o) => {
                                    ((e, t, o, n, r) => {
                                        ow(e).undoManager.extra(t, o, n, r)
                                    })(e, r, n, t, o)
                                }
                            };
                        return ew(e) || ((e, t, o) => {
                            const n = xa(!1),
                                r = e => {
                                    Xy(t, !1, o), t.add({}, e)
                                };
                            e.on("init", (() => {
                                t.add()
                            })), e.on("BeforeExecCommand", (e => {
                                const n = e.command;
                                ox(n) || (Jy(t, o), t.beforeChange())
                            })), e.on("ExecCommand", (e => {
                                const t = e.command;
                                ox(t) || r(e)
                            })), e.on("ObjectResizeStart cut", (() => {
                                t.beforeChange()
                            })), e.on("SaveContent ObjectResized blur", r), e.on("dragend", r), e.on("keyup", (o => {
                                const s = o.keyCode;
                                o.isDefaultPrevented() || ((s >= 33 && s <= 36 || s >= 37 && s <= 40 || 45 === s || o.ctrlKey) && (r(), e.nodeChanged()), 46 !== s && 8 !== s || e.nodeChanged(), n.get() && t.typing && !Ky(Wy(e), t.data[0]) && (e.isDirty() || e.setDirty(!0), e.dispatch("TypingUndo"), n.set(!1), e.nodeChanged()))
                            })), e.on("keydown", (e => {
                                const s = e.keyCode;
                                if (e.isDefaultPrevented()) return;
                                if (s >= 33 && s <= 36 || s >= 37 && s <= 40 || 45 === s) return void(t.typing && r(e));
                                const a = e.ctrlKey && !e.altKey || e.metaKey;
                                !(s < 16 || s > 20) || 224 === s || 91 === s || t.typing || a || (t.beforeChange(), Xy(t, !0, o), t.add({}, e), n.set(!0))
                            })), e.on("mousedown", (e => {
                                t.typing && r(e)
                            })), e.on("input", (e => {
                                var t;
                                e.inputType && ("insertReplacementText" === e.inputType || "insertText" === (t = e).inputType && null === t.data || (e => "insertFromPaste" === e.inputType || "insertFromDrop" === e.inputType)(e)) && r(e)
                            })), e.on("AddUndo Undo Redo ClearUndos", (t => {
                                t.isDefaultPrevented() || e.nodeChanged()
                            }))
                        })(e, r, o), (e => {
                            e.addShortcut("meta+z", "", "Undo"), e.addShortcut("meta+y,meta+shift+z", "", "Redo")
                        })(e), r
                    },
                    rx = [9, 27, Lm.HOME, Lm.END, 19, 20, 44, 144, 145, 33, 34, 45, 16, 17, 18, 91, 92, 93, Lm.DOWN, Lm.UP, Lm.LEFT, Lm.RIGHT].concat(Et.browser.isFirefox() ? [224] : []),
                    sx = "data-mce-placeholder",
                    ax = e => "keydown" === e.type || "keyup" === e.type,
                    ix = e => {
                        const t = e.keyCode;
                        return t === Lm.BACKSPACE || t === Lm.DELETE
                    },
                    lx = (e, t) => ({
                        from: e,
                        to: t
                    }),
                    cx = (e, t) => {
                        const o = go(e),
                            n = go(t.container());
                        return Up(o, n).map((e => ((e, t) => ({
                            block: e,
                            position: t
                        }))(e, t)))
                    },
                    dx = (e, t) => kn(t, (e => vr(e) || Kn(e.dom)), (t => bo(t, e))).filter(zt).getOr(e),
                    ux = e => {
                        const t = (e => {
                            const t = Mo(e);
                            return Q(t, dr).fold(E(t), (e => t.slice(0, e)))
                        })(e);
                        return W(t, rn), t
                    },
                    mx = (e, t) => {
                        const o = qh(t, e);
                        return J(o.reverse(), (e => rs(e))).each(rn)
                    },
                    gx = (e, t, o, n) => {
                        if (rs(o)) return Cr(o), eu(o.dom);
                        0 === G(Eo(n), (e => !rs(e))).length && rs(t) && Jo(n, uo("br"));
                        const r = Qd(o.dom, Si.before(n.dom));
                        return W(ux(t), (e => {
                            Jo(n, e)
                        })), mx(e, t), r
                    },
                    hx = (e, t, o) => {
                        if (rs(o)) return rn(o), rs(t) && Cr(t), eu(t.dom);
                        const n = tu(o.dom);
                        return W(ux(t), (e => {
                            tn(o, e)
                        })), mx(e, t), n
                    },
                    px = (e, t) => {
                        Xd(e, t.dom).bind((e => I.from(e.getNode()))).map(go).filter(mr).each(rn)
                    },
                    fx = (e, t, o) => (px(!0, t), px(!1, o), ((e, t) => yo(t, e) ? ((e, t) => {
                        const o = qh(t, e);
                        return I.from(o[o.length - 1])
                    })(t, e) : I.none())(t, o).fold(N(hx, e, t, o), N(gx, e, t, o))),
                    vx = (e, t, o, n) => t ? fx(e, n, o) : fx(e, o, n),
                    bx = (e, t) => {
                        const o = go(e.getBody()),
                            n = ((e, t, o) => o.collapsed ? ((e, t, o) => {
                                const n = cx(e, Si.fromRangeStart(o)),
                                    r = n.bind((o => Gd(t, e, o.position).bind((o => cx(e, o).map((o => ((e, t, o) => qn(o.position.getNode()) && !rs(o.block) ? Xd(!1, o.block.dom).bind((n => n.isEqual(o.position) ? Gd(t, e, n).bind((t => cx(e, t))) : I.some(o))).getOr(o) : o)(e, t, o)))))));
                                return Bt(n, r, lx).filter((t => (e => !bo(e.from.block, e.to.block))(t) && ((e, t) => {
                                    const o = go(e);
                                    return bo(dx(o, t.from.block), dx(o, t.to.block))
                                })(e, t) && (e => !1 === Yn(e.from.block.dom) && !1 === Yn(e.to.block.dom))(t) && (e => {
                                    const t = e => gr(e) || gs(e.dom);
                                    return t(e.from.block) && t(e.to.block)
                                })(t)))
                            })(e, t, o) : I.none())(o.dom, t, e.selection.getRng()).map((n => () => {
                                vx(o, t, n.from.block, n.to.block).each((t => {
                                    e.selection.setRng(t.toRange())
                                }))
                            }));
                        return n
                    },
                    yx = (e, t) => {
                        const o = go(t),
                            n = N(bo, e);
                        return Sn(o, vr, n).isSome()
                    },
                    wx = e => {
                        const t = go(e.getBody());
                        return ((e, t) => {
                            const o = Qd(e.dom, Si.fromRangeStart(t)).isNone(),
                                n = Jd(e.dom, Si.fromRangeEnd(t)).isNone();
                            return !((e, t) => yx(e, t.startContainer) || yx(e, t.endContainer))(e, t) && o && n
                        })(t, e.selection.getRng()) ? (e => I.some((() => {
                            e.setContent(""), e.selection.setCursorLocation()
                        })))(e) : ((e, t) => {
                            const o = t.getRng();
                            return Bt(Up(e, go(o.startContainer)), Up(e, go(o.endContainer)), ((n, r) => bo(n, r) ? I.none() : I.some((() => {
                                o.deleteContents(), vx(e, !0, n, r).each((e => {
                                    t.setRng(e.toRange())
                                }))
                            })))).getOr(I.none())
                        })(t, e.selection)
                    },
                    xx = (e, t) => e.selection.isCollapsed() ? I.none() : wx(e),
                    Cx = (e, t, o, n, r) => I.from(t._selectionOverrides.showCaret(e, o, n, r)),
                    Sx = (e, t) => e.dispatch("BeforeObjectSelected", {
                        target: t
                    }).isDefaultPrevented() ? I.none() : I.some((e => {
                        const t = e.ownerDocument.createRange();
                        return t.selectNode(e), t
                    })(t)),
                    kx = (e, t, o) => t.collapsed ? ((e, t, o) => {
                        const n = Td(1, e.getBody(), t),
                            r = Si.fromRangeStart(n),
                            s = r.getNode();
                        if (rd(s)) return Cx(1, e, s, !r.isAtEnd(), !1);
                        const a = r.getNode(!0);
                        if (rd(a)) return Cx(1, e, a, !1, !1);
                        const i = yf(e.dom.getRoot(), r.getNode());
                        return rd(i) ? Cx(1, e, i, !1, o) : I.none()
                    })(e, t, o).getOr(t) : t,
                    _x = e => jh(e) || Fh(e),
                    Ox = e => Wh(e) || Vh(e),
                    Tx = (e, t, o, n, r, s) => {
                        Cx(n, e, s.getNode(!r), r, !0).each((o => {
                            if (t.collapsed) {
                                const e = t.cloneRange();
                                r ? e.setEnd(o.startContainer, o.startOffset) : e.setStart(o.endContainer, o.endOffset), e.deleteContents()
                            } else t.deleteContents();
                            e.selection.setRng(o)
                        })), ((e, t) => {
                            Vn(t) && 0 === t.data.length && e.remove(t)
                        })(e.dom, o)
                    },
                    Ex = (e, t) => ((e, t) => {
                        const o = e.selection.getRng();
                        if (!Vn(o.commonAncestorContainer)) return I.none();
                        const n = t ? Dd.Forwards : Dd.Backwards,
                            r = jd(e.getBody()),
                            s = N(Nd, t ? r.next : r.prev),
                            a = t ? _x : Ox,
                            i = Ad(n, e.getBody(), o),
                            l = s(i),
                            c = l ? Ip(t, l) : l;
                        if (!c || !Rd(i, c)) return I.none();
                        if (a(c)) return I.some((() => Tx(e, o, i.getNode(), n, t, c)));
                        const d = s(c);
                        return d && a(d) && Rd(c, d) ? I.some((() => Tx(e, o, i.getNode(), n, t, d))) : I.none()
                    })(e, t),
                    Ax = (e, t) => {
                        const o = e.getBody();
                        return t ? eu(o).filter(jh) : tu(o).filter(Wh)
                    },
                    Mx = e => {
                        const t = e.selection.getRng();
                        return !t.collapsed && (Ax(e, !0).exists((e => e.isEqual(Si.fromRangeStart(t)))) || Ax(e, !1).exists((e => e.isEqual(Si.fromRangeEnd(t)))))
                    },
                    Nx = Gi([{
                        remove: ["element"]
                    }, {
                        moveToElement: ["element"]
                    }, {
                        moveToPosition: ["position"]
                    }]),
                    Rx = (e, t, o) => Gd(t, e, o).bind((n => {
                        return r = n.getNode(), x(r) && (vr(go(r)) || pr(go(r))) || ((e, t, o, n) => {
                            const r = t => ur(go(t)) && !wd(o, n, e);
                            return Ed(!t, o).fold((() => Ed(t, n).fold(L, r)), r)
                        })(e, t, o, n) ? I.none() : t && Yn(n.getNode()) || !t && Yn(n.getNode(!0)) ? ((e, t, o, n) => {
                            const r = n.getNode(!t);
                            return Up(go(e), go(o.getNode())).map((e => rs(e) ? Nx.remove(e.dom) : Nx.moveToElement(r))).orThunk((() => I.some(Nx.moveToElement(r))))
                        })(e, t, o, n) : t && Wh(o) || !t && jh(o) ? I.some(Nx.moveToPosition(n)) : I.none();
                        var r
                    })),
                    Dx = (e, t) => I.from(yf(e.getBody(), t)),
                    Bx = (e, t) => {
                        const o = e.selection.getNode();
                        return Dx(e, o).filter(Yn).fold((() => ((e, t, o) => {
                            const n = Td(t ? 1 : -1, e, o),
                                r = Si.fromRangeStart(n),
                                s = go(e);
                            return !t && Wh(r) ? I.some(Nx.remove(r.getNode(!0))) : t && jh(r) ? I.some(Nx.remove(r.getNode())) : !t && jh(r) && sp(s, r) ? ap(s, r).map((e => Nx.remove(e.getNode()))) : t && Wh(r) && rp(s, r) ? ip(s, r).map((e => Nx.remove(e.getNode()))) : ((e, t, o) => ((e, t) => {
                                const o = t.getNode(!e),
                                    n = e ? "after" : "before";
                                return Rn(o) && o.getAttribute("data-mce-caret") === n
                            })(t, o) ? ((e, t) => w(t) ? I.none() : e && Yn(t.nextSibling) ? I.some(Nx.moveToElement(t.nextSibling)) : !e && Yn(t.previousSibling) ? I.some(Nx.moveToElement(t.previousSibling)) : I.none())(t, o.getNode(!t)).orThunk((() => Rx(e, t, o))) : Rx(e, t, o).bind((t => ((e, t, o) => o.fold((e => I.some(Nx.remove(e))), (e => I.some(Nx.moveToElement(e))), (o => wd(t, o, e) ? I.none() : I.some(Nx.moveToPosition(o)))))(e, o, t))))(e, t, r)
                        })(e.getBody(), t, e.selection.getRng()).map((o => () => o.fold(((e, t) => o => (e._selectionOverrides.hideFakeCaret(), Dp(e, t, go(o)), !0))(e, t), ((e, t) => o => {
                            const n = t ? Si.before(o) : Si.after(o);
                            return e.selection.setRng(n.toRange()), !0
                        })(e, t), (e => t => (e.selection.setRng(t.toRange()), !0))(e))))), (() => I.some(_)))
                    },
                    Lx = e => {
                        const t = e.dom,
                            o = e.selection,
                            n = yf(e.getBody(), o.getNode());
                        if (Kn(n) && t.isBlock(n) && t.isEmpty(n)) {
                            const e = t.create("br", {
                                "data-mce-bogus": "1"
                            });
                            t.setHTML(n, ""), n.appendChild(e), o.setRng(Si.before(e).toRange())
                        }
                        return !0
                    },
                    Hx = (e, t) => e.selection.isCollapsed() ? Bx(e, t) : ((e, t) => {
                        const o = e.selection.getNode();
                        return Yn(o) && !Xn(o) ? Dx(e, o.parentNode).filter(Yn).fold((() => I.some((() => {
                            var o;
                            o = go(e.getBody()), W(rr(o, ".mce-offscreen-selection"), rn), Dp(e, t, go(e.selection.getNode())), jp(e)
                        }))), (() => I.some(_))) : Mx(e) ? I.some((() => {
                            $p(e, e.selection.getRng(), go(e.getBody()))
                        })) : I.none()
                    })(e, t),
                    Ix = (e, t) => e.selection.isCollapsed() ? ((e, t) => {
                        const o = Si.fromRangeStart(e.selection.getRng());
                        return Gd(t, e.getBody(), o).filter((e => t ? Ph(e) : zh(e))).bind((e => xd(t ? 0 : -1, e))).map((t => () => e.selection.select(t)))
                    })(e, t) : I.none(),
                    Px = Vn,
                    zx = e => Px(e) && e.data[0] === kr,
                    Fx = e => Px(e) && e.data[e.data.length - 1] === kr,
                    Vx = e => {
                        var t;
                        return (null !== (t = e.ownerDocument) && void 0 !== t ? t : document).createTextNode(kr)
                    },
                    Zx = (e, t) => e ? (e => {
                        var t;
                        if (Px(e.previousSibling)) return Fx(e.previousSibling) || e.previousSibling.appendData(kr), e.previousSibling;
                        if (Px(e)) return zx(e) || e.insertData(0, kr), e; {
                            const o = Vx(e);
                            return null === (t = e.parentNode) || void 0 === t || t.insertBefore(o, e), o
                        }
                    })(t) : (e => {
                        var t, o;
                        if (Px(e.nextSibling)) return zx(e.nextSibling) || e.nextSibling.insertData(0, kr), e.nextSibling;
                        if (Px(e)) return Fx(e) || e.appendData(kr), e; {
                            const n = Vx(e);
                            return e.nextSibling ? null === (t = e.parentNode) || void 0 === t || t.insertBefore(n, e.nextSibling) : null === (o = e.parentNode) || void 0 === o || o.appendChild(n), n
                        }
                    })(t),
                    Ux = N(Zx, !0),
                    jx = N(Zx, !1),
                    Wx = (e, t) => Vn(e.container()) ? Zx(t, e.container()) : Zx(t, e.getNode()),
                    $x = (e, t) => {
                        const o = t.get();
                        return o && e.container() === o && Mr(o)
                    },
                    qx = (e, t) => t.fold((t => {
                        Xc(e.get());
                        const o = Ux(t);
                        return e.set(o), I.some(Si(o, o.length - 1))
                    }), (t => eu(t).map((t => {
                        if ($x(t, e)) {
                            const t = e.get();
                            return Si(t, 1)
                        } {
                            Xc(e.get());
                            const o = Wx(t, !0);
                            return e.set(o), Si(o, 1)
                        }
                    }))), (t => tu(t).map((t => {
                        if ($x(t, e)) {
                            const t = e.get();
                            return Si(t, t.length - 1)
                        } {
                            Xc(e.get());
                            const o = Wx(t, !1);
                            return e.set(o), Si(o, o.length - 1)
                        }
                    }))), (t => {
                        Xc(e.get());
                        const o = jx(t);
                        return e.set(o), I.some(Si(o, 1))
                    })),
                    Gx = (e, t) => {
                        for (let o = 0; o < e.length; o++) {
                            const n = e[o].apply(null, t);
                            if (n.isSome()) return n
                        }
                        return I.none()
                    },
                    Kx = Gi([{
                        before: ["element"]
                    }, {
                        start: ["element"]
                    }, {
                        end: ["element"]
                    }, {
                        after: ["element"]
                    }]),
                    Yx = (e, t) => yd(t, e) || e,
                    Xx = (e, t, o) => {
                        const n = Pp(o),
                            r = Yx(t, n.container());
                        return Hp(e, r, n).fold((() => Jd(r, n).bind(N(Hp, e, r)).map((e => Kx.before(e)))), I.none)
                    },
                    Jx = (e, t) => null === ru(e, t),
                    Qx = (e, t, o) => Hp(e, t, o).filter(N(Jx, t)),
                    eC = (e, t, o) => {
                        const n = zp(o);
                        return Qx(e, t, n).bind((e => Qd(e, n).isNone() ? I.some(Kx.start(e)) : I.none()))
                    },
                    tC = (e, t, o) => {
                        const n = Pp(o);
                        return Qx(e, t, n).bind((e => Jd(e, n).isNone() ? I.some(Kx.end(e)) : I.none()))
                    },
                    oC = (e, t, o) => {
                        const n = zp(o),
                            r = Yx(t, n.container());
                        return Hp(e, r, n).fold((() => Qd(r, n).bind(N(Hp, e, r)).map((e => Kx.after(e)))), I.none)
                    },
                    nC = e => {
                        return t = sC(e), !("rtl" === ba.DOM.getStyle(t, "direction", !0) || (e => Bp.test(e))(null !== (o = t.textContent) && void 0 !== o ? o : ""));
                        var t, o
                    },
                    rC = (e, t, o) => Gx([Xx, eC, tC, oC], [e, t, o]).filter(nC),
                    sC = e => e.fold(A, A, A, A),
                    aC = e => e.fold(E("before"), E("start"), E("end"), E("after")),
                    iC = e => e.fold(Kx.before, Kx.before, Kx.after, Kx.after),
                    lC = e => e.fold(Kx.start, Kx.start, Kx.end, Kx.end),
                    cC = (e, t, o, n, r, s) => Bt(Hp(t, o, n), Hp(t, o, r), ((t, n) => t !== n && ((e, t, o) => {
                        const n = yd(t, e),
                            r = yd(o, e);
                        return x(n) && n === r
                    })(o, t, n) ? Kx.after(e ? t : n) : s)).getOr(s),
                    dC = (e, t) => e.fold(H, (e => {
                        return n = t, !(aC(o = e) === aC(n) && sC(o) === sC(n));
                        var o, n
                    })),
                    uC = (e, t) => e ? t.fold(O(I.some, Kx.start), I.none, O(I.some, Kx.after), I.none) : t.fold(I.none, O(I.some, Kx.before), I.none, O(I.some, Kx.end)),
                    mC = (e, t, o) => {
                        const n = e ? 1 : -1;
                        return t.setRng(Si(o.container(), o.offset() + n).toRange()), t.getSel().modify("move", e ? "forward" : "backward", "word"), !0
                    };
                var gC;
                ! function(e) {
                    e[e.Br = 0] = "Br", e[e.Block = 1] = "Block", e[e.Wrap = 2] = "Wrap", e[e.Eol = 3] = "Eol"
                }(gC || (gC = {}));
                const hC = (e, t) => e === Dd.Backwards ? ne(t) : t,
                    pC = (e, t, o) => e === Dd.Forwards ? t.next(o) : t.prev(o),
                    fC = (e, t, o, n) => qn(n.getNode(t === Dd.Forwards)) ? gC.Br : !1 === wd(o, n) ? gC.Block : gC.Wrap,
                    vC = (e, t, o, n) => {
                        const r = jd(o);
                        let s = n;
                        const a = [];
                        for (; s;) {
                            const o = pC(t, r, s);
                            if (!o) break;
                            if (qn(o.getNode(!1))) return t === Dd.Forwards ? {
                                positions: hC(t, a).concat([o]),
                                breakType: gC.Br,
                                breakAt: I.some(o)
                            } : {
                                positions: hC(t, a),
                                breakType: gC.Br,
                                breakAt: I.some(o)
                            };
                            if (o.isVisible()) {
                                if (e(s, o)) {
                                    const e = fC(0, t, s, o);
                                    return {
                                        positions: hC(t, a),
                                        breakType: e,
                                        breakAt: I.some(o)
                                    }
                                }
                                a.push(o), s = o
                            } else s = o
                        }
                        return {
                            positions: hC(t, a),
                            breakType: gC.Eol,
                            breakAt: I.none()
                        }
                    },
                    bC = (e, t, o, n) => t(o, n).breakAt.map((n => {
                        const r = t(o, n).positions;
                        return e === Dd.Backwards ? r.concat(n) : [n].concat(r)
                    })).getOr([]),
                    yC = (e, t) => Y(e, ((e, o) => e.fold((() => I.some(o)), (n => Bt(le(n.getClientRects()), le(o.getClientRects()), ((e, r) => {
                        const s = Math.abs(t - e.left);
                        return Math.abs(t - r.left) <= s ? o : n
                    })).or(e)))), I.none()),
                    wC = (e, t) => le(t.getClientRects()).bind((t => yC(e, t.left))),
                    xC = N(vC, Si.isAbove, -1),
                    CC = N(vC, Si.isBelow, 1),
                    SC = N(bC, -1, xC),
                    kC = N(bC, 1, CC),
                    _C = (e, t) => wC(SC(e, t), t),
                    OC = (e, t) => wC(kC(e, t), t),
                    TC = Yn,
                    EC = (e, t) => Math.abs(e.left - t),
                    AC = (e, t) => Math.abs(e.right - t),
                    MC = (e, t) => Ne(e, ((e, o) => {
                        const n = Math.min(EC(e, t), AC(e, t)),
                            r = Math.min(EC(o, t), AC(o, t));
                        return r === n && ke(o, "node") && TC(o.node) || r < n ? o : e
                    })),
                    NC = e => {
                        const t = t => j(t, (t => {
                            const o = Ya(t);
                            return o.node = e, o
                        }));
                        if (Rn(e)) return t(e.getClientRects());
                        if (Vn(e)) {
                            const o = e.ownerDocument.createRange();
                            return o.setStart(e, 0), o.setEnd(e, e.data.length), t(o.getClientRects())
                        }
                        return []
                    },
                    RC = e => te(e, NC);
                var DC;
                ! function(e) {
                    e[e.Up = -1] = "Up", e[e.Down = 1] = "Down"
                }(DC || (DC = {}));
                const BC = (e, t, o, n, r, s) => {
                        let a = 0;
                        const i = [],
                            l = n => {
                                let s = RC([n]); - 1 === e && (s = s.reverse());
                                for (let e = 0; e < s.length; e++) {
                                    const n = s[e];
                                    if (!o(n, c)) {
                                        if (i.length > 0 && t(n, De(i)) && a++, n.line = a, r(n)) return !0;
                                        i.push(n)
                                    }
                                }
                                return !1
                            },
                            c = De(s.getClientRects());
                        if (!c) return i;
                        const d = s.getNode();
                        return d && (l(d), ((e, t, o, n) => {
                            let r = n;
                            for (; r = bd(r, e, Kr, t);)
                                if (o(r)) return
                        })(e, n, l, d)), i
                    },
                    LC = N(BC, DC.Up, Qa, ei),
                    HC = N(BC, DC.Down, ei, Qa),
                    IC = e => De(e.getClientRects()),
                    PC = e => t => ((e, t) => t.line > e)(e, t),
                    zC = e => t => ((e, t) => t.line === e)(e, t),
                    FC = (e, t) => {
                        e.selection.setRng(t), Dg(e, e.selection.getRng())
                    },
                    VC = (e, t, o) => I.some(kx(e, t, o)),
                    ZC = (e, t, o, n, r, s) => {
                        const a = t === Dd.Forwards,
                            i = jd(e.getBody()),
                            l = N(Nd, a ? i.next : i.prev),
                            c = a ? n : r;
                        if (!o.collapsed) {
                            const n = oi(o);
                            if (s(n)) return Cx(t, e, n, t === Dd.Backwards, !1);
                            if (Mx(e)) {
                                const e = o.cloneRange();
                                return e.collapse(t === Dd.Backwards), I.from(e)
                            }
                        }
                        const d = Ad(t, e.getBody(), o);
                        if (c(d)) return Sx(e, d.getNode(!a));
                        let u = l(d);
                        const m = Pr(o);
                        if (!u) return m ? I.some(o) : I.none();
                        if (u = Ip(a, u), c(u)) return Cx(t, e, u.getNode(!a), a, !1);
                        const g = l(u);
                        return g && c(g) && Rd(u, g) ? Cx(t, e, g.getNode(!a), a, !1) : m ? VC(e, u.toRange(), !1) : I.none()
                    },
                    UC = (e, t, o, n, r, s) => {
                        const a = Ad(t, e.getBody(), o),
                            i = De(a.getClientRects()),
                            l = t === DC.Down,
                            c = e.getBody();
                        if (!i) return I.none();
                        if (Mx(e)) {
                            const e = l ? Si.fromRangeEnd(o) : Si.fromRangeStart(o);
                            return (l ? OC : _C)(c, e).orThunk((() => I.from(e))).map((e => e.toRange()))
                        }
                        const d = (l ? HC : LC)(c, PC(1), a),
                            u = G(d, zC(1)),
                            m = i.left,
                            g = MC(u, m);
                        if (g && s(g.node)) {
                            const o = Math.abs(m - g.left),
                                n = Math.abs(m - g.right);
                            return Cx(t, e, g.node, o < n, !1)
                        }
                        let h;
                        if (h = n(a) ? a.getNode() : r(a) ? a.getNode(!0) : oi(o), h) {
                            const o = ((e, t, o, n) => {
                                const r = jd(t);
                                let s, a, i, l;
                                const c = [];
                                let d = 0;
                                1 === e ? (s = r.next, a = ei, i = Qa, l = Si.after(n)) : (s = r.prev, a = Qa, i = ei, l = Si.before(n));
                                const u = IC(l);
                                do {
                                    if (!l.isVisible()) continue;
                                    const e = IC(l);
                                    if (i(e, u)) continue;
                                    c.length > 0 && a(e, De(c)) && d++;
                                    const t = Ya(e);
                                    if (t.position = l, t.line = d, o(t)) return c;
                                    c.push(t)
                                } while (l = s(l));
                                return c
                            })(t, c, PC(1), h);
                            let n = MC(G(o, zC(1)), m);
                            if (n) return VC(e, n.position.toRange(), !1);
                            if (n = De(G(o, zC(0))), n) return VC(e, n.position.toRange(), !1)
                        }
                        return 0 === u.length ? jC(e, l).filter(l ? r : n).map((t => kx(e, t.toRange(), !1))) : I.none()
                    },
                    jC = (e, t) => {
                        const o = e.selection.getRng(),
                            n = t ? Si.fromRangeEnd(o) : Si.fromRangeStart(o),
                            r = (s = n.container(), a = e.getBody(), Sn(go(s), (e => ad(e.dom)), (e => e.dom === a)).map((e => e.dom)).getOr(a));
                        var s, a;
                        if (t) {
                            const e = CC(r, n);
                            return ce(e.positions)
                        } {
                            const e = xC(r, n);
                            return le(e.positions)
                        }
                    },
                    WC = (e, t, o) => jC(e, t).filter(o).exists((t => (e.selection.setRng(t.toRange()), !0))),
                    $C = (e, t) => {
                        const o = e.dom.createRng();
                        o.setStart(t.container(), t.offset()), o.setEnd(t.container(), t.offset()), e.selection.setRng(o)
                    },
                    qC = (e, t) => {
                        e ? t.setAttribute("data-mce-selected", "inline-boundary") : t.removeAttribute("data-mce-selected")
                    },
                    GC = (e, t, o) => qx(t, o).map((t => ($C(e, t), o))),
                    KC = (e, t, o) => {
                        const n = e.getBody(),
                            r = ((e, t, o) => {
                                const n = Si.fromRangeStart(e);
                                if (e.collapsed) return n; {
                                    const r = Si.fromRangeEnd(e);
                                    return o ? Qd(t, r).getOr(r) : Jd(t, n).getOr(n)
                                }
                            })(e.selection.getRng(), n, o);
                        return ((e, t, o, n) => {
                            const r = Ip(e, n),
                                s = rC(t, o, r);
                            return rC(t, o, r).bind(N(uC, e)).orThunk((() => ((e, t, o, n, r) => {
                                const s = Ip(e, r);
                                return Gd(e, o, s).map(N(Ip, e)).fold((() => n.map(iC)), (r => rC(t, o, r).map(N(cC, e, t, o, s, r)).filter(N(dC, n)))).filter(nC)
                            })(e, t, o, s, n)))
                        })(o, N(Lp, e), n, r).bind((o => GC(e, t, o)))
                    },
                    YC = (e, t, o) => !!Xl(e) && KC(e, t, o).isSome(),
                    XC = (e, t, o) => !!Xl(t) && ((e, t) => {
                        const o = t.selection.getRng(),
                            n = e ? Si.fromRangeEnd(o) : Si.fromRangeStart(o);
                        return !!(e => C(e.selection.getSel().modify))(t) && (e && Dr(n) ? mC(!0, t.selection, n) : !(e || !Br(n)) && mC(!1, t.selection, n))
                    })(e, t),
                    JC = e => {
                        const t = xa(null),
                            o = N(Lp, e);
                        return e.on("NodeChange", (n => {
                            Xl(e) && (((e, t, o) => {
                                const n = j(rr(go(t.getRoot()), '*[data-mce-selected="inline-boundary"]'), (e => e.dom)),
                                    r = G(n, e),
                                    s = G(o, e);
                                W(re(r, s), N(qC, !1)), W(re(s, r), N(qC, !0))
                            })(o, e.dom, n.parents), ((e, t) => {
                                const o = t.get();
                                if (e.selection.isCollapsed() && !e.composing && o) {
                                    const n = Si.fromRangeStart(e.selection.getRng());
                                    Si.isTextPosition(n) && !(e => Dr(e) || Br(e))(n) && ($C(e, Yc(o, n)), t.set(null))
                                }
                            })(e, t), ((e, t, o, n) => {
                                if (t.selection.isCollapsed()) {
                                    const r = G(n, e);
                                    W(r, (n => {
                                        const r = Si.fromRangeStart(t.selection.getRng());
                                        rC(e, t.getBody(), r).bind((e => GC(t, o, e)))
                                    }))
                                }
                            })(o, e, t, n.parents))
                        })), t
                    },
                    QC = N(XC, !0),
                    eS = N(XC, !1),
                    tS = (e, t, o) => {
                        if (Xl(e)) {
                            const n = jC(e, t).getOrThunk((() => {
                                const o = e.selection.getRng();
                                return t ? Si.fromRangeEnd(o) : Si.fromRangeStart(o)
                            }));
                            return rC(N(Lp, e), e.getBody(), n).exists((t => {
                                const n = iC(t);
                                return qx(o, n).exists((t => ($C(e, t), !0)))
                            }))
                        }
                        return !1
                    },
                    oS = (e, t) => o => qx(t, o).map((t => () => $C(e, t))),
                    nS = (e, t, o, n) => {
                        const r = e.getBody(),
                            s = N(Lp, e);
                        e.undoManager.ignore((() => {
                            e.selection.setRng(((e, t) => {
                                const o = document.createRange();
                                return o.setStart(e.container(), e.offset()), o.setEnd(t.container(), t.offset()), o
                            })(o, n)), Vp(e), rC(s, r, Si.fromRangeStart(e.selection.getRng())).map(lC).bind(oS(e, t)).each(B)
                        })), e.nodeChanged()
                    },
                    rS = (e, t, o) => {
                        if (e.selection.isCollapsed() && Xl(e)) {
                            const n = Si.fromRangeStart(e.selection.getRng());
                            return ((e, t, o, n) => {
                                const r = ((e, t) => yd(t, e) || e)(e.getBody(), n.container()),
                                    s = N(Lp, e),
                                    a = rC(s, r, n);
                                return a.bind((e => o ? e.fold(E(I.some(lC(e))), I.none, E(I.some(iC(e))), I.none) : e.fold(I.none, E(I.some(iC(e))), I.none, E(I.some(lC(e)))))).map(oS(e, t)).getOrThunk((() => {
                                    const i = Kd(o, r, n),
                                        l = i.bind((e => rC(s, r, e)));
                                    return Bt(a, l, (() => Hp(s, r, n).bind((t => (e => Bt(eu(e), tu(e), ((t, o) => {
                                        const n = Ip(!0, t),
                                            r = Ip(!1, o);
                                        return Jd(e, n).forall((e => e.isEqual(r)))
                                    })).getOr(!0))(t) ? I.some((() => {
                                        Dp(e, o, go(t))
                                    })) : I.none())))).getOrThunk((() => l.bind((() => i.map((r => () => {
                                        o ? nS(e, t, n, r) : nS(e, t, r, n)
                                    }))))))
                                }))
                            })(e, t, o, n)
                        }
                        return I.none()
                    },
                    sS = e => 1 === Bo(e),
                    aS = (e, t) => {
                        const o = go(e.getBody()),
                            n = go(e.selection.getStart()),
                            r = G(((e, t) => {
                                const o = qh(t, e);
                                return Q(o, dr).fold(E(o), (e => o.slice(0, e)))
                            })(o, n), sS);
                        return ce(r).bind((o => {
                            const n = Si.fromRangeStart(e.selection.getRng());
                            return !((e, t, o) => Bt(eu(o), tu(o), ((n, r) => {
                                const s = Ip(!0, n),
                                    a = Ip(!1, r),
                                    i = Ip(!1, t);
                                return e ? Jd(o, i).exists((e => e.isEqual(a) && t.isEqual(s))) : Qd(o, i).exists((e => e.isEqual(s) && t.isEqual(a)))
                            })).getOr(!0))(t, n, o.dom) || nu((s = o).dom) && ev(s.dom) ? I.none() : I.some((() => ((e, t, o, n) => {
                                const r = N(lv, t),
                                    s = j(G(n, r), (e => e.dom));
                                if (0 === s.length) Dp(t, e, o);
                                else {
                                    const e = ((e, t) => {
                                        const o = ov(!1),
                                            n = av(t, o.dom);
                                        return Jo(go(e), o), rn(go(e)), Si(n, 0)
                                    })(o.dom, s);
                                    t.selection.setRng(e.toRange())
                                }
                            })(t, e, o, r)));
                            var s
                        }))
                    },
                    iS = (e, t) => e.selection.isCollapsed() ? aS(e, t) : I.none(),
                    lS = (e, t, o) => x(o) ? I.some((() => {
                        e._selectionOverrides.hideFakeCaret(), Dp(e, t, go(o))
                    })) : I.none(),
                    cS = (e, t) => e.selection.isCollapsed() ? ((e, t) => {
                        const o = t ? Fh : Vh,
                            n = t ? Dd.Forwards : Dd.Backwards,
                            r = Ad(n, e.getBody(), e.selection.getRng());
                        return o(r) ? lS(e, t, r.getNode(!t)) : I.from(Ip(t, r)).filter((e => o(e) && Rd(r, e))).bind((o => lS(e, t, o.getNode(!t))))
                    })(e, t) : ((e, t) => {
                        const o = e.selection.getNode();
                        return Qn(o) ? lS(e, t, o) : I.none()
                    })(e, t),
                    dS = e => Ke(null != e ? e : "").getOr(0),
                    uS = (e, t) => (e || "table" === Ht(t) ? "margin" : "padding") + ("rtl" === qo(t, "direction") ? "-right" : "-left"),
                    mS = e => {
                        const t = hS(e);
                        return !e.mode.isReadOnly() && (t.length > 1 || ((e, t) => oe(t, (t => {
                            const o = uS(Ll(e), t),
                                n = Ko(t, o).map(dS).getOr(0);
                            return "false" !== e.dom.getContentEditable(t.dom) && n > 0
                        })))(e, t))
                    },
                    gS = e => hr(e) || pr(e),
                    hS = e => G(an(e.selection.getSelectedBlocks()), (e => !gS(e) && !(e => So(e).exists(gS))(e) && kn(e, (e => Kn(e.dom) || Yn(e.dom))).exists((e => Kn(e.dom))))),
                    pS = (e, t) => {
                        var o, n;
                        const {
                            dom: r
                        } = e, s = Hl(e), a = null !== (n = null === (o = /[a-z%]+$/i.exec(s)) || void 0 === o ? void 0 : o[0]) && void 0 !== n ? n : "px", i = dS(s), l = Ll(e);
                        W(hS(e), (e => {
                            ((e, t, o, n, r, s) => {
                                const a = uS(o, go(s)),
                                    i = dS(e.getStyle(s, a));
                                if ("outdent" === t) {
                                    const t = Math.max(0, i - n);
                                    e.setStyle(s, a, t ? t + r : "")
                                } else {
                                    const t = i + n + r;
                                    e.setStyle(s, a, t)
                                }
                            })(r, t, l, i, a, e.dom)
                        }))
                    },
                    fS = e => pS(e, "outdent"),
                    vS = e => {
                        if (e.selection.isCollapsed() && mS(e)) {
                            const t = e.dom,
                                o = e.selection.getRng(),
                                n = Si.fromRangeStart(o),
                                r = t.getParent(o.startContainer, t.isBlock);
                            if (null !== r && Jh(go(r), n)) return I.some((() => fS(e)))
                        }
                        return I.none()
                    },
                    bS = (e, t, o) => ue([vS, Hx, Ex, (e, o) => rS(e, t, o), bx, bf, Ix, cS, xx, iS], (t => t(e, o))),
                    yS = (e, t) => {
                        e.addCommand("delete", (() => {
                            ((e, t) => {
                                bS(e, t, !1).fold((() => {
                                    Vp(e), jp(e)
                                }), B)
                            })(e, t)
                        })), e.addCommand("forwardDelete", (() => {
                            ((e, t) => {
                                bS(e, t, !0).fold((() => (e => Fp(e, "ForwardDelete"))(e)), B)
                            })(e, t)
                        }))
                    },
                    wS = e => void 0 === e.touches || 1 !== e.touches.length ? I.none() : I.some(e.touches[0]),
                    xS = (e, t) => Se(e, t.nodeName),
                    CS = (e, t) => !!Vn(t) || !!Rn(t) && !xS(e.getBlockElements(), t) && !fu(t) && !fs(e, t),
                    SS = (e, t) => {
                        if (Vn(t)) {
                            if (0 === t.data.length) return !0;
                            if (/^\s+$/.test(t.data) && (!t.nextSibling || xS(e, t.nextSibling))) return !0
                        }
                        return !1
                    },
                    kS = e => e.dom.create(pl(e), fl(e)),
                    _S = e => {
                        const t = e.dom,
                            o = e.selection,
                            n = e.schema,
                            r = n.getBlockElements(),
                            s = o.getStart(),
                            a = e.getBody();
                        let i, l, c = !1;
                        const d = pl(e);
                        if (!s || !Rn(s)) return;
                        const u = a.nodeName.toLowerCase();
                        if (!n.isValidChild(u, d.toLowerCase()) || ((e, t, o) => U($h(go(o), go(t)), (t => xS(e, t.dom))))(r, a, s)) return;
                        const m = o.getRng(),
                            {
                                startContainer: g,
                                startOffset: h,
                                endContainer: p,
                                endOffset: f
                            } = m,
                            v = eh(e);
                        let b = a.firstChild;
                        for (; b;)
                            if (Rn(b) && ms(n, b), CS(n, b)) {
                                if (SS(r, b)) {
                                    l = b, b = b.nextSibling, t.remove(l);
                                    continue
                                }
                                i || (i = kS(e), a.insertBefore(i, b), c = !0), l = b, b = b.nextSibling, i.appendChild(l)
                            } else i = null, b = b.nextSibling;
                        c && v && (m.setStart(g, h), m.setEnd(p, f), o.setRng(m), e.nodeChanged())
                    },
                    OS = (e, t, o) => {
                        const n = go(kS(e)),
                            r = xr();
                        tn(n, r), o(t, n);
                        const s = document.createRange();
                        return s.setStartBefore(r.dom), s.setEndBefore(r.dom), s
                    },
                    TS = e => t => -1 !== (" " + t.attr("class") + " ").indexOf(e),
                    ES = (e, t, o) => function(n) {
                        const r = arguments,
                            s = r[r.length - 2],
                            a = s > 0 ? t.charAt(s - 1) : "";
                        if ('"' === a) return n;
                        if (">" === a) {
                            const e = t.lastIndexOf("<", s);
                            if (-1 !== e && -1 !== t.substring(e, s).indexOf('contenteditable="false"')) return n
                        }
                        return '<span class="' + o + '" data-mce-content="' + e.dom.encode(r[0]) + '">' + e.dom.encode("string" == typeof r[1] ? r[1] : r[0]) + "</span>"
                    },
                    AS = (e, t) => {
                        t.hasAttribute("data-mce-caret") && (Ir(t), e.selection.setRng(e.selection.getRng()), e.selection.scrollIntoView(t))
                    },
                    MS = (e, t) => {
                        const o = (e => On(go(e.getBody()), "*[data-mce-caret]").map((e => e.dom)).getOrNull())(e);
                        if (o) return "compositionstart" === t.type ? (t.preventDefault(), t.stopPropagation(), void AS(e, o)) : void(Rr(o) && (AS(e, o), e.undoManager.add()))
                    },
                    NS = Yn,
                    RS = (e, t, o) => {
                        const n = jd(e.getBody()),
                            r = N(Nd, 1 === t ? n.next : n.prev);
                        if (o.collapsed) {
                            const n = e.dom.getParent(o.startContainer, "PRE");
                            if (!n) return;
                            if (!r(Si.fromRangeStart(o))) {
                                const o = go((e => {
                                    const t = e.dom.create(pl(e));
                                    return t.innerHTML = '<br data-mce-bogus="1">', t
                                })(e));
                                1 === t ? Qo(go(n), o) : Jo(go(n), o), e.selection.select(o.dom, !0), e.selection.collapse()
                            }
                        }
                    },
                    DS = (e, t) => ((e, t) => {
                        const o = t ? Dd.Forwards : Dd.Backwards,
                            n = e.selection.getRng();
                        return ((e, t, o) => ZC(t, e, o, jh, Wh, NS))(o, e, n).orThunk((() => (RS(e, o, n), I.none())))
                    })(e, t).exists((t => (FC(e, t), !0))),
                    BS = (e, t) => ((e, t) => {
                        const o = t ? 1 : -1,
                            n = e.selection.getRng();
                        return ((e, t, o) => UC(t, e, o, (e => jh(e) || Zh(e)), (e => Wh(e) || Uh(e)), NS))(o, e, n).orThunk((() => (RS(e, o, n), I.none())))
                    })(e, t).exists((t => (FC(e, t), !0))),
                    LS = (e, t) => WC(e, t, t ? Wh : jh),
                    HS = (e, t) => Ax(e, !t).map((o => {
                        const n = o.toRange(),
                            r = e.selection.getRng();
                        return t ? n.setStart(r.startContainer, r.startOffset) : n.setEnd(r.endContainer, r.endOffset), n
                    })).exists((t => (FC(e, t), !0))),
                    IS = e => Z(["figcaption"], Ht(e)),
                    PS = (e, t) => {
                        const o = go(e.getBody()),
                            n = Si.fromRangeStart(e.selection.getRng());
                        return ((e, t) => {
                            const o = N(bo, t);
                            return kn(go(e.container()), dr, o).filter(IS)
                        })(n, o).exists((() => {
                            if (((e, t, o) => t ? ((e, t) => CC(e, t).breakAt.isNone())(e.dom, o) : ((e, t) => xC(e, t).breakAt.isNone())(e.dom, o))(o, t, n)) {
                                const n = OS(e, o, t ? tn : en);
                                return e.selection.setRng(n), !0
                            }
                            return !1
                        }))
                    },
                    zS = (e, t) => !!e.selection.isCollapsed() && PS(e, t),
                    FS = {
                        shiftKey: !1,
                        altKey: !1,
                        ctrlKey: !1,
                        metaKey: !1,
                        keyCode: 0
                    },
                    VS = (e, t) => t.keyCode === e.keyCode && t.shiftKey === e.shiftKey && t.altKey === e.altKey && t.ctrlKey === e.ctrlKey && t.metaKey === e.metaKey,
                    ZS = (e, ...t) => () => e.apply(null, t),
                    US = (e, t) => J(((e, t) => te((e => j(e, (e => ({ ...FS,
                        ...e
                    }))))(e), (e => VS(e, t) ? [e] : [])))(e, t), (e => e.action())),
                    jS = (e, t) => ue(((e, t) => te((e => j(e, (e => ({ ...FS,
                        ...e
                    }))))(e), (e => VS(e, t) ? [e] : [])))(e, t), (e => e.action())),
                    WS = (e, t) => {
                        const o = t ? Dd.Forwards : Dd.Backwards,
                            n = e.selection.getRng();
                        return ZC(e, o, n, Fh, Vh, Qn).exists((t => (FC(e, t), !0)))
                    },
                    $S = (e, t) => {
                        const o = t ? 1 : -1,
                            n = e.selection.getRng();
                        return UC(e, o, n, Fh, Vh, Qn).exists((t => (FC(e, t), !0)))
                    },
                    qS = (e, t) => WC(e, t, t ? Vh : Fh),
                    GS = Gi([{
                        none: ["current"]
                    }, {
                        first: ["current"]
                    }, {
                        middle: ["current", "target"]
                    }, {
                        last: ["current"]
                    }]),
                    KS = { ...GS,
                        none: e => GS.none(e)
                    },
                    YS = (e, t, o) => te(Mo(e), (e => fo(e, t) ? o(e) ? [e] : [] : YS(e, t, o))),
                    XS = (e, t) => Tn(e, "table", t),
                    JS = (e, t, o, n, r = H) => {
                        const s = 1 === n;
                        if (!s && o <= 0) return KS.first(e[0]);
                        if (s && o >= e.length - 1) return KS.last(e[e.length - 1]); {
                            const s = o + n,
                                a = e[s];
                            return r(a) ? KS.middle(t, a) : JS(e, t, s, n, r)
                        }
                    },
                    QS = (e, t) => XS(e, t).bind((t => {
                        const o = YS(t, "th,td", H);
                        return Q(o, (t => bo(e, t))).map((e => ({
                            index: e,
                            all: o
                        })))
                    })),
                    ek = (e, t = !1) => {
                        return Uo(e) ? e.dom.isContentEditable : (o = e, Tn(o, "[contenteditable]")).fold(E(t), (e => "true" === tk(e)));
                        var o
                    },
                    tk = e => e.dom.contentEditable,
                    ok = (e, t, o, n, r) => {
                        const s = rr(go(o), "td,th,caption").map((e => e.dom)),
                            a = G(((e, t) => te(t, (t => {
                                const o = ((e, t) => ({
                                    left: e.left - t,
                                    top: e.top - t,
                                    right: e.right + -2,
                                    bottom: e.bottom + -2,
                                    width: e.width + t,
                                    height: e.height + t
                                }))(Ya(t.getBoundingClientRect()), -1);
                                return [{
                                    x: o.left,
                                    y: e(o),
                                    cell: t
                                }, {
                                    x: o.right,
                                    y: e(o),
                                    cell: t
                                }]
                            })))(e, s), (e => t(e, r)));
                        return ((e, t, o) => Y(e, ((e, n) => e.fold((() => I.some(n)), (e => {
                            const r = Math.sqrt(Math.abs(e.x - t) + Math.abs(e.y - o)),
                                s = Math.sqrt(Math.abs(n.x - t) + Math.abs(n.y - o));
                            return I.some(s < r ? n : e)
                        }))), I.none()))(a, n, r).map((e => e.cell))
                    },
                    nk = N(ok, (e => e.bottom), ((e, t) => e.y < t)),
                    rk = N(ok, (e => e.top), ((e, t) => e.y > t)),
                    sk = (e, t, o) => {
                        const n = e(t, o);
                        return (e => e.breakType === gC.Wrap && 0 === e.positions.length)(n) || !qn(o.getNode()) && (e => e.breakType === gC.Br && 1 === e.positions.length)(n) ? !((e, t, o) => o.breakAt.exists((o => e(t, o).breakAt.isSome())))(e, t, n) : n.breakAt.isNone()
                    },
                    ak = N(sk, xC),
                    ik = N(sk, CC),
                    lk = (e, t, o, n) => {
                        const r = e.selection.getRng(),
                            s = t ? 1 : -1;
                        return !(!nd() || !((e, t, o) => {
                            const n = Si.fromRangeStart(t);
                            return Xd(!e, o).exists((e => e.isEqual(n)))
                        })(t, r, o) || (Cx(s, e, o, !t, !1).each((t => {
                            FC(e, t)
                        })), 0))
                    },
                    ck = (e, t, o) => {
                        const n = ((e, t) => {
                                const o = t.getNode(e);
                                return Pn(o) ? I.some(o) : I.none()
                            })(!!t, o),
                            r = !1 === t;
                        n.fold((() => FC(e, o.toRange())), (n => Xd(r, e.getBody()).filter((e => e.isEqual(o))).fold((() => FC(e, o.toRange())), (o => ((e, t, o) => {
                            t.undoManager.transact((() => {
                                const n = e ? Qo : Jo,
                                    r = OS(t, go(o), n);
                                FC(t, r)
                            }))
                        })(t, e, n)))))
                    },
                    dk = (e, t, o, n) => {
                        const r = e.selection.getRng(),
                            s = Si.fromRangeStart(r),
                            a = e.getBody();
                        if (!t && ak(n, s)) {
                            const n = ((e, t, o) => ((e, t) => le(t.getClientRects()).bind((t => nk(e, t.left, t.top))).bind((e => {
                                return wC(tu(o = e).map((e => xC(o, e).positions.concat(e))).getOr([]), t);
                                var o
                            })))(t, o).orThunk((() => le(o.getClientRects()).bind((o => yC(SC(e, Si.before(t)), o.left))))).getOr(Si.before(t)))(a, o, s);
                            return ck(e, t, n), !0
                        }
                        if (t && ik(n, s)) {
                            const n = ((e, t, o) => ((e, t) => ce(t.getClientRects()).bind((t => rk(e, t.left, t.top))).bind((e => {
                                return wC(eu(o = e).map((e => [e].concat(CC(o, e).positions))).getOr([]), t);
                                var o
                            })))(t, o).orThunk((() => le(o.getClientRects()).bind((o => yC(kC(e, Si.after(t)), o.left))))).getOr(Si.after(t)))(a, o, s);
                            return ck(e, t, n), !0
                        }
                        return !1
                    },
                    uk = (e, t, o) => I.from(e.dom.getParent(e.selection.getNode(), "td,th")).bind((n => I.from(e.dom.getParent(n, "table")).map((r => o(e, t, r, n))))).getOr(!1),
                    mk = (e, t) => uk(e, t, lk),
                    gk = (e, t) => uk(e, t, dk),
                    hk = (e, t, o) => o.fold(I.none, I.none, ((e, t) => {
                        return (o = t, ((e, t) => {
                            const o = e => {
                                for (let n = 0; n < e.childNodes.length; n++) {
                                    const r = go(e.childNodes[n]);
                                    if (t(r)) return I.some(r);
                                    const s = o(e.childNodes[n]);
                                    if (s.isSome()) return s
                                }
                                return I.none()
                            };
                            return o(e.dom)
                        })(o, lh)).map((e => (e => {
                            const t = Ym.exact(e, 0, e, 0);
                            return tg(t)
                        })(e)));
                        var o
                    }), (o => (e.execCommand("mceTableInsertRowAfter"), pk(e, t, o)))),
                    pk = (e, t, o) => {
                        return hk(e, t, (r = ek, QS(n = o, void 0).fold((() => KS.none(n)), (e => JS(e.all, n, e.index, 1, r)))));
                        var n, r
                    },
                    fk = (e, t, o) => {
                        return hk(e, t, (r = ek, QS(n = o, void 0).fold((() => KS.none()), (e => JS(e.all, n, e.index, -1, r)))));
                        var n, r
                    },
                    vk = (e, t) => {
                        const o = ["table", "li", "dl"],
                            n = go(e.getBody()),
                            r = e => {
                                const t = Ht(e);
                                return bo(e, n) || Z(o, t)
                            },
                            s = e.selection.getRng();
                        return ((e, t) => ((e, t, o = L) => o(t) ? I.none() : Z(e, Ht(t)) ? I.some(t) : _n(t, e.join(","), (e => fo(e, "table") || o(e))))(["td", "th"], e, t))(go(t ? s.endContainer : s.startContainer), r).map((o => (XS(o, r).each((t => {
                            e.model.table.clearSelectedCells(t.dom)
                        })), e.selection.collapse(!t), (t ? pk : fk)(e, r, o).each((t => {
                            e.selection.setRng(t)
                        })), !0))).getOr(!1)
                    },
                    bk = (e, t) => ({
                        container: e,
                        offset: t
                    }),
                    yk = ba.DOM,
                    wk = e => t => e === t ? -1 : 0,
                    xk = (e, t, o) => {
                        if (Vn(e) && t >= 0) return I.some(bk(e, t)); {
                            const n = Ga(yk);
                            return I.from(n.backwards(e, t, wk(e), o)).map((e => bk(e.container, e.container.data.length)))
                        }
                    },
                    Ck = (e, t, o) => {
                        if (!Vn(e)) return I.none();
                        const n = e.data;
                        if (t >= 0 && t <= n.length) return I.some(bk(e, t)); {
                            const n = Ga(yk);
                            return I.from(n.backwards(e, t, wk(e), o)).bind((e => {
                                const n = e.container.data;
                                return Ck(e.container, t + n.length, o)
                            }))
                        }
                    },
                    Sk = (e, t, o) => {
                        if (!Vn(e)) return I.none();
                        const n = e.data;
                        if (t <= n.length) return I.some(bk(e, t)); {
                            const r = Ga(yk);
                            return I.from(r.forwards(e, t, wk(e), o)).bind((e => Sk(e.container, t - n.length, o)))
                        }
                    },
                    kk = (e, t, o, n, r) => {
                        const s = Ga(e, (e => t => e.isBlock(t) || Z(["BR", "IMG", "HR", "INPUT"], t.nodeName) || "false" === e.getContentEditable(t))(e));
                        return I.from(s.backwards(t, o, n, r))
                    },
                    _k = e => Or(e.toString().replace(/\u00A0/g, " ")),
                    Ok = e => "" !== e && -1 !== " \f\n\r\t\v".indexOf(e),
                    Tk = (e, t) => e.substring(t.length),
                    Ek = (e, t, o, n = 0) => {
                        return (r = go(t.startContainer), Tn(r, ch)).fold((() => ((e, t, o, n = 0) => {
                            if (!(r = t).collapsed || !Vn(r.startContainer)) return I.none();
                            var r;
                            const s = {
                                    text: "",
                                    offset: 0
                                },
                                a = e.getParent(t.startContainer, e.isBlock) || e.getRoot();
                            return kk(e, t.startContainer, t.startOffset, ((e, t, n) => (s.text = n + s.text, s.offset += t, ((e, t, o) => {
                                let n;
                                const r = o.charAt(0);
                                for (n = t - 1; n >= 0; n--) {
                                    const s = e.charAt(n);
                                    if (Ok(s)) return I.none();
                                    if (r === s && Fe(e, o, n, t)) break
                                }
                                return I.some(n)
                            })(s.text, s.offset, o).getOr(t))), a).bind((e => {
                                const r = t.cloneRange();
                                if (r.setStart(e.container, e.offset), r.setEnd(t.endContainer, t.endOffset), r.collapsed) return I.none();
                                const s = _k(r);
                                return 0 !== s.lastIndexOf(o) || Tk(s, o).length < n ? I.none() : I.some({
                                    text: Tk(s, o),
                                    range: r,
                                    trigger: o
                                })
                            }))
                        })(e, t, o, n)), (t => {
                            const n = e.createRng();
                            n.selectNode(t.dom);
                            const r = _k(n);
                            return I.some({
                                range: n,
                                text: Tk(r, o),
                                trigger: o
                            })
                        }));
                        var r
                    },
                    Ak = e => {
                        if ((e => 3 === e.nodeType)(e)) return bk(e, e.data.length); {
                            const t = e.childNodes;
                            return t.length > 0 ? Ak(t[t.length - 1]) : bk(e, t.length)
                        }
                    },
                    Mk = (e, t) => {
                        const o = e.childNodes;
                        return o.length > 0 && t < o.length ? Mk(o[t], 0) : o.length > 0 && (e => 1 === e.nodeType)(e) && o.length === t ? Ak(o[o.length - 1]) : bk(e, t)
                    },
                    Nk = (e, t, o, n = {}) => {
                        var r;
                        const s = t(),
                            a = null !== (r = e.selection.getRng().startContainer.nodeValue) && void 0 !== r ? r : "",
                            i = G(s.lookupByTrigger(o.trigger), (t => o.text.length >= t.minChars && t.matches.getOrThunk((() => (e => t => {
                                const o = Mk(t.startContainer, t.startOffset);
                                return !((e, t) => {
                                    var o;
                                    const n = null !== (o = e.getParent(t.container, e.isBlock)) && void 0 !== o ? o : e.getRoot();
                                    return kk(e, t.container, t.offset, ((e, t) => 0 === t ? -1 : t), n).filter((e => {
                                        const t = e.container.data.charAt(e.offset - 1);
                                        return !Ok(t)
                                    })).isSome()
                                })(e, o)
                            })(e.dom)))(o.range, a, o.text)));
                        if (0 === i.length) return I.none();
                        const l = Promise.all(j(i, (e => e.fetch(o.text, e.maxResults, n).then((t => ({
                            matchText: o.text,
                            items: t,
                            columns: e.columns,
                            onAction: e.onAction,
                            highlightOn: e.highlightOn
                        }))))));
                        return I.some({
                            lookupData: l,
                            context: o
                        })
                    };
                var Rk;
                ! function(e) {
                    e[e.Error = 0] = "Error", e[e.Value = 1] = "Value"
                }(Rk || (Rk = {}));
                const Dk = (e, t, o) => e.stype === Rk.Error ? t(e.serror) : o(e.svalue),
                    Bk = e => ({
                        stype: Rk.Value,
                        svalue: e
                    }),
                    Lk = e => ({
                        stype: Rk.Error,
                        serror: e
                    }),
                    Hk = Dk,
                    Ik = e => h(e) && me(e).length > 100 ? " removed due to size" : JSON.stringify(e, null, 2),
                    Pk = (e, t) => Lk([{
                        path: e,
                        getErrorInfo: t
                    }]),
                    zk = (e, t) => ({
                        extract: (o, n) => Ce(n, e).fold((() => ((e, t) => Pk(e, (() => 'Choice schema did not contain choice key: "' + t + '"')))(o, e)), (e => ((e, t, o, n) => Ce(o, n).fold((() => ((e, t, o) => Pk(e, (() => 'The chosen schema: "' + o + '" did not exist in branches: ' + Ik(t))))(e, o, n)), (o => o.extract(e.concat(["branch: " + n]), t))))(o, n, t, e))),
                        toString: () => "chooseOn(" + e + "). Possible values: " + me(t)
                    }),
                    Fk = e => (...t) => {
                        if (0 === t.length) throw new Error("Can't merge zero objects");
                        const o = {};
                        for (let n = 0; n < t.length; n++) {
                            const r = t[n];
                            for (const t in r) Se(r, t) && (o[t] = e(o[t], r[t]))
                        }
                        return o
                    },
                    Vk = Fk(((e, t) => p(e) && p(t) ? Vk(e, t) : t)),
                    Zk = (Fk(((e, t) => t)), e => ({
                        tag: "defaultedThunk",
                        process: E(e)
                    })),
                    Uk = e => {
                        const t = (e => {
                            const t = [],
                                o = [];
                            return W(e, (e => {
                                Dk(e, (e => o.push(e)), (e => t.push(e)))
                            })), {
                                values: t,
                                errors: o
                            }
                        })(e);
                        return t.errors.length > 0 ? (o = t.errors, O(Lk, ee)(o)) : Bk(t.values);
                        var o
                    },
                    jk = (e, t, o) => {
                        switch (e.tag) {
                            case "field":
                                return t(e.key, e.newKey, e.presence, e.prop);
                            case "custom":
                                return o(e.newKey, e.instantiator)
                        }
                    },
                    Wk = e => ({
                        extract: (t, o) => {
                            return n = e(o), r = e => ((e, t) => Pk(e, E(t)))(t, e), n.stype === Rk.Error ? r(n.serror) : n;
                            var n, r
                        },
                        toString: E("val")
                    }),
                    $k = Wk(Bk),
                    qk = (e, t, o, n) => n(Ce(e, t).getOrThunk((() => o(e)))),
                    Gk = (e, t, o, n, r) => {
                        const s = e => r.extract(t.concat([n]), e),
                            a = e => e.fold((() => Bk(I.none())), (e => {
                                const o = r.extract(t.concat([n]), e);
                                return s = o, a = I.some, s.stype === Rk.Value ? {
                                    stype: Rk.Value,
                                    svalue: a(s.svalue)
                                } : s;
                                var s, a
                            }));
                        switch (e.tag) {
                            case "required":
                                return ((e, t, o, n) => Ce(t, o).fold((() => ((e, t, o) => Pk(e, (() => 'Could not find valid *required* value for "' + t + '" in ' + Ik(o))))(e, o, t)), n))(t, o, n, s);
                            case "defaultedThunk":
                                return qk(o, n, e.process, s);
                            case "option":
                                return ((e, t, o) => o(Ce(e, t)))(o, n, a);
                            case "defaultedOptionThunk":
                                return ((e, t, o, n) => n(Ce(e, t).map((t => !0 === t ? o(e) : t))))(o, n, e.process, a);
                            case "mergeWithThunk":
                                return qk(o, n, E({}), (t => {
                                    const n = Vk(e.process(o), t);
                                    return s(n)
                                }))
                        }
                    },
                    Kk = e => ({
                        extract: (t, o) => ((e, t, o) => {
                            const n = {},
                                r = [];
                            for (const s of o) jk(s, ((o, s, a, i) => {
                                const l = Gk(a, e, t, o, i);
                                Hk(l, (e => {
                                    r.push(...e)
                                }), (e => {
                                    n[s] = e
                                }))
                            }), ((e, o) => {
                                n[e] = o(t)
                            }));
                            return r.length > 0 ? Lk(r) : Bk(n)
                        })(t, o, e),
                        toString: () => {
                            const t = j(e, (e => jk(e, ((e, t, o, n) => e + " -> " + n.toString()), ((e, t) => "state(" + e + ")"))));
                            return "obj{\n" + t.join("\n") + "}"
                        }
                    }),
                    Yk = e => ({
                        extract: (t, o) => {
                            const n = j(o, ((o, n) => e.extract(t.concat(["[" + n + "]"]), o)));
                            return Uk(n)
                        },
                        toString: () => "array(" + e.toString() + ")"
                    }),
                    Xk = (e, t, o) => {
                        return n = ((e, t, o) => ((e, t) => e.stype === Rk.Error ? {
                            stype: Rk.Error,
                            serror: t(e.serror)
                        } : e)(t.extract([e], o), (e => ({
                            input: o,
                            errors: e
                        }))))(e, t, o), Dk(n, qi.error, qi.value);
                        var n
                    },
                    Jk = (e, t) => zk(e, pe(t, Kk)),
                    Qk = E($k),
                    e_ = (e, t) => Wk((o => {
                        const n = typeof o;
                        return e(o) ? Bk(o) : Lk(`Expected type: ${t} but got: ${n}`)
                    })),
                    t_ = e_(S, "number"),
                    o_ = e_(g, "string"),
                    n_ = e_(b, "boolean"),
                    r_ = e_(C, "function"),
                    s_ = (e, t, o, n) => ({
                        tag: "field",
                        key: e,
                        newKey: t,
                        presence: o,
                        prop: n
                    }),
                    a_ = (e, t) => ({
                        tag: "custom",
                        newKey: e,
                        instantiator: t
                    }),
                    i_ = (e, t) => s_(e, e, {
                        tag: "required",
                        process: {}
                    }, t),
                    l_ = e => i_(e, o_),
                    c_ = e => i_(e, r_),
                    d_ = (e, t) => s_(e, e, {
                        tag: "option",
                        process: {}
                    }, t),
                    u_ = e => d_(e, o_),
                    m_ = (e, t, o) => s_(e, e, Zk(t), o),
                    g_ = (e, t) => m_(e, t, t_),
                    h_ = (e, t, o) => m_(e, t, (e => {
                        return t = t => Z(e, t) ? qi.value(t) : qi.error(`Unsupported value: "${t}", choose one of "${e.join(", ")}".`), Wk((e => t(e).fold(Lk, Bk)));
                        var t
                    })(o)),
                    p_ = (e, t) => m_(e, t, n_),
                    f_ = (e, t) => m_(e, t, r_),
                    v_ = l_("type"),
                    b_ = c_("fetch"),
                    y_ = c_("onAction"),
                    w_ = f_("onSetup", (() => _)),
                    x_ = u_("text"),
                    C_ = u_("icon"),
                    S_ = u_("tooltip"),
                    k_ = u_("label"),
                    __ = p_("active", !1),
                    O_ = p_("enabled", !0),
                    T_ = p_("primary", !1),
                    E_ = e => ((e, t) => m_("type", t, o_))(0, e),
                    A_ = Kk([v_, l_("trigger"), g_("minChars", 1), (1, ((e, t) => s_(e, e, Zk(1), Qk()))("columns")), g_("maxResults", 10), ("matches", d_("matches", r_)), b_, y_, (M_ = o_, m_("highlightOn", [], Yk(M_)))]);
                var M_;
                const N_ = [O_, S_, C_, x_, w_],
                    R_ = [__].concat(N_),
                    D_ = [f_("predicate", L), h_("scope", "node", ["node", "editor"]), h_("position", "selection", ["node", "selection", "line"])],
                    B_ = N_.concat([E_("contextformbutton"), T_, y_, a_("original", A)]),
                    L_ = R_.concat([E_("contextformbutton"), T_, y_, a_("original", A)]),
                    H_ = N_.concat([E_("contextformbutton")]),
                    I_ = R_.concat([E_("contextformtogglebutton")]),
                    P_ = Jk("type", {
                        contextformbutton: B_,
                        contextformtogglebutton: L_
                    });
                Kk([E_("contextform"), f_("initValue", E("")), k_, ((e, t) => s_(e, e, {
                    tag: "required",
                    process: {}
                }, Yk(t)))("commands", P_), d_("launch", Jk("type", {
                    contextformbutton: H_,
                    contextformtogglebutton: I_
                }))].concat(D_));
                const z_ = e => {
                        const t = e.ui.registry.getAll().popups,
                            o = pe(t, (e => {
                                return (t = e, Xk("Autocompleter", A_, {
                                    trigger: t.ch,
                                    ...t
                                })).fold((e => {
                                    throw new Error("Errors: \n" + (e => {
                                        const t = e.length > 10 ? e.slice(0, 10).concat([{
                                            path: [],
                                            getErrorInfo: E("... (only showing first ten failures)")
                                        }]) : e;
                                        return j(t, (e => "Failed path: (" + e.path.join(" > ") + ")\n" + e.getErrorInfo()))
                                    })((t = e).errors).join("\n") + "\n\nInput object: " + Ik(t.input));
                                    var t
                                }), A);
                                var t
                            })),
                            n = _e(we(o, (e => e.trigger))),
                            r = xe(o);
                        return {
                            dataset: o,
                            triggers: n,
                            lookupByTrigger: e => G(r, (t => t.trigger === e))
                        }
                    },
                    F_ = e => {
                        const t = Ea(),
                            o = xa(!1),
                            n = t.isSet,
                            r = () => {
                                n() && ((e => {
                                    ow(e).autocompleter.removeDecoration()
                                })(e), (e => {
                                    e.dispatch("AutocompleterEnd")
                                })(e), o.set(!1), t.clear())
                            },
                            s = Be((() => z_(e))),
                            a = a => {
                                (o => t.get().map((t => Ek(e.dom, e.selection.getRng(), t.trigger).bind((t => Nk(e, s, t, o))))).getOrThunk((() => ((e, t) => {
                                    const o = t(),
                                        n = e.selection.getRng();
                                    return ((e, t, o) => ue(o.triggers, (o => Ek(e, t, o))))(e.dom, n, o).bind((o => Nk(e, t, o)))
                                })(e, s))))(a).fold(r, (s => {
                                    (o => {
                                        n() || (((e, t) => {
                                            ow(e).autocompleter.addDecoration(t)
                                        })(e, o.range), t.set({
                                            trigger: o.trigger,
                                            matchLength: o.text.length
                                        }))
                                    })(s.context), s.lookupData.then((n => {
                                        t.get().map((a => {
                                            const i = s.context;
                                            a.trigger === i.trigger && (i.text.length - a.matchLength >= 10 ? r() : (t.set({ ...a,
                                                matchLength: i.text.length
                                            }), o.get() ? ((e, t) => {
                                                e.dispatch("AutocompleterUpdate", t)
                                            })(e, {
                                                lookupData: n
                                            }) : (o.set(!0), ((e, t) => {
                                                e.dispatch("AutocompleterStart", t)
                                            })(e, {
                                                lookupData: n
                                            }))))
                                        }))
                                    }))
                                }))
                            };
                        e.addCommand("mceAutocompleterReload", ((e, t) => {
                            const o = h(t) ? t.fetchOptions : {};
                            a(o)
                        })), e.addCommand("mceAutocompleterClose", r), ((e, t) => {
                            const o = Ma(t.load, 50);
                            e.on("keypress compositionend", (e => {
                                27 !== e.which && o.throttle()
                            })), e.on("keydown", (e => {
                                const n = e.which;
                                8 === n ? o.throttle() : 27 === n && t.cancelIfNecessary()
                            })), e.on("remove", o.cancel)
                        })(e, {
                            cancelIfNecessary: r,
                            load: a
                        })
                    },
                    V_ = e => (t, o, n = {}) => {
                        const r = t.getBody(),
                            s = {
                                bubbles: !0,
                                composed: !0,
                                data: null,
                                isComposing: !1,
                                detail: 0,
                                view: null,
                                target: r,
                                currentTarget: r,
                                eventPhase: Event.AT_TARGET,
                                originalTarget: r,
                                explicitOriginalTarget: r,
                                isTrusted: !1,
                                srcElement: r,
                                cancelable: !1,
                                preventDefault: _,
                                inputType: o
                            },
                            a = ta(new InputEvent(e));
                        return t.dispatch(e, { ...a,
                            ...s,
                            ...n
                        })
                    },
                    Z_ = V_("input"),
                    U_ = V_("beforeinput"),
                    j_ = (e, t) => {
                        const o = e.dom,
                            n = e.schema.getMoveCaretBeforeOnEnterElements();
                        if (!t) return;
                        if (/^(LI|DT|DD)$/.test(t.nodeName)) {
                            const e = (e => {
                                for (; e;) {
                                    if (Rn(e) || Vn(e) && e.data && /[\r\n\s]/.test(e.data)) return e;
                                    e = e.nextSibling
                                }
                                return null
                            })(t.firstChild);
                            e && /^(UL|OL|DL)$/.test(e.nodeName) && t.insertBefore(o.doc.createTextNode(or), t.firstChild)
                        }
                        const r = o.createRng();
                        if (t.normalize(), t.hasChildNodes()) {
                            const e = new An(t, t);
                            let o, s = t;
                            for (; o = e.current();) {
                                if (Vn(o)) {
                                    r.setStart(o, 0), r.setEnd(o, 0);
                                    break
                                }
                                if (n[o.nodeName.toLowerCase()]) {
                                    r.setStartBefore(o), r.setEndBefore(o);
                                    break
                                }
                                s = o, o = e.next()
                            }
                            o || (r.setStart(s, 0), r.setEnd(s, 0))
                        } else qn(t) ? t.nextSibling && o.isBlock(t.nextSibling) ? (r.setStartBefore(t), r.setEndBefore(t)) : (r.setStartAfter(t), r.setEndAfter(t)) : (r.setStart(t, 0), r.setEnd(t, 0));
                        e.selection.setRng(r), Dg(e, r)
                    },
                    W_ = (e, t) => {
                        const o = e.getRoot();
                        let n, r = t;
                        for (; r !== o && r && "false" !== e.getContentEditable(r);) "true" === e.getContentEditable(r) && (n = r), r = r.parentNode;
                        return r !== o ? n : o
                    },
                    $_ = e => I.from(e.dom.getParent(e.selection.getStart(!0), e.dom.isBlock)),
                    q_ = (e, t) => {
                        const o = null == e ? void 0 : e.parentNode;
                        return x(o) && o.nodeName === t
                    },
                    G_ = e => x(e) && /^(OL|UL|LI)$/.test(e.nodeName),
                    K_ = e => {
                        const t = e.parentNode;
                        return x(o = t) && /^(LI|DT|DD)$/.test(o.nodeName) ? t : e;
                        var o
                    },
                    Y_ = (e, t, o) => {
                        let n = e[o ? "firstChild" : "lastChild"];
                        for (; n && !Rn(n);) n = n[o ? "nextSibling" : "previousSibling"];
                        return n === t
                    },
                    X_ = (e, t) => t && "A" === t.nodeName && e.isEmpty(t),
                    J_ = e => {
                        e.innerHTML = '<br data-mce-bogus="1">'
                    },
                    Q_ = (e, t) => e.nodeName === t || e.previousSibling && e.previousSibling.nodeName === t,
                    eO = (e, t) => x(t) && e.isBlock(t) && !/^(TD|TH|CAPTION|FORM)$/.test(t.nodeName) && !/^(fixed|absolute)/i.test(t.style.position) && "true" !== e.getContentEditable(t),
                    tO = (e, t, o) => Vn(t) ? e ? 1 === o && t.data.charAt(o - 1) === kr ? 0 : o : o === t.data.length - 1 && t.data.charAt(o) === kr ? t.data.length : o : o,
                    oO = (e, t) => {
                        pl(e).toLowerCase() === t.tagName.toLowerCase() && ((e, t, o) => {
                            const n = e.dom;
                            I.from(o.style).map(n.parseStyle).each((e => {
                                const o = { ...Yo(go(t)),
                                    ...e
                                };
                                n.setStyles(t, o)
                            }));
                            const r = I.from(o.class).map((e => e.split(/\s+/))),
                                s = I.from(t.className).map((e => G(e.split(/\s+/), (e => "" !== e))));
                            Bt(r, s, ((e, o) => {
                                const r = G(o, (t => !Z(e, t))),
                                    s = [...e, ...r];
                                n.setAttrib(t, "class", s.join(" "))
                            }));
                            const a = ["style", "class"],
                                i = ye(o, ((e, t) => !Z(a, t)));
                            n.setAttribs(t, i)
                        })(e, t, fl(e))
                    },
                    nO = {
                        insert: (e, t) => {
                            let o, n, r, s, a = !1;
                            const i = e.dom,
                                l = e.schema,
                                c = l.getNonEmptyElements(),
                                d = e.selection.getRng(),
                                u = pl(e),
                                m = t => {
                                    let n = o;
                                    const s = l.getTextInlineElements();
                                    let a;
                                    a = t || "TABLE" === r || "HR" === r ? i.create(t || u) : y.cloneNode(!1);
                                    let c = a;
                                    if (!1 === wl(e)) i.setAttrib(a, "style", null), i.setAttrib(a, "class", null);
                                    else
                                        do {
                                            if (s[n.nodeName]) {
                                                if (nu(n) || fu(n)) continue;
                                                const e = n.cloneNode(!1);
                                                i.setAttrib(e, "id", ""), a.hasChildNodes() ? (e.appendChild(a.firstChild), a.appendChild(e)) : (c = e, a.appendChild(e))
                                            }
                                        } while ((n = n.parentNode) && n !== b);
                                    return oO(e, a), J_(c), a
                                },
                                h = e => {
                                    const t = tO(e, o, n);
                                    if (Vn(o) && (e ? t > 0 : t < o.data.length)) return !1;
                                    if (o.parentNode === y && a && !e) return !0;
                                    if (e && Rn(o) && o === y.firstChild) return !0;
                                    if (Q_(o, "TABLE") || Q_(o, "HR")) return a && !e || !a && e;
                                    const r = new An(o, y);
                                    let s;
                                    for (Vn(o) && (e && 0 === t ? r.prev() : e || t !== o.data.length || r.next()); s = r.current();) {
                                        if (Rn(s)) {
                                            if (!s.getAttribute("data-mce-bogus")) {
                                                const e = s.nodeName.toLowerCase();
                                                if (c[e] && "br" !== e) return !1
                                            }
                                        } else if (Vn(s) && !Xr(s.data)) return !1;
                                        e ? r.prev() : r.next()
                                    }
                                    return !0
                                },
                                p = () => {
                                    let t;
                                    return t = /^(H[1-6]|PRE|FIGURE)$/.test(r) && "HGROUP" !== C ? m(u) : m(), ((e, t) => {
                                        const o = xl(e);
                                        return !w(t) && (g(o) ? Z(Rt.explode(o), t.nodeName.toLowerCase()) : o)
                                    })(e, s) && eO(i, s) && i.isEmpty(y) ? t = i.split(s, y) : i.insertAfter(t, y), j_(e, t), t
                                };
                            dg(i, d).each((e => {
                                d.setStart(e.startContainer, e.startOffset), d.setEnd(e.endContainer, e.endOffset)
                            })), o = d.startContainer, n = d.startOffset;
                            const f = !(!t || !t.shiftKey),
                                v = !(!t || !t.ctrlKey);
                            Rn(o) && o.hasChildNodes() && (a = n > o.childNodes.length - 1, o = o.childNodes[Math.min(n, o.childNodes.length - 1)] || o, n = a && Vn(o) ? o.data.length : 0);
                            const b = W_(i, o);
                            if (!b || ((e, t) => {
                                    const o = e.dom.getParent(t, "ol,ul,dl");
                                    return null !== o && "false" === e.dom.getContentEditableParent(o)
                                })(e, o)) return;
                            f || (o = ((e, t, o, n, r) => {
                                var s;
                                const a = e.dom,
                                    i = null !== (s = W_(a, n)) && void 0 !== s ? s : a.getRoot();
                                let l = a.getParent(n, a.isBlock);
                                if (!l || !eO(a, l)) {
                                    let s;
                                    if (l = l || i, s = l === e.getBody() || Jn(l) ? l.nodeName.toLowerCase() : l.parentNode ? l.parentNode.nodeName.toLowerCase() : "", !l.hasChildNodes()) {
                                        const n = a.create(t);
                                        return oO(e, n), l.appendChild(n), o.setStart(n, 0), o.setEnd(n, 0), n
                                    }
                                    let c, d = n;
                                    for (; d && d.parentNode !== l;) d = d.parentNode;
                                    for (; d && !a.isBlock(d);) c = d, d = d.previousSibling;
                                    if (c && e.schema.isValidChild(s, t.toLowerCase())) {
                                        const s = c.parentNode,
                                            i = a.create(t);
                                        for (oO(e, i), s.insertBefore(i, c), d = c; d && !a.isBlock(d);) {
                                            const e = d.nextSibling;
                                            i.appendChild(d), d = e
                                        }
                                        o.setStart(n, r), o.setEnd(n, r)
                                    }
                                }
                                return n
                            })(e, u, d, o, n));
                            let y = i.getParent(o, i.isBlock) || i.getRoot();
                            s = x(null == y ? void 0 : y.parentNode) ? i.getParent(y.parentNode, i.isBlock) : null, r = y ? y.nodeName.toUpperCase() : "";
                            const C = s ? s.nodeName.toUpperCase() : "";
                            if ("LI" !== C || v || (y = s, s = s.parentNode, r = C), /^(LI|DT|DD)$/.test(r) && Rn(s) && i.isEmpty(y)) return void((e, t, o, n, r) => {
                                const s = e.dom,
                                    a = e.selection.getRng(),
                                    i = o.parentNode;
                                if (o === e.getBody() || !i) return;
                                var l;
                                G_(l = o) && G_(l.parentNode) && (r = "LI");
                                let c = t(r);
                                if (Y_(o, n, !0) && Y_(o, n, !1))
                                    if (q_(o, "LI")) {
                                        const e = K_(o);
                                        s.insertAfter(c, e), (e => {
                                            var t;
                                            return (null === (t = e.parentNode) || void 0 === t ? void 0 : t.firstChild) === e
                                        })(o) ? s.remove(e) : s.remove(o)
                                    } else s.replace(c, o);
                                else if (Y_(o, n, !0)) q_(o, "LI") ? (s.insertAfter(c, K_(o)), c.appendChild(s.doc.createTextNode(" ")), c.appendChild(o)) : i.insertBefore(c, o), s.remove(n);
                                else if (Y_(o, n, !1)) s.insertAfter(c, K_(o)), s.remove(n);
                                else {
                                    o = K_(o);
                                    const e = a.cloneRange();
                                    e.setStartAfter(n), e.setEndAfter(o);
                                    const t = e.extractContents();
                                    "LI" === r && ((e, t) => e.firstChild && "LI" === e.firstChild.nodeName)(t) ? (c = t.firstChild, s.insertAfter(t, o)) : (s.insertAfter(t, o), s.insertAfter(c, o)), s.remove(n)
                                }
                                j_(e, c)
                            })(e, m, s, y, u);
                            if (y === e.getBody()) return;
                            const S = y.parentNode;
                            let k;
                            if (Ar(y)) k = Ir(y), i.isEmpty(y) && J_(y), oO(e, k), j_(e, k);
                            else if (h(!1)) k = p();
                            else if (h(!0) && S) k = S.insertBefore(m(), y), j_(e, Q_(y, "HR") ? k : y);
                            else {
                                const t = (e => {
                                    const t = e.cloneRange();
                                    return t.setStart(e.startContainer, tO(!0, e.startContainer, e.startOffset)), t.setEnd(e.endContainer, tO(!1, e.endContainer, e.endOffset)), t
                                })(d).cloneRange();
                                t.setEndAfter(y);
                                const o = t.extractContents();
                                (e => {
                                    W(xn(go(e), Ft), (e => {
                                        const t = e.dom;
                                        t.nodeValue = Or(t.data)
                                    }))
                                })(o), (e => {
                                    let t = e;
                                    do {
                                        Vn(t) && (t.data = t.data.replace(/^[\r\n]+/, "")), t = t.firstChild
                                    } while (t)
                                })(o), k = o.firstChild, i.insertAfter(o, y), ((e, t, o) => {
                                    var n;
                                    const r = [];
                                    if (!o) return;
                                    let s = o;
                                    for (; s = s.firstChild;) {
                                        if (e.isBlock(s)) return;
                                        Rn(s) && !t[s.nodeName.toLowerCase()] && r.push(s)
                                    }
                                    let a = r.length;
                                    for (; a--;) s = r[a], (!s.hasChildNodes() || s.firstChild === s.lastChild && "" === (null === (n = s.firstChild) || void 0 === n ? void 0 : n.nodeValue) || X_(e, s)) && e.remove(s)
                                })(i, c, k), ((e, t) => {
                                    t.normalize();
                                    const o = t.lastChild;
                                    (!o || Rn(o) && /^(left|right)$/gi.test(e.getStyle(o, "float", !0))) && e.add(t, "br")
                                })(i, y), i.isEmpty(y) && J_(y), k.normalize(), i.isEmpty(k) ? (i.remove(k), p()) : (oO(e, k), j_(e, k))
                            }
                            i.setAttrib(k, "id", ""), e.dispatch("NewBlock", {
                                newBlock: k
                            })
                        },
                        fakeEventName: "insertParagraph"
                    },
                    rO = (e, t, o) => {
                        const n = e.dom.createRng();
                        o ? (n.setStartBefore(t), n.setEndBefore(t)) : (n.setStartAfter(t), n.setEndAfter(t)), e.selection.setRng(n), Dg(e, n)
                    },
                    sO = (e, t) => {
                        const o = uo("br");
                        Jo(go(t), o), e.undoManager.add()
                    },
                    aO = (e, t) => {
                        iO(e.getBody(), t) || Qo(go(t), uo("br"));
                        const o = uo("br");
                        Qo(go(t), o), rO(e, o.dom, !1), e.undoManager.add()
                    },
                    iO = (e, t) => {
                        return o = Si.after(t), !!qn(o.getNode()) || Jd(e, Si.after(t)).map((e => qn(e.getNode()))).getOr(!1);
                        var o
                    },
                    lO = e => e && "A" === e.nodeName && "href" in e,
                    cO = e => e.fold(L, lO, lO, L),
                    dO = (e, t) => {
                        t.fold(_, N(sO, e), N(aO, e), _)
                    },
                    uO = {
                        insert: (e, t) => {
                            const o = (e => {
                                const t = N(Lp, e),
                                    o = Si.fromRangeStart(e.selection.getRng());
                                return rC(t, e.getBody(), o).filter(cO)
                            })(e);
                            o.isSome() ? o.each(N(dO, e)) : ((e, t) => {
                                const o = e.selection,
                                    n = e.dom,
                                    r = o.getRng();
                                let s, a = !1;
                                dg(n, r).each((e => {
                                    r.setStart(e.startContainer, e.startOffset), r.setEnd(e.endContainer, e.endOffset)
                                }));
                                let i = r.startOffset,
                                    l = r.startContainer;
                                if (Rn(l) && l.hasChildNodes()) {
                                    const e = i > l.childNodes.length - 1;
                                    l = l.childNodes[Math.min(i, l.childNodes.length - 1)] || l, i = e && Vn(l) ? l.data.length : 0
                                }
                                let c = n.getParent(l, n.isBlock);
                                const d = c && c.parentNode ? n.getParent(c.parentNode, n.isBlock) : null,
                                    u = d ? d.nodeName.toUpperCase() : "",
                                    m = !(!t || !t.ctrlKey);
                                "LI" !== u || m || (c = d), Vn(l) && i >= l.data.length && (((e, t, o) => {
                                    const n = new An(t, o);
                                    let r;
                                    const s = e.getNonEmptyElements();
                                    for (; r = n.next();)
                                        if (s[r.nodeName.toLowerCase()] || Vn(r) && r.length > 0) return !0;
                                    return !1
                                })(e.schema, l, c || n.getRoot()) || (s = n.create("br"), r.insertNode(s), r.setStartAfter(s), r.setEndAfter(s), a = !0)), s = n.create("br"), _i(n, r, s), rO(e, s, a), e.undoManager.add()
                            })(e, t)
                        },
                        fakeEventName: "insertLineBreak"
                    },
                    mO = (e, t) => $_(e).filter((e => t.length > 0 && fo(go(e), t))).isSome(),
                    gO = Gi([{
                        br: []
                    }, {
                        block: []
                    }, {
                        none: []
                    }]),
                    hO = (e, t) => (e => mO(e, yl(e)))(e),
                    pO = e => (t, o) => (e => $_(e).filter((e => pr(go(e)))).isSome())(t) === e,
                    fO = (e, t) => (o, n) => {
                        const r = (e => $_(e).fold(E(""), (e => e.nodeName.toUpperCase())))(o) === e.toUpperCase();
                        return r === t
                    },
                    vO = e => {
                        const t = W_(e.dom, e.selection.getStart());
                        return w(t)
                    },
                    bO = e => fO("pre", e),
                    yO = e => (t, o) => hl(t) === e,
                    wO = (e, t) => (e => mO(e, bl(e)))(e),
                    xO = (e, t) => t,
                    CO = e => {
                        const t = pl(e),
                            o = W_(e.dom, e.selection.getStart());
                        return x(o) && e.schema.isValidChild(o.nodeName, t)
                    },
                    SO = (e, t) => (o, n) => Y(e, ((e, t) => e && t(o, n)), !0) ? I.some(t) : I.none(),
                    kO = (e, t, o) => {
                        t.selection.isCollapsed() || (e => {
                            e.execCommand("delete")
                        })(t), x(o) && U_(t, e.fakeEventName).isDefaultPrevented() || (e.insert(t, o), x(o) && Z_(t, e.fakeEventName))
                    },
                    _O = (e, t) => {
                        const o = () => kO(uO, e, t),
                            n = () => kO(nO, e, t),
                            r = ((e, t) => Gx([SO([hO], gO.none()), SO([bO(!0), vO], gO.none()), SO([fO("summary", !0)], gO.br()), SO([bO(!0), yO(!1), xO], gO.br()), SO([bO(!0), yO(!1)], gO.block()), SO([bO(!0), yO(!0), xO], gO.block()), SO([bO(!0), yO(!0)], gO.br()), SO([pO(!0), xO], gO.br()), SO([pO(!0)], gO.block()), SO([wO], gO.br()), SO([xO], gO.br()), SO([CO], gO.block())], [e, !(!t || !t.shiftKey)]).getOr(gO.none()))(e, t);
                        switch (vl(e)) {
                            case "linebreak":
                                r.fold(o, o, _);
                                break;
                            case "block":
                                r.fold(n, n, _);
                                break;
                            case "invert":
                                r.fold(n, o, _);
                                break;
                            default:
                                r.fold(o, n, _)
                        }
                    },
                    OO = xt(),
                    TO = e => e.stopImmediatePropagation(),
                    EO = e => e.keyCode === Lm.PAGE_UP || e.keyCode === Lm.PAGE_DOWN,
                    AO = (e, t, o) => {
                        o && !e.get() ? t.on("NodeChange", TO, !0) : !o && e.get() && t.off("NodeChange", TO), e.set(o)
                    },
                    MO = (e, t) => {
                        const o = t.container(),
                            n = t.offset();
                        return Vn(o) ? (o.insertData(n, e), I.some(Si(o, n + e.length))) : Md(t).map((o => {
                            const n = mo(e);
                            return t.isAtEnd() ? Qo(o, n) : Jo(o, n), Si(n.dom, e.length)
                        }))
                    },
                    NO = N(MO, or),
                    RO = N(MO, " "),
                    DO = (e, t) => o => ((e, t) => !mp(t) && (((e, t) => ((e, t) => Qd(e.dom, t).isNone())(e, t) || ((e, t) => Jd(e.dom, t).isNone())(e, t) || Jh(e, t) || Qh(e, t) || sp(e, t) || rp(e, t))(e, t) || dp(e, t) || up(e, t)))(e, o) ? NO(t) : RO(t),
                    BO = e => {
                        const t = Si.fromRangeStart(e.selection.getRng()),
                            o = go(e.getBody());
                        if (e.selection.isCollapsed()) {
                            const n = N(Lp, e),
                                r = Si.fromRangeStart(e.selection.getRng());
                            return rC(n, e.getBody(), r).bind((e => t => t.fold((t => Qd(e.dom, Si.before(t))), (e => eu(e)), (e => tu(e)), (t => Jd(e.dom, Si.after(t)))))(o)).map((n => () => DO(o, t)(n).each((e => t => (e.selection.setRng(t.toRange()), e.nodeChanged(), !0))(e))))
                        }
                        return I.none()
                    },
                    LO = e => Uc(e) ? [{
                        keyCode: Lm.TAB,
                        action: ZS(vk, e, !0)
                    }, {
                        keyCode: Lm.TAB,
                        shiftKey: !0,
                        action: ZS(vk, e, !1)
                    }] : [],
                    HO = e => {
                        if (e.addShortcut("Meta+P", "", "mcePrint"), F_(e), ew(e)) return xa(null); {
                            const t = JC(e);
                            return (e => {
                                e.on("keyup compositionstart", N(MS, e))
                            })(e), ((e, t) => {
                                e.on("keydown", (o => {
                                    o.isDefaultPrevented() || ((e, t, o) => {
                                        const n = Et.os.isMacOS() || Et.os.isiOS();
                                        US([{
                                            keyCode: Lm.RIGHT,
                                            action: ZS(DS, e, !0)
                                        }, {
                                            keyCode: Lm.LEFT,
                                            action: ZS(DS, e, !1)
                                        }, {
                                            keyCode: Lm.UP,
                                            action: ZS(BS, e, !1)
                                        }, {
                                            keyCode: Lm.DOWN,
                                            action: ZS(BS, e, !0)
                                        }, ...n ? [{
                                            keyCode: Lm.UP,
                                            action: ZS(HS, e, !1),
                                            metaKey: !0,
                                            shiftKey: !0
                                        }, {
                                            keyCode: Lm.DOWN,
                                            action: ZS(HS, e, !0),
                                            metaKey: !0,
                                            shiftKey: !0
                                        }] : [], {
                                            keyCode: Lm.RIGHT,
                                            action: ZS(mk, e, !0)
                                        }, {
                                            keyCode: Lm.LEFT,
                                            action: ZS(mk, e, !1)
                                        }, {
                                            keyCode: Lm.UP,
                                            action: ZS(gk, e, !1)
                                        }, {
                                            keyCode: Lm.DOWN,
                                            action: ZS(gk, e, !0)
                                        }, {
                                            keyCode: Lm.RIGHT,
                                            action: ZS(WS, e, !0)
                                        }, {
                                            keyCode: Lm.LEFT,
                                            action: ZS(WS, e, !1)
                                        }, {
                                            keyCode: Lm.UP,
                                            action: ZS($S, e, !1)
                                        }, {
                                            keyCode: Lm.DOWN,
                                            action: ZS($S, e, !0)
                                        }, {
                                            keyCode: Lm.RIGHT,
                                            action: ZS(YC, e, t, !0)
                                        }, {
                                            keyCode: Lm.LEFT,
                                            action: ZS(YC, e, t, !1)
                                        }, {
                                            keyCode: Lm.RIGHT,
                                            ctrlKey: !n,
                                            altKey: n,
                                            action: ZS(QC, e, t)
                                        }, {
                                            keyCode: Lm.LEFT,
                                            ctrlKey: !n,
                                            altKey: n,
                                            action: ZS(eS, e, t)
                                        }, {
                                            keyCode: Lm.UP,
                                            action: ZS(zS, e, !1)
                                        }, {
                                            keyCode: Lm.DOWN,
                                            action: ZS(zS, e, !0)
                                        }], o).each((e => {
                                            o.preventDefault()
                                        }))
                                    })(e, t, o)
                                }))
                            })(e, t), ((e, t) => {
                                e.on("keydown", (o => {
                                    o.isDefaultPrevented() || ((e, t, o) => {
                                        const n = o.keyCode === Lm.BACKSPACE ? "deleteContentBackward" : "deleteContentForward";
                                        jS([{
                                            keyCode: Lm.BACKSPACE,
                                            action: ZS(vS, e)
                                        }, {
                                            keyCode: Lm.BACKSPACE,
                                            action: ZS(Hx, e, !1)
                                        }, {
                                            keyCode: Lm.DELETE,
                                            action: ZS(Hx, e, !0)
                                        }, {
                                            keyCode: Lm.BACKSPACE,
                                            action: ZS(Ex, e, !1)
                                        }, {
                                            keyCode: Lm.DELETE,
                                            action: ZS(Ex, e, !0)
                                        }, {
                                            keyCode: Lm.BACKSPACE,
                                            action: ZS(rS, e, t, !1)
                                        }, {
                                            keyCode: Lm.DELETE,
                                            action: ZS(rS, e, t, !0)
                                        }, {
                                            keyCode: Lm.BACKSPACE,
                                            action: ZS(bf, e, !1)
                                        }, {
                                            keyCode: Lm.DELETE,
                                            action: ZS(bf, e, !0)
                                        }, {
                                            keyCode: Lm.BACKSPACE,
                                            action: ZS(Ix, e, !1)
                                        }, {
                                            keyCode: Lm.DELETE,
                                            action: ZS(Ix, e, !0)
                                        }, {
                                            keyCode: Lm.BACKSPACE,
                                            action: ZS(cS, e, !1)
                                        }, {
                                            keyCode: Lm.DELETE,
                                            action: ZS(cS, e, !0)
                                        }, {
                                            keyCode: Lm.BACKSPACE,
                                            action: ZS(xx, e, !1)
                                        }, {
                                            keyCode: Lm.DELETE,
                                            action: ZS(xx, e, !0)
                                        }, {
                                            keyCode: Lm.BACKSPACE,
                                            action: ZS(bx, e, !1)
                                        }, {
                                            keyCode: Lm.DELETE,
                                            action: ZS(bx, e, !0)
                                        }, {
                                            keyCode: Lm.BACKSPACE,
                                            action: ZS(iS, e, !1)
                                        }, {
                                            keyCode: Lm.DELETE,
                                            action: ZS(iS, e, !0)
                                        }], o).each((t => {
                                            o.preventDefault(), U_(e, n).isDefaultPrevented() || (t(), Z_(e, n))
                                        }))
                                    })(e, t, o)
                                })), e.on("keyup", (t => {
                                    t.isDefaultPrevented() || ((e, t) => {
                                        US([{
                                            keyCode: Lm.BACKSPACE,
                                            action: ZS(Lx, e)
                                        }, {
                                            keyCode: Lm.DELETE,
                                            action: ZS(Lx, e)
                                        }], t)
                                    })(e, t)
                                }))
                            })(e, t), (e => {
                                e.on("keydown", (t => {
                                    t.keyCode === Lm.ENTER && ((e, t) => {
                                        var o;
                                        t.isDefaultPrevented() || (t.preventDefault(), (o = e.undoManager).typing && (o.typing = !1, o.add()), e.undoManager.transact((() => {
                                            _O(e, t)
                                        })))
                                    })(e, t)
                                }))
                            })(e), (e => {
                                e.on("keydown", (t => {
                                    t.isDefaultPrevented() || ((e, t) => {
                                        jS([{
                                            keyCode: Lm.SPACEBAR,
                                            action: ZS(BO, e)
                                        }], t).each((o => {
                                            t.preventDefault(), U_(e, "insertText", {
                                                data: " "
                                            }).isDefaultPrevented() || (o(), Z_(e, "insertText", {
                                                data: " "
                                            }))
                                        }))
                                    })(e, t)
                                }))
                            })(e), (e => {
                                e.on("input", (t => {
                                    t.isComposing || (e => {
                                        const t = go(e.getBody());
                                        e.selection.isCollapsed() && xp(t, Si.fromRangeStart(e.selection.getRng())).each((t => {
                                            e.selection.setRng(t.toRange())
                                        }))
                                    })(e)
                                }))
                            })(e), (e => {
                                e.on("keydown", (t => {
                                    t.isDefaultPrevented() || ((e, t) => {
                                        US([...LO(e)], t).each((e => {
                                            t.preventDefault()
                                        }))
                                    })(e, t)
                                }))
                            })(e), ((e, t) => {
                                e.on("keydown", (o => {
                                    o.isDefaultPrevented() || ((e, t, o) => {
                                        const n = Et.os.isMacOS() || Et.os.isiOS();
                                        US([{
                                            keyCode: Lm.END,
                                            action: ZS(LS, e, !0)
                                        }, {
                                            keyCode: Lm.HOME,
                                            action: ZS(LS, e, !1)
                                        }, ...n ? [] : [{
                                            keyCode: Lm.HOME,
                                            action: ZS(HS, e, !1),
                                            ctrlKey: !0,
                                            shiftKey: !0
                                        }, {
                                            keyCode: Lm.END,
                                            action: ZS(HS, e, !0),
                                            ctrlKey: !0,
                                            shiftKey: !0
                                        }], {
                                            keyCode: Lm.END,
                                            action: ZS(qS, e, !0)
                                        }, {
                                            keyCode: Lm.HOME,
                                            action: ZS(qS, e, !1)
                                        }, {
                                            keyCode: Lm.END,
                                            action: ZS(tS, e, !0, t)
                                        }, {
                                            keyCode: Lm.HOME,
                                            action: ZS(tS, e, !1, t)
                                        }], o).each((e => {
                                            o.preventDefault()
                                        }))
                                    })(e, t, o)
                                }))
                            })(e, t), ((e, t) => {
                                if (OO.os.isMacOS()) return;
                                const o = xa(!1);
                                e.on("keydown", (t => {
                                    EO(t) && AO(o, e, !0)
                                })), e.on("keyup", (n => {
                                    n.isDefaultPrevented() || ((e, t, o) => {
                                        US([{
                                            keyCode: Lm.PAGE_UP,
                                            action: ZS(tS, e, !1, t)
                                        }, {
                                            keyCode: Lm.PAGE_DOWN,
                                            action: ZS(tS, e, !0, t)
                                        }], o)
                                    })(e, t, n), EO(n) && o.get() && (AO(o, e, !1), e.nodeChanged())
                                }))
                            })(e, t), t
                        }
                    };
                class IO {
                    constructor(e) {
                        let t;
                        this.lastPath = [], this.editor = e;
                        const o = this;
                        "onselectionchange" in e.getDoc() || e.on("NodeChange click mouseup keyup focus", (o => {
                            const n = e.selection.getRng(),
                                r = {
                                    startContainer: n.startContainer,
                                    startOffset: n.startOffset,
                                    endContainer: n.endContainer,
                                    endOffset: n.endOffset
                                };
                            "nodechange" !== o.type && ng(r, t) || e.dispatch("SelectionChange"), t = r
                        })), e.on("contextmenu", (() => {
                            e.dispatch("SelectionChange")
                        })), e.on("SelectionChange", (() => {
                            const t = e.selection.getStart(!0);
                            t && Hu(e) && !o.isSameElementPath(t) && e.dom.isChildOf(t, e.getBody()) && e.nodeChanged({
                                selectionChange: !0
                            })
                        })), e.on("mouseup", (t => {
                            !t.isDefaultPrevented() && Hu(e) && ("IMG" === e.selection.getNode().nodeName ? $g.setEditorTimeout(e, (() => {
                                e.nodeChanged()
                            })) : e.nodeChanged())
                        }))
                    }
                    nodeChanged(e = {}) {
                        const t = this.editor.selection;
                        let o;
                        if (this.editor.initialized && t && !cc(this.editor) && !this.editor.mode.isReadOnly()) {
                            const n = this.editor.getBody();
                            o = t.getStart(!0) || n, o.ownerDocument === this.editor.getDoc() && this.editor.dom.isChildOf(o, n) || (o = n);
                            const r = [];
                            this.editor.dom.getParent(o, (e => e === n || (r.push(e), !1))), this.editor.dispatch("NodeChange", { ...e,
                                element: o,
                                parents: r
                            })
                        }
                    }
                    isSameElementPath(e) {
                        let t;
                        const o = this.editor,
                            n = ne(o.dom.getParents(e, H, o.getBody()));
                        if (n.length === this.lastPath.length) {
                            for (t = n.length; t >= 0 && n[t] === this.lastPath[t]; t--);
                            if (-1 === t) return this.lastPath = n, !0
                        }
                        return this.lastPath = n, !1
                    }
                }
                const PO = "x-tinymce/html",
                    zO = E(PO),
                    FO = "\x3c!-- " + PO + " --\x3e",
                    VO = e => FO + e,
                    ZO = e => -1 !== e.indexOf(FO),
                    UO = "%MCEPASTEBIN%",
                    jO = e => e.dom.get("mcepastebin"),
                    WO = e => x(e) && "mcepastebin" === e.id,
                    $O = e => e === UO,
                    qO = (e, t) => (Rt.each(t, (t => {
                        e = m(t, RegExp) ? e.replace(t, "") : e.replace(t[0], t[1])
                    })), e),
                    GO = e => qO(e, [/^[\s\S]*<body[^>]*>\s*|\s*<\/body[^>]*>[\s\S]*$/gi, /<!--StartFragment-->|<!--EndFragment-->/g, [/( ?)<span class="Apple-converted-space">\u00a0<\/span>( ?)/g, (e, t, o) => t || o ? or : " "], /<br class="Apple-interchange-newline">/g, /<br>$/i]),
                    KO = (e, t) => ({
                        content: e,
                        cancelled: t
                    }),
                    YO = (e, t) => (e.insertContent(t, {
                        merge: Nc(e),
                        paste: !0
                    }), !0),
                    XO = e => /^https?:\/\/[\w\-\/+=.,!;:&%@^~(){}?#]+$/i.test(e),
                    JO = (e, t, o) => !(e.selection.isCollapsed() || !XO(t)) && ((e, t, o) => (e.undoManager.extra((() => {
                        o(e, t)
                    }), (() => {
                        e.execCommand("mceInsertLink", !1, t)
                    })), !0))(e, t, o),
                    QO = (e, t, o) => !!((e, t) => XO(t) && U(Zc(e), (e => Ze(t.toLowerCase(), `.${e.toLowerCase()}`))))(e, t) && ((e, t, o) => (e.undoManager.extra((() => {
                        o(e, t)
                    }), (() => {
                        e.insertContent('<img src="' + t + '">')
                    })), !0))(e, t, o),
                    eT = (e => {
                        let t = 0;
                        return () => "mceclip" + t++
                    })(),
                    tT = (e, t, o, n) => {
                        const r = ((e, t, o) => ((e, t, o) => {
                            const n = ((e, t, o) => e.dispatch("PastePreProcess", {
                                    content: t,
                                    internal: o
                                }))(e, t, o),
                                r = ((e, t) => {
                                    const o = xy({}, e.schema);
                                    o.addNodeFilter("meta", (e => {
                                        Rt.each(e, (e => {
                                            e.remove()
                                        }))
                                    }));
                                    const n = o.parse(t, {
                                        forced_root_block: !1,
                                        isRootContent: !0
                                    });
                                    return Oh({
                                        validate: !0
                                    }, e.schema).serialize(n)
                                })(e, n.content);
                            return e.hasEventListeners("PastePostProcess") && !n.isDefaultPrevented() ? ((e, t, o) => {
                                const n = e.dom.create("div", {
                                        style: "display:none"
                                    }, t),
                                    r = ((e, t, o) => e.dispatch("PastePostProcess", {
                                        node: t,
                                        internal: o
                                    }))(e, n, o);
                                return KO(r.node.innerHTML, r.isDefaultPrevented())
                            })(e, r, o) : KO(r, n.isDefaultPrevented())
                        })(e, t, o))(e, t, o);
                        r.cancelled || ((e, t, o) => {
                            o || !Rc(e) ? YO(e, t) : ((e, t) => {
                                Rt.each([JO, QO, YO], (o => !o(e, t, YO)))
                            })(e, t)
                        })(e, r.content, n)
                    },
                    oT = (e, t, o) => {
                        const n = o || ZO(t);
                        tT(e, (e => e.replace(FO, ""))(t), n, !1)
                    },
                    nT = (e, t) => {
                        const o = e.dom.encode(t).replace(/\r\n/g, "\n"),
                            n = ((e, t, o) => {
                                const n = e.split(/\n\n/),
                                    r = ((e, t) => {
                                        let o = "<" + e;
                                        const n = we(t, ((e, t) => t + '="' + zs.encodeAllRaw(e) + '"'));
                                        return n.length && (o += " " + n.join(" ")), o + ">"
                                    })(t, o),
                                    s = "</" + t + ">",
                                    a = j(n, (e => e.split(/\n/).join("<br />")));
                                return 1 === a.length ? a[0] : j(a, (e => r + e + s)).join("")
                            })(Qr(o, Bc(e)), pl(e), fl(e));
                        tT(e, n, !1, !0)
                    },
                    rT = e => {
                        const t = {};
                        if (e && e.types)
                            for (let o = 0; o < e.types.length; o++) {
                                const n = e.types[o];
                                try {
                                    t[n] = e.getData(n)
                                } catch (e) {
                                    t[n] = ""
                                }
                            }
                        return t
                    },
                    sT = (e, t) => t in e && e[t].length > 0,
                    aT = e => sT(e, "text/html") || sT(e, "text/plain"),
                    iT = (e, t, o) => {
                        const n = "paste" === t.type ? t.clipboardData : t.dataTransfer;
                        var r;
                        if (Oc(e) && n) {
                            const s = ((e, t) => {
                                const o = t.items ? te(de(t.items), (e => "file" === e.kind ? [e.getAsFile()] : [])) : [],
                                    n = t.files ? de(t.files) : [];
                                return G(o.length > 0 ? o : n, (e => {
                                    const t = Zc(e);
                                    return e => Ve(e.type, "image/") && U(t, (t => (e => {
                                        const t = e.toLowerCase(),
                                            o = {
                                                jpg: "jpeg",
                                                jpe: "jpeg",
                                                jfi: "jpeg",
                                                jif: "jpeg",
                                                jfif: "jpeg",
                                                pjpeg: "jpeg",
                                                pjp: "jpeg",
                                                svg: "svg+xml"
                                            };
                                        return Rt.hasOwn(o, t) ? "image/" + o[t] : "image/" + t
                                    })(t) === e.type))
                                })(e))
                            })(e, n);
                            if (s.length > 0) return t.preventDefault(), (r = s, Promise.all(j(r, (e => oy(e).then((t => ({
                                file: e,
                                uri: t
                            }))))))).then((t => {
                                o && e.selection.setRng(o), W(t, (t => {
                                    ((e, t) => {
                                        ey(t.uri).each((({
                                            data: o,
                                            type: n,
                                            base64Encoded: r
                                        }) => {
                                            const s = r ? o : btoa(o),
                                                a = t.file,
                                                i = e.editorUpload.blobCache,
                                                l = i.getByData(s, n),
                                                c = null != l ? l : ((e, t, o, n) => {
                                                    const r = eT(),
                                                        s = Sl(e) && x(o.name),
                                                        a = s ? ((e, t) => {
                                                            const o = t.match(/([\s\S]+?)(?:\.[a-z0-9.]+)$/i);
                                                            return x(o) ? e.dom.encode(o[1]) : void 0
                                                        })(e, o.name) : r,
                                                        i = s ? o.name : void 0,
                                                        l = t.create(r, o, n, a, i);
                                                    return t.add(l), l
                                                })(e, i, a, s);
                                            oT(e, `<img src="${c.blobUri()}">`, !1)
                                        }))
                                    })(e, t)
                                }))
                            })), !0
                        }
                        return !1
                    },
                    lT = (e, t, o, n) => {
                        let r = GO(o);
                        const s = sT(t, zO()) || ZO(o),
                            a = !s && (e => !/<(?:\/?(?!(?:div|p|br|span)>)\w+|(?:(?!(?:span style="white-space:\s?pre;?">)|br\s?\/>))\w+\s[^>]+)>/i.test(e))(r),
                            i = XO(r);
                        ($O(r) || !r.length || a && !i) && (n = !0), (n || i) && (r = sT(t, "text/plain") && a ? t["text/plain"] : (e => {
                            const t = Js(),
                                o = xy({}, t);
                            let n = "";
                            const r = t.getVoidElements(),
                                s = Rt.makeMap("script noscript style textarea video audio iframe object", " "),
                                a = t.getBlockElements(),
                                i = e => {
                                    const o = e.name,
                                        l = e;
                                    if ("br" !== o) {
                                        if ("wbr" !== o)
                                            if (r[o] && (n += " "), s[o]) n += " ";
                                            else {
                                                if (3 === e.type && (n += e.value), !(e.name in t.getVoidElements())) {
                                                    let t = e.firstChild;
                                                    if (t)
                                                        do {
                                                            i(t)
                                                        } while (t = t.next)
                                                }
                                                a[o] && l.next && (n += "\n", "p" === o && (n += "\n"))
                                            }
                                    } else n += "\n"
                                };
                            return e = qO(e, [/<!\[[^\]]+\]>/g]), i(o.parse(e)), n
                        })(r)), $O(r) || (n ? nT(e, r) : oT(e, r, s))
                    },
                    cT = (e, t, o) => {
                        ((e, t, o) => {
                            let n;
                            e.on("keydown", (e => {
                                (e => Lm.metaKeyPressed(e) && 86 === e.keyCode || e.shiftKey && 45 === e.keyCode)(e) && !e.isDefaultPrevented() && (n = e.shiftKey && 86 === e.keyCode)
                            })), e.on("paste", (r => {
                                if (r.isDefaultPrevented() || (e => {
                                        var t, o;
                                        return Et.os.isAndroid() && 0 === (null === (o = null === (t = e.clipboardData) || void 0 === t ? void 0 : t.items) || void 0 === o ? void 0 : o.length)
                                    })(r)) return;
                                const s = "text" === o.get() || n;
                                n = !1;
                                const a = rT(r.clipboardData);
                                !aT(a) && iT(e, r, t.getLastRng() || e.selection.getRng()) || (sT(a, "text/html") ? (r.preventDefault(), lT(e, a, a["text/html"], s)) : (t.create(), $g.setEditorTimeout(e, (() => {
                                    const o = t.getHtml();
                                    t.remove(), lT(e, a, o, s)
                                }), 0)))
                            }))
                        })(e, t, o), (e => {
                            const t = e => Ve(e, "webkit-fake-url"),
                                o = e => Ve(e, "data:");
                            e.parser.addNodeFilter("img", ((n, r, s) => {
                                if (!Oc(e) && (e => {
                                        var t;
                                        return !0 === (null === (t = e.data) || void 0 === t ? void 0 : t.paste)
                                    })(s))
                                    for (const r of n) {
                                        const n = r.attr("src");
                                        g(n) && !r.attr("data-mce-object") && n !== Et.transparentSrc && (t(n) || !Lc(e) && o(n)) && r.remove()
                                    }
                            }))
                        })(e)
                    },
                    dT = (e, t, o, n) => {
                        ((e, t, o) => {
                            if (!e) return !1;
                            try {
                                return e.clearData(), e.setData("text/html", t), e.setData("text/plain", o), e.setData(zO(), t), !0
                            } catch (e) {
                                return !1
                            }
                        })(e.clipboardData, t.html, t.text) ? (e.preventDefault(), n()) : o(t.html, n)
                    },
                    uT = e => (t, o) => {
                        const {
                            dom: n,
                            selection: r
                        } = e, s = n.create("div", {
                            contenteditable: "false",
                            "data-mce-bogus": "all"
                        }), a = n.create("div", {
                            contenteditable: "true"
                        }, t);
                        n.setStyles(s, {
                            position: "fixed",
                            top: "0",
                            left: "-3000px",
                            width: "1000px",
                            overflow: "hidden"
                        }), s.appendChild(a), n.add(e.getBody(), s);
                        const i = r.getRng();
                        a.focus();
                        const l = n.createRng();
                        l.selectNodeContents(a), r.setRng(l), $g.setEditorTimeout(e, (() => {
                            r.setRng(i), n.remove(s), o()
                        }), 0)
                    },
                    mT = e => ({
                        html: VO(e.selection.getContent({
                            contextual: !0
                        })),
                        text: e.selection.getContent({
                            format: "text"
                        })
                    }),
                    gT = e => !e.selection.isCollapsed() || (e => !!e.dom.getParent(e.selection.getStart(), "td[data-mce-selected],th[data-mce-selected]", e.getBody()))(e),
                    hT = (e, t) => {
                        var o, n;
                        return gg.getCaretRangeFromPoint(null !== (o = t.clientX) && void 0 !== o ? o : 0, null !== (n = t.clientY) && void 0 !== n ? n : 0, e.getDoc())
                    },
                    pT = (e, t) => {
                        e.focus(), t && e.selection.setRng(t)
                    },
                    fT = /rgb\s*\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\s*\)/gi,
                    vT = e => Rt.trim(e).replace(fT, Tu).toLowerCase(),
                    bT = (e, t, o) => {
                        const n = Ac(e);
                        if (o || "all" === n || !Mc(e)) return t;
                        const r = n ? n.split(/[, ]/) : [];
                        if (r && "none" !== n) {
                            const o = e.dom,
                                n = e.selection.getNode();
                            t = t.replace(/(<[^>]+) style="([^"]*)"([^>]*>)/gi, ((e, t, s, a) => {
                                const i = o.parseStyle(o.decode(s)),
                                    l = {};
                                for (let e = 0; e < r.length; e++) {
                                    const t = i[r[e]];
                                    let s = t,
                                        a = o.getStyle(n, r[e], !0);
                                    /color/.test(r[e]) && (s = vT(s), a = vT(a)), a !== s && (l[r[e]] = t)
                                }
                                const c = o.serializeStyle(l, "span");
                                return c ? t + ' style="' + c + '"' + a : t + a
                            }))
                        } else t = t.replace(/(<[^>]+) style="([^"]*)"([^>]*>)/gi, "$1$3");
                        return t = t.replace(/(<[^>]+) data-mce-style="([^"]+)"([^>]*>)/gi, ((e, t, o, n) => t + ' style="' + o + '"' + n)), t
                    },
                    yT = e => {
                        const t = xa(!1),
                            o = xa(Dc(e) ? "text" : "html"),
                            n = (e => {
                                const t = xa(null);
                                return {
                                    create: () => ((e, t) => {
                                        const {
                                            dom: o,
                                            selection: n
                                        } = e, r = e.getBody();
                                        t.set(n.getRng());
                                        const s = o.add(e.getBody(), "div", {
                                            id: "mcepastebin",
                                            class: "mce-pastebin",
                                            contentEditable: !0,
                                            "data-mce-bogus": "all",
                                            style: "position: fixed; top: 50%; width: 10px; height: 10px; overflow: hidden; opacity: 0"
                                        }, UO);
                                        Et.browser.isFirefox() && o.setStyle(s, "left", "rtl" === o.getStyle(r, "direction", !0) ? 65535 : -65535), o.bind(s, "beforedeactivate focusin focusout", (e => {
                                            e.stopPropagation()
                                        })), s.focus(), n.select(s, !0)
                                    })(e, t),
                                    remove: () => ((e, t) => {
                                        const o = e.dom;
                                        if (jO(e)) {
                                            let n;
                                            const r = t.get();
                                            for (; n = jO(e);) o.remove(n), o.unbind(n);
                                            r && e.selection.setRng(r)
                                        }
                                        t.set(null)
                                    })(e, t),
                                    getEl: () => jO(e),
                                    getHtml: () => (e => {
                                        const t = e.dom,
                                            o = (e, o) => {
                                                e.appendChild(o), t.remove(o, !0)
                                            },
                                            [n, ...r] = G(e.getBody().childNodes, WO);
                                        W(r, (e => {
                                            o(n, e)
                                        }));
                                        const s = t.select("div[id=mcepastebin]", n);
                                        for (let e = s.length - 1; e >= 0; e--) {
                                            const r = t.create("div");
                                            n.insertBefore(r, s[e]), o(r, s[e])
                                        }
                                        return n ? n.innerHTML : ""
                                    })(e),
                                    getLastRng: t.get
                                }
                            })(e);
                        (e => {
                            (Et.browser.isChromium() || Et.browser.isSafari()) && ((e, t) => {
                                e.on("PastePreProcess", (o => {
                                    o.content = t(e, o.content, o.internal)
                                }))
                            })(e, bT)
                        })(e), ((e, t) => {
                            e.addCommand("mceTogglePlainTextPaste", (() => {
                                ((e, t) => {
                                    "text" === t.get() ? (t.set("html"), Bm(e, !1)) : (t.set("text"), Bm(e, !0)), e.focus()
                                })(e, t)
                            })), e.addCommand("mceInsertClipboardContent", ((t, o) => {
                                o.html && oT(e, o.html, o.internal), o.text && nT(e, o.text)
                            }))
                        })(e, o), (e => {
                            const t = t => o => {
                                    t(e, o)
                                },
                                o = Tc(e);
                            C(o) && e.on("PastePreProcess", t(o));
                            const n = Ec(e);
                            C(n) && e.on("PastePostProcess", t(n))
                        })(e), e.on("PreInit", (() => {
                            (e => {
                                e.on("cut", (e => t => {
                                    !t.isDefaultPrevented() && gT(e) && dT(t, mT(e), uT(e), (() => {
                                        if (Et.browser.isChromium() || Et.browser.isFirefox()) {
                                            const t = e.selection.getRng();
                                            $g.setEditorTimeout(e, (() => {
                                                e.selection.setRng(t), e.execCommand("Delete")
                                            }), 0)
                                        } else e.execCommand("Delete")
                                    }))
                                })(e)), e.on("copy", (e => t => {
                                    !t.isDefaultPrevented() && gT(e) && dT(t, mT(e), uT(e), _)
                                })(e))
                            })(e), ((e, t) => {
                                _c(e) && e.on("dragend dragover draggesture dragdrop drop drag", (e => {
                                    e.preventDefault(), e.stopPropagation()
                                })), Oc(e) || e.on("drop", (e => {
                                    const t = e.dataTransfer;
                                    t && (e => U(e.files, (e => /^image\//.test(e.type))))(t) && e.preventDefault()
                                })), e.on("drop", (o => {
                                    if (o.isDefaultPrevented() || t.get()) return;
                                    const n = hT(e, o);
                                    if (w(n)) return;
                                    const r = rT(o.dataTransfer),
                                        s = sT(r, zO());
                                    if ((!aT(r) || (e => {
                                            const t = e["text/plain"];
                                            return !!t && 0 === t.indexOf("file://")
                                        })(r)) && iT(e, o, n)) return;
                                    const a = r[zO()],
                                        i = a || r["text/html"] || r["text/plain"];
                                    i && (o.preventDefault(), $g.setEditorTimeout(e, (() => {
                                        e.undoManager.transact((() => {
                                            a && e.execCommand("Delete"), pT(e, n);
                                            const t = GO(i);
                                            r["text/html"] ? oT(e, t, s) : nT(e, t)
                                        }))
                                    })))
                                })), e.on("dragstart", (e => {
                                    t.set(!0)
                                })), e.on("dragover dragend", (o => {
                                    Oc(e) && !t.get() && (o.preventDefault(), pT(e, hT(e, o))), "dragend" === o.type && t.set(!1)
                                }))
                            })(e, t), cT(e, n, o)
                        }))
                    },
                    wT = qn,
                    xT = Vn,
                    CT = e => Yn(e.dom),
                    ST = e => t => bo(go(e), t),
                    kT = (e, t) => kn(go(e), CT, ST(t)),
                    _T = (e, t, o) => {
                        const n = new An(e, t),
                            r = o ? n.next.bind(n) : n.prev.bind(n);
                        let s = e;
                        for (let t = o ? e : r(); t && !wT(t); t = r()) qr(t) && (s = t);
                        return s
                    },
                    OT = e => {
                        const t = ((e, t) => {
                            const o = Si.fromRangeStart(e).getNode(),
                                n = ((e, t) => kn(go(e), (e => (e => Kn(e.dom))(e) || dr(e)), ST(t)).getOr(go(t)).dom)(o, t),
                                r = _T(o, n, !1),
                                s = _T(o, n, !0),
                                a = document.createRange();
                            return kT(r, n).fold((() => {
                                xT(r) ? a.setStart(r, 0) : a.setStartBefore(r)
                            }), (e => a.setStartBefore(e.dom))), kT(s, n).fold((() => {
                                xT(s) ? a.setEnd(s, s.data.length) : a.setEndAfter(s)
                            }), (e => a.setEndAfter(e.dom))), a
                        })(e.selection.getRng(), e.getBody());
                        e.selection.setRng(Rf(t))
                    };
                var TT;
                ! function(e) {
                    e.Before = "before", e.After = "after"
                }(TT || (TT = {}));
                const ET = (e, t) => Math.abs(e.left - t),
                    AT = (e, t) => Math.abs(e.right - t),
                    MT = (e, t) => (e => Y(e, ((e, t) => e.fold((() => I.some(t)), (e => {
                        const o = Math.min(t.left, e.left),
                            n = Math.min(t.top, e.top),
                            r = Math.max(t.right, e.right),
                            s = Math.max(t.bottom, e.bottom);
                        return I.some({
                            top: n,
                            right: r,
                            bottom: s,
                            left: o,
                            width: r - o,
                            height: s - n
                        })
                    }))), I.none()))(G(e, (e => {
                        return (o = t) >= (n = e).top && o <= n.bottom;
                        var o, n
                    }))).fold((() => [
                        [], e
                    ]), (t => {
                        const {
                            pass: o,
                            fail: n
                        } = q(e, (e => ((e, t) => {
                            const o = ((e, t) => Math.max(0, Math.min(e.bottom, t.bottom) - Math.max(e.top, t.top)))(e, t) / Math.min(e.height, t.height);
                            return ((e, t) => e.top < t.bottom && e.bottom > t.top)(e, t) && o > .5
                        })(e, t)));
                        return [o, n]
                    })),
                    NT = (e, t, o) => t > e.left && t < e.right ? 0 : Math.min(Math.abs(e.left - t), Math.abs(e.right - t)),
                    RT = (e, t, o) => {
                        const n = e => qr(e.node) ? I.some(e) : Rn(e.node) ? RT(de(e.node.childNodes), t, o) : I.none(),
                            r = (e, r) => {
                                const s = ae(e, ((e, n) => r(e, t, o) - r(n, t, o)));
                                return ((e, r) => {
                                    if (e.length >= 2) {
                                        const s = n(e[0]).getOr(e[0]),
                                            a = n(e[1]).getOr(e[1]);
                                        if (Math.abs(r(s, t, o) - r(a, t, o)) < 2) {
                                            if (Vn(s.node)) return I.some(s);
                                            if (Vn(a.node)) return I.some(a)
                                        }
                                    }
                                    return I.none()
                                })(s, r).orThunk((() => ue(s, n)))
                            },
                            [s, a] = MT(RC(e), o),
                            {
                                pass: i,
                                fail: l
                            } = q(a, (e => e.top < o));
                        return r(s, NT).orThunk((() => r(l, ti))).orThunk((() => r(i, ti)))
                    },
                    DT = (e, t, o) => ((e, t, o) => {
                        const n = go(e),
                            r = xo(n),
                            s = ho(r, t, o).filter((e => yo(n, e))).getOr(n);
                        return ((e, t, o, n) => {
                            const r = (t, s) => {
                                const a = G(t.dom.childNodes, R((e => Rn(e) && e.classList.contains("mce-drag-container"))));
                                return s.fold((() => RT(a, o, n)), (e => {
                                    const t = G(a, (t => t !== e.dom));
                                    return RT(t, o, n)
                                })).orThunk((() => (bo(t, e) ? I.none() : ko(t)).bind((e => r(e, I.some(t))))))
                            };
                            return r(t, I.none())
                        })(n, s, t, o)
                    })(e, t, o).filter((e => sd(e.node))).map((e => ((e, t) => ({
                        node: e.node,
                        position: ET(e, t) < AT(e, t) ? TT.Before : TT.After
                    }))(e, t))),
                    BT = e => {
                        var t, o;
                        const n = e.getBoundingClientRect(),
                            r = e.ownerDocument,
                            s = r.documentElement,
                            a = r.defaultView;
                        return {
                            top: n.top + (null !== (t = null == a ? void 0 : a.scrollY) && void 0 !== t ? t : 0) - s.clientTop,
                            left: n.left + (null !== (o = null == a ? void 0 : a.scrollX) && void 0 !== o ? o : 0) - s.clientLeft
                        }
                    },
                    LT = Yn,
                    HT = ((...e) => t => {
                        for (let o = 0; o < e.length; o++)
                            if (e[o](t)) return !0;
                        return !1
                    })(LT, Kn),
                    IT = (e, t, o, n) => {
                        const r = e.dom,
                            s = t.cloneNode(!0);
                        r.setStyles(s, {
                            width: o,
                            height: n
                        }), r.setAttrib(s, "data-mce-selected", null);
                        const a = r.create("div", {
                            class: "mce-drag-container",
                            "data-mce-bogus": "all",
                            unselectable: "on",
                            contenteditable: "false"
                        });
                        return r.setStyles(a, {
                            position: "absolute",
                            opacity: .5,
                            overflow: "hidden",
                            border: 0,
                            padding: 0,
                            margin: 0,
                            width: o,
                            height: n
                        }), r.setStyles(s, {
                            margin: 0,
                            boxSizing: "border-box"
                        }), a.appendChild(s), a
                    },
                    PT = (e, t) => o => () => {
                        const n = "left" === e ? o.scrollX : o.scrollY;
                        o.scroll({
                            [e]: n + t,
                            behavior: "smooth"
                        })
                    },
                    zT = PT("left", -32),
                    FT = PT("left", 32),
                    VT = PT("top", -32),
                    ZT = PT("top", 32),
                    UT = e => {
                        e && e.parentNode && e.parentNode.removeChild(e)
                    },
                    jT = (e, t) => {
                        const o = Aa(((e, o) => {
                            t._selectionOverrides.hideFakeCaret(), DT(t.getBody(), e, o).fold((() => t.selection.placeCaretAt(e, o)), (n => {
                                const r = t._selectionOverrides.showCaret(1, n.node, n.position === TT.Before, !1);
                                r ? t.selection.setRng(r) : t.selection.placeCaretAt(e, o)
                            }))
                        }), 0);
                        t.on("remove", o.cancel);
                        const n = e;
                        return r => e.on((e => {
                            const s = Math.max(Math.abs(r.screenX - e.screenX), Math.abs(r.screenY - e.screenY));
                            if (!e.dragging && s > 10) {
                                if (t.dispatch("dragstart", {
                                        target: e.element
                                    }).isDefaultPrevented()) return;
                                e.dragging = !0, t.focus()
                            }
                            if (e.dragging) {
                                const s = r.currentTarget === t.getDoc().documentElement,
                                    l = ((e, t) => ({
                                        pageX: t.pageX - e.relX,
                                        pageY: t.pageY + 5
                                    }))(e, ((e, t) => {
                                        return o = (e => e.inline ? BT(e.getBody()) : {
                                            left: 0,
                                            top: 0
                                        })(e), n = (e => {
                                            const t = e.getBody();
                                            return e.inline ? {
                                                left: t.scrollLeft,
                                                top: t.scrollTop
                                            } : {
                                                left: 0,
                                                top: 0
                                            }
                                        })(e), r = ((e, t) => {
                                            if (t.target.ownerDocument !== e.getDoc()) {
                                                const o = BT(e.getContentAreaContainer()),
                                                    n = (e => {
                                                        const t = e.getBody(),
                                                            o = e.getDoc().documentElement,
                                                            n = {
                                                                left: t.scrollLeft,
                                                                top: t.scrollTop
                                                            },
                                                            r = {
                                                                left: t.scrollLeft || o.scrollLeft,
                                                                top: t.scrollTop || o.scrollTop
                                                            };
                                                        return e.inline ? n : r
                                                    })(e);
                                                return {
                                                    left: t.pageX - o.left + n.left,
                                                    top: t.pageY - o.top + n.top
                                                }
                                            }
                                            return {
                                                left: t.pageX,
                                                top: t.pageY
                                            }
                                        })(e, t), {
                                            pageX: r.left - o.left + n.left,
                                            pageY: r.top - o.top + n.top
                                        };
                                        var o, n, r
                                    })(t, r));
                                a = e.ghost, i = t.getBody(), a.parentNode !== i && i.appendChild(a), ((e, t, o, n, r, s, a, i, l, c, d, u) => {
                                    let m = 0,
                                        g = 0;
                                    e.style.left = t.pageX + "px", e.style.top = t.pageY + "px", t.pageX + o > r && (m = t.pageX + o - r), t.pageY + n > s && (g = t.pageY + n - s), e.style.width = o - m + "px", e.style.height = n - g + "px";
                                    const h = l.clientHeight,
                                        p = l.clientWidth,
                                        f = a + l.getBoundingClientRect().top,
                                        v = i + l.getBoundingClientRect().left;
                                    d.on((e => {
                                        e.intervalId.clear(), e.dragging && u && (a + 8 >= h ? e.intervalId.set(ZT(c)) : a - 8 <= 0 ? e.intervalId.set(VT(c)) : i + 8 >= p ? e.intervalId.set(FT(c)) : i - 8 <= 0 ? e.intervalId.set(zT(c)) : f + 16 >= window.innerHeight ? e.intervalId.set(ZT(window)) : f - 16 <= 0 ? e.intervalId.set(VT(window)) : v + 16 >= window.innerWidth ? e.intervalId.set(FT(window)) : v - 16 <= 0 && e.intervalId.set(zT(window)))
                                    }))
                                })(e.ghost, l, e.width, e.height, e.maxX, e.maxY, r.clientY, r.clientX, t.getContentAreaContainer(), t.getWin(), n, s), o.throttle(r.clientX, r.clientY)
                            }
                            var a, i
                        }))
                    },
                    WT = e => {
                        e.on((e => {
                            e.intervalId.clear(), UT(e.ghost)
                        })), e.clear()
                    },
                    $T = e => {
                        const t = Ea(),
                            o = ba.DOM,
                            n = document,
                            r = ((e, t) => o => {
                                if ((e => 0 === e.button)(o)) {
                                    const s = J(t.dom.getParents(o.target), HT).getOr(null);
                                    if (x(s) && (n = t.getBody(), LT(r = s) && r !== n)) {
                                        const n = t.dom.getPos(s),
                                            r = t.getBody(),
                                            a = t.getDoc().documentElement;
                                        e.set({
                                            element: s,
                                            dragging: !1,
                                            screenX: o.screenX,
                                            screenY: o.screenY,
                                            maxX: (t.inline ? r.scrollWidth : a.offsetWidth) - 2,
                                            maxY: (t.inline ? r.scrollHeight : a.offsetHeight) - 2,
                                            relX: o.pageX - n.x,
                                            relY: o.pageY - n.y,
                                            width: s.offsetWidth,
                                            height: s.offsetHeight,
                                            ghost: IT(t, s, s.offsetWidth, s.offsetHeight),
                                            intervalId: Ta(100)
                                        })
                                    }
                                }
                                var n, r
                            })(t, e),
                            s = jT(t, e),
                            a = ((e, t) => o => {
                                e.on((e => {
                                    if (e.intervalId.clear(), e.dragging) {
                                        if (((e, t, o) => !w(t) && t !== o && !e.dom.isChildOf(t, o) && !LT(t))(t, (e => {
                                                const t = e.getSel();
                                                if (x(t)) {
                                                    const e = t.getRangeAt(0).startContainer;
                                                    return Vn(e) ? e.parentNode : e
                                                }
                                                return null
                                            })(t.selection), e.element)) {
                                            const n = (e => {
                                                const t = e.cloneNode(!0);
                                                return t.removeAttribute("data-mce-selected"), t
                                            })(e.element);
                                            t.dispatch("drop", {
                                                clientX: o.clientX,
                                                clientY: o.clientY
                                            }).isDefaultPrevented() || t.undoManager.transact((() => {
                                                UT(e.element), t.insertContent(t.dom.getOuterHTML(n)), t._selectionOverrides.hideFakeCaret()
                                            }))
                                        }
                                        t.dispatch("dragend")
                                    }
                                })), WT(e)
                            })(t, e),
                            i = ((e, t) => () => {
                                e.on((e => {
                                    e.intervalId.clear(), e.dragging && t.dispatch("dragend")
                                })), WT(e)
                            })(t, e);
                        e.on("mousedown", r), e.on("mousemove", s), e.on("mouseup", a), o.bind(n, "mousemove", s), o.bind(n, "mouseup", i), e.on("remove", (() => {
                            o.unbind(n, "mousemove", s), o.unbind(n, "mouseup", i)
                        })), e.on("keydown", (e => {
                            e.keyCode === Lm.ESC && i()
                        }))
                    },
                    qT = Yn,
                    GT = (e, t) => yf(e.getBody(), t),
                    KT = e => {
                        const t = e.selection,
                            o = e.dom,
                            n = e.getBody(),
                            r = od(e, n, o.isBlock, (() => eh(e))),
                            s = "sel-" + o.uniqueId(),
                            a = "data-mce-selected";
                        let i;
                        const l = e => e !== n && (qT(e) || Qn(e)) && o.isChildOf(e, n),
                            c = (o, n, s, a = !0) => e.dispatch("ShowCaret", {
                                target: n,
                                direction: o,
                                before: s
                            }).isDefaultPrevented() ? null : (a && t.scrollIntoView(n, -1 === o), r.show(s, n)),
                            d = e => Nr(e) || Lr(e) || Hr(e),
                            u = e => d(e.startContainer) || d(e.endContainer),
                            m = t => {
                                const n = e.schema.getVoidElements(),
                                    r = o.createRng(),
                                    s = t.startContainer,
                                    a = t.startOffset,
                                    i = t.endContainer,
                                    l = t.endOffset;
                                return Se(n, s.nodeName.toLowerCase()) ? 0 === a ? r.setStartBefore(s) : r.setStartAfter(s) : r.setStart(s, a), Se(n, i.nodeName.toLowerCase()) ? 0 === l ? r.setEndBefore(i) : r.setEndAfter(i) : r.setEnd(i, l), r
                            },
                            g = (r, d) => {
                                if (!r) return null;
                                if (r.collapsed) {
                                    if (!u(r)) {
                                        const e = d ? 1 : -1,
                                            t = Ad(e, n, r),
                                            s = t.getNode(!d);
                                        if (x(s)) {
                                            if (sd(s)) return c(e, s, !!d && !t.isAtEnd(), !1);
                                            if (Mr(s) && Yn(s.nextSibling)) {
                                                const e = o.createRng();
                                                return e.setStart(s, 0), e.setEnd(s, 0), e
                                            }
                                        }
                                        const a = t.getNode(d);
                                        if (x(a)) {
                                            if (sd(a)) return c(e, a, !d && !t.isAtEnd(), !1);
                                            if (Mr(a) && Yn(a.previousSibling)) {
                                                const e = o.createRng();
                                                return e.setStart(a, 1), e.setEnd(a, 1), e
                                            }
                                        }
                                    }
                                    return null
                                }
                                let m = r.startContainer,
                                    g = r.startOffset;
                                const h = r.endOffset;
                                if (Vn(m) && 0 === g && qT(m.parentNode) && (m = m.parentNode, g = o.nodeIndex(m), m = m.parentNode), !Rn(m)) return null;
                                if (h === g + 1 && m === r.endContainer) {
                                    const n = m.childNodes[g];
                                    if (l(n)) return (n => {
                                        const r = n.cloneNode(!0),
                                            l = e.dispatch("ObjectSelected", {
                                                target: n,
                                                targetClone: r
                                            });
                                        if (l.isDefaultPrevented()) return null;
                                        const c = ((n, r) => {
                                                const a = go(e.getBody()),
                                                    i = e.getDoc(),
                                                    l = On(a, "#" + s).getOrThunk((() => {
                                                        const e = co('<div data-mce-bogus="all" class="mce-offscreen-selection"></div>', i);
                                                        return Wt(e, "id", s), tn(a, e), e
                                                    })),
                                                    c = o.createRng();
                                                nn(l), on(l, [mo(or, i), go(r), mo(or, i)]), c.setStart(l.dom.firstChild, 1), c.setEnd(l.dom.lastChild, 0), $o(l, {
                                                    top: o.getPos(n, e.getBody()).y + "px"
                                                }), Bg(l);
                                                const d = t.getSel();
                                                return d && (d.removeAllRanges(), d.addRange(c)), c
                                            })(n, l.targetClone),
                                            d = go(n);
                                        return W(rr(go(e.getBody()), `*[${a}]`), (e => {
                                            bo(d, e) || Yt(e, a)
                                        })), o.getAttrib(n, a) || n.setAttribute(a, "1"), i = n, p(), c
                                    })(n)
                                }
                                return null
                            },
                            h = () => {
                                i && i.removeAttribute(a), On(go(e.getBody()), "#" + s).each(rn), i = null
                            },
                            p = () => {
                                r.hide()
                            };
                        return ew(e) || (e.on("click", (t => {
                            const o = GT(e, t.target);
                            o && qT(o) && (t.preventDefault(), e.focus())
                        })), e.on("blur NewBlock", h), e.on("ResizeWindow FullscreenStateChanged", r.reposition), e.on("tap", (t => {
                            const o = t.target,
                                n = GT(e, o);
                            qT(n) ? (t.preventDefault(), Sx(e, n).each(g)) : l(o) && Sx(e, o).each(g)
                        }), !0), e.on("mousedown", (r => {
                            const s = r.target;
                            if (s !== n && "HTML" !== s.nodeName && !o.isChildOf(s, n)) return;
                            if (!((e, t, o) => {
                                    const n = go(e.getBody()),
                                        r = e.inline ? n : go(xo(n).dom.documentElement),
                                        s = ((e, t, o, n) => {
                                            const r = (e => e.dom.getBoundingClientRect())(t);
                                            return {
                                                x: o - (e ? r.left + t.dom.clientLeft + Ow(t) : 0),
                                                y: n - (e ? r.top + t.dom.clientTop + _w(t) : 0)
                                            }
                                        })(e.inline, r, t, o);
                                    return ((e, t, o) => {
                                        const n = Sw(e),
                                            r = kw(e);
                                        return t >= 0 && o >= 0 && t <= n && o <= r
                                    })(r, s.x, s.y)
                                })(e, r.clientX, r.clientY)) return;
                            h(), p();
                            const a = GT(e, s);
                            qT(a) ? (r.preventDefault(), Sx(e, a).each(g)) : DT(n, r.clientX, r.clientY).each((o => {
                                var n;
                                r.preventDefault(), (n = c(1, o.node, o.position === TT.Before, !1)) && t.setRng(n), Rn(a) ? a.focus() : e.getBody().focus()
                            }))
                        })), e.on("keypress", (e => {
                            Lm.modifierPressed(e) || qT(t.getNode()) && e.preventDefault()
                        })), e.on("GetSelectionRange", (e => {
                            let t = e.range;
                            if (i) {
                                if (!i.parentNode) return void(i = null);
                                t = t.cloneRange(), t.selectNode(i), e.range = t
                            }
                        })), e.on("SetSelectionRange", (e => {
                            e.range = m(e.range);
                            const t = g(e.range, e.forward);
                            t && (e.range = t)
                        })), e.on("AfterSetSelectionRange", (e => {
                            const t = e.range,
                                n = t.startContainer.parentElement;
                            var r;
                            u(t) || Rn(r = n) && "mcepastebin" === r.id || p(), (e => x(e) && o.hasClass(e, "mce-offscreen-selection"))(n) || h()
                        })), (e => {
                            $T(e), hc(e) && (e => {
                                const t = t => {
                                        if (!t.isDefaultPrevented()) {
                                            const o = t.dataTransfer;
                                            o && (Z(o.types, "Files") || o.files.length > 0) && (t.preventDefault(), "drop" === t.type && Rw(e, "Dropped file type is not supported"))
                                        }
                                    },
                                    o = o => {
                                        Kg(e, o.target) && t(o)
                                    },
                                    n = () => {
                                        const n = ba.DOM,
                                            r = e.dom,
                                            s = document,
                                            a = e.inline ? e.getBody() : e.getDoc(),
                                            i = ["drop", "dragover"];
                                        W(i, (e => {
                                            n.bind(s, e, o), r.bind(a, e, t)
                                        })), e.on("remove", (() => {
                                            W(i, (e => {
                                                n.unbind(s, e, o), r.unbind(a, e, t)
                                            }))
                                        }))
                                    };
                                e.on("init", (() => {
                                    $g.setEditorTimeout(e, n, 0)
                                }))
                            })(e)
                        })(e), (e => {
                            const t = Aa((() => {
                                if (!e.removed && e.getBody().contains(document.activeElement)) {
                                    const t = e.selection.getRng();
                                    if (t.collapsed) {
                                        const o = kx(e, t, !1);
                                        e.selection.setRng(o)
                                    }
                                }
                            }), 0);
                            e.on("focus", (() => {
                                t.throttle()
                            })), e.on("blur", (() => {
                                t.cancel()
                            }))
                        })(e), (e => {
                            e.on("init", (() => {
                                e.on("focusin", (t => {
                                    const o = t.target;
                                    if (Qn(o)) {
                                        const t = yf(e.getBody(), o),
                                            n = Yn(t) ? t : o;
                                        e.selection.getNode() !== n && Sx(e, n).each((t => e.selection.setRng(t)))
                                    }
                                }))
                            }))
                        })(e)), {
                            showCaret: c,
                            showBlockCaretContainer: e => {
                                e.hasAttribute("data-mce-caret") && (Ir(e), t.scrollIntoView(e))
                            },
                            hideFakeCaret: p,
                            destroy: () => {
                                r.destroy(), i = null
                            }
                        }
                    },
                    YT = (e, t) => {
                        let o = t;
                        for (let t = e.previousSibling; Vn(t); t = t.previousSibling) o += t.data.length;
                        return o
                    },
                    XT = (e, t, o, n, r) => {
                        if (Vn(o) && (n < 0 || n > o.data.length)) return [];
                        const s = r && Vn(o) ? [YT(o, n)] : [n];
                        let a = o;
                        for (; a !== t && a.parentNode;) s.push(e.nodeIndex(a, r)), a = a.parentNode;
                        return a === t ? s.reverse() : []
                    },
                    JT = (e, t, o, n, r, s, a = !1) => ({
                        start: XT(e, t, o, n, a),
                        end: XT(e, t, r, s, a)
                    }),
                    QT = (e, t) => {
                        const o = t.slice(),
                            n = o.pop();
                        return S(n) ? Y(o, ((e, t) => e.bind((e => I.from(e.childNodes[t])))), I.some(e)).bind((e => Vn(e) && (n < 0 || n > e.data.length) ? I.none() : I.some({
                            node: e,
                            offset: n
                        }))) : I.none()
                    },
                    eE = (e, t) => QT(e, t.start).bind((({
                        node: o,
                        offset: n
                    }) => QT(e, t.end).map((({
                        node: e,
                        offset: t
                    }) => {
                        const r = document.createRange();
                        return r.setStart(o, n), r.setEnd(e, t), r
                    })))),
                    tE = (e, t, o) => {
                        if (t && e.isEmpty(t) && !o(t)) {
                            const n = t.parentNode;
                            e.remove(t), tE(e, n, o)
                        }
                    },
                    oE = (e, t, o, n = !0) => {
                        const r = t.startContainer.parentNode,
                            s = t.endContainer.parentNode;
                        t.deleteContents(), n && !o(t.startContainer) && (Vn(t.startContainer) && 0 === t.startContainer.data.length && e.remove(t.startContainer), Vn(t.endContainer) && 0 === t.endContainer.data.length && e.remove(t.endContainer), tE(e, r, o), r !== s && tE(e, s, o))
                    },
                    nE = (e, t) => I.from(e.dom.getParent(t.startContainer, e.dom.isBlock)),
                    rE = (e, t, o) => {
                        const n = e.dynamicPatternsLookup({
                            text: o,
                            block: t
                        });
                        return { ...e,
                            blockPatterns: Ji(n).concat(e.blockPatterns),
                            inlinePatterns: Qi(n).concat(e.inlinePatterns)
                        }
                    },
                    sE = (e, t, o, n) => {
                        const r = e.createRng();
                        return r.setStart(t, 0), r.setEnd(o, n), r.toString()
                    },
                    aE = (e, t, o) => {
                        ((e, t, o) => {
                            if (Vn(e) && 0 >= e.length) return I.some(bk(e, 0)); {
                                const t = Ga(yk);
                                return I.from(t.forwards(e, 0, wk(e), o)).map((e => bk(e.container, 0)))
                            }
                        })(t, 0, t).each((n => {
                            const r = n.container;
                            Sk(r, o.start.length, t).each((o => {
                                const n = e.createRng();
                                n.setStart(r, 0), n.setEnd(o.container, o.offset), oE(e, n, (e => e === t))
                            }))
                        }))
                    },
                    iE = (e, t) => e.create("span", {
                        "data-mce-type": "bookmark",
                        id: t
                    }),
                    lE = (e, t) => {
                        const o = e.createRng();
                        return o.setStartAfter(t.start), o.setEndBefore(t.end), o
                    },
                    cE = (e, t, o) => {
                        const n = eE(e.getRoot(), o).getOrDie("Unable to resolve path range"),
                            r = n.startContainer,
                            s = n.endContainer,
                            a = 0 === n.endOffset ? s : s.splitText(n.endOffset),
                            i = 0 === n.startOffset ? r : r.splitText(n.startOffset),
                            l = i.parentNode;
                        return {
                            prefix: t,
                            end: a.parentNode.insertBefore(iE(e, t + "-end"), a),
                            start: l.insertBefore(iE(e, t + "-start"), i)
                        }
                    },
                    dE = (e, t, o) => {
                        tE(e, e.get(t.prefix + "-end"), o), tE(e, e.get(t.prefix + "-start"), o)
                    },
                    uE = e => 0 === e.start.length,
                    mE = (e, t, o, n) => {
                        const r = t.start;
                        var s;
                        return kk(e, n.container, n.offset, (s = r, (e, t) => {
                            const o = e.data.substring(0, t),
                                n = o.lastIndexOf(s.charAt(s.length - 1)),
                                r = o.lastIndexOf(s);
                            return -1 !== r ? r + s.length : -1 !== n ? n + 1 : -1
                        }), o).bind((n => {
                            var s, a;
                            const i = null !== (a = null === (s = o.textContent) || void 0 === s ? void 0 : s.indexOf(r)) && void 0 !== a ? a : -1;
                            if (-1 !== i && n.offset >= i + r.length) {
                                const t = e.createRng();
                                return t.setStart(n.container, n.offset - r.length), t.setEnd(n.container, n.offset), I.some(t)
                            } {
                                const s = n.offset - r.length;
                                return Ck(n.container, s, o).map((t => {
                                    const o = e.createRng();
                                    return o.setStart(t.container, t.offset), o.setEnd(n.container, n.offset), o
                                })).filter((e => e.toString() === r)).orThunk((() => mE(e, t, o, bk(n.container, 0))))
                            }
                        }))
                    },
                    gE = (e, t, o, n) => {
                        const r = e.dom,
                            s = r.getRoot(),
                            a = o.pattern,
                            i = o.position.container,
                            l = o.position.offset;
                        return Ck(i, l - o.pattern.end.length, t).bind((c => {
                            const d = JT(r, s, c.container, c.offset, i, l, n);
                            if (uE(a)) return I.some({
                                matches: [{
                                    pattern: a,
                                    startRng: d,
                                    endRng: d
                                }],
                                position: c
                            }); {
                                const i = hE(e, o.remainingPatterns, c.container, c.offset, t, n),
                                    l = i.getOr({
                                        matches: [],
                                        position: c
                                    }),
                                    u = l.position,
                                    m = ((e, t, o, n, r, s = !1) => {
                                        if (0 === t.start.length && !s) {
                                            const t = e.createRng();
                                            return t.setStart(o, n), t.setEnd(o, n), I.some(t)
                                        }
                                        return xk(o, n, r).bind((o => mE(e, t, r, o).bind((e => {
                                            var t;
                                            if (s) {
                                                if (e.endContainer === o.container && e.endOffset === o.offset) return I.none();
                                                if (0 === o.offset && (null === (t = e.endContainer.textContent) || void 0 === t ? void 0 : t.length) === e.endOffset) return I.none()
                                            }
                                            return I.some(e)
                                        }))))
                                    })(r, a, u.container, u.offset, t, i.isNone());
                                return m.map((e => {
                                    const t = ((e, t, o, n = !1) => JT(e, t, o.startContainer, o.startOffset, o.endContainer, o.endOffset, n))(r, s, e, n);
                                    return {
                                        matches: l.matches.concat([{
                                            pattern: a,
                                            startRng: t,
                                            endRng: d
                                        }]),
                                        position: bk(e.startContainer, e.startOffset)
                                    }
                                }))
                            }
                        }))
                    },
                    hE = (e, t, o, n, r, s) => {
                        const a = e.dom;
                        return xk(o, n, a.getRoot()).bind((i => {
                            const l = sE(a, r, o, n);
                            for (let a = 0; a < t.length; a++) {
                                const c = t[a];
                                if (!Ze(l, c.end)) continue;
                                const d = t.slice();
                                d.splice(a, 1);
                                const u = gE(e, r, {
                                    pattern: c,
                                    remainingPatterns: d,
                                    position: i
                                }, s);
                                if (u.isNone() && n > 0) return hE(e, t, o, n - 1, r, s);
                                if (u.isSome()) return u
                            }
                            return I.none()
                        }))
                    },
                    pE = (e, t, o) => {
                        e.selection.setRng(o), "inline-format" === t.type ? W(t.format, (t => {
                            e.formatter.apply(t)
                        })) : e.execCommand(t.cmd, !1, t.value)
                    },
                    fE = (e, t, o, n, r, s) => {
                        var a;
                        return ((e, t) => {
                            const o = oe(e, (e => U(t, (t => e.pattern.start === t.pattern.start && e.pattern.end === t.pattern.end))));
                            return e.length === t.length ? o ? e : t : e.length > t.length ? e : t
                        })(hE(e, r.inlinePatterns, o, n, t, s).fold((() => []), (e => e.matches)), hE(e, (a = r.inlinePatterns, ae(a, ((e, t) => t.end.length - e.end.length))), o, n, t, s).fold((() => []), (e => e.matches)))
                    },
                    vE = (e, t) => {
                        if (0 === t.length) return;
                        const o = e.dom,
                            n = e.selection.getBookmark(),
                            r = ((e, t) => {
                                const o = Ua("mce_textpattern"),
                                    n = K(t, ((t, n) => {
                                        const r = cE(e, o + `_end${t.length}`, n.endRng);
                                        return t.concat([{ ...n,
                                            endMarker: r
                                        }])
                                    }), []);
                                return K(n, ((t, r) => {
                                    const s = n.length - t.length - 1,
                                        a = uE(r.pattern) ? r.endMarker : cE(e, o + `_start${s}`, r.startRng);
                                    return t.concat([{ ...r,
                                        startMarker: a
                                    }])
                                }), [])
                            })(o, t);
                        W(r, (t => {
                            const n = o.getParent(t.startMarker.start, o.isBlock),
                                r = e => e === n;
                            uE(t.pattern) ? ((e, t, o, n) => {
                                const r = lE(e.dom, o);
                                oE(e.dom, r, n), pE(e, t, r)
                            })(e, t.pattern, t.endMarker, r) : ((e, t, o, n, r) => {
                                const s = e.dom,
                                    a = lE(s, n),
                                    i = lE(s, o);
                                oE(s, i, r), oE(s, a, r);
                                const l = {
                                        prefix: o.prefix,
                                        start: o.end,
                                        end: n.start
                                    },
                                    c = lE(s, l);
                                pE(e, t, c)
                            })(e, t.pattern, t.startMarker, t.endMarker, r), dE(o, t.endMarker, r), dE(o, t.startMarker, r)
                        })), e.selection.moveToBookmark(n)
                    },
                    bE = (e, t) => {
                        const o = e.selection.getRng();
                        return nE(e, o).map((n => {
                            var r;
                            const s = Math.max(0, o.startOffset),
                                a = rE(t, n, null !== (r = n.textContent) && void 0 !== r ? r : ""),
                                i = fE(e, n, o.startContainer, s, a, !0),
                                l = ((e, t, o, n) => {
                                    var r;
                                    const s = e.dom,
                                        a = pl(e);
                                    if (!s.is(t, a)) return [];
                                    const i = null !== (r = t.textContent) && void 0 !== r ? r : "";
                                    return ((e, t) => {
                                        const o = (e => ae(e, ((e, t) => t.start.length - e.start.length)))(e),
                                            n = t.replace(or, " ");
                                        return J(o, (e => 0 === t.indexOf(e.start) || 0 === n.indexOf(e.start)))
                                    })(o.blockPatterns, i).map((e => Rt.trim(i).length === e.start.length ? [] : [{
                                        pattern: e,
                                        range: JT(s, s.getRoot(), t, 0, t, 0, true)
                                    }])).getOr([])
                                })(e, n, a);
                            return (l.length > 0 || i.length > 0) && (e.undoManager.add(), e.undoManager.extra((() => {
                                e.execCommand("mceInsertNewLine")
                            }), (() => {
                                e.insertContent(tr), vE(e, i), ((e, t) => {
                                    if (0 === t.length) return;
                                    const o = e.selection.getBookmark();
                                    W(t, (t => ((e, t) => {
                                        const o = e.dom,
                                            n = t.pattern,
                                            r = eE(o.getRoot(), t.range).getOrDie("Unable to resolve path range");
                                        return nE(e, r).each((t => {
                                            "block-format" === n.type ? ((e, t) => {
                                                const o = t.get(e);
                                                return f(o) && le(o).exists((e => Se(e, "block")))
                                            })(n.format, e.formatter) && e.undoManager.transact((() => {
                                                aE(e.dom, t, n), e.formatter.apply(n.format)
                                            })) : "block-command" === n.type && e.undoManager.transact((() => {
                                                aE(e.dom, t, n), e.execCommand(n.cmd, !1, n.value)
                                            }))
                                        })), !0
                                    })(e, t))), e.selection.moveToBookmark(o)
                                })(e, l);
                                const t = e.selection.getRng(),
                                    o = xk(t.startContainer, t.startOffset, e.dom.getRoot());
                                e.execCommand("mceInsertNewLine"), o.each((t => {
                                    const o = t.container;
                                    o.data.charAt(t.offset - 1) === tr && (o.deleteData(t.offset - 1, 1), tE(e.dom, o.parentNode, (t => t === e.dom.getRoot())))
                                }))
                            })), !0)
                        })).getOr(!1)
                    },
                    yE = (e, t, o) => {
                        for (let n = 0; n < e.length; n++)
                            if (o(e[n], t)) return !0;
                        return !1
                    },
                    wE = e => {
                        const t = Rt.each,
                            o = Lm.BACKSPACE,
                            n = Lm.DELETE,
                            r = e.dom,
                            s = e.selection,
                            a = e.parser,
                            i = Et.browser,
                            l = i.isFirefox(),
                            c = i.isChromium() || i.isSafari(),
                            d = Et.deviceType.isiPhone() || Et.deviceType.isiPad(),
                            u = Et.os.isMacOS() || Et.os.isiOS(),
                            m = (t, o) => {
                                try {
                                    e.getDoc().execCommand(t, !1, String(o))
                                } catch (e) {}
                            },
                            g = e => e.isDefaultPrevented(),
                            h = () => {
                                e.shortcuts.add("meta+a", null, "SelectAll")
                            },
                            p = () => {
                                e.inline || r.bind(e.getDoc(), "mousedown mouseup", (t => {
                                    let o;
                                    if (t.target === e.getDoc().documentElement)
                                        if (o = s.getRng(), e.getBody().focus(), "mousedown" === t.type) {
                                            if (Nr(o.startContainer)) return;
                                            s.placeCaretAt(t.clientX, t.clientY)
                                        } else s.setRng(o)
                                }))
                            },
                            f = () => {
                                Range.prototype.getClientRects || e.on("mousedown", (t => {
                                    if (!g(t) && "HTML" === t.target.nodeName) {
                                        const t = e.getBody();
                                        t.blur(), $g.setEditorTimeout(e, (() => {
                                            t.focus()
                                        }))
                                    }
                                }))
                            },
                            v = () => {
                                const t = vc(e);
                                e.on("click", (o => {
                                    const n = o.target;
                                    /^(IMG|HR)$/.test(n.nodeName) && "false" !== r.getContentEditableParent(n) && (o.preventDefault(), e.selection.select(n), e.nodeChanged()), "A" === n.nodeName && r.hasClass(n, t) && 0 === n.childNodes.length && (o.preventDefault(), s.select(n))
                                }))
                            },
                            b = () => {
                                e.on("keydown", (e => {
                                    if (!g(e) && e.keyCode === o && s.isCollapsed() && 0 === s.getRng().startOffset) {
                                        const t = s.getNode().previousSibling;
                                        if (t && t.nodeName && "table" === t.nodeName.toLowerCase()) return e.preventDefault(), !1
                                    }
                                    return !0
                                }))
                            },
                            y = () => {
                                dc(e) || e.on("BeforeExecCommand mousedown", (() => {
                                    m("StyleWithCSS", !1), m("enableInlineTableEditing", !1), Zl(e) || m("enableObjectResizing", !1)
                                }))
                            },
                            w = () => {
                                e.contentStyles.push("img:-moz-broken {-moz-force-broken-image-icon:1;min-width:24px;min-height:24px}")
                            },
                            x = () => {
                                e.inline || e.on("keydown", (() => {
                                    document.activeElement === document.body && e.getWin().focus()
                                }))
                            },
                            C = () => {
                                e.inline || (e.contentStyles.push("body {min-height: 150px}"), e.on("click", (t => {
                                    let o;
                                    "HTML" === t.target.nodeName && (o = e.selection.getRng(), e.getBody().focus(), e.selection.setRng(o), e.selection.normalize(), e.nodeChanged())
                                })))
                            },
                            S = () => {
                                u && e.on("keydown", (t => {
                                    !Lm.metaKeyPressed(t) || t.shiftKey || 37 !== t.keyCode && 39 !== t.keyCode || (t.preventDefault(), e.selection.getSel().modify("move", 37 === t.keyCode ? "backward" : "forward", "lineboundary"))
                                }))
                            },
                            k = () => {
                                e.on("click", (e => {
                                    let t = e.target;
                                    do {
                                        if ("A" === t.tagName) return void e.preventDefault()
                                    } while (t = t.parentNode)
                                })), e.contentStyles.push(".mce-content-body {-webkit-touch-callout: none}")
                            },
                            O = () => {
                                e.on("init", (() => {
                                    e.dom.bind(e.getBody(), "submit", (e => {
                                        e.preventDefault()
                                    }))
                                }))
                            },
                            T = _;
                        return ew(e) ? (c && (p(), v(), O(), h(), d && (x(), C(), k())), l && (f(), y(), w(), S())) : (e.on("keydown", (t => {
                            if (g(t) || t.keyCode !== Lm.BACKSPACE) return;
                            let o = s.getRng();
                            const n = o.startContainer,
                                a = o.startOffset,
                                i = r.getRoot();
                            let l = n;
                            if (o.collapsed && 0 === a) {
                                for (; l.parentNode && l.parentNode.firstChild === l && l.parentNode !== i;) l = l.parentNode;
                                "BLOCKQUOTE" === l.nodeName && (e.formatter.toggle("blockquote", void 0, l), o = r.createRng(), o.setStart(n, 0), o.setEnd(n, 0), s.setRng(o))
                            }
                        })), (() => {
                            const t = e => {
                                const t = r.create("body"),
                                    o = e.cloneContents();
                                return t.appendChild(o), s.serializer.serialize(t, {
                                    format: "html"
                                })
                            };
                            e.on("keydown", (s => {
                                const a = s.keyCode;
                                if (!g(s) && (a === n || a === o)) {
                                    const o = e.selection.isCollapsed(),
                                        n = e.getBody();
                                    if (o && !r.isEmpty(n)) return;
                                    if (!o && !(o => {
                                            const n = t(o),
                                                s = r.createRng();
                                            return s.selectNode(e.getBody()), n === t(s)
                                        })(e.selection.getRng())) return;
                                    s.preventDefault(), e.setContent(""), n.firstChild && r.isBlock(n.firstChild) ? e.selection.setCursorLocation(n.firstChild, 0) : e.selection.setCursorLocation(n, 0), e.nodeChanged()
                                }
                            }))
                        })(), Et.windowsPhone || e.on("keyup focusin mouseup", (t => {
                            Lm.modifierPressed(t) || (e => {
                                const t = e.getBody(),
                                    o = e.selection.getRng();
                                return o.startContainer === o.endContainer && o.startContainer === t && 0 === o.startOffset && o.endOffset === t.childNodes.length
                            })(e) || s.normalize()
                        }), !0), c && (p(), v(), e.on("init", (() => {
                            m("DefaultParagraphSeparator", pl(e))
                        })), O(), b(), a.addNodeFilter("br", (e => {
                            let t = e.length;
                            for (; t--;) "Apple-interchange-newline" === e[t].attr("class") && e[t].remove()
                        })), d ? (x(), C(), k()) : h()), l && (e.on("keydown", (t => {
                            if (!g(t) && t.keyCode === o) {
                                if (!e.getBody().getElementsByTagName("hr").length) return;
                                if (s.isCollapsed() && 0 === s.getRng().startOffset) {
                                    const e = s.getNode(),
                                        o = e.previousSibling;
                                    if ("HR" === e.nodeName) return r.remove(e), void t.preventDefault();
                                    o && o.nodeName && "hr" === o.nodeName.toLowerCase() && (r.remove(o), t.preventDefault())
                                }
                            }
                        })), f(), (() => {
                            const o = () => {
                                    const o = r.getAttribs(s.getStart().cloneNode(!1));
                                    return () => {
                                        const n = s.getStart();
                                        n !== e.getBody() && (r.setAttrib(n, "style", null), t(o, (e => {
                                            n.setAttributeNode(e.cloneNode(!0))
                                        })))
                                    }
                                },
                                n = () => !s.isCollapsed() && r.getParent(s.getStart(), r.isBlock) !== r.getParent(s.getEnd(), r.isBlock);
                            e.on("keypress", (t => {
                                let r;
                                return !(!(g(t) || 8 !== t.keyCode && 46 !== t.keyCode) && n() && (r = o(), e.getDoc().execCommand("delete", !1), r(), t.preventDefault(), 1))
                            })), r.bind(e.getDoc(), "cut", (t => {
                                if (!g(t) && n()) {
                                    const t = o();
                                    $g.setEditorTimeout(e, (() => {
                                        t()
                                    }))
                                }
                            }))
                        })(), y(), e.on("SetContent ExecCommand", (e => {
                            "setcontent" !== e.type && "mceInsertLink" !== e.command || t(r.select("a:not([data-mce-block])"), (e => {
                                var t;
                                let o = e.parentNode;
                                const n = r.getRoot();
                                if ((null == o ? void 0 : o.lastChild) === e) {
                                    for (; o && !r.isBlock(o);) {
                                        if ((null === (t = o.parentNode) || void 0 === t ? void 0 : t.lastChild) !== o || o === n) return;
                                        o = o.parentNode
                                    }
                                    r.add(o, "br", {
                                        "data-mce-bogus": 1
                                    })
                                }
                            }))
                        })), w(), S(), b())), {
                            refreshContentEditable: T,
                            isHidden: () => {
                                if (!l || e.removed) return !1;
                                const t = e.selection.getSel();
                                return !t || !t.rangeCount || 0 === t.rangeCount
                            }
                        }
                    },
                    xE = ba.DOM,
                    CE = e => e.inline ? e.getElement().nodeName.toLowerCase() : void 0,
                    SE = e => ye(e, (e => !1 === y(e))),
                    kE = e => {
                        const t = e.options.get,
                            o = e.editorUpload.blobCache;
                        return SE({
                            allow_conditional_comments: t("allow_conditional_comments"),
                            allow_html_data_urls: t("allow_html_data_urls"),
                            allow_svg_data_urls: t("allow_svg_data_urls"),
                            allow_html_in_named_anchor: t("allow_html_in_named_anchor"),
                            allow_script_urls: t("allow_script_urls"),
                            allow_unsafe_link_target: t("allow_unsafe_link_target"),
                            convert_fonts_to_spans: t("convert_fonts_to_spans"),
                            fix_list_elements: t("fix_list_elements"),
                            font_size_legacy_values: t("font_size_legacy_values"),
                            forced_root_block: t("forced_root_block"),
                            forced_root_block_attrs: t("forced_root_block_attrs"),
                            preserve_cdata: t("preserve_cdata"),
                            remove_trailing_brs: t("remove_trailing_brs"),
                            inline_styles: t("inline_styles"),
                            root_name: CE(e),
                            validate: !0,
                            blob_cache: o,
                            document: e.getDoc()
                        })
                    },
                    _E = e => {
                        const t = e.options.get;
                        return SE({
                            custom_elements: t("custom_elements"),
                            extended_valid_elements: t("extended_valid_elements"),
                            invalid_elements: t("invalid_elements"),
                            invalid_styles: t("invalid_styles"),
                            schema: t("schema"),
                            valid_children: t("valid_children"),
                            valid_classes: t("valid_classes"),
                            valid_elements: t("valid_elements"),
                            valid_styles: t("valid_styles"),
                            verify_html: t("verify_html"),
                            padd_empty_block_inline_children: t("format_empty_lines")
                        })
                    },
                    OE = e => e.inline ? e.ui.styleSheetLoader : e.dom.styleSheetLoader,
                    TE = e => {
                        const t = OE(e),
                            o = zl(e),
                            n = e.contentCSS,
                            r = () => {
                                t.unloadAll(n), e.inline || e.ui.styleSheetLoader.unloadAll(o)
                            },
                            s = () => {
                                e.removed ? r() : e.on("remove", r)
                            };
                        if (e.contentStyles.length > 0) {
                            let t = "";
                            Rt.each(e.contentStyles, (e => {
                                t += e + "\r\n"
                            })), e.dom.addStyle(t)
                        }
                        const a = Promise.all(((e, t, o) => {
                                const n = [OE(e).loadAll(t)];
                                return e.inline ? n : n.concat([e.ui.styleSheetLoader.loadAll(o)])
                            })(e, n, o)).then(s).catch(s),
                            i = Pl(e);
                        return i && ((e, t) => {
                            const o = go(e.getBody()),
                                n = zo(Po(o)),
                                r = uo("style");
                            Wt(r, "type", "text/css"), tn(r, mo(t)), tn(n, r), e.on("remove", (() => {
                                rn(r)
                            }))
                        })(e, i), a
                    },
                    EE = e => {
                        !0 !== e.removed && ((e => {
                            ew(e) || e.load({
                                initial: !0,
                                format: "html"
                            }), e.startContent = e.getContent({
                                format: "raw"
                            })
                        })(e), (e => {
                            e.bindPendingEventDelegates(), e.initialized = !0, (e => {
                                e.dispatch("Init")
                            })(e), e.focus(!0), (e => {
                                const t = e.dom.getRoot();
                                e.inline || Hu(e) && e.selection.getStart(!0) !== t || eu(t).each((t => {
                                    const o = t.getNode(),
                                        n = Pn(o) ? eu(o).getOr(t) : t;
                                    e.selection.setRng(n.toRange())
                                }))
                            })(e), e.nodeChanged({
                                initial: !0
                            });
                            const t = wc(e);
                            C(t) && t.call(e, e), (e => {
                                const t = Cc(e);
                                t && $g.setEditorTimeout(e, (() => {
                                    let o;
                                    o = !0 === t ? e : e.editorManager.get(t), o && !o.destroyed && (o.focus(), o.selection.scrollIntoView())
                                }), 100)
                            })(e)
                        })(e))
                    },
                    AE = e => {
                        const t = e.getElement();
                        let o = e.getDoc();
                        e.inline && (xE.addClass(t, "mce-content-body"), e.contentDocument = o = document, e.contentWindow = window, e.bodyElement = t, e.contentAreaContainer = t);
                        const n = e.getBody();
                        n.disabled = !0, e.readonly = dc(e), e.readonly || (e.inline && "static" === xE.getStyle(n, "position", !0) && (n.style.position = "relative"), n.contentEditable = "true"), n.disabled = !1, e.editorUpload = jw(e), e.schema = Js(_E(e)), e.dom = ba(o, {
                            keep_values: !0,
                            url_converter: e.convertURL,
                            url_converter_scope: e,
                            update_styles: !0,
                            root_element: e.inline ? e.getBody() : null,
                            collect: e.inline,
                            schema: e.schema,
                            contentCssCors: Nl(e),
                            referrerPolicy: Rl(e),
                            onSetAttrib: t => {
                                e.dispatch("SetAttrib", t)
                            }
                        }), e.parser = (e => {
                            const t = xy(kE(e), e.schema);
                            return t.addAttributeFilter("src,href,style,tabindex", ((t, o) => {
                                const n = e.dom,
                                    r = "data-mce-" + o;
                                let s = t.length;
                                for (; s--;) {
                                    const a = t[s];
                                    let i = a.attr(o);
                                    if (i && !a.attr(r)) {
                                        if (0 === i.indexOf("data:") || 0 === i.indexOf("blob:")) continue;
                                        "style" === o ? (i = n.serializeStyle(n.parseStyle(i), a.name), i.length || (i = null), a.attr(r, i), a.attr(o, i)) : "tabindex" === o ? (a.attr(r, i), a.attr(o, null)) : a.attr(r, e.convertURL(i, o, a.name))
                                    }
                                }
                            })), t.addNodeFilter("script", (e => {
                                let t = e.length;
                                for (; t--;) {
                                    const o = e[t],
                                        n = o.attr("type") || "no/type";
                                    0 !== n.indexOf("mce-") && o.attr("type", "mce-" + n)
                                }
                            })), Vc(e) && t.addNodeFilter("#cdata", (t => {
                                var o;
                                let n = t.length;
                                for (; n--;) {
                                    const r = t[n];
                                    r.type = 8, r.name = "#comment", r.value = "[CDATA[" + e.dom.encode(null !== (o = r.value) && void 0 !== o ? o : "") + "]]"
                                }
                            })), t.addNodeFilter("p,h1,h2,h3,h4,h5,h6,div", (t => {
                                let o = t.length;
                                const n = e.schema.getNonEmptyElements();
                                for (; o--;) {
                                    const e = t[o];
                                    e.isEmpty(n) && 0 === e.getAll("br").length && e.append(new fh("br", 1))
                                }
                            })), t
                        })(e), e.serializer = uw((e => {
                            const t = e.options.get;
                            return { ...kE(e),
                                ..._E(e),
                                ...SE({
                                    url_converter: t("url_converter"),
                                    url_converter_scope: t("url_converter_scope"),
                                    element_format: t("element_format"),
                                    entities: t("entities"),
                                    entity_encoding: t("entity_encoding"),
                                    indent: t("indent"),
                                    indent_after: t("indent_after"),
                                    indent_before: t("indent_before")
                                })
                            }
                        })(e), e), e.selection = lw(e.dom, e.getWin(), e.serializer, e), e.annotator = Om(e), e.formatter = tx(e), e.undoManager = nx(e), e._nodeChangeDispatcher = new IO(e), e._selectionOverrides = KT(e), (e => {
                            const t = Ea(),
                                o = xa(!1),
                                n = Ma((t => {
                                    e.dispatch("longpress", { ...t,
                                        type: "longpress"
                                    }), o.set(!0)
                                }), 400);
                            e.on("touchstart", (e => {
                                wS(e).each((r => {
                                    n.cancel();
                                    const s = {
                                        x: r.clientX,
                                        y: r.clientY,
                                        target: e.target
                                    };
                                    n.throttle(e), o.set(!1), t.set(s)
                                }))
                            }), !0), e.on("touchmove", (r => {
                                n.cancel(), wS(r).each((n => {
                                    t.on((r => {
                                        ((e, t) => {
                                            const o = Math.abs(e.clientX - t.x),
                                                n = Math.abs(e.clientY - t.y);
                                            return o > 5 || n > 5
                                        })(n, r) && (t.clear(), o.set(!1), e.dispatch("longpresscancel"))
                                    }))
                                }))
                            }), !0), e.on("touchend touchcancel", (r => {
                                n.cancel(), "touchcancel" !== r.type && t.get().filter((e => e.target.isEqualNode(r.target))).each((() => {
                                    o.get() ? r.preventDefault() : e.dispatch("tap", { ...r,
                                        type: "tap"
                                    })
                                }))
                            }), !0)
                        })(e), (e => {
                            (e => {
                                e.on("click", (t => {
                                    e.dom.getParent(t.target, "details") && t.preventDefault()
                                }))
                            })(e), (e => {
                                e.parser.addNodeFilter("details", (e => {
                                    W(e, (e => {
                                        e.attr("data-mce-open", e.attr("open")), e.attr("open", "open")
                                    }))
                                })), e.serializer.addNodeFilter("details", (e => {
                                    W(e, (e => {
                                        const t = e.attr("data-mce-open");
                                        e.attr("open", g(t) ? t : null), e.attr("data-mce-open", null)
                                    }))
                                }))
                            })(e)
                        })(e), (e => {
                            const t = "contenteditable",
                                o = " " + Rt.trim(zc(e)) + " ",
                                n = " " + Rt.trim(Pc(e)) + " ",
                                r = TS(o),
                                s = TS(n),
                                a = Fc(e);
                            a.length > 0 && e.on("BeforeSetContent", (t => {
                                ((e, t, o) => {
                                    let n = t.length,
                                        r = o.content;
                                    if ("raw" !== o.format) {
                                        for (; n--;) r = r.replace(t[n], ES(e, r, Pc(e)));
                                        o.content = r
                                    }
                                })(e, a, t)
                            })), e.parser.addAttributeFilter("class", (e => {
                                let o = e.length;
                                for (; o--;) {
                                    const n = e[o];
                                    r(n) ? n.attr(t, "true") : s(n) && n.attr(t, "false")
                                }
                            })), e.serializer.addAttributeFilter(t, (e => {
                                let o = e.length;
                                for (; o--;) {
                                    const n = e[o];
                                    (r(n) || s(n)) && (a.length > 0 && n.attr("data-mce-content") ? (n.name = "#text", n.type = 3, n.raw = !0, n.value = n.attr("data-mce-content")) : n.attr(t, null))
                                }
                            }))
                        })(e), ew(e) || ((e => {
                            e.on("mousedown", (t => {
                                t.detail >= 3 && (t.preventDefault(), OT(e))
                            }))
                        })(e), (e => {
                            (e => {
                                const t = [",", ".", ";", ":", "!", "?"],
                                    o = [32],
                                    n = () => {
                                        return t = Hc(e), o = Ic(e), {
                                            inlinePatterns: Qi(t),
                                            blockPatterns: Ji(t),
                                            dynamicPatternsLookup: o
                                        };
                                        var t, o
                                    },
                                    r = () => (e => e.options.isSet("text_patterns_lookup"))(e);
                                e.on("keydown", (t => {
                                    if (13 === t.keyCode && !Lm.modifierPressed(t) && e.selection.isCollapsed()) {
                                        const o = n();
                                        (o.inlinePatterns.length > 0 || o.blockPatterns.length > 0 || r()) && bE(e, o) && t.preventDefault()
                                    }
                                }), !0);
                                const s = () => {
                                    if (e.selection.isCollapsed()) {
                                        const t = n();
                                        (t.inlinePatterns.length > 0 || r()) && ((e, t) => {
                                            const o = e.selection.getRng();
                                            nE(e, o).map((n => {
                                                const r = Math.max(0, o.startOffset - 1),
                                                    s = sE(e.dom, n, o.startContainer, r),
                                                    a = rE(t, n, s),
                                                    i = fE(e, n, o.startContainer, r, a, !1);
                                                i.length > 0 && e.undoManager.transact((() => {
                                                    vE(e, i)
                                                }))
                                            }))
                                        })(e, t)
                                    }
                                };
                                e.on("keyup", (e => {
                                    yE(o, e, ((e, t) => e === t.keyCode && !Lm.modifierPressed(t))) && s()
                                })), e.on("keypress", (o => {
                                    yE(t, o, ((e, t) => e.charCodeAt(0) === t.charCode)) && $g.setEditorTimeout(e, s)
                                }))
                            })(e)
                        })(e));
                        const r = HO(e);
                        yS(e, r), (e => {
                            e.on("NodeChange", N(_S, e))
                        })(e), (e => {
                            var t;
                            const o = e.dom,
                                n = pl(e),
                                r = null !== (t = jl(e)) && void 0 !== t ? t : "",
                                s = (t, a) => {
                                    if ((e => {
                                            if (ax(e)) {
                                                const t = e.keyCode;
                                                return !ix(e) && (Lm.metaKeyPressed(e) || e.altKey || t >= 112 && t <= 123 || Z(rx, t))
                                            }
                                            return !1
                                        })(t)) return;
                                    const i = e.getBody(),
                                        l = !(e => ax(e) && !(ix(e) || "keyup" === e.type && 229 === e.keyCode))(t) && ((e, t, o) => {
                                            if (rs(go(t), !1)) {
                                                const n = t.firstElementChild;
                                                return !n || !e.getStyle(t.firstElementChild, "padding-left") && !e.getStyle(t.firstElementChild, "padding-right") && o === n.nodeName.toLowerCase()
                                            }
                                            return !1
                                        })(o, i, n);
                                    ("" !== o.getAttrib(i, sx) !== l || a) && (o.setAttrib(i, sx, l ? r : null), o.setAttrib(i, "aria-placeholder", l ? r : null), ((e, t) => {
                                        e.dispatch("PlaceholderToggle", {
                                            state: t
                                        })
                                    })(e, l), e.on(l ? "keydown" : "keyup", s), e.off(l ? "keyup" : "keydown", s))
                                };
                            qe(r) && e.on("init", (t => {
                                s(t, !0), e.on("change SetContent ExecCommand", s), e.on("paste", (t => $g.setEditorTimeout(e, (() => s(t)))))
                            }))
                        })(e), yT(e);
                        const s = (e => {
                            const t = e;
                            return (e => Ce(e.plugins, "rtc").bind((e => I.from(e.setup))))(e).fold((() => (t.rtcInstance = Qy(e), I.none())), (e => (t.rtcInstance = (() => {
                                const e = E(null),
                                    t = E("");
                                return {
                                    init: {
                                        bindEvents: _
                                    },
                                    undoManager: {
                                        beforeChange: _,
                                        add: e,
                                        undo: e,
                                        redo: e,
                                        clear: _,
                                        reset: _,
                                        hasUndo: L,
                                        hasRedo: L,
                                        transact: e,
                                        ignore: _,
                                        extra: _
                                    },
                                    formatter: {
                                        match: L,
                                        matchAll: E([]),
                                        matchNode: E(void 0),
                                        canApply: L,
                                        closest: t,
                                        apply: _,
                                        remove: _,
                                        toggle: _,
                                        formatChanged: E({
                                            unbind: _
                                        })
                                    },
                                    editor: {
                                        getContent: t,
                                        setContent: E({
                                            content: "",
                                            html: ""
                                        }),
                                        insertContent: E(""),
                                        addVisual: _
                                    },
                                    selection: {
                                        getContent: t
                                    },
                                    autocompleter: {
                                        addDecoration: _,
                                        removeDecoration: _
                                    },
                                    raw: {
                                        getModel: E(I.none())
                                    }
                                }
                            })(), I.some((() => e().then((e => (t.rtcInstance = (e => {
                                const t = e => h(e) ? e : {},
                                    {
                                        init: o,
                                        undoManager: n,
                                        formatter: r,
                                        editor: s,
                                        selection: a,
                                        autocompleter: i,
                                        raw: l
                                    } = e;
                                return {
                                    init: {
                                        bindEvents: o.bindEvents
                                    },
                                    undoManager: {
                                        beforeChange: n.beforeChange,
                                        add: n.add,
                                        undo: n.undo,
                                        redo: n.redo,
                                        clear: n.clear,
                                        reset: n.reset,
                                        hasUndo: n.hasUndo,
                                        hasRedo: n.hasRedo,
                                        transact: (e, t, o) => n.transact(o),
                                        ignore: (e, t) => n.ignore(t),
                                        extra: (e, t, o, r) => n.extra(o, r)
                                    },
                                    formatter: {
                                        match: (e, o, n, s) => r.match(e, t(o), s),
                                        matchAll: r.matchAll,
                                        matchNode: r.matchNode,
                                        canApply: e => r.canApply(e),
                                        closest: e => r.closest(e),
                                        apply: (e, o, n) => r.apply(e, t(o)),
                                        remove: (e, o, n, s) => r.remove(e, t(o)),
                                        toggle: (e, o, n) => r.toggle(e, t(o)),
                                        formatChanged: (e, t, o, n, s) => r.formatChanged(t, o, n, s)
                                    },
                                    editor: {
                                        getContent: e => s.getContent(e),
                                        setContent: (e, t) => ({
                                            content: s.setContent(e, t),
                                            html: ""
                                        }),
                                        insertContent: (e, t) => (s.insertContent(e), ""),
                                        addVisual: s.addVisual
                                    },
                                    selection: {
                                        getContent: (e, t) => a.getContent(t)
                                    },
                                    autocompleter: {
                                        addDecoration: i.addDecoration,
                                        removeDecoration: i.removeDecoration
                                    },
                                    raw: {
                                        getModel: () => I.some(l.getRawModel())
                                    }
                                }
                            })(e), e.rtc.isRemote))))))))
                        })(e);
                        (e => {
                            const t = e.getDoc(),
                                o = e.getBody();
                            (e => {
                                e.dispatch("PreInit")
                            })(e), Sc(e) || (t.body.spellcheck = !1, xE.setAttrib(o, "spellcheck", "false")), e.quirks = wE(e), (e => {
                                e.dispatch("PostRender")
                            })(e);
                            const n = Fl(e);
                            void 0 !== n && (o.dir = n);
                            const r = kc(e);
                            r && e.on("BeforeSetContent", (e => {
                                Rt.each(r, (t => {
                                    e.content = e.content.replace(t, (e => "\x3c!--mce:protected " + escape(e) + "--\x3e"))
                                }))
                            })), e.on("SetContent", (() => {
                                e.addVisual(e.getBody())
                            })), e.on("compositionstart compositionend", (t => {
                                e.composing = "compositionstart" === t.type
                            }))
                        })(e), s.fold((() => {
                            TE(e).then((() => EE(e)))
                        }), (t => {
                            e.setProgressState(!0), TE(e).then((() => {
                                t().then((t => {
                                    e.setProgressState(!1), EE(e), nw(e)
                                }), (t => {
                                    e.notificationManager.open({
                                        type: "error",
                                        text: String(t)
                                    }), EE(e), nw(e)
                                }))
                            }))
                        }))
                    },
                    ME = (e, t) => {
                        if (e.inline || (e.getElement().style.visibility = e.orgVisibility), t || e.inline) AE(e);
                        else {
                            const t = e.iframeElement,
                                n = (o = go(t), dn(o, "load", Iw, (() => {
                                    n.unbind(), e.contentDocument = t.contentDocument, AE(e)
                                })));
                            if (Et.browser.isFirefox()) {
                                const t = e.getDoc();
                                t.open(), t.write(e.iframeHTML), t.close()
                            } else t.srcdoc = e.iframeHTML
                        }
                        var o
                    },
                    NE = ba.DOM,
                    RE = ba.DOM,
                    DE = (e, t) => ({
                        editorContainer: e,
                        iframeContainer: t,
                        api: {}
                    }),
                    BE = e => {
                        const t = e.getElement();
                        return e.inline ? DE(null) : (e => {
                            const t = RE.create("div");
                            return RE.insertAfter(t, e), DE(t, t)
                        })(t)
                    },
                    LE = e => {
                        e.dispatch("ScriptsLoaded"), (e => {
                            const t = Rt.trim(_l(e)),
                                o = e.ui.registry.getAll().icons,
                                n = { ...yw.get("default").icons,
                                    ...yw.get(t).icons
                                };
                            he(n, ((t, n) => {
                                Se(o, n) || e.ui.registry.addIcon(n, t)
                            }))
                        })(e), (e => {
                            const t = ql(e);
                            if (g(t)) {
                                const o = Aw.get(t);
                                e.theme = o(e, Aw.urls[t]) || {}, C(e.theme.init) && e.theme.init(e, Aw.urls[t] || e.documentBaseUrl.replace(/\/$/, ""))
                            } else e.theme = {}
                        })(e), (e => {
                            const t = Kl(e),
                                o = ww.get(t);
                            e.model = o(e, ww.urls[t])
                        })(e), (e => {
                            const t = [];
                            W(mc(e), (o => {
                                ((e, t, o) => {
                                    const n = Ew.get(o),
                                        r = Ew.urls[o] || e.documentBaseUrl.replace(/\/$/, "");
                                    if (o = Rt.trim(o), n && -1 === Rt.inArray(t, o)) {
                                        if (e.plugins[o]) return;
                                        try {
                                            const s = n(e, r) || {};
                                            e.plugins[o] = s, C(s.init) && (s.init(e, r), t.push(o))
                                        } catch (t) {
                                            ((e, t, o) => {
                                                const n = _a.translate(["Failed to initialize plugin: {0}", t]);
                                                Am(e, "PluginLoadError", {
                                                    message: n
                                                }), Lw(n, o), Rw(e, n)
                                            })(e, o, t)
                                        }
                                    }
                                })(e, t, (e => e.replace(/^\-/, ""))(o))
                            }))
                        })(e);
                        const t = (e => {
                            const t = e.getElement();
                            return e.orgDisplay = t.style.display, g(ql(e)) ? (e => {
                                const t = e.theme.renderUI;
                                return t ? t() : BE(e)
                            })(e) : C(ql(e)) ? (e => {
                                const t = e.getElement(),
                                    o = ql(e)(e, t);
                                return o.editorContainer.nodeType && (o.editorContainer.id = o.editorContainer.id || e.id + "_parent"), o.iframeContainer && o.iframeContainer.nodeType && (o.iframeContainer.id = o.iframeContainer.id || e.id + "_iframecontainer"), o.height = o.iframeHeight ? o.iframeHeight : t.offsetHeight, o
                            })(e) : BE(e)
                        })(e);
                        ((e, t) => {
                            const o = {
                                show: I.from(t.show).getOr(_),
                                hide: I.from(t.hide).getOr(_),
                                isEnabled: I.from(t.isEnabled).getOr(H),
                                setEnabled: o => {
                                    e.mode.isReadOnly() || I.from(t.setEnabled).each((e => e(o)))
                                }
                            };
                            e.ui = { ...e.ui,
                                ...o
                            }
                        })(e, I.from(t.api).getOr({})), e.editorContainer = t.editorContainer, (e => {
                            e.contentCSS = e.contentCSS.concat((e => Hw(e, Il(e)))(e), (e => Hw(e, zl(e)))(e))
                        })(e), e.inline ? ME(e) : ((e, t) => {
                            ((e, t) => {
                                const o = e.translate("Rich Text Area"),
                                    n = Gt(go(e.getElement()), "tabindex").bind(Ke),
                                    r = ((e, t, o, n) => {
                                        const r = uo("iframe");
                                        return n.each((e => Wt(r, "tabindex", e))), $t(r, o), $t(r, {
                                            id: e + "_ifr",
                                            frameBorder: "0",
                                            allowTransparency: "true",
                                            title: t
                                        }), no(r, "tox-edit-area__iframe"), r
                                    })(e.id, o, ll(e), n).dom;
                                r.onload = () => {
                                    r.onload = null, e.dispatch("load")
                                }, e.contentAreaContainer = t.iframeContainer, e.iframeElement = r, e.iframeHTML = (e => {
                                    let t = cl(e) + "<html><head>";
                                    dl(e) !== e.documentBaseUrl && (t += '<base href="' + e.documentBaseURI.getURI() + '" />'), t += '<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />';
                                    const o = ul(e),
                                        n = ml(e),
                                        r = e.translate(bc(e));
                                    return gl(e) && (t += '<meta http-equiv="Content-Security-Policy" content="' + gl(e) + '" />'), t += `</head><body id="${o}" class="mce-content-body ${n}" data-id="${e.id}" aria-label="${r}"><br></body></html>`, t
                                })(e), NE.add(t.iframeContainer, r)
                            })(e, t), t.editorContainer && (t.editorContainer.style.display = e.orgDisplay, e.hidden = NE.isHidden(t.editorContainer)), e.getElement().style.display = "none", NE.setAttrib(e.id, "aria-hidden", "true"), ME(e)
                        })(e, {
                            editorContainer: t.editorContainer,
                            iframeContainer: t.iframeContainer
                        })
                    },
                    HE = ba.DOM,
                    IE = e => "-" === e.charAt(0),
                    PE = (e, t, o) => I.from(t).filter((e => qe(e) && !yw.has(e))).map((t => ({
                        url: `${e.editorManager.baseURL}/icons/${t}/icons${o}.js`,
                        name: I.some(t)
                    }))),
                    zE = (e, t) => {
                        const o = wa.ScriptLoader,
                            n = () => {
                                !e.removed && (e => {
                                    const t = ql(e);
                                    return !g(t) || x(Aw.get(t))
                                })(e) && (e => {
                                    const t = Kl(e);
                                    return x(ww.get(t))
                                })(e) && LE(e)
                            };
                        ((e, t) => {
                            const o = ql(e);
                            if (g(o) && !IE(o) && !Se(Aw.urls, o)) {
                                const n = Gl(e),
                                    r = n ? e.documentBaseURI.toAbsolute(n) : `themes/${o}/theme${t}.js`;
                                Aw.load(o, r).catch((() => {
                                    ((e, t, o) => {
                                        Dw(e, "ThemeLoadError", Bw("theme", t, o))
                                    })(e, r, o)
                                }))
                            }
                        })(e, t), ((e, t) => {
                            const o = Kl(e);
                            if ("plugin" !== o && !Se(ww.urls, o)) {
                                const n = Yl(e),
                                    r = g(n) ? e.documentBaseURI.toAbsolute(n) : `models/${o}/model${t}.js`;
                                ww.load(o, r).catch((() => {
                                    ((e, t, o) => {
                                        Dw(e, "ModelLoadError", Bw("model", t, o))
                                    })(e, r, o)
                                }))
                            }
                        })(e, t), ((e, t) => {
                            const o = Dl(t),
                                n = Bl(t);
                            if (!_a.hasCode(o) && "en" !== o) {
                                const r = qe(n) ? n : `${t.editorManager.baseURL}/langs/${o}.js`;
                                e.add(r).catch((() => {
                                    ((e, t, o) => {
                                        Dw(e, "LanguageLoadError", Bw("language", t, o))
                                    })(t, r, o)
                                }))
                            }
                        })(o, e), ((e, t, o) => {
                            const n = PE(t, "default", o),
                                r = (e => I.from(Ol(e)).filter(qe).map((e => ({
                                    url: e,
                                    name: I.none()
                                }))))(t).orThunk((() => PE(t, _l(t), "")));
                            W((e => {
                                const t = [],
                                    o = e => {
                                        t.push(e)
                                    };
                                for (let t = 0; t < e.length; t++) e[t].each(o);
                                return t
                            })([n, r]), (o => {
                                e.add(o.url).catch((() => {
                                    ((e, t, o) => {
                                        Dw(e, "IconsLoadError", Bw("icons", t, o))
                                    })(t, o.url, o.name.getOrUndefined())
                                }))
                            }))
                        })(o, e, t), ((e, t) => {
                            const o = (t, o) => {
                                Ew.load(t, o).catch((() => {
                                    ((e, t, o) => {
                                        Dw(e, "PluginLoadError", Bw("plugin", t, o))
                                    })(e, o, t)
                                }))
                            };
                            he(gc(e), ((t, n) => {
                                o(n, t), e.options.set("plugins", mc(e).concat(n))
                            })), W(mc(e), (e => {
                                !(e = Rt.trim(e)) || Ew.urls[e] || IE(e) || o(e, `plugins/${e}/plugin${t}.js`)
                            }))
                        })(e, t), o.loadQueue().then(n, n)
                    },
                    FE = xt().deviceType,
                    VE = FE.isPhone(),
                    ZE = FE.isTablet(),
                    UE = e => {
                        if (w(e)) return []; {
                            const t = f(e) ? e : e.split(/[ ,]/),
                                o = j(t, je);
                            return G(o, qe)
                        }
                    },
                    jE = (e, t) => {
                        const o = ((t, o) => {
                            const n = {},
                                r = {};
                            return be(t, ((t, o) => Z(e, o)), ve(n), ve(r)), {
                                t: n,
                                f: r
                            }
                        })(t);
                        return n = o.t, r = o.f, {
                            sections: E(n),
                            options: E(r)
                        };
                        var n, r
                    },
                    WE = (e, t) => Se(e.sections(), t),
                    $E = (e, t) => ({
                        table_grid: !1,
                        object_resizing: !1,
                        resize: !1,
                        toolbar_mode: Ce(e, "toolbar_mode").getOr("scrolling"),
                        toolbar_sticky: !1,
                        ...t ? {
                            menubar: !1
                        } : {}
                    }),
                    qE = (e, t) => {
                        var o;
                        const n = null !== (o = t.external_plugins) && void 0 !== o ? o : {};
                        return e && e.external_plugins ? Rt.extend({}, e.external_plugins, n) : n
                    },
                    GE = (e, t, o, n, r) => {
                        var s;
                        const a = e ? {
                                mobile: $E(null !== (s = r.mobile) && void 0 !== s ? s : {}, t)
                            } : {},
                            i = jE(["mobile"], Vk(a, r)),
                            l = Rt.extend(o, n, i.options(), ((e, t) => e && WE(t, "mobile"))(e, i) ? ((e, t, o = {}) => {
                                const n = e.sections(),
                                    r = Ce(n, t).getOr({});
                                return Rt.extend({}, o, r)
                            })(i, "mobile") : {}, {
                                external_plugins: qE(n, i.options())
                            });
                        return ((e, t, o, n) => {
                            const r = UE(o.forced_plugins),
                                s = UE(n.plugins),
                                a = ((e, t) => WE(e, t) ? e.sections()[t] : {})(t, "mobile"),
                                i = ((e, t, o, n) => e && WE(t, "mobile") ? n : o)(e, t, s, a.plugins ? UE(a.plugins) : s),
                                l = ((e, t) => [...UE(e), ...UE(t)])(r, i);
                            return Rt.extend(n, {
                                forced_plugins: r,
                                plugins: l
                            })
                        })(e, i, n, l)
                    },
                    KE = e => {
                        (e => {
                            const t = t => () => {
                                W("left,center,right,justify".split(","), (o => {
                                    t !== o && e.formatter.remove("align" + o)
                                })), "none" !== t && ((t, o) => {
                                    e.formatter.toggle(t, void 0), e.nodeChanged()
                                })("align" + t)
                            };
                            e.editorCommands.addCommands({
                                JustifyLeft: t("left"),
                                JustifyCenter: t("center"),
                                JustifyRight: t("right"),
                                JustifyFull: t("justify"),
                                JustifyNone: t("none")
                            })
                        })(e), (e => {
                            const t = t => () => {
                                const o = e.selection,
                                    n = o.isCollapsed() ? [e.dom.getParent(o.getNode(), e.dom.isBlock)] : o.getSelectedBlocks();
                                return U(n, (o => x(e.formatter.matchNode(o, t))))
                            };
                            e.editorCommands.addCommands({
                                JustifyLeft: t("alignleft"),
                                JustifyCenter: t("aligncenter"),
                                JustifyRight: t("alignright"),
                                JustifyFull: t("alignjustify")
                            }, "state")
                        })(e)
                    },
                    YE = (e, t) => {
                        const o = e.selection,
                            n = e.dom;
                        return /^ | $/.test(t) ? ((e, t, o) => {
                            const n = go(e.getRoot());
                            return o = hp(n, Si.fromRangeStart(t)) ? o.replace(/^ /, "&nbsp;") : o.replace(/^&nbsp;/, " "), pp(n, Si.fromRangeEnd(t)) ? o.replace(/(&nbsp;| )(<br( \/)>)?$/, "&nbsp;") : o.replace(/&nbsp;(<br( \/)?>)?$/, " ")
                        })(n, o.getRng(), t) : t
                    },
                    XE = (e, t) => {
                        const {
                            content: o,
                            details: n
                        } = (e => {
                            if ("string" != typeof e) {
                                const t = Rt.extend({
                                    paste: e.paste,
                                    data: {
                                        paste: e.paste
                                    }
                                }, e);
                                return {
                                    content: e.content,
                                    details: t
                                }
                            }
                            return {
                                content: e,
                                details: {}
                            }
                        })(t);
                        _y(e, { ...n,
                            content: YE(e, o),
                            format: "html",
                            set: !1,
                            selection: !0
                        }).each((t => {
                            const o = ((e, t, o) => tw(e).editor.insertContent(t, o))(e, t.content, n);
                            Oy(e, o, t), e.addVisual()
                        }))
                    },
                    JE = {
                        "font-size": "size",
                        "font-family": "face"
                    },
                    QE = Ut("font"),
                    eA = e => (t, o) => I.from(o).map(go).filter(zt).bind((o => ((e, t, o) => Wf(go(o), (t => (t => Ko(t, e).orThunk((() => QE(t) ? Ce(JE, e).bind((e => Gt(t, e))) : I.none())))(t)), (e => bo(go(t), e))))(e, t, o.dom).or(((e, t) => I.from(ba.DOM.getStyle(t, e, !0)))(e, o.dom)))).getOr(""),
                    tA = eA("font-size"),
                    oA = O((e => e.replace(/[\'\"\\]/g, "").replace(/,\s+/g, ",")), eA("font-family")),
                    nA = e => eu(e.getBody()).bind((e => {
                        const t = e.container();
                        return I.from(Vn(t) ? t.parentNode : t)
                    })),
                    rA = (e, t) => ((e, t) => (e => I.from(e.selection.getRng()).bind((t => {
                        const o = e.getBody();
                        return t.startContainer === o && 0 === t.startOffset ? I.none() : I.from(e.selection.getStart(!0))
                    })))(e).orThunk(N(nA, e)).map(go).filter(zt).bind(t))(e, T(I.some, t)),
                    sA = (e, t) => {
                        if (/^[0-9.]+$/.test(t)) {
                            const o = parseInt(t, 10);
                            if (o >= 1 && o <= 7) {
                                const n = (e => Rt.explode(e.options.get("font_size_style_values")))(e),
                                    r = (e => Rt.explode(e.options.get("font_size_classes")))(e);
                                return r.length > 0 ? r[o - 1] || t : n[o - 1] || t
                            }
                            return t
                        }
                        return t
                    },
                    aA = e => {
                        const t = e.split(/\s*,\s*/);
                        return j(t, (e => -1 === e.indexOf(" ") || Ve(e, '"') || Ve(e, "'") ? e : `'${e}'`)).join(",")
                    },
                    iA = e => {
                        KE(e), (e => {
                            e.editorCommands.addCommands({
                                "Cut,Copy,Paste": t => {
                                    const o = e.getDoc();
                                    let n;
                                    try {
                                        o.execCommand(t)
                                    } catch (e) {
                                        n = !0
                                    }
                                    if ("paste" !== t || o.queryCommandEnabled(t) || (n = !0), n || !o.queryCommandSupported(t)) {
                                        let t = e.translate("Your browser doesn't support direct access to the clipboard. Please use the Ctrl+X/C/V keyboard shortcuts instead.");
                                        (Et.os.isMacOS() || Et.os.isiOS()) && (t = t.replace(/Ctrl\+/g, "+")), e.notificationManager.open({
                                            text: t,
                                            type: "error"
                                        })
                                    }
                                }
                            })
                        })(e), (e => {
                            e.editorCommands.addCommands({
                                mceAddUndoLevel: () => {
                                    e.undoManager.add()
                                },
                                mceEndUndoLevel: () => {
                                    e.undoManager.add()
                                },
                                Undo: () => {
                                    e.undoManager.undo()
                                },
                                Redo: () => {
                                    e.undoManager.redo()
                                }
                            })
                        })(e), (e => {
                            e.editorCommands.addCommands({
                                mceSelectNodeDepth: (t, o, n) => {
                                    let r = 0;
                                    e.dom.getParent(e.selection.getNode(), (t => !Rn(t) || r++ !== n || (e.selection.select(t), !1)), e.getBody())
                                },
                                mceSelectNode: (t, o, n) => {
                                    e.selection.select(n)
                                },
                                selectAll: () => {
                                    const t = e.dom.getParent(e.selection.getStart(), Kn);
                                    if (t) {
                                        const o = e.dom.createRng();
                                        o.selectNodeContents(t), e.selection.setRng(o)
                                    }
                                }
                            })
                        })(e), (e => {
                            e.editorCommands.addCommands({
                                mceCleanup: () => {
                                    const t = e.selection.getBookmark();
                                    e.setContent(e.getContent()), e.selection.moveToBookmark(t)
                                },
                                insertImage: (t, o, n) => {
                                    XE(e, e.dom.createHTML("img", {
                                        src: n
                                    }))
                                },
                                insertHorizontalRule: () => {
                                    e.execCommand("mceInsertContent", !1, "<hr>")
                                },
                                insertText: (t, o, n) => {
                                    XE(e, e.dom.encode(n))
                                },
                                insertHTML: (t, o, n) => {
                                    XE(e, n)
                                },
                                mceInsertContent: (t, o, n) => {
                                    XE(e, n)
                                },
                                mceSetContent: (t, o, n) => {
                                    e.setContent(n)
                                },
                                mceReplaceContent: (t, o, n) => {
                                    e.execCommand("mceInsertContent", !1, n.replace(/\{\$selection\}/g, e.selection.getContent({
                                        format: "text"
                                    })))
                                },
                                mceNewDocument: () => {
                                    e.setContent("")
                                }
                            })
                        })(e), (e => {
                            const t = (t, o, n) => {
                                const r = g(n) ? {
                                        href: n
                                    } : n,
                                    s = e.dom.getParent(e.selection.getNode(), "a");
                                h(r) && g(r.href) && (r.href = r.href.replace(/ /g, "%20"), s && r.href || e.formatter.remove("link"), r.href && e.formatter.apply("link", r, s))
                            };
                            e.editorCommands.addCommands({
                                unlink: () => {
                                    if (e.selection.isCollapsed()) {
                                        const t = e.dom.getParent(e.selection.getStart(), "a");
                                        t && e.dom.remove(t, !0)
                                    } else e.formatter.remove("link")
                                },
                                mceInsertLink: t,
                                createLink: t
                            })
                        })(e), (e => {
                            e.editorCommands.addCommands({
                                Indent: () => {
                                    (e => {
                                        pS(e, "indent")
                                    })(e)
                                },
                                Outdent: () => {
                                    fS(e)
                                }
                            }), e.editorCommands.addCommands({
                                Outdent: () => mS(e)
                            }, "state")
                        })(e), (e => {
                            e.editorCommands.addCommands({
                                insertParagraph: () => {
                                    kO(nO, e)
                                },
                                mceInsertNewLine: (t, o, n) => {
                                    _O(e, n)
                                },
                                InsertLineBreak: (t, o, n) => {
                                    kO(uO, e)
                                }
                            })
                        })(e), (e => {
                            (e => {
                                e.editorCommands.addCommands({
                                    "InsertUnorderedList,InsertOrderedList": t => {
                                        e.getDoc().execCommand(t);
                                        const o = e.dom.getParent(e.selection.getNode(), "ol,ul");
                                        if (o) {
                                            const t = o.parentNode;
                                            if (t && /^(H[1-6]|P|ADDRESS|PRE)$/.test(t.nodeName)) {
                                                const n = e.selection.getBookmark();
                                                e.dom.split(t, o), e.selection.moveToBookmark(n)
                                            }
                                        }
                                    }
                                })
                            })(e), (e => {
                                e.editorCommands.addCommands({
                                    "InsertUnorderedList,InsertOrderedList": t => {
                                        const o = e.dom.getParent(e.selection.getNode(), "ul,ol");
                                        return o && ("insertunorderedlist" === t && "UL" === o.tagName || "insertorderedlist" === t && "OL" === o.tagName)
                                    }
                                }, "state")
                            })(e)
                        })(e), (e => {
                            (e => {
                                const t = (t, o) => {
                                    e.formatter.toggle(t, o), e.nodeChanged()
                                };
                                e.editorCommands.addCommands({
                                    "Bold,Italic,Underline,Strikethrough,Superscript,Subscript": e => {
                                        t(e)
                                    },
                                    "ForeColor,HiliteColor": (e, o, n) => {
                                        t(e, {
                                            value: n
                                        })
                                    },
                                    BackColor: (e, o, n) => {
                                        t("hilitecolor", {
                                            value: n
                                        })
                                    },
                                    FontName: (t, o, n) => {
                                        ((e, t) => {
                                            const o = sA(e, t);
                                            e.formatter.toggle("fontname", {
                                                value: aA(o)
                                            }), e.nodeChanged()
                                        })(e, n)
                                    },
                                    FontSize: (t, o, n) => {
                                        ((e, t) => {
                                            e.formatter.toggle("fontsize", {
                                                value: sA(e, t)
                                            }), e.nodeChanged()
                                        })(e, n)
                                    },
                                    LineHeight: (t, o, n) => {
                                        ((e, t) => {
                                            e.formatter.toggle("lineheight", {
                                                value: String(t)
                                            }), e.nodeChanged()
                                        })(e, n)
                                    },
                                    Lang: (e, o, n) => {
                                        var r;
                                        t(e, {
                                            value: n.code,
                                            customValue: null !== (r = n.customCode) && void 0 !== r ? r : null
                                        })
                                    },
                                    RemoveFormat: t => {
                                        e.formatter.remove(t)
                                    },
                                    mceBlockQuote: () => {
                                        t("blockquote")
                                    },
                                    FormatBlock: (e, o, n) => {
                                        t(g(n) ? n : "p")
                                    },
                                    mceToggleFormat: (e, o, n) => {
                                        t(n)
                                    }
                                })
                            })(e), (e => {
                                const t = t => e.formatter.match(t);
                                e.editorCommands.addCommands({
                                    "Bold,Italic,Underline,Strikethrough,Superscript,Subscript": e => t(e),
                                    mceBlockQuote: () => t("blockquote")
                                }, "state"), e.editorCommands.addQueryValueHandler("FontName", (() => (e => rA(e, (t => oA(e.getBody(), t.dom))).getOr(""))(e))), e.editorCommands.addQueryValueHandler("FontSize", (() => (e => rA(e, (t => tA(e.getBody(), t.dom))).getOr(""))(e))), e.editorCommands.addQueryValueHandler("LineHeight", (() => (e => rA(e, (t => {
                                    const o = go(e.getBody()),
                                        n = Wf(t, (e => Ko(e, "line-height")), N(bo, o));
                                    return n.getOrThunk((() => {
                                        const e = parseFloat(qo(t, "line-height")),
                                            o = parseFloat(qo(t, "font-size"));
                                        return String(e / o)
                                    }))
                                })).getOr(""))(e)))
                            })(e)
                        })(e), (e => {
                            e.editorCommands.addCommands({
                                mceRemoveNode: (t, o, n) => {
                                    const r = null != n ? n : e.selection.getNode();
                                    if (r !== e.getBody()) {
                                        const t = e.selection.getBookmark();
                                        e.dom.remove(r, !0), e.selection.moveToBookmark(t)
                                    }
                                },
                                mcePrint: () => {
                                    e.getWin().print()
                                },
                                mceFocus: (t, o, n) => {
                                    ((e, t) => {
                                        e.removed || (t ? th(e) : (e => {
                                            const t = e.selection,
                                                o = e.getBody();
                                            let n = t.getRng();
                                            e.quirks.refreshContentEditable(), x(e.bookmark) && !eh(e) && jg(e).each((t => {
                                                e.selection.setRng(t), n = t
                                            }));
                                            const r = ((e, t) => e.dom.getParent(t, (t => "true" === e.dom.getContentEditable(t))))(e, t.getNode());
                                            if (r && e.dom.isChildOf(r, o)) return Qg(r), Jg(e, n), void th(e);
                                            e.inline || (Et.browser.isOpera() || Qg(o), e.getWin().focus()), (Et.browser.isFirefox() || e.inline) && (Qg(o), Jg(e, n)), th(e)
                                        })(e))
                                    })(e, !0 === n)
                                },
                                mceToggleVisualAid: () => {
                                    e.hasVisual = !e.hasVisual, e.addVisual()
                                }
                            })
                        })(e)
                    },
                    lA = ["toggleview"],
                    cA = e => Z(lA, e.toLowerCase());
                class dA {
                    constructor(e) {
                        this.commands = {
                            state: {},
                            exec: {},
                            value: {}
                        }, this.editor = e
                    }
                    execCommand(e, t = !1, o, n) {
                        const r = this.editor,
                            s = e.toLowerCase(),
                            a = null == n ? void 0 : n.skip_focus;
                        if (r.removed) return !1;
                        if ("mcefocus" !== s && (/^(mceAddUndoLevel|mceEndUndoLevel)$/i.test(s) || a ? (e => {
                                jg(e).each((t => e.selection.setRng(t)))
                            })(r) : r.focus()), r.dispatch("BeforeExecCommand", {
                                command: e,
                                ui: t,
                                value: o
                            }).isDefaultPrevented()) return !1;
                        const i = this.commands.exec[s];
                        return !!C(i) && (i(s, t, o), r.dispatch("ExecCommand", {
                            command: e,
                            ui: t,
                            value: o
                        }), !0)
                    }
                    queryCommandState(e) {
                        if (!cA(e) && this.editor.quirks.isHidden() || this.editor.removed) return !1;
                        const t = e.toLowerCase(),
                            o = this.commands.state[t];
                        return !!C(o) && o(t)
                    }
                    queryCommandValue(e) {
                        if (!cA(e) && this.editor.quirks.isHidden() || this.editor.removed) return "";
                        const t = e.toLowerCase(),
                            o = this.commands.value[t];
                        return C(o) ? o(t) : ""
                    }
                    addCommands(e, t = "exec") {
                        const o = this.commands;
                        he(e, ((e, n) => {
                            W(n.toLowerCase().split(","), (n => {
                                o[t][n] = e
                            }))
                        }))
                    }
                    addCommand(e, t, o) {
                        const n = e.toLowerCase();
                        this.commands.exec[n] = (e, n, r) => t.call(null != o ? o : this.editor, n, r)
                    }
                    queryCommandSupported(e) {
                        const t = e.toLowerCase();
                        return !!this.commands.exec[t]
                    }
                    addQueryStateHandler(e, t, o) {
                        this.commands.state[e.toLowerCase()] = () => t.call(null != o ? o : this.editor)
                    }
                    addQueryValueHandler(e, t, o) {
                        this.commands.value[e.toLowerCase()] = () => t.call(null != o ? o : this.editor)
                    }
                }
                const uA = "data-mce-contenteditable",
                    mA = (e, t, o) => {
                        try {
                            e.getDoc().execCommand(t, !1, String(o))
                        } catch (e) {}
                    },
                    gA = (e, t) => {
                        e.dom.contentEditable = t ? "true" : "false"
                    },
                    hA = (e, t) => {
                        const o = go(e.getBody());
                        ((e, t, o) => {
                            ao(e, t) && !o ? so(e, t) : o && no(e, t)
                        })(o, "mce-content-readonly", t), t ? (e.selection.controlSelection.hideResizeRect(), e._selectionOverrides.hideFakeCaret(), (e => {
                            I.from(e.selection.getNode()).each((e => {
                                e.removeAttribute("data-mce-selected")
                            }))
                        })(e), e.readonly = !0, gA(o, !1), W(rr(o, '*[contenteditable="true"]'), (e => {
                            Wt(e, uA, "true"), gA(e, !1)
                        }))) : (e.readonly = !1, gA(o, !0), W(rr(o, `*[${uA}="true"]`), (e => {
                            Yt(e, uA), gA(e, !0)
                        })), mA(e, "StyleWithCSS", !1), mA(e, "enableInlineTableEditing", !1), mA(e, "enableObjectResizing", !1), (e => eh(e) || (e => {
                            const t = Po(go(e.getElement()));
                            return Hg(t).filter((t => !(e => {
                                const t = e.classList;
                                return void 0 !== t && (t.contains("tox-edit-area") || t.contains("tox-edit-area__iframe") || t.contains("mce-content-body"))
                            })(t.dom) && Kg(e, t.dom))).isSome()
                        })(e))(e) && e.focus(), (e => {
                            e.selection.setRng(e.selection.getRng())
                        })(e), e.nodeChanged())
                    },
                    pA = e => e.readonly,
                    fA = e => {
                        e.parser.addAttributeFilter("contenteditable", (t => {
                            pA(e) && W(t, (e => {
                                e.attr(uA, e.attr("contenteditable")), e.attr("contenteditable", "false")
                            }))
                        })), e.serializer.addAttributeFilter(uA, (t => {
                            pA(e) && W(t, (e => {
                                e.attr("contenteditable", e.attr(uA))
                            }))
                        })), e.serializer.addTempAttr(uA)
                    },
                    vA = ["copy"],
                    bA = Rt.makeMap("focus blur focusin focusout click dblclick mousedown mouseup mousemove mouseover beforepaste paste cut copy selectionchange mouseout mouseenter mouseleave wheel keydown keypress keyup input beforeinput contextmenu dragstart dragend dragover draggesture dragdrop drop drag submit compositionstart compositionend compositionupdate touchstart touchmove touchend touchcancel", " ");
                class yA {
                    constructor(e) {
                        this.bindings = {}, this.settings = e || {}, this.scope = this.settings.scope || this, this.toggleEvent = this.settings.toggleEvent || L
                    }
                    static isNative(e) {
                        return !!bA[e.toLowerCase()]
                    }
                    fire(e, t) {
                        return this.dispatch(e, t)
                    }
                    dispatch(e, t) {
                        const o = e.toLowerCase(),
                            n = oa(o, null != t ? t : {}, this.scope);
                        this.settings.beforeFire && this.settings.beforeFire(n);
                        const r = this.bindings[o];
                        if (r)
                            for (let e = 0, t = r.length; e < t; e++) {
                                const t = r[e];
                                if (!t.removed) {
                                    if (t.once && this.off(o, t.func), n.isImmediatePropagationStopped()) return n;
                                    if (!1 === t.func.call(this.scope, n)) return n.preventDefault(), n
                                }
                            }
                        return n
                    }
                    on(e, t, o, n) {
                        if (!1 === t && (t = L), t) {
                            const r = {
                                func: t,
                                removed: !1
                            };
                            n && Rt.extend(r, n);
                            const s = e.toLowerCase().split(" ");
                            let a = s.length;
                            for (; a--;) {
                                const e = s[a];
                                let t = this.bindings[e];
                                t || (t = [], this.toggleEvent(e, !0)), t = o ? [r, ...t] : [...t, r], this.bindings[e] = t
                            }
                        }
                        return this
                    }
                    off(e, t) {
                        if (e) {
                            const o = e.toLowerCase().split(" ");
                            let n = o.length;
                            for (; n--;) {
                                const r = o[n];
                                let s = this.bindings[r];
                                if (!r) return he(this.bindings, ((e, t) => {
                                    this.toggleEvent(t, !1), delete this.bindings[t]
                                })), this;
                                if (s) {
                                    if (t) {
                                        const e = q(s, (e => e.func === t));
                                        s = e.fail, this.bindings[r] = s, W(e.pass, (e => {
                                            e.removed = !0
                                        }))
                                    } else s.length = 0;
                                    s.length || (this.toggleEvent(e, !1), delete this.bindings[r])
                                }
                            }
                        } else he(this.bindings, ((e, t) => {
                            this.toggleEvent(t, !1)
                        })), this.bindings = {};
                        return this
                    }
                    once(e, t, o) {
                        return this.on(e, t, o, {
                            once: !0
                        })
                    }
                    has(e) {
                        e = e.toLowerCase();
                        const t = this.bindings[e];
                        return !(!t || 0 === t.length)
                    }
                }
                const wA = e => (e._eventDispatcher || (e._eventDispatcher = new yA({
                        scope: e,
                        toggleEvent: (t, o) => {
                            yA.isNative(t) && e.toggleNativeEvent && e.toggleNativeEvent(t, o)
                        }
                    })), e._eventDispatcher),
                    xA = {
                        fire(e, t, o) {
                            return this.dispatch(e, t, o)
                        },
                        dispatch(e, t, o) {
                            const n = this;
                            if (n.removed && "remove" !== e && "detach" !== e) return oa(e.toLowerCase(), null != t ? t : {}, n);
                            const r = wA(n).dispatch(e, t);
                            if (!1 !== o && n.parent) {
                                let t = n.parent();
                                for (; t && !r.isPropagationStopped();) t.dispatch(e, r, !1), t = t.parent ? t.parent() : void 0
                            }
                            return r
                        },
                        on(e, t, o) {
                            return wA(this).on(e, t, o)
                        },
                        off(e, t) {
                            return wA(this).off(e, t)
                        },
                        once(e, t) {
                            return wA(this).once(e, t)
                        },
                        hasEventListeners(e) {
                            return wA(this).has(e)
                        }
                    },
                    CA = ba.DOM;
                let SA;
                const kA = (e, t) => {
                        if ("selectionchange" === t) return e.getDoc();
                        if (!e.inline && /^mouse|touch|click|contextmenu|drop|dragover|dragend/.test(t)) return e.getDoc().documentElement;
                        const o = Wl(e);
                        return o ? (e.eventRoot || (e.eventRoot = CA.select(o)[0]), e.eventRoot) : e.getBody()
                    },
                    _A = (e, t, o) => {
                        (e => !e.hidden && !pA(e))(e) ? e.dispatch(t, o): pA(e) && ((e, t) => {
                            if ((e => "click" === e.type)(t) && !Lm.metaKeyPressed(t)) {
                                const o = go(t.target);
                                ((e, t) => Tn(t, "a", (t => bo(t, go(e.getBody())))).bind((e => Gt(e, "href"))))(e, o).each((o => {
                                    if (t.preventDefault(), /^#/.test(o)) {
                                        const t = e.dom.select(`${o},[name="${n=o,Ve(n,"#")?((e,t)=>e.substring(t))(n,"#".length):n}"]`);
                                        t.length && e.selection.scrollIntoView(t[0], !0)
                                    } else window.open(o, "_blank", "rel=noopener noreferrer,menubar=yes,toolbar=yes,location=yes,status=yes,resizable=yes,scrollbars=yes");
                                    var n
                                }))
                            } else(e => Z(vA, e.type))(t) && e.dispatch(t.type, t)
                        })(e, o)
                    },
                    OA = (e, t) => {
                        if (e.delegates || (e.delegates = {}), e.delegates[t] || e.removed) return;
                        const o = kA(e, t);
                        if (Wl(e)) {
                            if (SA || (SA = {}, e.editorManager.on("removeEditor", (() => {
                                    e.editorManager.activeEditor || SA && (he(SA, ((t, o) => {
                                        e.dom.unbind(kA(e, o))
                                    })), SA = null)
                                }))), SA[t]) return;
                            const n = o => {
                                const n = o.target,
                                    r = e.editorManager.get();
                                let s = r.length;
                                for (; s--;) {
                                    const e = r[s].getBody();
                                    (e === n || CA.isChildOf(n, e)) && _A(r[s], t, o)
                                }
                            };
                            SA[t] = n, CA.bind(o, t, n)
                        } else {
                            const n = o => {
                                _A(e, t, o)
                            };
                            CA.bind(o, t, n), e.delegates[t] = n
                        }
                    },
                    TA = { ...xA,
                        bindPendingEventDelegates() {
                            const e = this;
                            Rt.each(e._pendingNativeEvents, (t => {
                                OA(e, t)
                            }))
                        },
                        toggleNativeEvent(e, t) {
                            const o = this;
                            "focus" !== e && "blur" !== e && (o.removed || (t ? o.initialized ? OA(o, e) : o._pendingNativeEvents ? o._pendingNativeEvents.push(e) : o._pendingNativeEvents = [e] : o.initialized && o.delegates && (o.dom.unbind(kA(o, e), e, o.delegates[e]), delete o.delegates[e])))
                        },
                        unbindAllNativeEvents() {
                            const e = this,
                                t = e.getBody(),
                                o = e.dom;
                            e.delegates && (he(e.delegates, ((t, o) => {
                                e.dom.unbind(kA(e, o), o, t)
                            })), delete e.delegates), !e.inline && t && o && (t.onload = null, o.unbind(e.getWin()), o.unbind(e.getDoc())), o && (o.unbind(t), o.unbind(e.getContainer()))
                        }
                    },
                    EA = e => g(e) ? {
                        value: e.split(/[ ,]/),
                        valid: !0
                    } : k(e, g) ? {
                        value: e,
                        valid: !0
                    } : {
                        valid: !1,
                        message: "The value must be a string[] or a comma/space separated string."
                    },
                    AA = (e, t) => e + (Ge(t.message) ? "" : `. ${t.message}`),
                    MA = e => e.valid,
                    NA = (e, t, o = "") => {
                        const n = t(e);
                        return b(n) ? n ? {
                            value: e,
                            valid: !0
                        } : {
                            valid: !1,
                            message: o
                        } : n
                    },
                    RA = ["design", "readonly"],
                    DA = (e, t, o, n) => {
                        const r = o[t.get()],
                            s = o[n];
                        try {
                            s.activate()
                        } catch (e) {
                            return void console.error(`problem while activating editor mode ${n}:`, e)
                        }
                        r.deactivate(), r.editorReadOnly !== s.editorReadOnly && hA(e, s.editorReadOnly), t.set(n), ((e, t) => {
                            e.dispatch("SwitchMode", {
                                mode: t
                            })
                        })(e, n)
                    },
                    BA = Rt.each,
                    LA = Rt.explode,
                    HA = {
                        f1: 112,
                        f2: 113,
                        f3: 114,
                        f4: 115,
                        f5: 116,
                        f6: 117,
                        f7: 118,
                        f8: 119,
                        f9: 120,
                        f10: 121,
                        f11: 122,
                        f12: 123
                    },
                    IA = Rt.makeMap("alt,ctrl,shift,meta,access"),
                    PA = e => {
                        const t = {},
                            o = Et.os.isMacOS() || Et.os.isiOS();
                        BA(LA(e.toLowerCase(), "+"), (e => {
                            (e => e in IA)(e) ? t[e] = !0: /^[0-9]{2,}$/.test(e) ? t.keyCode = parseInt(e, 10) : (t.charCode = e.charCodeAt(0), t.keyCode = HA[e] || e.toUpperCase().charCodeAt(0))
                        }));
                        const n = [t.keyCode];
                        let r;
                        for (r in IA) t[r] ? n.push(r) : t[r] = !1;
                        return t.id = n.join(","), t.access && (t.alt = !0, o ? t.ctrl = !0 : t.shift = !0), t.meta && (o ? t.meta = !0 : (t.ctrl = !0, t.meta = !1)), t
                    };
                class zA {
                    constructor(e) {
                        this.shortcuts = {}, this.pendingPatterns = [], this.editor = e;
                        const t = this;
                        e.on("keyup keypress keydown", (e => {
                            !t.hasModifier(e) && !t.isFunctionKey(e) || e.isDefaultPrevented() || (BA(t.shortcuts, (o => {
                                t.matchShortcut(e, o) && (t.pendingPatterns = o.subpatterns.slice(0), "keydown" === e.type && t.executeShortcutAction(o))
                            })), t.matchShortcut(e, t.pendingPatterns[0]) && (1 === t.pendingPatterns.length && "keydown" === e.type && t.executeShortcutAction(t.pendingPatterns[0]), t.pendingPatterns.shift()))
                        }))
                    }
                    add(e, t, o, n) {
                        const r = this,
                            s = r.normalizeCommandFunc(o);
                        return BA(LA(Rt.trim(e)), (e => {
                            const o = r.createShortcut(e, t, s, n);
                            r.shortcuts[o.id] = o
                        })), !0
                    }
                    remove(e) {
                        const t = this.createShortcut(e);
                        return !!this.shortcuts[t.id] && (delete this.shortcuts[t.id], !0)
                    }
                    normalizeCommandFunc(e) {
                        const t = this,
                            o = e;
                        return "string" == typeof o ? () => {
                            t.editor.execCommand(o, !1, null)
                        } : Rt.isArray(o) ? () => {
                            t.editor.execCommand(o[0], o[1], o[2])
                        } : o
                    }
                    createShortcut(e, t, o, n) {
                        const r = Rt.map(LA(e, ">"), PA);
                        return r[r.length - 1] = Rt.extend(r[r.length - 1], {
                            func: o,
                            scope: n || this.editor
                        }), Rt.extend(r[0], {
                            desc: this.editor.translate(t),
                            subpatterns: r.slice(1)
                        })
                    }
                    hasModifier(e) {
                        return e.altKey || e.ctrlKey || e.metaKey
                    }
                    isFunctionKey(e) {
                        return "keydown" === e.type && e.keyCode >= 112 && e.keyCode <= 123
                    }
                    matchShortcut(e, t) {
                        return !!t && t.ctrl === e.ctrlKey && t.meta === e.metaKey && t.alt === e.altKey && t.shift === e.shiftKey && !!(e.keyCode === t.keyCode || e.charCode && e.charCode === t.charCode) && (e.preventDefault(), !0)
                    }
                    executeShortcutAction(e) {
                        return e.func ? e.func.call(e.scope) : null
                    }
                }
                const FA = () => {
                        const e = (() => {
                            const e = {},
                                t = {},
                                o = {},
                                n = {},
                                r = {},
                                s = {},
                                a = {},
                                i = {},
                                l = (e, t) => (o, n) => {
                                    e[o.toLowerCase()] = { ...n,
                                        type: t
                                    }
                                };
                            return {
                                addButton: l(e, "button"),
                                addGroupToolbarButton: l(e, "grouptoolbarbutton"),
                                addToggleButton: l(e, "togglebutton"),
                                addMenuButton: l(e, "menubutton"),
                                addSplitButton: l(e, "splitbutton"),
                                addMenuItem: l(t, "menuitem"),
                                addNestedMenuItem: l(t, "nestedmenuitem"),
                                addToggleMenuItem: l(t, "togglemenuitem"),
                                addAutocompleter: l(o, "autocompleter"),
                                addContextMenu: l(r, "contextmenu"),
                                addContextToolbar: l(s, "contexttoolbar"),
                                addContextForm: l(s, "contextform"),
                                addSidebar: l(a, "sidebar"),
                                addView: l(i, "views"),
                                addIcon: (e, t) => n[e.toLowerCase()] = t,
                                getAll: () => ({
                                    buttons: e,
                                    menuItems: t,
                                    icons: n,
                                    popups: o,
                                    contextMenus: r,
                                    contextToolbars: s,
                                    sidebars: a,
                                    views: i
                                })
                            }
                        })();
                        return {
                            addAutocompleter: e.addAutocompleter,
                            addButton: e.addButton,
                            addContextForm: e.addContextForm,
                            addContextMenu: e.addContextMenu,
                            addContextToolbar: e.addContextToolbar,
                            addIcon: e.addIcon,
                            addMenuButton: e.addMenuButton,
                            addMenuItem: e.addMenuItem,
                            addNestedMenuItem: e.addNestedMenuItem,
                            addSidebar: e.addSidebar,
                            addSplitButton: e.addSplitButton,
                            addToggleButton: e.addToggleButton,
                            addGroupToolbarButton: e.addGroupToolbarButton,
                            addToggleMenuItem: e.addToggleMenuItem,
                            addView: e.addView,
                            getAll: e.getAll
                        }
                    },
                    VA = ba.DOM,
                    ZA = Rt.extend,
                    UA = Rt.each;
                class jA {
                    constructor(e, t, o) {
                        this.plugins = {}, this.contentCSS = [], this.contentStyles = [], this.loadedCSS = {}, this.isNotDirty = !1, this.composing = !1, this.destroyed = !1, this.hasHiddenInput = !1, this.iframeElement = null, this.initialized = !1, this.readonly = !1, this.removed = !1, this.startContent = "", this._pendingNativeEvents = [], this._skinLoaded = !1, this.editorManager = o, this.documentBaseUrl = o.documentBaseURL, ZA(this, TA);
                        const n = this;
                        this.id = e, this.hidden = !1;
                        const r = ((e, t) => GE(VE || ZE, VE, t, e, t))(o.defaultOptions, t);
                        this.options = ((e, t) => {
                            const o = {},
                                n = {},
                                r = (e, t, o) => {
                                    const r = NA(t, o);
                                    return MA(r) ? (n[e] = r.value, !0) : (console.warn(AA(`Invalid value passed for the ${e} option`, r)), !1)
                                },
                                s = e => Se(o, e);
                            return {
                                register: (e, s) => {
                                    const a = (e => g(e.processor))(s) ? (e => {
                                            const t = (() => {
                                                switch (e) {
                                                    case "array":
                                                        return f;
                                                    case "boolean":
                                                        return b;
                                                    case "function":
                                                        return C;
                                                    case "number":
                                                        return S;
                                                    case "object":
                                                        return h;
                                                    case "string":
                                                        return g;
                                                    case "string[]":
                                                        return EA;
                                                    case "object[]":
                                                        return e => k(e, h);
                                                    case "regexp":
                                                        return e => m(e, RegExp);
                                                    default:
                                                        return H
                                                }
                                            })();
                                            return o => NA(o, t, `The value must be a ${e}.`)
                                        })(s.processor) : s.processor,
                                        i = ((e, t, o) => {
                                            if (!y(t)) {
                                                const n = NA(t, o);
                                                if (MA(n)) return n.value;
                                                console.error(AA(`Invalid default value passed for the "${e}" option`, n))
                                            }
                                        })(e, s.default, a);
                                    o[e] = { ...s,
                                        default: i,
                                        processor: a
                                    }, Ce(n, e).orThunk((() => Ce(t, e))).each((t => r(e, t, a)))
                                },
                                isRegistered: s,
                                get: e => Ce(n, e).orThunk((() => Ce(o, e).map((e => e.default)))).getOrUndefined(),
                                set: (e, t) => {
                                    if (s(e)) {
                                        const n = o[e];
                                        return n.immutable ? (console.error(`"${e}" is an immutable option and cannot be updated`), !1) : r(e, t, n.processor)
                                    }
                                    return console.warn(`"${e}" is not a registered option. Ensure the option has been registered before setting a value.`), !1
                                },
                                unset: e => {
                                    const t = s(e);
                                    return t && delete n[e], t
                                },
                                isSet: e => Se(n, e)
                            }
                        })(0, r), (e => {
                            const t = e.options.register;
                            t("id", {
                                processor: "string",
                                default: e.id
                            }), t("selector", {
                                processor: "string"
                            }), t("target", {
                                processor: "object"
                            }), t("suffix", {
                                processor: "string"
                            }), t("cache_suffix", {
                                processor: "string"
                            }), t("base_url", {
                                processor: "string"
                            }), t("referrer_policy", {
                                processor: "string",
                                default: ""
                            }), t("language_load", {
                                processor: "boolean",
                                default: !0
                            }), t("inline", {
                                processor: "boolean",
                                default: !1
                            }), t("iframe_attrs", {
                                processor: "object",
                                default: {}
                            }), t("doctype", {
                                processor: "string",
                                default: "<!DOCTYPE html>"
                            }), t("document_base_url", {
                                processor: "string",
                                default: e.documentBaseUrl
                            }), t("body_id", {
                                processor: il(e, "tinymce"),
                                default: "tinymce"
                            }), t("body_class", {
                                processor: il(e),
                                default: ""
                            }), t("content_security_policy", {
                                processor: "string",
                                default: ""
                            }), t("br_in_pre", {
                                processor: "boolean",
                                default: !0
                            }), t("forced_root_block", {
                                processor: e => {
                                    const t = g(e) && qe(e);
                                    return t ? {
                                        value: e,
                                        valid: t
                                    } : {
                                        valid: !1,
                                        message: "Must be a non-empty string."
                                    }
                                },
                                default: "p"
                            }), t("forced_root_block_attrs", {
                                processor: "object",
                                default: {}
                            }), t("newline_behavior", {
                                processor: e => {
                                    const t = Z(["block", "linebreak", "invert", "default"], e);
                                    return t ? {
                                        value: e,
                                        valid: t
                                    } : {
                                        valid: !1,
                                        message: "Must be one of: block, linebreak, invert or default."
                                    }
                                },
                                default: "default"
                            }), t("br_newline_selector", {
                                processor: "string",
                                default: ".mce-toc h2,figcaption,caption"
                            }), t("no_newline_selector", {
                                processor: "string",
                                default: ""
                            }), t("keep_styles", {
                                processor: "boolean",
                                default: !0
                            }), t("end_container_on_empty_block", {
                                processor: e => b(e) || g(e) ? {
                                    valid: !0,
                                    value: e
                                } : {
                                    valid: !1,
                                    message: "Must be boolean or a string"
                                },
                                default: "blockquote"
                            }), t("font_size_style_values", {
                                processor: "string",
                                default: "xx-small,x-small,small,medium,large,x-large,xx-large"
                            }), t("font_size_legacy_values", {
                                processor: "string",
                                default: "xx-small,small,medium,large,x-large,xx-large,300%"
                            }), t("font_size_classes", {
                                processor: "string",
                                default: ""
                            }), t("automatic_uploads", {
                                processor: "boolean",
                                default: !0
                            }), t("images_reuse_filename", {
                                processor: "boolean",
                                default: !1
                            }), t("images_replace_blob_uris", {
                                processor: "boolean",
                                default: !0
                            }), t("icons", {
                                processor: "string",
                                default: ""
                            }), t("icons_url", {
                                processor: "string",
                                default: ""
                            }), t("images_upload_url", {
                                processor: "string",
                                default: ""
                            }), t("images_upload_base_path", {
                                processor: "string",
                                default: ""
                            }), t("images_upload_credentials", {
                                processor: "boolean",
                                default: !1
                            }), t("images_upload_handler", {
                                processor: "function"
                            }), t("language", {
                                processor: "string",
                                default: "en"
                            }), t("language_url", {
                                processor: "string",
                                default: ""
                            }), t("entity_encoding", {
                                processor: "string",
                                default: "named"
                            }), t("indent", {
                                processor: "boolean",
                                default: !0
                            }), t("indent_before", {
                                processor: "string",
                                default: "p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,tfoot,tbody,tr,section,summary,article,hgroup,aside,figure,figcaption,option,optgroup,datalist"
                            }), t("indent_after", {
                                processor: "string",
                                default: "p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,tfoot,tbody,tr,section,summary,article,hgroup,aside,figure,figcaption,option,optgroup,datalist"
                            }), t("indent_use_margin", {
                                processor: "boolean",
                                default: !1
                            }), t("indentation", {
                                processor: "string",
                                default: "40px"
                            }), t("content_css", {
                                processor: e => {
                                    const t = !1 === e || g(e) || k(e, g);
                                    return t ? g(e) ? {
                                        value: j(e.split(","), je),
                                        valid: t
                                    } : f(e) ? {
                                        value: e,
                                        valid: t
                                    } : !1 === e ? {
                                        value: [],
                                        valid: t
                                    } : {
                                        value: e,
                                        valid: t
                                    } : {
                                        valid: !1,
                                        message: "Must be false, a string or an array of strings."
                                    }
                                },
                                default: nc(e) ? [] : ["default"]
                            }), t("content_style", {
                                processor: "string"
                            }), t("content_css_cors", {
                                processor: "boolean",
                                default: !1
                            }), t("font_css", {
                                processor: e => {
                                    const t = g(e) || k(e, g);
                                    return t ? {
                                        value: f(e) ? e : j(e.split(","), je),
                                        valid: t
                                    } : {
                                        valid: !1,
                                        message: "Must be a string or an array of strings."
                                    }
                                },
                                default: []
                            }), t("inline_boundaries", {
                                processor: "boolean",
                                default: !0
                            }), t("inline_boundaries_selector", {
                                processor: "string",
                                default: "a[href],code,span.mce-annotation"
                            }), t("object_resizing", {
                                processor: e => {
                                    const t = b(e) || g(e);
                                    return t ? !1 === e || tl.isiPhone() || tl.isiPad() ? {
                                        value: "",
                                        valid: t
                                    } : {
                                        value: !0 === e ? "table,img,figure.image,div,video,iframe" : e,
                                        valid: t
                                    } : {
                                        valid: !1,
                                        message: "Must be boolean or a string"
                                    }
                                },
                                default: !ol
                            }), t("resize_img_proportional", {
                                processor: "boolean",
                                default: !0
                            }), t("event_root", {
                                processor: "object"
                            }), t("service_message", {
                                processor: "string"
                            }), t("theme", {
                                processor: e => !1 === e || g(e) || C(e),
                                default: "silver"
                            }), t("theme_url", {
                                processor: "string"
                            }), t("formats", {
                                processor: "object"
                            }), t("format_empty_lines", {
                                processor: "boolean",
                                default: !1
                            }), t("format_noneditable_selector", {
                                processor: "string",
                                default: ""
                            }), t("preview_styles", {
                                processor: e => {
                                    const t = !1 === e || g(e);
                                    return t ? {
                                        value: !1 === e ? "" : e,
                                        valid: t
                                    } : {
                                        valid: !1,
                                        message: "Must be false or a string"
                                    }
                                },
                                default: "font-family font-size font-weight font-style text-decoration text-transform color background-color border border-radius outline text-shadow"
                            }), t("custom_ui_selector", {
                                processor: "string",
                                default: ""
                            }), t("hidden_input", {
                                processor: "boolean",
                                default: !0
                            }), t("submit_patch", {
                                processor: "boolean",
                                default: !0
                            }), t("encoding", {
                                processor: "string"
                            }), t("add_form_submit_trigger", {
                                processor: "boolean",
                                default: !0
                            }), t("add_unload_trigger", {
                                processor: "boolean",
                                default: !0
                            }), t("custom_undo_redo_levels", {
                                processor: "number",
                                default: 0
                            }), t("disable_nodechange", {
                                processor: "boolean",
                                default: !1
                            }), t("readonly", {
                                processor: "boolean",
                                default: !1
                            }), t("plugins", {
                                processor: "string[]",
                                default: []
                            }), t("external_plugins", {
                                processor: "object"
                            }), t("forced_plugins", {
                                processor: "string[]"
                            }), t("model", {
                                processor: "string",
                                default: e.hasPlugin("rtc") ? "plugin" : "dom"
                            }), t("model_url", {
                                processor: "string"
                            }), t("block_unsupported_drop", {
                                processor: "boolean",
                                default: !0
                            }), t("visual", {
                                processor: "boolean",
                                default: !0
                            }), t("visual_table_class", {
                                processor: "string",
                                default: "mce-item-table"
                            }), t("visual_anchor_class", {
                                processor: "string",
                                default: "mce-item-anchor"
                            }), t("iframe_aria_text", {
                                processor: "string",
                                default: "Rich Text Area. Press ALT-0 for help."
                            }), t("setup", {
                                processor: "function"
                            }), t("init_instance_callback", {
                                processor: "function"
                            }), t("url_converter", {
                                processor: "function",
                                default: e.convertURL
                            }), t("url_converter_scope", {
                                processor: "object",
                                default: e
                            }), t("urlconverter_callback", {
                                processor: "function"
                            }), t("allow_conditional_comments", {
                                processor: "boolean",
                                default: !1
                            }), t("allow_html_data_urls", {
                                processor: "boolean",
                                default: !1
                            }), t("allow_svg_data_urls", {
                                processor: "boolean"
                            }), t("allow_html_in_named_anchor", {
                                processor: "boolean",
                                default: !1
                            }), t("allow_script_urls", {
                                processor: "boolean",
                                default: !1
                            }), t("allow_unsafe_link_target", {
                                processor: "boolean",
                                default: !1
                            }), t("convert_fonts_to_spans", {
                                processor: "boolean",
                                default: !0,
                                deprecated: !0
                            }), t("fix_list_elements", {
                                processor: "boolean",
                                default: !1
                            }), t("preserve_cdata", {
                                processor: "boolean",
                                default: !1
                            }), t("remove_trailing_brs", {
                                processor: "boolean"
                            }), t("inline_styles", {
                                processor: "boolean",
                                default: !0,
                                deprecated: !0
                            }), t("element_format", {
                                processor: "string",
                                default: "html"
                            }), t("entities", {
                                processor: "string"
                            }), t("schema", {
                                processor: "string",
                                default: "html5"
                            }), t("convert_urls", {
                                processor: "boolean",
                                default: !0
                            }), t("relative_urls", {
                                processor: "boolean",
                                default: !0
                            }), t("remove_script_host", {
                                processor: "boolean",
                                default: !0
                            }), t("custom_elements", {
                                processor: "string"
                            }), t("extended_valid_elements", {
                                processor: "string"
                            }), t("invalid_elements", {
                                processor: "string"
                            }), t("invalid_styles", {
                                processor: al
                            }), t("valid_children", {
                                processor: "string"
                            }), t("valid_classes", {
                                processor: al
                            }), t("valid_elements", {
                                processor: "string"
                            }), t("valid_styles", {
                                processor: al
                            }), t("verify_html", {
                                processor: "boolean",
                                default: !0
                            }), t("auto_focus", {
                                processor: e => g(e) || !0 === e
                            }), t("browser_spellcheck", {
                                processor: "boolean",
                                default: !1
                            }), t("protect", {
                                processor: "array"
                            }), t("images_file_types", {
                                processor: "string",
                                default: "jpeg,jpg,jpe,jfi,jif,jfif,png,gif,bmp,webp"
                            }), t("deprecation_warnings", {
                                processor: "boolean",
                                default: !0
                            }), t("a11y_advanced_options", {
                                processor: "boolean",
                                default: !1
                            }), t("api_key", {
                                processor: "string"
                            }), t("paste_block_drop", {
                                processor: "boolean",
                                default: !1
                            }), t("paste_data_images", {
                                processor: "boolean",
                                default: !0
                            }), t("paste_preprocess", {
                                processor: "function"
                            }), t("paste_postprocess", {
                                processor: "function"
                            }), t("paste_webkit_styles", {
                                processor: "string",
                                default: "none"
                            }), t("paste_remove_styles_if_webkit", {
                                processor: "boolean",
                                default: !0
                            }), t("paste_merge_formats", {
                                processor: "boolean",
                                default: !0
                            }), t("smart_paste", {
                                processor: "boolean",
                                default: !0
                            }), t("paste_as_text", {
                                processor: "boolean",
                                default: !1
                            }), t("paste_tab_spaces", {
                                processor: "number",
                                default: 4
                            }), t("text_patterns", {
                                processor: e => k(e, h) || !1 === e ? {
                                    value: el(!1 === e ? [] : e),
                                    valid: !0
                                } : {
                                    valid: !1,
                                    message: "Must be an array of objects or false."
                                },
                                default: [{
                                    start: "*",
                                    end: "*",
                                    format: "italic"
                                }, {
                                    start: "**",
                                    end: "**",
                                    format: "bold"
                                }, {
                                    start: "#",
                                    format: "h1"
                                }, {
                                    start: "##",
                                    format: "h2"
                                }, {
                                    start: "###",
                                    format: "h3"
                                }, {
                                    start: "####",
                                    format: "h4"
                                }, {
                                    start: "#####",
                                    format: "h5"
                                }, {
                                    start: "######",
                                    format: "h6"
                                }, {
                                    start: "1. ",
                                    cmd: "InsertOrderedList"
                                }, {
                                    start: "* ",
                                    cmd: "InsertUnorderedList"
                                }, {
                                    start: "- ",
                                    cmd: "InsertUnorderedList"
                                }]
                            }), t("text_patterns_lookup", {
                                processor: e => {
                                    return C(e) ? {
                                        value: (t = e, e => {
                                            const o = t(e);
                                            return el(o)
                                        }),
                                        valid: !0
                                    } : {
                                        valid: !1,
                                        message: "Must be a single function"
                                    };
                                    var t
                                },
                                default: e => []
                            }), t("noneditable_class", {
                                processor: "string",
                                default: "mceNonEditable"
                            }), t("editable_class", {
                                processor: "string",
                                default: "mceEditable"
                            }), t("noneditable_regexp", {
                                processor: e => k(e, rl) ? {
                                    value: e,
                                    valid: !0
                                } : rl(e) ? {
                                    value: [e],
                                    valid: !0
                                } : {
                                    valid: !1,
                                    message: "Must be a RegExp or an array of RegExp."
                                },
                                default: []
                            }), t("table_tab_navigation", {
                                processor: "boolean",
                                default: !0
                            }), e.on("ScriptsLoaded", (() => {
                                t("directionality", {
                                    processor: "string",
                                    default: _a.isRtl() ? "rtl" : void 0
                                }), t("placeholder", {
                                    processor: "string",
                                    default: nl.getAttrib(e.getElement(), "placeholder")
                                })
                            }))
                        })(n);
                        const s = this.options.get;
                        s("deprecation_warnings") && ((e, t) => {
                            ((e, t) => {
                                const o = pw(e),
                                    n = fw(t),
                                    r = n.length > 0,
                                    s = o.length > 0,
                                    a = "mobile" === t.theme;
                                if (r || s || a) {
                                    const e = "\n- ",
                                        t = a ? `\n\nThemes:${e}mobile` : "",
                                        i = r ? `\n\nPlugins:${e}${n.join(e)}` : "",
                                        l = s ? `\n\nOptions:${e}${o.join(e)}` : "";
                                    console.warn("The following deprecated features are currently enabled and have been removed in TinyMCE 6.0. These features will no longer work and should be removed from the TinyMCE configuration. See https://www.tiny.cloud/docs/tinymce/6/migration-from-5x/ for more information." + t + i + l)
                                }
                            })(e, t)
                        })(t, r);
                        const a = s("suffix");
                        a && (o.suffix = a), this.suffix = o.suffix;
                        const i = s("base_url");
                        i && o._setBaseUrl(i), this.baseUri = o.baseURI;
                        const l = Rl(n);
                        l && (wa.ScriptLoader._setReferrerPolicy(l), ba.DOM.styleSheetLoader._setReferrerPolicy(l));
                        const c = uc(n);
                        x(c) && ba.DOM.styleSheetLoader._setContentCssCors(c), Oa.languageLoad = s("language_load"), Oa.baseURL = o.baseURL, this.setDirty(!1), this.documentBaseURI = new gy(dl(n), {
                            base_uri: this.baseUri
                        }), this.baseURI = this.baseUri, this.inline = nc(n), this.hasVisual = pc(n), this.shortcuts = new zA(this), this.editorCommands = new dA(this), iA(this);
                        const d = s("cache_suffix");
                        d && (Et.cacheSuffix = d.replace(/^[\?\&]+/, "")), this.ui = {
                            registry: FA(),
                            styleSheetLoader: void 0,
                            show: _,
                            hide: _,
                            setEnabled: _,
                            isEnabled: H
                        }, this.mode = (e => {
                            const t = xa("design"),
                                o = xa({
                                    design: {
                                        activate: _,
                                        deactivate: _,
                                        editorReadOnly: !1
                                    },
                                    readonly: {
                                        activate: _,
                                        deactivate: _,
                                        editorReadOnly: !0
                                    }
                                });
                            return (e => {
                                e.serializer ? fA(e) : e.on("PreInit", (() => {
                                    fA(e)
                                }))
                            })(e), (e => {
                                e.on("ShowCaret", (t => {
                                    pA(e) && t.preventDefault()
                                })), e.on("ObjectSelected", (t => {
                                    pA(e) && t.preventDefault()
                                }))
                            })(e), {
                                isReadOnly: () => pA(e),
                                set: n => ((e, t, o, n) => {
                                    if (n !== o.get()) {
                                        if (!Se(t, n)) throw new Error(`Editor mode '${n}' is invalid`);
                                        e.initialized ? DA(e, o, t, n) : e.on("init", (() => DA(e, o, t, n)))
                                    }
                                })(e, o.get(), t, n),
                                get: () => t.get(),
                                register: (e, t) => {
                                    o.set(((e, t, o) => {
                                        if (Z(RA, t)) throw new Error(`Cannot override default mode ${t}`);
                                        return { ...e,
                                            [t]: { ...o,
                                                deactivate: () => {
                                                    try {
                                                        o.deactivate()
                                                    } catch (e) {
                                                        console.error(`problem while deactivating editor mode ${t}:`, e)
                                                    }
                                                }
                                            }
                                        }
                                    })(o.get(), e, t))
                                }
                            }
                        })(n), o.dispatch("SetupEditor", {
                            editor: this
                        });
                        const u = yc(n);
                        C(u) && u.call(n, n)
                    }
                    render() {
                        (e => {
                            const t = e.id;
                            _a.setCode(Dl(e));
                            const o = () => {
                                HE.unbind(window, "ready", o), e.render()
                            };
                            if (!la.Event.domLoaded) return void HE.bind(window, "ready", o);
                            if (!e.getElement()) return;
                            const n = go(e.getElement()),
                                r = Xt(n);
                            e.on("remove", (() => {
                                $(n.dom.attributes, (e => Yt(n, e.name))), $t(n, r)
                            })), e.ui.styleSheetLoader = ((e, t) => Cs.forElement(e, {
                                contentCssCors: uc(t),
                                referrerPolicy: Rl(t)
                            }))(n, e), nc(e) ? e.inline = !0 : (e.orgVisibility = e.getElement().style.visibility, e.getElement().style.visibility = "hidden");
                            const s = e.getElement().form || HE.getParent(t, "form");
                            s && (e.formElement = s, rc(e) && !Fn(e.getElement()) && (HE.insertAfter(HE.create("input", {
                                type: "hidden",
                                name: t
                            }), t), e.hasHiddenInput = !0), e.formEventDelegate = t => {
                                e.dispatch(t.type, t)
                            }, HE.bind(s, "submit reset", e.formEventDelegate), e.on("reset", (() => {
                                e.resetContent()
                            })), !sc(e) || s.submit.nodeType || s.submit.length || s._mceOldSubmit || (s._mceOldSubmit = s.submit, s.submit = () => (e.editorManager.triggerSave(), e.setDirty(!1), s._mceOldSubmit(s)))), e.windowManager = Mw(e), e.notificationManager = Tw(e), (e => "xml" === e.options.get("encoding"))(e) && e.on("GetContent", (e => {
                                e.save && (e.content = HE.encode(e.content))
                            })), ac(e) && e.on("submit", (() => {
                                e.initialized && e.save()
                            })), ic(e) && (e._beforeUnload = () => {
                                !e.initialized || e.destroyed || e.isHidden() || e.save({
                                    format: "raw",
                                    no_events: !0,
                                    set_dirty: !1
                                })
                            }, e.editorManager.on("BeforeUnload", e._beforeUnload)), e.editorManager.add(e), zE(e, e.suffix)
                        })(this)
                    }
                    focus(e) {
                        this.execCommand("mceFocus", !1, e)
                    }
                    hasFocus() {
                        return eh(this)
                    }
                    translate(e) {
                        return _a.translate(e)
                    }
                    getParam(e, t, o) {
                        const n = this.options;
                        return n.isRegistered(e) || (x(o) ? n.register(e, {
                            processor: o,
                            default: t
                        }) : n.register(e, {
                            processor: H,
                            default: t
                        })), n.isSet(e) || y(t) ? n.get(e) : t
                    }
                    hasPlugin(e, t) {
                        return !(!Z(mc(this), e) || t && void 0 === Ew.get(e))
                    }
                    nodeChanged(e) {
                        this._nodeChangeDispatcher.nodeChanged(e)
                    }
                    addCommand(e, t, o) {
                        this.editorCommands.addCommand(e, t, o)
                    }
                    addQueryStateHandler(e, t, o) {
                        this.editorCommands.addQueryStateHandler(e, t, o)
                    }
                    addQueryValueHandler(e, t, o) {
                        this.editorCommands.addQueryValueHandler(e, t, o)
                    }
                    addShortcut(e, t, o, n) {
                        this.shortcuts.add(e, t, o, n)
                    }
                    execCommand(e, t, o, n) {
                        return this.editorCommands.execCommand(e, t, o, n)
                    }
                    queryCommandState(e) {
                        return this.editorCommands.queryCommandState(e)
                    }
                    queryCommandValue(e) {
                        return this.editorCommands.queryCommandValue(e)
                    }
                    queryCommandSupported(e) {
                        return this.editorCommands.queryCommandSupported(e)
                    }
                    show() {
                        const e = this;
                        e.hidden && (e.hidden = !1, e.inline ? e.getBody().contentEditable = "true" : (VA.show(e.getContainer()), VA.hide(e.id)), e.load(), e.dispatch("show"))
                    }
                    hide() {
                        const e = this;
                        e.hidden || (e.save(), e.inline ? (e.getBody().contentEditable = "false", e === e.editorManager.focusedEditor && (e.editorManager.focusedEditor = null)) : (VA.hide(e.getContainer()), VA.setStyle(e.id, "display", e.orgDisplay)), e.hidden = !0, e.dispatch("hide"))
                    }
                    isHidden() {
                        return this.hidden
                    }
                    setProgressState(e, t) {
                        this.dispatch("ProgressState", {
                            state: e,
                            time: t
                        })
                    }
                    load(e = {}) {
                        const t = this,
                            o = t.getElement();
                        if (t.removed) return "";
                        if (o) {
                            const n = { ...e,
                                    load: !0
                                },
                                r = Fn(o) ? o.value : o.innerHTML,
                                s = t.setContent(r, n);
                            return n.no_events || t.dispatch("LoadContent", { ...n,
                                element: o
                            }), s
                        }
                        return ""
                    }
                    save(e = {}) {
                        const t = this;
                        let o = t.getElement();
                        if (!o || !t.initialized || t.removed) return "";
                        const n = { ...e,
                            save: !0,
                            element: o
                        };
                        let r = t.getContent(n);
                        const s = { ...n,
                            content: r
                        };
                        if (s.no_events || t.dispatch("SaveContent", s), "raw" === s.format && t.dispatch("RawSaveContent", s), r = s.content, Fn(o)) o.value = r;
                        else {
                            !e.is_removing && t.inline || (o.innerHTML = r);
                            const n = VA.getParent(t.id, "form");
                            n && UA(n.elements, (e => e.name !== t.id || (e.value = r, !1)))
                        }
                        return s.element = n.element = o = null, !1 !== s.set_dirty && t.setDirty(!1), r
                    }
                    setContent(e, t) {
                        return mw(this, e, t)
                    }
                    getContent(e) {
                        return ((e, t = {}) => {
                            const o = ((e, t) => ({ ...e,
                                format: t,
                                get: !0,
                                getInner: !0
                            }))(t, t.format ? t.format : "html");
                            return Sy(e, o).fold(A, (t => {
                                const o = ((e, t) => tw(e).editor.getContent(t))(e, t);
                                return ky(e, o, t)
                            }))
                        })(this, e)
                    }
                    insertContent(e, t) {
                        t && (e = ZA({
                            content: e
                        }, t)), this.execCommand("mceInsertContent", !1, e)
                    }
                    resetContent(e) {
                        void 0 === e ? mw(this, this.startContent, {
                            format: "raw"
                        }) : mw(this, e), this.undoManager.reset(), this.setDirty(!1), this.nodeChanged()
                    }
                    isDirty() {
                        return !this.isNotDirty
                    }
                    setDirty(e) {
                        const t = !this.isNotDirty;
                        this.isNotDirty = !e, e && e !== t && this.dispatch("dirty")
                    }
                    getContainer() {
                        const e = this;
                        return e.container || (e.container = e.editorContainer || VA.get(e.id + "_parent")), e.container
                    }
                    getContentAreaContainer() {
                        return this.contentAreaContainer
                    }
                    getElement() {
                        return this.targetElm || (this.targetElm = VA.get(this.id)), this.targetElm
                    }
                    getWin() {
                        const e = this;
                        if (!e.contentWindow) {
                            const t = e.iframeElement;
                            t && (e.contentWindow = t.contentWindow)
                        }
                        return e.contentWindow
                    }
                    getDoc() {
                        const e = this;
                        if (!e.contentDocument) {
                            const t = e.getWin();
                            t && (e.contentDocument = t.document)
                        }
                        return e.contentDocument
                    }
                    getBody() {
                        var e, t;
                        const o = this.getDoc();
                        return null !== (t = null !== (e = this.bodyElement) && void 0 !== e ? e : null == o ? void 0 : o.body) && void 0 !== t ? t : null
                    }
                    convertURL(e, t, o) {
                        const n = this,
                            r = n.options.get,
                            s = xc(n);
                        return C(s) ? s.call(n, e, o, !0, t) : !r("convert_urls") || "link" === o || h(o) && "LINK" === o.nodeName || 0 === e.indexOf("file:") || 0 === e.length ? e : r("relative_urls") ? n.documentBaseURI.toRelative(e) : e = n.documentBaseURI.toAbsolute(e, r("remove_script_host"))
                    }
                    addVisual(e) {
                        ((e, t) => {
                            ((e, t) => {
                                ow(e).editor.addVisual(t)
                            })(e, t)
                        })(this, e)
                    }
                    remove() {
                        (e => {
                            if (!e.removed) {
                                const {
                                    _selectionOverrides: t,
                                    editorUpload: o
                                } = e, n = e.getBody(), r = e.getElement();
                                n && e.save({
                                    is_removing: !0
                                }), e.removed = !0, e.unbindAllNativeEvents(), e.hasHiddenInput && x(null == r ? void 0 : r.nextSibling) && vw.remove(r.nextSibling), (e => {
                                    e.dispatch("remove")
                                })(e), e.editorManager.remove(e), !e.inline && n && (e => {
                                    vw.setStyle(e.id, "display", e.orgDisplay)
                                })(e), (e => {
                                    e.dispatch("detach")
                                })(e), vw.remove(e.getContainer()), bw(t), bw(o), e.destroy()
                            }
                        })(this)
                    }
                    destroy(e) {
                        ((e, t) => {
                            const {
                                selection: o,
                                dom: n
                            } = e;
                            e.destroyed || (t || e.removed ? (t || (e.editorManager.off("beforeunload", e._beforeUnload), e.theme && e.theme.destroy && e.theme.destroy(), bw(o), bw(n)), (e => {
                                const t = e.formElement;
                                t && (t._mceOldSubmit && (t.submit = t._mceOldSubmit, delete t._mceOldSubmit), vw.unbind(t, "submit reset", e.formEventDelegate))
                            })(e), (e => {
                                const t = e;
                                t.contentAreaContainer = t.formElement = t.container = t.editorContainer = null, t.bodyElement = t.contentDocument = t.contentWindow = null, t.iframeElement = t.targetElm = null;
                                const o = e.selection;
                                if (o) {
                                    const e = o.dom;
                                    t.selection = o.win = o.dom = e.doc = null
                                }
                            })(e), e.destroyed = !0) : e.remove())
                        })(this, e)
                    }
                    uploadImages() {
                        return this.editorUpload.uploadImages()
                    }
                    _scanForImages() {
                        return this.editorUpload.scanForImages()
                    }
                }
                const WA = ba.DOM,
                    $A = Rt.each;
                let qA, GA = !1,
                    KA = [];
                const YA = e => {
                        const t = e.type;
                        $A(eM.get(), (o => {
                            switch (t) {
                                case "scroll":
                                    o.dispatch("ScrollWindow", e);
                                    break;
                                case "resize":
                                    o.dispatch("ResizeWindow", e)
                            }
                        }))
                    },
                    XA = e => {
                        if (e !== GA) {
                            const t = ba.DOM;
                            e ? (t.bind(window, "resize", YA), t.bind(window, "scroll", YA)) : (t.unbind(window, "resize", YA), t.unbind(window, "scroll", YA)), GA = e
                        }
                    },
                    JA = e => {
                        const t = KA;
                        return KA = G(KA, (t => e !== t)), eM.activeEditor === e && (eM.activeEditor = KA.length > 0 ? KA[0] : null), eM.focusedEditor === e && (eM.focusedEditor = null), t.length !== KA.length
                    },
                    QA = "CSS1Compat" !== document.compatMode,
                    eM = { ...xA,
                        baseURI: null,
                        baseURL: null,
                        defaultOptions: {},
                        documentBaseURL: null,
                        suffix: null,
                        majorVersion: "6",
                        minorVersion: "3.1",
                        releaseDate: "2022-12-06",
                        i18n: _a,
                        activeEditor: null,
                        focusedEditor: null,
                        setup() {
                            const e = this;
                            let t = "",
                                o = "",
                                n = gy.getDocumentBaseUrl(document.location);
                            /^[^:]+:\/\/\/?[^\/]+\//.test(n) && (n = n.replace(/[\?#].*$/, "").replace(/[\/\\][^\/]+$/, ""), /[\/\\]$/.test(n) || (n += "/"));
                            const r = window.tinymce || window.tinyMCEPreInit;
                            if (r) t = r.base || r.baseURL, o = r.suffix;
                            else {
                                const e = document.getElementsByTagName("script");
                                for (let n = 0; n < e.length; n++) {
                                    const r = e[n].src || "";
                                    if ("" === r) continue;
                                    const s = r.substring(r.lastIndexOf("/"));
                                    if (/tinymce(\.full|\.jquery|)(\.min|\.dev|)\.js/.test(r)) {
                                        -1 !== s.indexOf(".min") && (o = ".min"), t = r.substring(0, r.lastIndexOf("/"));
                                        break
                                    }
                                }
                                if (!t && document.currentScript) {
                                    const e = document.currentScript.src; - 1 !== e.indexOf(".min") && (o = ".min"), t = e.substring(0, e.lastIndexOf("/"))
                                }
                            }
                            var s;
                            e.baseURL = new gy(n).toAbsolute(t), e.documentBaseURL = n, e.baseURI = new gy(e.baseURL), e.suffix = o, (s = e).on("AddEditor", N(Yg, s)), s.on("RemoveEditor", N(Xg, s))
                        },
                        overrideDefaults(e) {
                            const t = e.base_url;
                            t && this._setBaseUrl(t);
                            const o = e.suffix;
                            o && (this.suffix = o), this.defaultOptions = e;
                            const n = e.plugin_base_urls;
                            void 0 !== n && he(n, ((e, t) => {
                                Oa.PluginManager.urls[t] = e
                            }))
                        },
                        init(e) {
                            const t = this;
                            let o;
                            const n = Rt.makeMap("area base basefont br col frame hr img input isindex link meta param embed source wbr track colgroup option table tbody tfoot thead tr th td script noscript style textarea video audio iframe object menu", " ");
                            let r = e => {
                                o = e
                            };
                            const s = () => {
                                let o = 0;
                                const a = [];
                                let i;
                                WA.unbind(window, "ready", s), (o => {
                                    const n = e.onpageload;
                                    n && n.apply(t, [])
                                })(), i = ((e, t) => {
                                    const o = [],
                                        n = C(t) ? e => U(o, (o => t(o, e))) : e => Z(o, e);
                                    for (let t = 0, r = e.length; t < r; t++) {
                                        const r = e[t];
                                        n(r) || o.push(r)
                                    }
                                    return o
                                })((e => Et.browser.isIE() || Et.browser.isEdge() ? (Lw("TinyMCE does not support the browser you are using. For a list of supported browsers please see: https://www.tiny.cloud/docs/tinymce/6/support/#supportedwebbrowsers"), []) : QA ? (Lw("Failed to initialize the editor as the document is not in standards mode. TinyMCE requires standards mode."), []) : g(e.selector) ? WA.select(e.selector) : x(e.target) ? [e.target] : [])(e)), Rt.each(i, (e => {
                                    var o;
                                    (o = t.get(e.id)) && o.initialized && !(o.getContainer() || o.getBody()).parentNode && (JA(o), o.unbindAllNativeEvents(), o.destroy(!0), o.removed = !0)
                                })), i = Rt.grep(i, (e => !t.get(e.id))), 0 === i.length ? r([]) : $A(i, (s => {
                                    ((e, t) => e.inline && t.tagName.toLowerCase() in n)(e, s) ? Lw("Could not initialize inline editor on invalid inline target element", s): ((e, n, s) => {
                                        const l = new jA(e, n, t);
                                        a.push(l), l.on("init", (() => {
                                            ++o === i.length && r(a)
                                        })), l.targetElm = l.targetElm || s, l.render()
                                    })((e => {
                                        let t = e.id;
                                        return t || (t = Ce(e, "name").filter((e => !WA.get(e))).getOrThunk(WA.uniqueId), e.setAttribute("id", t)), t
                                    })(s), e, s)
                                }))
                            };
                            return WA.bind(window, "ready", s), new Promise((e => {
                                o ? e(o) : r = t => {
                                    e(t)
                                }
                            }))
                        },
                        get(e) {
                            return 0 === arguments.length ? KA.slice(0) : g(e) ? J(KA, (t => t.id === e)).getOr(null) : S(e) && KA[e] ? KA[e] : null
                        },
                        add(e) {
                            const t = this,
                                o = t.get(e.id);
                            return o === e || (null === o && KA.push(e), XA(!0), t.activeEditor = e, t.dispatch("AddEditor", {
                                editor: e
                            }), qA || (qA = e => {
                                const o = t.dispatch("BeforeUnload");
                                if (o.returnValue) return e.preventDefault(), e.returnValue = o.returnValue, o.returnValue
                            }, window.addEventListener("beforeunload", qA))), e
                        },
                        createEditor(e, t) {
                            return this.add(new jA(e, t, this))
                        },
                        remove(e) {
                            const t = this;
                            let o;
                            if (e) {
                                if (!g(e)) return o = e, v(t.get(o.id)) ? null : (JA(o) && t.dispatch("RemoveEditor", {
                                    editor: o
                                }), 0 === KA.length && window.removeEventListener("beforeunload", qA), o.remove(), XA(KA.length > 0), o);
                                $A(WA.select(e), (e => {
                                    o = t.get(e.id), o && t.remove(o)
                                }))
                            } else
                                for (let e = KA.length - 1; e >= 0; e--) t.remove(KA[e])
                        },
                        execCommand(e, t, o) {
                            var n;
                            const r = this,
                                s = h(o) ? null !== (n = o.id) && void 0 !== n ? n : o.index : o;
                            switch (e) {
                                case "mceAddEditor":
                                    if (!r.get(s)) {
                                        const e = o.options;
                                        new jA(s, e, r).render()
                                    }
                                    return !0;
                                case "mceRemoveEditor":
                                    {
                                        const e = r.get(s);
                                        return e && e.remove(),
                                        !0
                                    }
                                case "mceToggleEditor":
                                    {
                                        const e = r.get(s);
                                        return e ? (e.isHidden() ? e.show() : e.hide(), !0) : (r.execCommand("mceAddEditor", !1, o), !0)
                                    }
                            }
                            return !!r.activeEditor && r.activeEditor.execCommand(e, t, o)
                        },
                        triggerSave: () => {
                            $A(KA, (e => {
                                e.save()
                            }))
                        },
                        addI18n: (e, t) => {
                            _a.add(e, t)
                        },
                        translate: e => _a.translate(e),
                        setActive(e) {
                            const t = this.activeEditor;
                            this.activeEditor !== e && (t && t.dispatch("deactivate", {
                                relatedTarget: e
                            }), e.dispatch("activate", {
                                relatedTarget: t
                            })), this.activeEditor = e
                        },
                        _setBaseUrl(e) {
                            this.baseURL = new gy(this.documentBaseURL).toAbsolute(e.replace(/\/+$/, "")), this.baseURI = new gy(this.baseURL)
                        }
                    };
                eM.setup();
                const tM = (() => {
                        const e = Ea();
                        return {
                            FakeClipboardItem: e => ({
                                items: e,
                                types: me(e),
                                getType: t => Ce(e, t).getOrUndefined()
                            }),
                            write: t => {
                                e.set(t)
                            },
                            read: () => e.get().getOrUndefined(),
                            clear: e.clear
                        }
                    })(),
                    oM = Math.min,
                    nM = Math.max,
                    rM = Math.round,
                    sM = (e, t, o) => {
                        let n = t.x,
                            r = t.y;
                        const s = e.w,
                            a = e.h,
                            i = t.w,
                            l = t.h,
                            c = (o || "").split("");
                        return "b" === c[0] && (r += l), "r" === c[1] && (n += i), "c" === c[0] && (r += rM(l / 2)), "c" === c[1] && (n += rM(i / 2)), "b" === c[3] && (r -= a), "r" === c[4] && (n -= s), "c" === c[3] && (r -= rM(a / 2)), "c" === c[4] && (n -= rM(s / 2)), aM(n, r, s, a)
                    },
                    aM = (e, t, o, n) => ({
                        x: e,
                        y: t,
                        w: o,
                        h: n
                    }),
                    iM = {
                        inflate: (e, t, o) => aM(e.x - t, e.y - o, e.w + 2 * t, e.h + 2 * o),
                        relativePosition: sM,
                        findBestRelativePosition: (e, t, o, n) => {
                            for (let r = 0; r < n.length; r++) {
                                const s = sM(e, t, n[r]);
                                if (s.x >= o.x && s.x + s.w <= o.w + o.x && s.y >= o.y && s.y + s.h <= o.h + o.y) return n[r]
                            }
                            return null
                        },
                        intersect: (e, t) => {
                            const o = nM(e.x, t.x),
                                n = nM(e.y, t.y),
                                r = oM(e.x + e.w, t.x + t.w),
                                s = oM(e.y + e.h, t.y + t.h);
                            return r - o < 0 || s - n < 0 ? null : aM(o, n, r - o, s - n)
                        },
                        clamp: (e, t, o) => {
                            let n = e.x,
                                r = e.y,
                                s = e.x + e.w,
                                a = e.y + e.h;
                            const i = t.x + t.w,
                                l = t.y + t.h,
                                c = nM(0, t.x - n),
                                d = nM(0, t.y - r),
                                u = nM(0, s - i),
                                m = nM(0, a - l);
                            return n += c, r += d, o && (s += c, a += d, n -= u, r -= m), s -= u, a -= m, aM(n, r, s - n, a - r)
                        },
                        create: aM,
                        fromClientRect: e => aM(e.left, e.top, e.width, e.height)
                    },
                    lM = (() => {
                        const e = {},
                            t = {};
                        return {
                            load: (o, n) => {
                                const r = `Script at URL "${n}" failed to load`,
                                    s = `Script at URL "${n}" did not call \`tinymce.Resource.add('${o}', data)\` within 1 second`;
                                if (void 0 !== e[o]) return e[o]; {
                                    const a = new Promise(((e, a) => {
                                        const i = ((e, t, o = 1e3) => {
                                            let n = !1,
                                                r = null;
                                            const s = e => (...t) => {
                                                    n || (n = !0, null !== r && (clearTimeout(r), r = null), e.apply(null, t))
                                                },
                                                a = s(e),
                                                i = s(t);
                                            return {
                                                start: (...e) => {
                                                    n || null !== r || (r = setTimeout((() => i.apply(null, e)), o))
                                                },
                                                resolve: a,
                                                reject: i
                                            }
                                        })(e, a);
                                        t[o] = i.resolve, wa.ScriptLoader.loadScript(n).then((() => i.start(s)), (() => i.reject(r)))
                                    }));
                                    return e[o] = a, a
                                }
                            },
                            add: (o, n) => {
                                void 0 !== t[o] && (t[o](n), delete t[o]), e[o] = Promise.resolve(n)
                            },
                            unload: t => {
                                delete e[t]
                            }
                        }
                    })();
                let cM;
                try {
                    const e = "__storage_test__";
                    cM = window.localStorage, cM.setItem(e, e), cM.removeItem(e)
                } catch (e) {
                    cM = (() => {
                        let e = {},
                            t = [];
                        const o = {
                            getItem: t => e[t] || null,
                            setItem: (o, n) => {
                                t.push(o), e[o] = String(n)
                            },
                            key: e => t[e],
                            removeItem: o => {
                                t = t.filter((e => e === o)), delete e[o]
                            },
                            clear: () => {
                                t = [], e = {}
                            },
                            length: 0
                        };
                        return Object.defineProperty(o, "length", {
                            get: () => t.length,
                            configurable: !1,
                            enumerable: !1
                        }), o
                    })()
                }
                const dM = {
                        geom: {
                            Rect: iM
                        },
                        util: {
                            Delay: $g,
                            Tools: Rt,
                            VK: Lm,
                            URI: gy,
                            EventDispatcher: yA,
                            Observable: xA,
                            I18n: _a,
                            LocalStorage: cM,
                            ImageUploader: e => {
                                const t = zw(),
                                    o = Uw(e, t);
                                return {
                                    upload: (t, n = !0) => o.upload(t, n ? Zw(e) : void 0)
                                }
                            }
                        },
                        dom: {
                            EventUtils: la,
                            TreeWalker: An,
                            TextSeeker: Ga,
                            DOMUtils: ba,
                            ScriptLoader: wa,
                            RangeUtils: gg,
                            Serializer: uw,
                            StyleSheetLoader: xs,
                            ControlSelection: Fm,
                            BookmarkManager: Tm,
                            Selection: lw,
                            Event: la.Event
                        },
                        html: {
                            Styles: Qs,
                            Entities: zs,
                            Node: fh,
                            Schema: Js,
                            DomParser: xy,
                            Writer: _h,
                            Serializer: Oh
                        },
                        Env: Et,
                        AddOnManager: Oa,
                        Annotator: Om,
                        Formatter: tx,
                        UndoManager: nx,
                        EditorCommands: dA,
                        WindowManager: Mw,
                        NotificationManager: Tw,
                        EditorObservable: TA,
                        Shortcuts: zA,
                        Editor: jA,
                        FocusManager: Wg,
                        EditorManager: eM,
                        DOM: ba.DOM,
                        ScriptLoader: wa.ScriptLoader,
                        PluginManager: Ew,
                        ThemeManager: Aw,
                        ModelManager: ww,
                        IconManager: yw,
                        Resource: lM,
                        FakeClipboard: tM,
                        trim: Rt.trim,
                        isArray: Rt.isArray,
                        is: Rt.is,
                        toArray: Rt.toArray,
                        makeMap: Rt.makeMap,
                        each: Rt.each,
                        map: Rt.map,
                        grep: Rt.grep,
                        inArray: Rt.inArray,
                        extend: Rt.extend,
                        walk: Rt.walk,
                        resolve: Rt.resolve,
                        explode: Rt.explode,
                        _addCacheSuffix: Rt._addCacheSuffix
                    },
                    uM = Rt.extend(eM, dM);
                (e => {
                    window.tinymce = e, window.tinyMCE = e
                })(uM), (t => {
                    try {
                        e.exports = t
                    } catch (e) {}
                })(uM)
            }()
        }
    }
]);